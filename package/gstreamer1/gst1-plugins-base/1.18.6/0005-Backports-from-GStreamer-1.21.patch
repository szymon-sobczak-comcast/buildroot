From b4ba025fd1b001d80638088c58acdeead087abce Mon Sep 17 00:00:00 2001
From: Philippe Normand <philn@igalia.com>
Date: Thu, 19 Jan 2023 14:51:08 +0000
Subject: [PATCH] Backports from GStreamer 1.21.

---
 gst-libs/gst/app/gstappsink.c               |  316 +++++-
 gst-libs/gst/app/gstappsink.h               |   28 +-
 gst-libs/gst/app/gstappsrc.c                |  840 ++++++++++++++--
 gst-libs/gst/app/gstappsrc.h                |   41 +
 gst-libs/gst/audio/audio-buffer.c           |    2 +-
 gst-libs/gst/audio/audio-channel-mixer.c    |    5 +-
 gst-libs/gst/audio/audio-converter.c        |   17 +-
 gst-libs/gst/audio/audio-converter.h        |   11 +
 gst-libs/gst/audio/audio-format.c           |   22 +-
 gst-libs/gst/audio/audio-format.h           |   19 +-
 gst-libs/gst/audio/audio-info.c             |   26 +-
 gst-libs/gst/audio/audio-info.h             |    5 +-
 gst-libs/gst/audio/audio-quantize.c         |   33 +-
 gst-libs/gst/audio/audio-resampler.c        |    3 +-
 gst-libs/gst/audio/audio.c                  |   41 +-
 gst-libs/gst/audio/gstaudiobasesink.c       |    6 +-
 gst-libs/gst/audio/gstaudiobasesink.h       |    2 +-
 gst-libs/gst/audio/gstaudiobasesrc.c        |   11 +-
 gst-libs/gst/audio/gstaudiocdsrc.c          |    4 +-
 gst-libs/gst/audio/gstaudiodecoder.c        |  110 +-
 gst-libs/gst/audio/gstaudiodecoder.h        |    7 +-
 gst-libs/gst/audio/gstaudioencoder.c        |  144 ++-
 gst-libs/gst/audio/gstaudiofilter.c         |    5 +
 gst-libs/gst/audio/gstaudiometa.c           |  128 +++
 gst-libs/gst/audio/gstaudiometa.h           |   49 +
 gst-libs/gst/audio/gstaudioringbuffer.c     |    4 +-
 gst-libs/gst/audio/gstaudiosink.c           |    5 +-
 gst-libs/gst/audio/gstaudiosink.h           |    7 +-
 gst-libs/gst/audio/gstaudiosrc.c            |    2 +-
 gst-libs/gst/audio/gstaudiosrc.h            |    8 +-
 gst-libs/gst/audio/gstaudiostreamalign.c    |   17 +-
 gst-libs/gst/audio/gstaudiostreamalign.h    |   10 +-
 gst-libs/gst/audio/gstaudioutilsprivate.c   |   10 +-
 gst-libs/gst/meson.build                    |    2 +-
 gst-libs/gst/pbutils/codec-utils.c          |  733 +++++++++++++-
 gst-libs/gst/pbutils/codec-utils.h          |   14 +
 gst-libs/gst/pbutils/descriptions.c         |  104 +-
 gst-libs/gst/pbutils/descriptions.h         |   48 +
 gst-libs/gst/pbutils/pbutils-private.h      |    4 +
 gst-libs/gst/pbutils/pbutils.c              |   22 +-
 gst-libs/gst/rtp/gstrtcpbuffer.c            |   53 +-
 gst-libs/gst/rtp/gstrtcpbuffer.h            |   80 +-
 gst-libs/gst/rtp/gstrtpbasedepayload.c      |  632 +++++++++++-
 gst-libs/gst/rtp/gstrtpbasepayload.c        |  667 ++++++++++--
 gst-libs/gst/rtp/gstrtpbasepayload.h        |    4 +
 gst-libs/gst/rtp/gstrtpbuffer.c             |   90 +-
 gst-libs/gst/rtp/gstrtpbuffer.h             |    3 +
 gst-libs/gst/rtp/gstrtphdrext.c             |  779 +++++++++++++++
 gst-libs/gst/rtp/gstrtphdrext.h             |  238 +++++
 gst-libs/gst/rtp/gstrtpmeta.c               |   10 +-
 gst-libs/gst/rtp/gstrtppayloads.c           |    4 +-
 gst-libs/gst/sdp/gstmikey.c                 |   28 +-
 gst-libs/gst/sdp/gstsdpmessage.c            |  372 ++++++-
 gst-libs/gst/sdp/meson.build                |    2 +-
 gst-libs/gst/video/convertframe.c           |   44 +-
 gst-libs/gst/video/gstvideocodecalphameta.c |  155 +++
 gst-libs/gst/video/gstvideocodecalphameta.h |   88 ++
 gst-libs/gst/video/gstvideodecoder.c        | 1001 ++++++++++++++++---
 gst-libs/gst/video/gstvideodecoder.h        |   79 +-
 gst-libs/gst/video/gstvideoencoder.c        |  152 +--
 gst-libs/gst/video/gstvideometa.c           |    8 +-
 gst-libs/gst/video/gstvideopool.c           |    2 +-
 gst-libs/gst/video/gstvideopool.h           |    2 +-
 gst-libs/gst/video/gstvideosink.c           |  149 ++-
 gst-libs/gst/video/gstvideosink.h           |   22 +-
 gst-libs/gst/video/gstvideotimecode.c       |    2 +-
 gst-libs/gst/video/gstvideoutils.c          |    4 +
 gst-libs/gst/video/gstvideoutils.h          |   45 +-
 gst-libs/gst/video/meson.build              |    9 +
 gst-libs/gst/video/navigation.c             |  586 ++++++++++-
 gst-libs/gst/video/navigation.h             |  276 ++++-
 gst-libs/gst/video/video-chroma.c           |  122 ++-
 gst-libs/gst/video/video-chroma.h           |   10 +-
 gst-libs/gst/video/video-color.c            |  132 ++-
 gst-libs/gst/video/video-color.h            |   18 +-
 gst-libs/gst/video/video-hdr.c              |   41 +-
 gst-libs/gst/video/video-hdr.h              |    4 +
 gst-libs/gst/video/video-sei.c              |  236 +++++
 gst-libs/gst/video/video-sei.h              |  110 ++
 gst-libs/gst/video/video.c                  |   87 ++
 gst-libs/gst/video/video.h                  |   26 +-
 81 files changed, 8370 insertions(+), 867 deletions(-)
 create mode 100644 gst-libs/gst/video/gstvideocodecalphameta.c
 create mode 100644 gst-libs/gst/video/gstvideocodecalphameta.h
 create mode 100644 gst-libs/gst/video/video-sei.c
 create mode 100644 gst-libs/gst/video/video-sei.h

diff --git a/gst-libs/gst/app/gstappsink.c b/gst-libs/gst/app/gstappsink.c
index cfcb1bf6d2..fb6ce0d857 100644
--- a/gst-libs/gst/app/gstappsink.c
+++ b/gst-libs/gst/app/gstappsink.c
@@ -113,6 +113,7 @@ struct _GstAppSinkPrivate
   GstCaps *caps;
   gboolean emit_signals;
   guint num_buffers;
+  guint num_events;
   guint max_buffers;
   gboolean drop;
   gboolean wait_on_eos;
@@ -146,12 +147,14 @@ enum
   SIGNAL_EOS,
   SIGNAL_NEW_PREROLL,
   SIGNAL_NEW_SAMPLE,
+  SIGNAL_NEW_SERIALIZED_EVENT,
 
   /* actions */
   SIGNAL_PULL_PREROLL,
   SIGNAL_PULL_SAMPLE,
   SIGNAL_TRY_PULL_PREROLL,
   SIGNAL_TRY_PULL_SAMPLE,
+  SIGNAL_TRY_PULL_OBJECT,
 
   LAST_SIGNAL
 };
@@ -332,6 +335,34 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
       G_STRUCT_OFFSET (GstAppSinkClass, new_sample),
       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 
+  /**
+   * GstAppSink::new-serialized-event:
+   * @appsink: the appsink element that emitted the signal
+   *
+   * Signal that a new downstream serialized event is available.
+   *
+   * This signal is emitted from the streaming thread and only when the
+   * "emit-signals" property is %TRUE.
+   *
+   * The new event can be retrieved with the "try-pull-object" action
+   * signal or gst_app_sink_pull_object() either from this signal callback
+   * or from any other thread.
+   *
+   * EOS will not be notified using this signal, use #GstAppSink::eos instead.
+   * EOS cannot be pulled either, use gst_app_sink_is_eos() to check for it.
+   *
+   * Note that this signal is only emitted when the "emit-signals" property is
+   * set to %TRUE, which it is not by default for performance reasons.
+   *
+   * The callback should return %TRUE if the event has been handled, which will
+   * skip basesink handling of the event, %FALSE otherwise.
+   *
+   * Since: 1.20
+   */
+  gst_app_sink_signals[SIGNAL_NEW_SERIALIZED_EVENT] =
+      g_signal_new ("new-serialized-event", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, 0, NULL, NULL, NULL, G_TYPE_BOOLEAN, 0, G_TYPE_NONE);
+
   /**
    * GstAppSink::pull-preroll:
    * @appsink: the appsink element to emit this signal on
@@ -355,7 +386,7 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
    * This function blocks until a preroll sample or EOS is received or the appsink
    * element is set to the READY/NULL state.
    *
-   * Returns: a #GstSample or NULL when the appsink is stopped or EOS.
+   * Returns: (nullable): a #GstSample or NULL when the appsink is stopped or EOS.
    */
   gst_app_sink_signals[SIGNAL_PULL_PREROLL] =
       g_signal_new ("pull-preroll", G_TYPE_FROM_CLASS (klass),
@@ -380,12 +411,13 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
    * If an EOS event was received before any buffers, this function returns
    * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
    *
-   * Returns: a #GstSample or NULL when the appsink is stopped or EOS.
+   * Returns: (nullable): a #GstSample or NULL when the appsink is stopped or EOS.
    */
   gst_app_sink_signals[SIGNAL_PULL_SAMPLE] =
       g_signal_new ("pull-sample", G_TYPE_FROM_CLASS (klass),
       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstAppSinkClass,
           pull_sample), NULL, NULL, NULL, GST_TYPE_SAMPLE, 0, G_TYPE_NONE);
+
   /**
    * GstAppSink::try-pull-preroll:
    * @appsink: the appsink element to emit this signal on
@@ -411,7 +443,7 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
    * This function blocks until a preroll sample or EOS is received, the appsink
    * element is set to the READY/NULL state, or the timeout expires.
    *
-   * Returns: a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
+   * Returns: (nullable): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
    *
    * Since: 1.10
    */
@@ -441,7 +473,7 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
    * this function returns %NULL. Use gst_app_sink_is_eos () to check
    * for the EOS condition.
    *
-   * Returns: a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
+   * Returns: (nullable): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
    *
    * Since: 1.10
    */
@@ -451,6 +483,44 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
       G_STRUCT_OFFSET (GstAppSinkClass, try_pull_sample), NULL, NULL, NULL,
       GST_TYPE_SAMPLE, 1, GST_TYPE_CLOCK_TIME);
 
+  /**
+   * GstAppSink::try-pull-object:
+   * @appsink: the appsink element to emit this signal on
+   * @timeout: the maximum amount of time to wait for a sample
+   *
+   * This function blocks until a sample or an event becomes available or the appsink
+   * element is set to the READY/NULL state or the timeout expires.
+   *
+   * This function will only return samples when the appsink is in the PLAYING
+   * state. All rendered samples and events will be put in a queue so that the application
+   * can pull them at its own rate.
+   * Events can be pulled when the appsink is in the READY, PAUSED or PLAYING state.
+   *
+   * Note that when the application does not pull samples fast enough, the
+   * queued samples could consume a lot of memory, especially when dealing with
+   * raw video frames. It's possible to control the behaviour of the queue with
+   * the "drop" and "max-buffers" properties.
+   *
+   * This function will only pull serialized events, excluding
+   * the EOS event for which this functions returns
+   * %NULL. Use gst_app_sink_is_eos() to check for the EOS condition.
+   *
+   * This signal is a variant of #GstAppSink::try-pull-sample: that can be used
+   * to handle incoming events as well as samples.
+   *
+   * Note that future releases may extend this API to return other object types
+   * so make sure that your code is checking for the actual type it is handling.
+   *
+   * Returns: (nullable) (transfer full): a #GstSample or a #GstEvent or NULL when the appsink is stopped or EOS or the timeout expires.
+   *
+   * Since: 1.20
+   */
+  gst_app_sink_signals[SIGNAL_TRY_PULL_OBJECT] =
+      g_signal_new ("try-pull-object", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GstAppSinkClass, try_pull_object), NULL, NULL, NULL,
+      GST_TYPE_MINI_OBJECT, 1, GST_TYPE_CLOCK_TIME);
+
   gst_element_class_set_static_metadata (element_class, "AppSink",
       "Generic/Sink", "Allow the application to get access to raw buffer",
       "David Schleef <ds@schleef.org>, Wim Taymans <wim.taymans@gmail.com>");
@@ -474,6 +544,7 @@ gst_app_sink_class_init (GstAppSinkClass * klass)
   klass->pull_sample = gst_app_sink_pull_sample;
   klass->try_pull_preroll = gst_app_sink_try_pull_preroll;
   klass->try_pull_sample = gst_app_sink_try_pull_sample;
+  klass->try_pull_object = gst_app_sink_try_pull_object;
 }
 
 static void
@@ -659,6 +730,8 @@ gst_app_sink_flush_unlocked (GstAppSink * appsink)
   while ((obj = gst_queue_array_pop_head (priv->queue)))
     gst_mini_object_unref (obj);
   priv->num_buffers = 0;
+  priv->num_events = 0;
+  gst_caps_replace (&priv->last_caps, NULL);
   g_cond_signal (&priv->cond);
 }
 
@@ -716,6 +789,7 @@ gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps)
   g_mutex_lock (&priv->mutex);
   GST_DEBUG_OBJECT (appsink, "receiving CAPS");
   gst_queue_array_push_tail (priv->queue, gst_event_new_caps (caps));
+  priv->num_events++;
   if (!priv->preroll_buffer)
     gst_caps_replace (&priv->preroll_caps, caps);
   g_mutex_unlock (&priv->mutex);
@@ -729,11 +803,12 @@ gst_app_sink_event (GstBaseSink * sink, GstEvent * event)
   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
   GstAppSinkPrivate *priv = appsink->priv;
 
+  GST_DEBUG_OBJECT (appsink, "%" GST_PTR_FORMAT, event);
+
   switch (event->type) {
     case GST_EVENT_SEGMENT:
       g_mutex_lock (&priv->mutex);
       GST_DEBUG_OBJECT (appsink, "receiving SEGMENT");
-      gst_queue_array_push_tail (priv->queue, gst_event_ref (event));
       if (!priv->preroll_buffer)
         gst_event_copy_segment (event, &priv->preroll_segment);
       g_mutex_unlock (&priv->mutex);
@@ -805,6 +880,40 @@ gst_app_sink_event (GstBaseSink * sink, GstEvent * event)
     default:
       break;
   }
+
+  if (GST_EVENT_TYPE (event) != GST_EVENT_EOS
+      && GST_EVENT_IS_SERIALIZED (event)) {
+    gboolean emit;
+    Callbacks *callbacks = NULL;
+    gboolean ret;
+
+    g_mutex_lock (&priv->mutex);
+
+    emit = priv->emit_signals;
+    if (priv->callbacks)
+      callbacks = callbacks_ref (priv->callbacks);
+
+    gst_queue_array_push_tail (priv->queue, gst_event_ref (event));
+    priv->num_events++;
+
+    g_mutex_unlock (&priv->mutex);
+
+    if (callbacks && callbacks->callbacks.new_event) {
+      ret = callbacks->callbacks.new_event (appsink, callbacks->user_data);
+    } else {
+      ret = FALSE;
+      if (emit)
+        g_signal_emit (appsink,
+            gst_app_sink_signals[SIGNAL_NEW_SERIALIZED_EVENT], 0, &ret);
+    }
+    g_clear_pointer (&callbacks, callbacks_unref);
+
+    if (ret) {
+      gst_event_unref (event);
+      return TRUE;
+    }
+  }
+
   return GST_BASE_SINK_CLASS (parent_class)->event (sink, event);
 }
 
@@ -854,45 +963,61 @@ flushing:
 }
 
 static GstMiniObject *
-dequeue_buffer (GstAppSink * appsink)
+dequeue_object (GstAppSink * appsink)
 {
   GstAppSinkPrivate *priv = appsink->priv;
   GstMiniObject *obj;
 
+  obj = gst_queue_array_pop_head (priv->queue);
+
+  if (GST_IS_BUFFER (obj) || GST_IS_BUFFER_LIST (obj)) {
+    GST_DEBUG_OBJECT (appsink, "dequeued buffer/list %p", obj);
+    priv->num_buffers--;
+  } else if (GST_IS_EVENT (obj)) {
+    GstEvent *event = GST_EVENT_CAST (obj);
+
+    priv->num_events--;
+
+    switch (GST_EVENT_TYPE (obj)) {
+      case GST_EVENT_CAPS:
+      {
+        GstCaps *caps;
+
+        gst_event_parse_caps (event, &caps);
+        GST_DEBUG_OBJECT (appsink, "activating caps %" GST_PTR_FORMAT, caps);
+        gst_caps_replace (&priv->last_caps, caps);
+        priv->sample = gst_sample_make_writable (priv->sample);
+        gst_sample_set_caps (priv->sample, priv->last_caps);
+        break;
+      }
+      case GST_EVENT_SEGMENT:
+        gst_event_copy_segment (event, &priv->last_segment);
+        priv->sample = gst_sample_make_writable (priv->sample);
+        gst_sample_set_segment (priv->sample, &priv->last_segment);
+        GST_DEBUG_OBJECT (appsink, "activated segment %" GST_SEGMENT_FORMAT,
+            &priv->last_segment);
+        break;
+      default:
+        break;
+    }
+  }
+
+  return obj;
+}
+
+static GstMiniObject *
+dequeue_buffer (GstAppSink * appsink)
+{
+  GstMiniObject *obj;
+
   do {
-    obj = gst_queue_array_pop_head (priv->queue);
+    obj = dequeue_object (appsink);
 
     if (GST_IS_BUFFER (obj) || GST_IS_BUFFER_LIST (obj)) {
-      GST_DEBUG_OBJECT (appsink, "dequeued buffer/list %p", obj);
-      priv->num_buffers--;
       break;
-    } else if (GST_IS_EVENT (obj)) {
-      GstEvent *event = GST_EVENT_CAST (obj);
-
-      switch (GST_EVENT_TYPE (obj)) {
-        case GST_EVENT_CAPS:
-        {
-          GstCaps *caps;
-
-          gst_event_parse_caps (event, &caps);
-          GST_DEBUG_OBJECT (appsink, "activating caps %" GST_PTR_FORMAT, caps);
-          gst_caps_replace (&priv->last_caps, caps);
-          priv->sample = gst_sample_make_writable (priv->sample);
-          gst_sample_set_caps (priv->sample, priv->last_caps);
-          break;
-        }
-        case GST_EVENT_SEGMENT:
-          gst_event_copy_segment (event, &priv->last_segment);
-          priv->sample = gst_sample_make_writable (priv->sample);
-          gst_sample_set_segment (priv->sample, &priv->last_segment);
-          GST_DEBUG_OBJECT (appsink, "activated segment %" GST_SEGMENT_FORMAT,
-              &priv->last_segment);
-          break;
-        default:
-          break;
-      }
-      gst_mini_object_unref (obj);
     }
+
+    gst_mini_object_unref (obj);
   } while (TRUE);
 
   return obj;
@@ -1147,7 +1272,7 @@ gst_app_sink_set_caps (GstAppSink * appsink, const GstCaps * caps)
  *
  * Get the configured caps on @appsink.
  *
- * Returns: the #GstCaps accepted by the sink. gst_caps_unref() after usage.
+ * Returns: (nullable) (transfer full): the #GstCaps accepted by the sink. gst_caps_unref() after usage.
  */
 GstCaps *
 gst_app_sink_get_caps (GstAppSink * appsink)
@@ -1499,7 +1624,7 @@ gst_app_sink_get_wait_on_eos (GstAppSink * appsink)
  * This function blocks until a preroll sample or EOS is received or the appsink
  * element is set to the READY/NULL state.
  *
- * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS.
+ * Returns: (transfer full) (nullable): a #GstSample or NULL when the appsink is stopped or EOS.
  *          Call gst_sample_unref() after usage.
  */
 GstSample *
@@ -1524,7 +1649,7 @@ gst_app_sink_pull_preroll (GstAppSink * appsink)
  * If an EOS event was received before any buffers, this function returns
  * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
  *
- * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS.
+ * Returns: (transfer full) (nullable): a #GstSample or NULL when the appsink is stopped or EOS.
  *          Call gst_sample_unref() after usage.
  */
 GstSample *
@@ -1533,6 +1658,41 @@ gst_app_sink_pull_sample (GstAppSink * appsink)
   return gst_app_sink_try_pull_sample (appsink, GST_CLOCK_TIME_NONE);
 }
 
+/**
+ * gst_app_sink_pull_object: (skip)
+ * @appsink: a #GstAppSink
+ *
+ * This function blocks until a sample or an event becomes available or the appsink
+ * element is set to the READY/NULL state.
+ *
+ * This function will only return samples when the appsink is in the PLAYING
+ * state. All rendered buffers and events will be put in a queue so that the application
+ * can pull them at its own rate. Note that when the application does not
+ * pull samples fast enough, the queued buffers could consume a lot of memory,
+ * especially when dealing with raw video frames.
+ * Events can be pulled when the appsink is in the READY, PAUSED or PLAYING state.
+ *
+ * This function will only pull serialized events, excluding
+ * the EOS event for which this functions returns
+ * %NULL. Use gst_app_sink_is_eos() to check for the EOS condition.
+ *
+ * This method is a variant of gst_app_sink_pull_sample() that can be used
+ * to handle incoming events events as well as samples.
+ *
+ * Note that future releases may extend this API to return other object types
+ * so make sure that your code is checking for the actual type it is handling.
+ *
+ * Returns: (transfer full) (nullable): a #GstSample, or a #GstEvent or NULL when the appsink is stopped or EOS.
+ *          Call gst_mini_object_unref() after usage.
+ *
+ * Since: 1.20
+ */
+GstMiniObject *
+gst_app_sink_pull_object (GstAppSink * appsink)
+{
+  return gst_app_sink_try_pull_object (appsink, GST_CLOCK_TIME_NONE);
+}
+
 /**
  * gst_app_sink_try_pull_preroll:
  * @appsink: a #GstAppSink
@@ -1558,7 +1718,7 @@ gst_app_sink_pull_sample (GstAppSink * appsink)
  * This function blocks until a preroll sample or EOS is received, the appsink
  * element is set to the READY/NULL state, or the timeout expires.
  *
- * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
+ * Returns: (transfer full) (nullable): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
  *          Call gst_sample_unref() after usage.
  *
  * Since: 1.10
@@ -1654,17 +1814,64 @@ not_started:
  * this function returns %NULL. Use gst_app_sink_is_eos () to check for the EOS
  * condition.
  *
- * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
- * Call gst_sample_unref() after usage.
+ * Returns: (transfer full) (nullable): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
+ *          Call gst_sample_unref() after usage.
  *
  * Since: 1.10
  */
 GstSample *
 gst_app_sink_try_pull_sample (GstAppSink * appsink, GstClockTime timeout)
+{
+  while (TRUE) {
+    GstMiniObject *obj;
+
+    obj = gst_app_sink_try_pull_object (appsink, timeout);
+
+    if (!obj) {
+      return NULL;
+    } else if (GST_IS_SAMPLE (obj)) {
+      return GST_SAMPLE_CAST (obj);
+    } else {
+      gst_mini_object_unref (obj);
+    }
+  }
+}
+
+/**
+ * gst_app_sink_try_pull_object: (skip)
+ * @appsink: a #GstAppSink
+ * @timeout: the maximum amount of time to wait for a sample
+ *
+ * This function blocks until a sample or an event or EOS becomes available or the appsink
+ * element is set to the READY/NULL state or the timeout expires.
+ *
+ * This function will only return samples when the appsink is in the PLAYING
+ * state. All rendered buffers and events will be put in a queue so that the application
+ * can pull them at its own rate. Note that when the application does not
+ * pull samples fast enough, the queued buffers could consume a lot of memory,
+ * especially when dealing with raw video frames.
+ * Events can be pulled when the appsink is in the READY, PAUSED or PLAYING state.
+ *
+ * This function will only pull serialized events, excluding
+ * the EOS event for which this functions returns
+ * %NULL. Use gst_app_sink_is_eos() to check for the EOS condition.
+ *
+ * This method is a variant of gst_app_sink_try_pull_sample() that can be used
+ * to handle incoming events events as well as samples.
+ *
+ * Note that future releases may extend this API to return other object types
+ * so make sure that your code is checking for the actual type it is handling.
+ *
+ * Returns: (transfer full) (nullable): a #GstSample, or #GstEvent or NULL when the appsink is stopped or EOS or the timeout expires.
+ * Call gst_mini_object_unref() after usage.
+ *
+ * Since: 1.20
+ */
+GstMiniObject *
+gst_app_sink_try_pull_object (GstAppSink * appsink, GstClockTime timeout)
 {
   GstAppSinkPrivate *priv;
-  GstSample *sample = NULL;
-  GstMiniObject *obj;
+  GstMiniObject *obj = NULL, *ret;
   gboolean timeout_valid;
   gint64 end_time;
 
@@ -1682,18 +1889,18 @@ gst_app_sink_try_pull_sample (GstAppSink * appsink, GstClockTime timeout)
   gst_buffer_replace (&priv->preroll_buffer, NULL);
 
   while (TRUE) {
-    GST_DEBUG_OBJECT (appsink, "trying to grab a buffer");
+    GST_DEBUG_OBJECT (appsink, "trying to grab an object");
     if (!priv->started)
       goto not_started;
 
-    if (priv->num_buffers > 0)
+    if (priv->num_buffers > 0 || priv->num_events > 0)
       break;
 
     if (priv->is_eos)
       goto eos;
 
     /* nothing to return, wait */
-    GST_DEBUG_OBJECT (appsink, "waiting for a buffer");
+    GST_DEBUG_OBJECT (appsink, "waiting for an object");
     priv->wait_status |= APP_WAITING;
     if (timeout_valid) {
       if (!g_cond_wait_until (&priv->cond, &priv->mutex, end_time))
@@ -1704,28 +1911,33 @@ gst_app_sink_try_pull_sample (GstAppSink * appsink, GstClockTime timeout)
     priv->wait_status &= ~APP_WAITING;
   }
 
-  obj = dequeue_buffer (appsink);
+  obj = dequeue_object (appsink);
+
+  /* convert buffer and buffer list to sample */
   if (GST_IS_BUFFER (obj)) {
     GST_DEBUG_OBJECT (appsink, "we have a buffer %p", obj);
     priv->sample = gst_sample_make_writable (priv->sample);
     gst_sample_set_buffer_list (priv->sample, NULL);
     gst_sample_set_buffer (priv->sample, GST_BUFFER_CAST (obj));
-    sample = gst_sample_ref (priv->sample);
-  } else {
+    ret = GST_MINI_OBJECT_CAST (gst_sample_ref (priv->sample));
+    gst_mini_object_unref (obj);
+  } else if (GST_IS_BUFFER_LIST (obj)) {
     GST_DEBUG_OBJECT (appsink, "we have a list %p", obj);
     priv->sample = gst_sample_make_writable (priv->sample);
     gst_sample_set_buffer (priv->sample, NULL);
     gst_sample_set_buffer_list (priv->sample, GST_BUFFER_LIST_CAST (obj));
-    sample = gst_sample_ref (priv->sample);
+    ret = GST_MINI_OBJECT_CAST (gst_sample_ref (priv->sample));
+    gst_mini_object_unref (obj);
+  } else {
+    ret = obj;
   }
-  gst_mini_object_unref (obj);
 
   if ((priv->wait_status & STREAM_WAITING))
     g_cond_signal (&priv->cond);
 
   g_mutex_unlock (&priv->mutex);
 
-  return sample;
+  return ret;
 
   /* special conditions */
 expired:
diff --git a/gst-libs/gst/app/gstappsink.h b/gst-libs/gst/app/gstappsink.h
index 036b86e50a..90e678f53f 100644
--- a/gst-libs/gst/app/gstappsink.h
+++ b/gst-libs/gst/app/gstappsink.h
@@ -59,6 +59,14 @@ typedef struct _GstAppSinkPrivate GstAppSinkPrivate;
  *       The new sample can be retrieved with
  *       gst_app_sink_pull_sample() either from this callback
  *       or from any other thread.
+ * @new_event: Called when a new event is available.
+ *       This callback is called from the streaming thread.
+ *       The new event can be retrieved with
+ *       gst_app_sink_pull_event() either from this callback
+ *       or from any other thread.
+ *       The callback should return %TRUE if the event has been handled,
+ *       %FALSE otherwise.
+ *       Since: 1.20
  *
  * A set of callbacks that can be installed on the appsink with
  * gst_app_sink_set_callbacks().
@@ -67,9 +75,10 @@ typedef struct {
   void          (*eos)              (GstAppSink *appsink, gpointer user_data);
   GstFlowReturn (*new_preroll)      (GstAppSink *appsink, gpointer user_data);
   GstFlowReturn (*new_sample)       (GstAppSink *appsink, gpointer user_data);
+  gboolean      (*new_event)        (GstAppSink *appsink, gpointer user_data);
 
   /*< private >*/
-  gpointer     _gst_reserved[GST_PADDING];
+  gpointer     _gst_reserved[GST_PADDING - 1];
 } GstAppSinkCallbacks;
 
 struct _GstAppSink
@@ -91,15 +100,24 @@ struct _GstAppSinkClass
   void          (*eos)              (GstAppSink *appsink);
   GstFlowReturn (*new_preroll)      (GstAppSink *appsink);
   GstFlowReturn (*new_sample)       (GstAppSink *appsink);
+  /* new_event is missing as we ran out padding */
 
   /* actions */
   GstSample *   (*pull_preroll)      (GstAppSink *appsink);
   GstSample *   (*pull_sample)       (GstAppSink *appsink);
   GstSample *   (*try_pull_preroll)  (GstAppSink *appsink, GstClockTime timeout);
   GstSample *   (*try_pull_sample)   (GstAppSink *appsink, GstClockTime timeout);
+ /**
+   * GstAppSinkClass::try_pull_object:
+   *
+   * See #GstAppSink::try-pull-object: signal.
+   *
+   * Since: 1.20
+   */
+  GstMiniObject * (*try_pull_object) (GstAppSink *appsink, GstClockTime timeout);
 
   /*< private >*/
-  gpointer     _gst_reserved[GST_PADDING - 2];
+  gpointer     _gst_reserved[GST_PADDING - 3];
 };
 
 GST_APP_API
@@ -150,12 +168,18 @@ GstSample *     gst_app_sink_pull_preroll     (GstAppSink *appsink);
 GST_APP_API
 GstSample *     gst_app_sink_pull_sample      (GstAppSink *appsink);
 
+GST_APP_API
+GstMiniObject * gst_app_sink_pull_object      (GstAppSink *appsink);
+
 GST_APP_API
 GstSample *     gst_app_sink_try_pull_preroll (GstAppSink *appsink, GstClockTime timeout);
 
 GST_APP_API
 GstSample *     gst_app_sink_try_pull_sample  (GstAppSink *appsink, GstClockTime timeout);
 
+GST_APP_API
+GstMiniObject * gst_app_sink_try_pull_object    (GstAppSink *appsink, GstClockTime timeout);
+
 GST_APP_API
 void            gst_app_sink_set_callbacks    (GstAppSink * appsink,
                                                GstAppSinkCallbacks *callbacks,
diff --git a/gst-libs/gst/app/gstappsrc.c b/gst-libs/gst/app/gstappsrc.c
index c2267a045a..add6a289dd 100644
--- a/gst-libs/gst/app/gstappsrc.c
+++ b/gst-libs/gst/app/gstappsrc.c
@@ -46,11 +46,12 @@
  * streaming thread. It is important to note that data transport will not happen
  * from the thread that performed the push-buffer call.
  *
- * The "max-bytes" property controls how much data can be queued in appsrc
- * before appsrc considers the queue full. A filled internal queue will always
- * signal the "enough-data" signal, which signals the application that it should
- * stop pushing data into appsrc. The "block" property will cause appsrc to
- * block the push-buffer method until free data becomes available again.
+ * The "max-bytes", "max-buffers" and "max-time" properties control how much
+ * data can be queued in appsrc before appsrc considers the queue full. A
+ * filled internal queue will always signal the "enough-data" signal, which
+ * signals the application that it should stop pushing data into appsrc. The
+ * "block" property will cause appsrc to block the push-buffer method until
+ * free data becomes available again.
  *
  * When the internal queue is running out of data, the "need-data" signal is
  * emitted, which signals the application that it should start pushing more data
@@ -146,14 +147,25 @@ struct _GstAppSrcPrivate
 
   GstCaps *last_caps;
   GstCaps *current_caps;
+  /* last segment received on the input */
   GstSegment last_segment;
+  /* currently configured segment for the output */
   GstSegment current_segment;
+  /* queue up a segment event based on last_segment before
+   * the next buffer of buffer list */
   gboolean pending_custom_segment;
 
+  /* the next buffer that will be queued needs a discont flag
+   * because the previous one was dropped - GST_APP_LEAKY_TYPE_UPSTREAM */
+  gboolean need_discont_upstream;
+  /* the next buffer that will be dequeued needs a discont flag
+   * because the previous one was dropped - GST_APP_LEAKY_TYPE_DOWNSTREAM */
+  gboolean need_discont_downstream;
+
   gint64 size;
   GstClockTime duration;
   GstAppStreamType stream_type;
-  guint64 max_bytes;
+  guint64 max_bytes, max_buffers, max_time;
   GstFormat format;
   gboolean block;
   gchar *uri;
@@ -161,16 +173,25 @@ struct _GstAppSrcPrivate
   gboolean flushing;
   gboolean started;
   gboolean is_eos;
-  guint64 queued_bytes;
+  guint64 queued_bytes, queued_buffers;
+  /* Used to calculate the current time level */
+  GstClockTime last_in_running_time, last_out_running_time;
+  /* Updated based on the above whenever they change */
+  GstClockTime queued_time;
   guint64 offset;
   GstAppStreamType current_type;
 
   guint64 min_latency;
   guint64 max_latency;
+  /* Tracks whether the latency message was posted at least once */
+  gboolean posted_latency_msg;
+
   gboolean emit_signals;
   guint min_percent;
   gboolean handle_segment_change;
 
+  GstAppLeakyType leaky_type;
+
   Callbacks *callbacks;
 };
 
@@ -196,6 +217,8 @@ enum
 #define DEFAULT_PROP_SIZE          -1
 #define DEFAULT_PROP_STREAM_TYPE   GST_APP_STREAM_TYPE_STREAM
 #define DEFAULT_PROP_MAX_BYTES     200000
+#define DEFAULT_PROP_MAX_BUFFERS   0
+#define DEFAULT_PROP_MAX_TIME      (0 * GST_SECOND)
 #define DEFAULT_PROP_FORMAT        GST_FORMAT_BYTES
 #define DEFAULT_PROP_BLOCK         FALSE
 #define DEFAULT_PROP_IS_LIVE       FALSE
@@ -204,8 +227,11 @@ enum
 #define DEFAULT_PROP_EMIT_SIGNALS  TRUE
 #define DEFAULT_PROP_MIN_PERCENT   0
 #define DEFAULT_PROP_CURRENT_LEVEL_BYTES   0
+#define DEFAULT_PROP_CURRENT_LEVEL_BUFFERS 0
+#define DEFAULT_PROP_CURRENT_LEVEL_TIME    0
 #define DEFAULT_PROP_DURATION      GST_CLOCK_TIME_NONE
 #define DEFAULT_PROP_HANDLE_SEGMENT_CHANGE FALSE
+#define DEFAULT_PROP_LEAKY_TYPE    GST_APP_LEAKY_TYPE_NONE
 
 enum
 {
@@ -214,6 +240,8 @@ enum
   PROP_SIZE,
   PROP_STREAM_TYPE,
   PROP_MAX_BYTES,
+  PROP_MAX_BUFFERS,
+  PROP_MAX_TIME,
   PROP_FORMAT,
   PROP_BLOCK,
   PROP_IS_LIVE,
@@ -222,8 +250,11 @@ enum
   PROP_EMIT_SIGNALS,
   PROP_MIN_PERCENT,
   PROP_CURRENT_LEVEL_BYTES,
+  PROP_CURRENT_LEVEL_BUFFERS,
+  PROP_CURRENT_LEVEL_TIME,
   PROP_DURATION,
   PROP_HANDLE_SEGMENT_CHANGE,
+  PROP_LEAKY_TYPE,
   PROP_LAST
 };
 
@@ -347,6 +378,37 @@ gst_app_src_class_init (GstAppSrcClass * klass)
           "The maximum number of bytes to queue internally (0 = unlimited)",
           0, G_MAXUINT64, DEFAULT_PROP_MAX_BYTES,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstAppSrc:max-buffers:
+   *
+   * The maximum amount of buffers that can be queued internally.
+   * After the maximum amount of buffers are queued, appsrc will emit the
+   * "enough-data" signal.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_MAX_BUFFERS,
+      g_param_spec_uint64 ("max-buffers", "Max buffers",
+          "The maximum number of buffers to queue internally (0 = unlimited)",
+          0, G_MAXUINT64, DEFAULT_PROP_MAX_BUFFERS,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstAppSrc:max-time:
+   *
+   * The maximum amount of time that can be queued internally.
+   * After the maximum amount of time are queued, appsrc will emit the
+   * "enough-data" signal.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_MAX_TIME,
+      g_param_spec_uint64 ("max-time", "Max time",
+          "The maximum amount of time to queue internally (0 = unlimited)",
+          0, G_MAXUINT64, DEFAULT_PROP_MAX_TIME,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstAppSrc:block:
    *
@@ -430,6 +492,32 @@ gst_app_src_class_init (GstAppSrcClass * klass)
           0, G_MAXUINT64, DEFAULT_PROP_CURRENT_LEVEL_BYTES,
           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstAppSrc:current-level-buffers:
+   *
+   * The number of currently queued buffers inside appsrc.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_CURRENT_LEVEL_BUFFERS,
+      g_param_spec_uint64 ("current-level-buffers", "Current Level Buffers",
+          "The number of currently queued buffers",
+          0, G_MAXUINT64, DEFAULT_PROP_CURRENT_LEVEL_BUFFERS,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstAppSrc:current-level-time:
+   *
+   * The amount of currently queued time inside appsrc.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_CURRENT_LEVEL_TIME,
+      g_param_spec_uint64 ("current-level-time", "Current Level Time",
+          "The amount of currently queued time",
+          0, G_MAXUINT64, DEFAULT_PROP_CURRENT_LEVEL_TIME,
+          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstAppSrc:duration:
    *
@@ -467,6 +555,24 @@ gst_app_src_class_init (GstAppSrcClass * klass)
           G_PARAM_READWRITE | GST_PARAM_MUTABLE_READY |
           G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstAppSrc:leaky-type:
+   *
+   * When set to any other value than GST_APP_LEAKY_TYPE_NONE then the appsrc
+   * will drop any buffers that are pushed into it once its internal queue is
+   * full. The selected type defines whether to drop the oldest or new
+   * buffers.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_LEAKY_TYPE,
+      g_param_spec_enum ("leaky-type", "Leaky Type",
+          "Whether to drop buffers once the internal queue is full",
+          GST_TYPE_APP_LEAKY_TYPE,
+          DEFAULT_PROP_LEAKY_TYPE,
+          G_PARAM_READWRITE | GST_PARAM_MUTABLE_READY |
+          G_PARAM_STATIC_STRINGS));
+
   /**
    * GstAppSrc::need-data:
    * @appsrc: the appsrc element that emitted the signal
@@ -518,11 +624,14 @@ gst_app_src_class_init (GstAppSrcClass * klass)
    /**
     * GstAppSrc::push-buffer:
     * @appsrc: the appsrc
-    * @buffer: a buffer to push
+    * @buffer: (transfer none): a buffer to push
     *
     * Adds a buffer to the queue of buffers that the appsrc element will
-    * push to its source pad. This function does not take ownership of the
-    * buffer so the buffer needs to be unreffed after calling this function.
+    * push to its source pad.
+    *
+    * This function does not take ownership of the buffer, but it takes a
+    * reference so the buffer can be unreffed at any time after calling this
+    * function.
     *
     * When the block property is TRUE, this function can block until free space
     * becomes available in the queue.
@@ -536,12 +645,14 @@ gst_app_src_class_init (GstAppSrcClass * klass)
    /**
     * GstAppSrc::push-buffer-list:
     * @appsrc: the appsrc
-    * @buffer_list: a buffer list to push
+    * @buffer_list: (transfer none): a buffer list to push
     *
     * Adds a buffer list to the queue of buffers and buffer lists that the
-    * appsrc element will push to its source pad. This function does not take
-    * ownership of the buffer list so the buffer list needs to be unreffed
-    * after calling this function.
+    * appsrc element will push to its source pad.
+    *
+    * This function does not take ownership of the buffer list, but it takes a
+    * reference so the buffer list can be unreffed at any time after calling
+    * this function.
     *
     * When the block property is TRUE, this function can block until free space
     * becomes available in the queue.
@@ -557,7 +668,7 @@ gst_app_src_class_init (GstAppSrcClass * klass)
   /**
     * GstAppSrc::push-sample:
     * @appsrc: the appsrc
-    * @sample: a sample from which extract buffer to push
+    * @sample: (transfer none): a sample from which extract buffer to push
     *
     * Extract a buffer from the provided sample and adds the extracted buffer
     * to the queue of buffers that the appsrc element will
@@ -565,8 +676,10 @@ gst_app_src_class_init (GstAppSrcClass * klass)
     * in the sample and reset the caps if they change.
     * Only the caps and the buffer of the provided sample are used and not
     * for example the segment in the sample.
-    * This function does not take ownership of the
-    * sample so the sample needs to be unreffed after calling this function.
+    *
+    * This function does not take ownership of the sample, but it takes a
+    * reference so the sample can be unreffed at any time after calling this
+    * function.
     *
     * When the block property is TRUE, this function can block until free space
     * becomes available in the queue.
@@ -636,6 +749,8 @@ gst_app_src_init (GstAppSrc * appsrc)
   priv->duration = DEFAULT_PROP_DURATION;
   priv->stream_type = DEFAULT_PROP_STREAM_TYPE;
   priv->max_bytes = DEFAULT_PROP_MAX_BYTES;
+  priv->max_buffers = DEFAULT_PROP_MAX_BUFFERS;
+  priv->max_time = DEFAULT_PROP_MAX_TIME;
   priv->format = DEFAULT_PROP_FORMAT;
   priv->block = DEFAULT_PROP_BLOCK;
   priv->min_latency = DEFAULT_PROP_MIN_LATENCY;
@@ -643,6 +758,7 @@ gst_app_src_init (GstAppSrc * appsrc)
   priv->emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
   priv->min_percent = DEFAULT_PROP_MIN_PERCENT;
   priv->handle_segment_change = DEFAULT_PROP_HANDLE_SEGMENT_CHANGE;
+  priv->leaky_type = DEFAULT_PROP_LEAKY_TYPE;
 
   gst_base_src_set_live (GST_BASE_SRC (appsrc), DEFAULT_PROP_IS_LIVE);
 }
@@ -670,6 +786,12 @@ gst_app_src_flush_queued (GstAppSrc * src, gboolean retain_last_caps)
   }
 
   priv->queued_bytes = 0;
+  priv->queued_buffers = 0;
+  priv->queued_time = 0;
+  priv->last_in_running_time = GST_CLOCK_TIME_NONE;
+  priv->last_out_running_time = GST_CLOCK_TIME_NONE;
+  priv->need_discont_upstream = FALSE;
+  priv->need_discont_downstream = FALSE;
 }
 
 static void
@@ -762,6 +884,12 @@ gst_app_src_set_property (GObject * object, guint prop_id,
     case PROP_MAX_BYTES:
       gst_app_src_set_max_bytes (appsrc, g_value_get_uint64 (value));
       break;
+    case PROP_MAX_BUFFERS:
+      gst_app_src_set_max_buffers (appsrc, g_value_get_uint64 (value));
+      break;
+    case PROP_MAX_TIME:
+      gst_app_src_set_max_time (appsrc, g_value_get_uint64 (value));
+      break;
     case PROP_FORMAT:
       priv->format = g_value_get_enum (value);
       break;
@@ -792,6 +920,9 @@ gst_app_src_set_property (GObject * object, guint prop_id,
     case PROP_HANDLE_SEGMENT_CHANGE:
       priv->handle_segment_change = g_value_get_boolean (value);
       break;
+    case PROP_LEAKY_TYPE:
+      priv->leaky_type = g_value_get_enum (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -818,6 +949,12 @@ gst_app_src_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_MAX_BYTES:
       g_value_set_uint64 (value, gst_app_src_get_max_bytes (appsrc));
       break;
+    case PROP_MAX_BUFFERS:
+      g_value_set_uint64 (value, gst_app_src_get_max_buffers (appsrc));
+      break;
+    case PROP_MAX_TIME:
+      g_value_set_uint64 (value, gst_app_src_get_max_time (appsrc));
+      break;
     case PROP_FORMAT:
       g_value_set_enum (value, priv->format);
       break;
@@ -852,12 +989,22 @@ gst_app_src_get_property (GObject * object, guint prop_id, GValue * value,
     case PROP_CURRENT_LEVEL_BYTES:
       g_value_set_uint64 (value, gst_app_src_get_current_level_bytes (appsrc));
       break;
+    case PROP_CURRENT_LEVEL_BUFFERS:
+      g_value_set_uint64 (value,
+          gst_app_src_get_current_level_buffers (appsrc));
+      break;
+    case PROP_CURRENT_LEVEL_TIME:
+      g_value_set_uint64 (value, gst_app_src_get_current_level_time (appsrc));
+      break;
     case PROP_DURATION:
       g_value_set_uint64 (value, gst_app_src_get_duration (appsrc));
       break;
     case PROP_HANDLE_SEGMENT_CHANGE:
       g_value_set_boolean (value, priv->handle_segment_change);
       break;
+    case PROP_LEAKY_TYPE:
+      g_value_set_enum (value, priv->leaky_type);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -877,6 +1024,17 @@ gst_app_src_send_event (GstElement * element, GstEvent * event)
       g_mutex_unlock (&priv->mutex);
       break;
     default:
+      if (GST_EVENT_IS_SERIALIZED (event)) {
+        GST_DEBUG_OBJECT (appsrc, "queue event: %" GST_PTR_FORMAT, event);
+        g_mutex_lock (&priv->mutex);
+        gst_queue_array_push_tail (priv->queue, event);
+
+        if ((priv->wait_status & STREAM_WAITING))
+          g_cond_broadcast (&priv->cond);
+
+        g_mutex_unlock (&priv->mutex);
+        return TRUE;
+      }
       break;
   }
 
@@ -948,6 +1106,7 @@ gst_app_src_stop (GstBaseSrc * bsrc)
   priv->is_eos = FALSE;
   priv->flushing = TRUE;
   priv->started = FALSE;
+  priv->posted_latency_msg = FALSE;
   gst_app_src_flush_queued (appsrc, TRUE);
   g_cond_broadcast (&priv->cond);
   g_mutex_unlock (&priv->mutex);
@@ -1204,6 +1363,204 @@ gst_app_src_negotiate (GstBaseSrc * basesrc)
   return result;
 }
 
+/* Update the currently queued bytes/buffers/time information for the item
+ * that was just removed from the queue.
+ *
+ * If update_offset is set, additionally the offset of the source will be
+ * moved forward accordingly as if that many bytes were output.
+ */
+static void
+gst_app_src_update_queued_pop (GstAppSrc * appsrc, GstMiniObject * item,
+    gboolean update_offset)
+{
+  GstAppSrcPrivate *priv = appsrc->priv;
+  guint buf_size = 0;
+  guint n_buffers = 0;
+  GstClockTime end_buffer_ts = GST_CLOCK_TIME_NONE;
+
+  if (GST_IS_BUFFER (item)) {
+    GstBuffer *buf = GST_BUFFER_CAST (item);
+    buf_size = gst_buffer_get_size (buf);
+    n_buffers = 1;
+
+    end_buffer_ts = GST_BUFFER_DTS_OR_PTS (buf);
+    if (end_buffer_ts != GST_CLOCK_TIME_NONE
+        && GST_BUFFER_DURATION_IS_VALID (buf))
+      end_buffer_ts += GST_BUFFER_DURATION (buf);
+
+    GST_LOG_OBJECT (appsrc, "have buffer %p of size %u", buf, buf_size);
+  } else if (GST_IS_BUFFER_LIST (item)) {
+    GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (item);
+    guint i;
+
+    n_buffers = gst_buffer_list_length (buffer_list);
+
+    for (i = 0; i < n_buffers; i++) {
+      GstBuffer *tmp = gst_buffer_list_get (buffer_list, i);
+      GstClockTime ts = GST_BUFFER_DTS_OR_PTS (tmp);
+
+      buf_size += gst_buffer_get_size (tmp);
+      /* Update to the last buffer's timestamp that is known */
+      if (ts != GST_CLOCK_TIME_NONE) {
+        end_buffer_ts = ts;
+        if (GST_BUFFER_DURATION_IS_VALID (tmp))
+          end_buffer_ts += GST_BUFFER_DURATION (tmp);
+      }
+    }
+  }
+
+  priv->queued_bytes -= buf_size;
+  priv->queued_buffers -= n_buffers;
+
+  /* Update time level if working on a TIME segment */
+  if ((priv->current_segment.format == GST_FORMAT_TIME
+          || (priv->current_segment.format == GST_FORMAT_UNDEFINED
+              && priv->last_segment.format == GST_FORMAT_TIME))
+      && end_buffer_ts != GST_CLOCK_TIME_NONE) {
+    const GstSegment *segment =
+        priv->current_segment.format ==
+        GST_FORMAT_TIME ? &priv->current_segment : &priv->last_segment;
+
+    /* Clip to the current segment boundaries */
+    if (segment->stop != -1 && end_buffer_ts > segment->stop)
+      end_buffer_ts = segment->stop;
+    else if (segment->start > end_buffer_ts)
+      end_buffer_ts = segment->start;
+
+    priv->last_out_running_time =
+        gst_segment_to_running_time (segment, GST_FORMAT_TIME, end_buffer_ts);
+
+    GST_TRACE_OBJECT (appsrc,
+        "Last in running time %" GST_TIME_FORMAT ", last out running time %"
+        GST_TIME_FORMAT, GST_TIME_ARGS (priv->last_in_running_time),
+        GST_TIME_ARGS (priv->last_out_running_time));
+
+    /* If timestamps on both sides are known, calculate the current
+     * fill level in time and consider the queue empty if the output
+     * running time is lower than the input one (i.e. some kind of reset
+     * has happened).
+     */
+    if (priv->last_out_running_time != GST_CLOCK_TIME_NONE
+        && priv->last_in_running_time != GST_CLOCK_TIME_NONE) {
+      if (priv->last_out_running_time > priv->last_in_running_time) {
+        priv->queued_time = 0;
+      } else {
+        priv->queued_time =
+            priv->last_in_running_time - priv->last_out_running_time;
+      }
+    }
+  }
+
+  GST_DEBUG_OBJECT (appsrc,
+      "Currently queued: %" G_GUINT64_FORMAT " bytes, %" G_GUINT64_FORMAT
+      " buffers, %" GST_TIME_FORMAT, priv->queued_bytes,
+      priv->queued_buffers, GST_TIME_ARGS (priv->queued_time));
+
+  /* only update the offset when in random_access mode and when requested by
+   * the caller, i.e. not when just dropping the item */
+  if (update_offset && priv->stream_type == GST_APP_STREAM_TYPE_RANDOM_ACCESS)
+    priv->offset += buf_size;
+}
+
+/* Update the currently queued bytes/buffers/time information for the item
+ * that was just added to the queue.
+ */
+static void
+gst_app_src_update_queued_push (GstAppSrc * appsrc, GstMiniObject * item)
+{
+  GstAppSrcPrivate *priv = appsrc->priv;
+  GstClockTime start_buffer_ts = GST_CLOCK_TIME_NONE;
+  GstClockTime end_buffer_ts = GST_CLOCK_TIME_NONE;
+  guint buf_size = 0;
+  guint n_buffers = 0;
+
+  if (GST_IS_BUFFER (item)) {
+    GstBuffer *buf = GST_BUFFER_CAST (item);
+
+    buf_size = gst_buffer_get_size (buf);
+    n_buffers = 1;
+
+    start_buffer_ts = end_buffer_ts = GST_BUFFER_DTS_OR_PTS (buf);
+    if (end_buffer_ts != GST_CLOCK_TIME_NONE
+        && GST_BUFFER_DURATION_IS_VALID (buf))
+      end_buffer_ts += GST_BUFFER_DURATION (buf);
+  } else if (GST_IS_BUFFER_LIST (item)) {
+    GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (item);
+    guint i;
+
+    n_buffers = gst_buffer_list_length (buffer_list);
+
+    for (i = 0; i < n_buffers; i++) {
+      GstBuffer *tmp = gst_buffer_list_get (buffer_list, i);
+      GstClockTime ts = GST_BUFFER_DTS_OR_PTS (tmp);
+
+      buf_size += gst_buffer_get_size (tmp);
+
+      if (ts != GST_CLOCK_TIME_NONE) {
+        if (start_buffer_ts == GST_CLOCK_TIME_NONE)
+          start_buffer_ts = ts;
+        end_buffer_ts = ts;
+        if (GST_BUFFER_DURATION_IS_VALID (tmp))
+          end_buffer_ts += GST_BUFFER_DURATION (tmp);
+      }
+    }
+  }
+
+  priv->queued_bytes += buf_size;
+  priv->queued_buffers += n_buffers;
+
+  /* Update time level if working on a TIME segment */
+  if (priv->last_segment.format == GST_FORMAT_TIME
+      && end_buffer_ts != GST_CLOCK_TIME_NONE) {
+    /* Clip to the last segment boundaries */
+    if (priv->last_segment.stop != -1
+        && end_buffer_ts > priv->last_segment.stop)
+      end_buffer_ts = priv->last_segment.stop;
+    else if (priv->last_segment.start > end_buffer_ts)
+      end_buffer_ts = priv->last_segment.start;
+
+    priv->last_in_running_time =
+        gst_segment_to_running_time (&priv->last_segment, GST_FORMAT_TIME,
+        end_buffer_ts);
+
+    /* If this is the only buffer then we can directly update the queued time
+     * here. This is especially useful if this was the first buffer because
+     * otherwise we would have to wait until it is actually unqueued to know
+     * the queued duration */
+    if (priv->queued_buffers == 1) {
+      if (priv->last_segment.stop != -1
+          && start_buffer_ts > priv->last_segment.stop)
+        start_buffer_ts = priv->last_segment.stop;
+      else if (priv->last_segment.start > start_buffer_ts)
+        start_buffer_ts = priv->last_segment.start;
+
+      priv->last_out_running_time =
+          gst_segment_to_running_time (&priv->last_segment, GST_FORMAT_TIME,
+          start_buffer_ts);
+    }
+
+    GST_TRACE_OBJECT (appsrc,
+        "Last in running time %" GST_TIME_FORMAT ", last out running time %"
+        GST_TIME_FORMAT, GST_TIME_ARGS (priv->last_in_running_time),
+        GST_TIME_ARGS (priv->last_out_running_time));
+
+    if (priv->last_out_running_time != GST_CLOCK_TIME_NONE
+        && priv->last_in_running_time != GST_CLOCK_TIME_NONE) {
+      if (priv->last_out_running_time > priv->last_in_running_time) {
+        priv->queued_time = 0;
+      } else {
+        priv->queued_time =
+            priv->last_in_running_time - priv->last_out_running_time;
+      }
+    }
+  }
+
+  GST_DEBUG_OBJECT (appsrc,
+      "Currently queued: %" G_GUINT64_FORMAT " bytes, %" G_GUINT64_FORMAT
+      " buffers, %" GST_TIME_FORMAT, priv->queued_bytes, priv->queued_buffers,
+      GST_TIME_ARGS (priv->queued_time));
+}
+
 static GstFlowReturn
 gst_app_src_create (GstBaseSrc * bsrc, guint64 offset, guint size,
     GstBuffer ** buf)
@@ -1261,9 +1618,13 @@ gst_app_src_create (GstBaseSrc * bsrc, guint64 offset, guint size,
   }
 
   while (TRUE) {
+    /* Our lock may have been release to push events or caps, check out
+     * state in case we are now flushing. */
+    if (G_UNLIKELY (priv->flushing))
+      goto flushing;
+
     /* return data as long as we have some */
     if (!gst_queue_array_is_empty (priv->queue)) {
-      guint buf_size;
       GstMiniObject *obj = gst_queue_array_pop_head (priv->queue);
 
       if (GST_IS_CAPS (obj)) {
@@ -1284,74 +1645,116 @@ gst_app_src_create (GstBaseSrc * bsrc, guint64 offset, guint size,
         if (caps_changed)
           gst_app_src_do_negotiate (bsrc);
 
-        /* Lock has released so now may need
-         *- flushing
-         *- new caps change
-         *- check queue has data */
-        if (G_UNLIKELY (priv->flushing))
-          goto flushing;
-
         /* Continue checks caps and queue */
         continue;
       }
 
       if (GST_IS_BUFFER (obj)) {
-        *buf = GST_BUFFER (obj);
-        buf_size = gst_buffer_get_size (*buf);
-        GST_LOG_OBJECT (appsrc, "have buffer %p of size %u", *buf, buf_size);
+        GstBuffer *buffer = GST_BUFFER (obj);
+
+        /* Mark the buffer as DISCONT if we previously dropped a buffer
+         * instead of outputting it */
+        if (priv->need_discont_downstream) {
+          buffer = gst_buffer_make_writable (buffer);
+          GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+          priv->need_discont_downstream = FALSE;
+        }
+
+        *buf = buffer;
       } else if (GST_IS_BUFFER_LIST (obj)) {
         GstBufferList *buffer_list;
 
         buffer_list = GST_BUFFER_LIST (obj);
 
-        buf_size = gst_buffer_list_calculate_size (buffer_list);
+        /* Mark the first buffer of the buffer list as DISCONT if we
+         * previously dropped a buffer instead of outputting it */
+        if (priv->need_discont_downstream) {
+          GstBuffer *buffer;
 
-        GST_LOG_OBJECT (appsrc, "have buffer list %p of size %u, %u buffers",
-            buffer_list, buf_size, gst_buffer_list_length (buffer_list));
+          buffer_list = gst_buffer_list_make_writable (buffer_list);
+          buffer = gst_buffer_list_get_writable (buffer_list, 0);
+          GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+          priv->need_discont_downstream = FALSE;
+        }
 
         gst_base_src_submit_buffer_list (bsrc, buffer_list);
         *buf = NULL;
       } else if (GST_IS_EVENT (obj)) {
         GstEvent *event = GST_EVENT (obj);
-        const GstSegment *segment = NULL;
-
-        gst_event_parse_segment (event, &segment);
-        g_assert (segment != NULL);
-
-        if (!gst_segment_is_equal (&priv->current_segment, segment)) {
-          GST_DEBUG_OBJECT (appsrc,
-              "Update new segment %" GST_PTR_FORMAT, event);
-          if (!gst_base_src_new_segment (bsrc, segment)) {
-            GST_ERROR_OBJECT (appsrc,
-                "Couldn't set new segment %" GST_PTR_FORMAT, event);
-            gst_event_unref (event);
-            goto invalid_segment;
+
+        GST_DEBUG_OBJECT (appsrc, "pop event %" GST_PTR_FORMAT, event);
+
+        if (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT) {
+          const GstSegment *segment = NULL;
+
+          gst_event_parse_segment (event, &segment);
+          g_assert (segment != NULL);
+
+          if (!gst_segment_is_equal (&priv->current_segment, segment)) {
+            GST_DEBUG_OBJECT (appsrc,
+                "Update new segment %" GST_PTR_FORMAT, event);
+            if (!gst_base_src_new_segment (bsrc, segment)) {
+              GST_ERROR_OBJECT (appsrc,
+                  "Couldn't set new segment %" GST_PTR_FORMAT, event);
+              gst_event_unref (event);
+              goto invalid_segment;
+            }
+            gst_segment_copy_into (segment, &priv->current_segment);
           }
-          gst_segment_copy_into (segment, &priv->current_segment);
-        }
 
-        gst_event_unref (event);
+          gst_event_unref (event);
+        } else {
+          GstEvent *seg_event;
+          GstSegment last_segment = priv->last_segment;
+
+          /* event is serialized with the buffers flow */
+
+          /* We are about to push an event, release out lock */
+          g_mutex_unlock (&priv->mutex);
+
+          seg_event =
+              gst_pad_get_sticky_event (GST_BASE_SRC_PAD (appsrc),
+              GST_EVENT_SEGMENT, 0);
+          if (!seg_event) {
+            seg_event = gst_event_new_segment (&last_segment);
+
+            GST_DEBUG_OBJECT (appsrc,
+                "received serialized event before first buffer, push default segment %"
+                GST_PTR_FORMAT, seg_event);
+
+            gst_pad_push_event (GST_BASE_SRC_PAD (appsrc), seg_event);
+          } else {
+            gst_event_unref (seg_event);
+          }
+
+          gst_pad_push_event (GST_BASE_SRC_PAD (appsrc), event);
+
+          g_mutex_lock (&priv->mutex);
+        }
         continue;
       } else {
         g_assert_not_reached ();
       }
 
-      priv->queued_bytes -= buf_size;
-
-      /* only update the offset when in random_access mode */
-      if (priv->stream_type == GST_APP_STREAM_TYPE_RANDOM_ACCESS)
-        priv->offset += buf_size;
+      gst_app_src_update_queued_pop (appsrc, obj, TRUE);
 
       /* signal that we removed an item */
       if ((priv->wait_status & APP_WAITING))
         g_cond_broadcast (&priv->cond);
 
       /* see if we go lower than the min-percent */
-      if (priv->min_percent && priv->max_bytes) {
-        if (priv->queued_bytes * 100 / priv->max_bytes <= priv->min_percent)
+      if (priv->min_percent) {
+        if ((priv->max_bytes
+                && priv->queued_bytes * 100 / priv->max_bytes <=
+                priv->min_percent) || (priv->max_buffers
+                && priv->queued_buffers * 100 / priv->max_buffers <=
+                priv->min_percent) || (priv->max_time
+                && priv->queued_time * 100 / priv->max_time <=
+                priv->min_percent)) {
           /* ignore flushing state, we got a buffer and we will return it now.
            * Errors will be handled in the next round */
           gst_app_src_emit_need_data (appsrc, size);
+        }
       }
       ret = GST_FLOW_OK;
       break;
@@ -1473,7 +1876,7 @@ gst_app_src_set_caps (GstAppSrc * appsrc, const GstCaps * caps)
  *
  * Get the configured caps on @appsrc.
  *
- * Returns: the #GstCaps produced by the source. gst_caps_unref() after usage.
+ * Returns: (nullable) (transfer full): the #GstCaps produced by the source. gst_caps_unref() after usage.
  */
 GstCaps *
 gst_app_src_get_caps (GstAppSrc * appsrc)
@@ -1717,7 +2120,7 @@ gst_app_src_get_max_bytes (GstAppSrc * appsrc)
 guint64
 gst_app_src_get_current_level_bytes (GstAppSrc * appsrc)
 {
-  gint64 queued;
+  guint64 queued;
   GstAppSrcPrivate *priv;
 
   g_return_val_if_fail (GST_IS_APP_SRC (appsrc), -1);
@@ -1733,6 +2136,183 @@ gst_app_src_get_current_level_bytes (GstAppSrc * appsrc)
   return queued;
 }
 
+/**
+ * gst_app_src_set_max_buffers:
+ * @appsrc: a #GstAppSrc
+ * @max: the maximum number of buffers to queue
+ *
+ * Set the maximum amount of buffers that can be queued in @appsrc.
+ * After the maximum amount of buffers are queued, @appsrc will emit the
+ * "enough-data" signal.
+ *
+ * Since: 1.20
+ */
+void
+gst_app_src_set_max_buffers (GstAppSrc * appsrc, guint64 max)
+{
+  GstAppSrcPrivate *priv;
+
+  g_return_if_fail (GST_IS_APP_SRC (appsrc));
+
+  priv = appsrc->priv;
+
+  g_mutex_lock (&priv->mutex);
+  if (max != priv->max_buffers) {
+    GST_DEBUG_OBJECT (appsrc, "setting max-buffers to %" G_GUINT64_FORMAT, max);
+    priv->max_buffers = max;
+    /* signal the change */
+    g_cond_broadcast (&priv->cond);
+  }
+  g_mutex_unlock (&priv->mutex);
+}
+
+/**
+ * gst_app_src_get_max_buffers:
+ * @appsrc: a #GstAppSrc
+ *
+ * Get the maximum amount of buffers that can be queued in @appsrc.
+ *
+ * Returns: The maximum amount of buffers that can be queued.
+ *
+ * Since: 1.20
+ */
+guint64
+gst_app_src_get_max_buffers (GstAppSrc * appsrc)
+{
+  guint64 result;
+  GstAppSrcPrivate *priv;
+
+  g_return_val_if_fail (GST_IS_APP_SRC (appsrc), 0);
+
+  priv = appsrc->priv;
+
+  g_mutex_lock (&priv->mutex);
+  result = priv->max_buffers;
+  GST_DEBUG_OBJECT (appsrc, "getting max-buffers of %" G_GUINT64_FORMAT,
+      result);
+  g_mutex_unlock (&priv->mutex);
+
+  return result;
+}
+
+/**
+ * gst_app_src_get_current_level_buffers:
+ * @appsrc: a #GstAppSrc
+ *
+ * Get the number of currently queued buffers inside @appsrc.
+ *
+ * Returns: The number of currently queued buffers.
+ *
+ * Since: 1.20
+ */
+guint64
+gst_app_src_get_current_level_buffers (GstAppSrc * appsrc)
+{
+  guint64 queued;
+  GstAppSrcPrivate *priv;
+
+  g_return_val_if_fail (GST_IS_APP_SRC (appsrc), -1);
+
+  priv = appsrc->priv;
+
+  GST_OBJECT_LOCK (appsrc);
+  queued = priv->queued_buffers;
+  GST_DEBUG_OBJECT (appsrc, "current level buffers is %" G_GUINT64_FORMAT,
+      queued);
+  GST_OBJECT_UNLOCK (appsrc);
+
+  return queued;
+}
+
+/**
+ * gst_app_src_set_max_time:
+ * @appsrc: a #GstAppSrc
+ * @max: the maximum amonut of time to queue
+ *
+ * Set the maximum amount of time that can be queued in @appsrc.
+ * After the maximum amount of time are queued, @appsrc will emit the
+ * "enough-data" signal.
+ *
+ * Since: 1.20
+ */
+void
+gst_app_src_set_max_time (GstAppSrc * appsrc, GstClockTime max)
+{
+  GstAppSrcPrivate *priv;
+
+  g_return_if_fail (GST_IS_APP_SRC (appsrc));
+
+  priv = appsrc->priv;
+
+  g_mutex_lock (&priv->mutex);
+  if (max != priv->max_time) {
+    GST_DEBUG_OBJECT (appsrc, "setting max-time to %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (max));
+    priv->max_time = max;
+    /* signal the change */
+    g_cond_broadcast (&priv->cond);
+  }
+  g_mutex_unlock (&priv->mutex);
+}
+
+/**
+ * gst_app_src_get_max_time:
+ * @appsrc: a #GstAppSrc
+ *
+ * Get the maximum amount of time that can be queued in @appsrc.
+ *
+ * Returns: The maximum amount of time that can be queued.
+ *
+ * Since: 1.20
+ */
+GstClockTime
+gst_app_src_get_max_time (GstAppSrc * appsrc)
+{
+  GstClockTime result;
+  GstAppSrcPrivate *priv;
+
+  g_return_val_if_fail (GST_IS_APP_SRC (appsrc), 0);
+
+  priv = appsrc->priv;
+
+  g_mutex_lock (&priv->mutex);
+  result = priv->max_time;
+  GST_DEBUG_OBJECT (appsrc, "getting max-time of %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (result));
+  g_mutex_unlock (&priv->mutex);
+
+  return result;
+}
+
+/**
+ * gst_app_src_get_current_level_time:
+ * @appsrc: a #GstAppSrc
+ *
+ * Get the amount of currently queued time inside @appsrc.
+ *
+ * Returns: The amount of currently queued time.
+ *
+ * Since: 1.20
+ */
+GstClockTime
+gst_app_src_get_current_level_time (GstAppSrc * appsrc)
+{
+  gint64 queued;
+  GstAppSrcPrivate *priv;
+
+  g_return_val_if_fail (GST_IS_APP_SRC (appsrc), GST_CLOCK_TIME_NONE);
+
+  priv = appsrc->priv;
+
+  GST_OBJECT_LOCK (appsrc);
+  queued = priv->queued_time;
+  GST_DEBUG_OBJECT (appsrc, "current level time is %" GST_TIME_FORMAT,
+      GST_TIME_ARGS (queued));
+  GST_OBJECT_UNLOCK (appsrc);
+
+  return queued;
+}
+
 static void
 gst_app_src_set_latencies (GstAppSrc * appsrc, gboolean do_min, guint64 min,
     gboolean do_max, guint64 max)
@@ -1749,6 +2329,10 @@ gst_app_src_set_latencies (GstAppSrc * appsrc, gboolean do_min, guint64 min,
     priv->max_latency = max;
     changed = TRUE;
   }
+  if (!priv->posted_latency_msg) {
+    priv->posted_latency_msg = TRUE;
+    changed = TRUE;
+  }
   g_mutex_unlock (&priv->mutex);
 
   if (changed) {
@@ -1758,6 +2342,45 @@ gst_app_src_set_latencies (GstAppSrc * appsrc, gboolean do_min, guint64 min,
   }
 }
 
+/**
+ * gst_app_src_set_leaky_type:
+ * @appsrc: a #GstAppSrc
+ * @leaky: the #GstAppLeakyType
+ *
+ * When set to any other value than GST_APP_LEAKY_TYPE_NONE then the appsrc
+ * will drop any buffers that are pushed into it once its internal queue is
+ * full. The selected type defines whether to drop the oldest or new
+ * buffers.
+ *
+ * Since: 1.20
+ */
+void
+gst_app_src_set_leaky_type (GstAppSrc * appsrc, GstAppLeakyType leaky)
+{
+  g_return_if_fail (GST_IS_APP_SRC (appsrc));
+
+  appsrc->priv->leaky_type = leaky;
+}
+
+/**
+ * gst_app_src_get_leaky_type:
+ * @appsrc: a #GstAppSrc
+ *
+ * Returns the currently set #GstAppLeakyType. See gst_app_src_set_leaky_type()
+ * for more details.
+ *
+ * Returns: The currently set #GstAppLeakyType.
+ *
+ * Since: 1.20
+ */
+GstAppLeakyType
+gst_app_src_get_leaky_type (GstAppSrc * appsrc)
+{
+  g_return_val_if_fail (GST_IS_APP_SRC (appsrc), GST_APP_LEAKY_TYPE_NONE);
+
+  return appsrc->priv->leaky_type;
+}
+
 /**
  * gst_app_src_set_latency:
  * @appsrc: a #GstAppSrc
@@ -1925,10 +2548,17 @@ gst_app_src_push_internal (GstAppSrc * appsrc, GstBuffer * buffer,
     if (priv->is_eos)
       goto eos;
 
-    if (priv->max_bytes && priv->queued_bytes >= priv->max_bytes) {
+    if ((priv->max_bytes && priv->queued_bytes >= priv->max_bytes) ||
+        (priv->max_buffers && priv->queued_buffers >= priv->max_buffers) ||
+        (priv->max_time && priv->queued_time >= priv->max_time)) {
       GST_DEBUG_OBJECT (appsrc,
-          "queue filled (%" G_GUINT64_FORMAT " >= %" G_GUINT64_FORMAT ")",
-          priv->queued_bytes, priv->max_bytes);
+          "queue filled (queued %" G_GUINT64_FORMAT " bytes, max %"
+          G_GUINT64_FORMAT " bytes, " "queued %" G_GUINT64_FORMAT
+          " buffers, max %" G_GUINT64_FORMAT " buffers, " "queued %"
+          GST_TIME_FORMAT " time, max %" GST_TIME_FORMAT " time)",
+          priv->queued_bytes, priv->max_bytes, priv->queued_buffers,
+          priv->max_buffers, GST_TIME_ARGS (priv->queued_time),
+          GST_TIME_ARGS (priv->max_time));
 
       if (first) {
         Callbacks *callbacks = NULL;
@@ -1949,6 +2579,46 @@ gst_app_src_push_internal (GstAppSrc * appsrc, GstBuffer * buffer,
         g_clear_pointer (&callbacks, callbacks_unref);
 
         g_mutex_lock (&priv->mutex);
+      }
+
+      if (priv->leaky_type == GST_APP_LEAKY_TYPE_UPSTREAM) {
+        priv->need_discont_upstream = TRUE;
+        goto dropped;
+      } else if (priv->leaky_type == GST_APP_LEAKY_TYPE_DOWNSTREAM) {
+        guint i, length = gst_queue_array_get_length (priv->queue);
+        GstMiniObject *item = NULL;
+
+        /* Find the oldest buffer or buffer list and drop it, then update the
+         * limits. Dropping one is sufficient to go below the limits again.
+         */
+        for (i = 0; i < length; i++) {
+          item = gst_queue_array_peek_nth (priv->queue, i);
+          if (GST_IS_BUFFER (item) || GST_IS_BUFFER_LIST (item)) {
+            gst_queue_array_drop_element (priv->queue, i);
+            break;
+          }
+          /* To not accidentally have an event after the loop */
+          item = NULL;
+        }
+
+        if (!item) {
+          GST_FIXME_OBJECT (appsrc,
+              "No buffer or buffer list queued but queue is full");
+          /* This shouldn't really happen but in this case we can't really do
+           * anything apart from accepting the buffer / bufferlist */
+          break;
+        }
+
+        GST_WARNING_OBJECT (appsrc, "Dropping old item %" GST_PTR_FORMAT, item);
+
+        gst_app_src_update_queued_pop (appsrc, item, FALSE);
+        gst_mini_object_unref (item);
+
+        priv->need_discont_downstream = TRUE;
+        continue;
+      }
+
+      if (first) {
         /* continue to check for flushing/eos after releasing the lock */
         first = FALSE;
         continue;
@@ -1966,8 +2636,9 @@ gst_app_src_push_internal (GstAppSrc * appsrc, GstBuffer * buffer,
          * stops pushing buffers. */
         break;
       }
-    } else
+    } else {
       break;
+    }
   }
 
   if (priv->pending_custom_segment) {
@@ -1979,19 +2650,48 @@ gst_app_src_push_internal (GstAppSrc * appsrc, GstBuffer * buffer,
   }
 
   if (buflist != NULL) {
+    /* Mark the first buffer of the buffer list as DISCONT if we previously
+     * dropped a buffer instead of queueing it */
+    if (priv->need_discont_upstream) {
+      if (!steal_ref) {
+        buflist = gst_buffer_list_copy (buflist);
+        steal_ref = TRUE;
+      } else {
+        buflist = gst_buffer_list_make_writable (buflist);
+      }
+      buffer = gst_buffer_list_get_writable (buflist, 0);
+      GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+      priv->need_discont_upstream = FALSE;
+    }
+
     GST_DEBUG_OBJECT (appsrc, "queueing buffer list %p", buflist);
+
     if (!steal_ref)
       gst_buffer_list_ref (buflist);
     gst_queue_array_push_tail (priv->queue, buflist);
-    priv->queued_bytes += gst_buffer_list_calculate_size (buflist);
   } else {
+    /* Mark the buffer as DISCONT if we previously dropped a buffer instead of
+     * queueing it */
+    if (priv->need_discont_upstream) {
+      if (!steal_ref) {
+        buffer = gst_buffer_copy (buffer);
+        steal_ref = TRUE;
+      } else {
+        buffer = gst_buffer_make_writable (buffer);
+      }
+      GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+      priv->need_discont_upstream = FALSE;
+    }
+
     GST_DEBUG_OBJECT (appsrc, "queueing buffer %p", buffer);
     if (!steal_ref)
       gst_buffer_ref (buffer);
     gst_queue_array_push_tail (priv->queue, buffer);
-    priv->queued_bytes += gst_buffer_get_size (buffer);
   }
 
+  gst_app_src_update_queued_push (appsrc,
+      buflist ? GST_MINI_OBJECT_CAST (buflist) : GST_MINI_OBJECT_CAST (buffer));
+
   if ((priv->wait_status & STREAM_WAITING))
     g_cond_broadcast (&priv->cond);
 
@@ -2024,6 +2724,18 @@ eos:
     g_mutex_unlock (&priv->mutex);
     return GST_FLOW_EOS;
   }
+dropped:
+  {
+    GST_DEBUG_OBJECT (appsrc, "dropped new buffer %p, we are full", buffer);
+    if (steal_ref) {
+      if (buflist)
+        gst_buffer_list_unref (buflist);
+      else
+        gst_buffer_unref (buffer);
+    }
+    g_mutex_unlock (&priv->mutex);
+    return GST_FLOW_EOS;
+  }
 }
 
 static GstFlowReturn
@@ -2064,6 +2776,10 @@ gst_app_src_push_sample_internal (GstAppSrc * appsrc, GstSample * sample)
       GST_LOG_OBJECT (appsrc, "segment wasn't changed");
       g_mutex_unlock (&priv->mutex);
       goto handle_buffer;
+    } else {
+      GST_LOG_OBJECT (appsrc,
+          "segment changed %" GST_SEGMENT_FORMAT " -> %" GST_SEGMENT_FORMAT,
+          &priv->last_segment, segment);
     }
 
     /* will be pushed to queue with next buffer/buffer-list */
diff --git a/gst-libs/gst/app/gstappsrc.h b/gst-libs/gst/app/gstappsrc.h
index 82f8c2a4e0..16180fd165 100644
--- a/gst-libs/gst/app/gstappsrc.h
+++ b/gst-libs/gst/app/gstappsrc.h
@@ -88,6 +88,23 @@ typedef enum
   GST_APP_STREAM_TYPE_RANDOM_ACCESS
 } GstAppStreamType;
 
+/**
+ * GstAppLeakyType:
+ * @GST_APP_LEAKY_TYPE_NONE: Not Leaky
+ * @GST_APP_LEAKY_TYPE_UPSTREAM: Leaky on upstream (new buffers)
+ * @GST_APP_LEAKY_TYPE_DOWNSTREAM: Leaky on downstream (old buffers)
+ *
+ * Buffer dropping scheme to avoid the element's internal queue to block when
+ * full.
+ *
+ * Since: 1.20
+ */
+typedef enum {
+  GST_APP_LEAKY_TYPE_NONE,
+  GST_APP_LEAKY_TYPE_UPSTREAM,
+  GST_APP_LEAKY_TYPE_DOWNSTREAM
+} GstAppLeakyType;
+
 struct _GstAppSrc
 {
   GstBaseSrc basesrc;
@@ -154,6 +171,30 @@ guint64          gst_app_src_get_max_bytes           (GstAppSrc *appsrc);
 GST_APP_API
 guint64          gst_app_src_get_current_level_bytes (GstAppSrc *appsrc);
 
+GST_APP_API
+void             gst_app_src_set_max_buffers           (GstAppSrc *appsrc, guint64 max);
+
+GST_APP_API
+guint64          gst_app_src_get_max_buffers           (GstAppSrc *appsrc);
+
+GST_APP_API
+guint64          gst_app_src_get_current_level_buffers (GstAppSrc *appsrc);
+
+GST_APP_API
+void             gst_app_src_set_max_time            (GstAppSrc *appsrc, GstClockTime max);
+
+GST_APP_API
+GstClockTime     gst_app_src_get_max_time            (GstAppSrc *appsrc);
+
+GST_APP_API
+GstClockTime     gst_app_src_get_current_level_time  (GstAppSrc *appsrc);
+
+GST_APP_API
+void             gst_app_src_set_leaky_type          (GstAppSrc *appsrc, GstAppLeakyType leaky);
+
+GST_APP_API
+GstAppLeakyType  gst_app_src_get_leaky_type          (GstAppSrc *appsrc);
+
 GST_APP_API
 void             gst_app_src_set_latency             (GstAppSrc *appsrc, guint64 min, guint64 max);
 
diff --git a/gst-libs/gst/audio/audio-buffer.c b/gst-libs/gst/audio/audio-buffer.c
index e0165728d2..7d139f0b22 100644
--- a/gst-libs/gst/audio/audio-buffer.c
+++ b/gst-libs/gst/audio/audio-buffer.c
@@ -55,7 +55,7 @@ gst_audio_buffer_unmap (GstAudioBuffer * buffer)
 
 /**
  * gst_audio_buffer_map:
- * @buffer: pointer to a #GstAudioBuffer
+ * @buffer: (out caller-allocates): pointer to a #GstAudioBuffer
  * @info: the audio properties of the buffer
  * @gstbuffer: (transfer none): the #GstBuffer to be mapped
  * @flags: the access mode for the memory
diff --git a/gst-libs/gst/audio/audio-channel-mixer.c b/gst-libs/gst/audio/audio-channel-mixer.c
index 49d248c3d5..07c1148a9a 100644
--- a/gst-libs/gst/audio/audio-channel-mixer.c
+++ b/gst-libs/gst/audio/audio-channel-mixer.c
@@ -817,8 +817,7 @@ DEFINE_FLOAT_MIX_FUNC (double, planar, planar);
  *
  * Create a new channel mixer object for the given parameters.
  *
- * Returns: a new #GstAudioChannelMixer object, or %NULL if @format isn't supported,
- *   @matrix is invalid, or @matrix is %NULL and @in_channels != @out_channels.
+ * Returns: a new #GstAudioChannelMixer object.
  *   Free with gst_audio_channel_mixer_free() after usage.
  *
  * Since: 1.14
@@ -980,7 +979,7 @@ gst_audio_channel_mixer_new_with_matrix (GstAudioChannelMixerFlags flags,
  *
  * Create a new channel mixer object for the given parameters.
  *
- * Returns: a new #GstAudioChannelMixer object, or %NULL if @format isn't supported.
+ * Returns: a new #GstAudioChannelMixer object.
  *   Free with gst_audio_channel_mixer_free() after usage.
  */
 GstAudioChannelMixer *
diff --git a/gst-libs/gst/audio/audio-converter.c b/gst-libs/gst/audio/audio-converter.c
index 06a2841dd7..f1116d3917 100644
--- a/gst-libs/gst/audio/audio-converter.c
+++ b/gst-libs/gst/audio/audio-converter.c
@@ -263,7 +263,6 @@ audio_chain_get_samples (AudioChain * chain, gsize * avail)
   return res;
 }
 
-/*
 static guint
 get_opt_uint (GstAudioConverter * convert, const gchar * opt, guint def)
 {
@@ -272,7 +271,6 @@ get_opt_uint (GstAudioConverter * convert, const gchar * opt, guint def)
     res = def;
   return res;
 }
-*/
 
 static gint
 get_opt_enum (GstAudioConverter * convert, const gchar * opt, GType type,
@@ -292,6 +290,7 @@ get_opt_value (GstAudioConverter * convert, const gchar * opt)
 
 #define DEFAULT_OPT_RESAMPLER_METHOD GST_AUDIO_RESAMPLER_METHOD_BLACKMAN_NUTTALL
 #define DEFAULT_OPT_DITHER_METHOD GST_AUDIO_DITHER_NONE
+#define DEFAULT_OPT_DITHER_THRESHOLD 20
 #define DEFAULT_OPT_NOISE_SHAPING_METHOD GST_AUDIO_NOISE_SHAPING_NONE
 #define DEFAULT_OPT_QUANTIZATION 1
 
@@ -301,6 +300,8 @@ get_opt_value (GstAudioConverter * convert, const gchar * opt)
 #define GET_OPT_DITHER_METHOD(c) get_opt_enum(c, \
     GST_AUDIO_CONVERTER_OPT_DITHER_METHOD, GST_TYPE_AUDIO_DITHER_METHOD, \
     DEFAULT_OPT_DITHER_METHOD)
+#define GET_OPT_DITHER_THRESHOLD(c) get_opt_uint(c, \
+    GST_AUDIO_CONVERTER_OPT_DITHER_THRESHOLD, DEFAULT_OPT_DITHER_THRESHOLD)
 #define GET_OPT_NOISE_SHAPING_METHOD(c) get_opt_enum(c, \
     GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD, GST_TYPE_AUDIO_NOISE_SHAPING_METHOD, \
     DEFAULT_OPT_NOISE_SHAPING_METHOD)
@@ -478,7 +479,7 @@ do_unpack (AudioChain * chain, gpointer user_data)
       }
     } else {
       for (i = 0; i < chain->blocks; i++) {
-        gst_audio_format_fill_silence (chain->finfo, tmp[i],
+        gst_audio_format_info_fill_silence (chain->finfo, tmp[i],
             num_samples * chain->inc);
       }
     }
@@ -951,9 +952,11 @@ chain_quantize (GstAudioConverter * convert, AudioChain * prev)
   gint in_depth, out_depth;
   gboolean in_int, out_int;
   GstAudioDitherMethod dither;
+  guint dither_threshold;
   GstAudioNoiseShapingMethod ns;
 
   dither = GET_OPT_DITHER_METHOD (convert);
+  dither_threshold = GET_OPT_DITHER_THRESHOLD (convert);
   ns = GET_OPT_NOISE_SHAPING_METHOD (convert);
 
   cur_finfo = gst_audio_format_get_info (convert->current_format);
@@ -969,7 +972,7 @@ chain_quantize (GstAudioConverter * convert, AudioChain * prev)
    * as DA converters only can do a SNR up to 20 bits in reality.
    * Also don't dither or apply noise shaping if target depth is larger than
    * source depth. */
-  if (out_depth > 20 || (in_int && out_depth >= in_depth)) {
+  if (out_depth > dither_threshold || (in_int && out_depth >= in_depth)) {
     dither = GST_AUDIO_DITHER_NONE;
     ns = GST_AUDIO_NOISE_SHAPING_NONE;
     GST_INFO ("using no dither and noise shaping");
@@ -1103,7 +1106,7 @@ converter_passthrough (GstAudioConverter * convert,
     }
   } else {
     for (i = 0; i < chain->blocks; i++)
-      gst_audio_format_fill_silence (convert->in.finfo, out[i], samples);
+      gst_audio_format_info_fill_silence (convert->in.finfo, out[i], samples);
   }
   return TRUE;
 }
@@ -1249,7 +1252,7 @@ converter_endian (GstAudioConverter * convert,
       convert->swap_endian (out[i], in[i], samples);
   } else {
     for (i = 0; i < chain->blocks; i++)
-      gst_audio_format_fill_silence (convert->in.finfo, out[i], samples);
+      gst_audio_format_info_fill_silence (convert->in.finfo, out[i], samples);
   }
   return TRUE;
 }
@@ -1317,7 +1320,7 @@ converter_resample (GstAudioConverter * convert,
  * @config contains extra configuration options, see `GST_AUDIO_CONVERTER_OPT_*`
  * parameters for details about the options and values.
  *
- * Returns: a #GstAudioConverter or %NULL if conversion is not possible.
+ * Returns: (nullable): a #GstAudioConverter or %NULL if conversion is not possible.
  */
 GstAudioConverter *
 gst_audio_converter_new (GstAudioConverterFlags flags, GstAudioInfo * in_info,
diff --git a/gst-libs/gst/audio/audio-converter.h b/gst-libs/gst/audio/audio-converter.h
index 083bda4fa2..ef5ac9a003 100644
--- a/gst-libs/gst/audio/audio-converter.h
+++ b/gst-libs/gst/audio/audio-converter.h
@@ -106,6 +106,17 @@ typedef struct _GstAudioConverter GstAudioConverter;
  */
 #define GST_AUDIO_CONVERTER_OPT_MIX_MATRIX   "GstAudioConverter.mix-matrix"
 
+/**
+ * GST_AUDIO_CONVERTER_OPT_DITHER_THRESHOLD:
+ *
+ * Threshold for the output bit depth at/below which to apply dithering.
+ *
+ * Default is 20 bit.
+ *
+ * Since: 1.22
+ */
+#define GST_AUDIO_CONVERTER_OPT_DITHER_THRESHOLD   "GstAudioConverter.dither-threshold"
+
 /**
  * GstAudioConverterFlags:
  * @GST_AUDIO_CONVERTER_FLAG_NONE: no flag
diff --git a/gst-libs/gst/audio/audio-format.c b/gst-libs/gst/audio/audio-format.c
index b79a49c734..b1b8d60a17 100644
--- a/gst-libs/gst/audio/audio-format.c
+++ b/gst-libs/gst/audio/audio-format.c
@@ -459,14 +459,34 @@ gst_audio_format_get_info (GstAudioFormat format)
  * @length: the length to fill
  *
  * Fill @length bytes in @dest with silence samples for @info.
+ *
+ * Deprecated: 1.20: Use gst_audio_format_info_fill_silence() instead.
  */
 void
 gst_audio_format_fill_silence (const GstAudioFormatInfo * info,
     gpointer dest, gsize length)
+{
+  gst_audio_format_info_fill_silence (info, dest, length);
+}
+
+/**
+ * gst_audio_format_info_fill_silence:
+ * @info: a #GstAudioFormatInfo
+ * @dest: (array length=length) (element-type guint8): a destination
+ *   to fill
+ * @length: the length to fill
+ *
+ * Fill @length bytes in @dest with silence samples for @info.
+ *
+ * Since: 1.20
+ */
+void
+gst_audio_format_info_fill_silence (const GstAudioFormatInfo * info,
+    gpointer dest, gsize length)
 {
   guint8 *dptr = dest;
 
-  g_return_if_fail (info != NULL);
+  g_return_if_fail (GST_AUDIO_FORMAT_INFO_IS_VALID_RAW (info));
   g_return_if_fail (dest != NULL);
 
   if (info->flags & GST_AUDIO_FORMAT_FLAG_FLOAT ||
diff --git a/gst-libs/gst/audio/audio-format.h b/gst-libs/gst/audio/audio-format.h
index aaab644e19..c7aeef8de3 100644
--- a/gst-libs/gst/audio/audio-format.h
+++ b/gst-libs/gst/audio/audio-format.h
@@ -256,6 +256,18 @@ struct _GstAudioFormatInfo {
 GST_AUDIO_API
 GType gst_audio_format_info_get_type (void);
 
+/**
+ * GST_AUDIO_FORMAT_INFO_IS_VALID_RAW:
+ *
+ * Tests that the given #GstAudioFormatInfo represents a valid un-encoded
+ * format.
+ *
+ * Since: 1.22
+ */
+#define GST_AUDIO_FORMAT_INFO_IS_VALID_RAW(info)                        \
+  (info != NULL && (info)->format > GST_AUDIO_FORMAT_ENCODED &&         \
+   (info)->width > 0 && (info)->depth > 0)
+
 #define GST_AUDIO_FORMAT_INFO_FORMAT(info)           ((info)->format)
 #define GST_AUDIO_FORMAT_INFO_NAME(info)             ((info)->name)
 #define GST_AUDIO_FORMAT_INFO_FLAGS(info)            ((info)->flags)
@@ -286,8 +298,11 @@ const GstAudioFormatInfo *
                gst_audio_format_get_info         (GstAudioFormat format) G_GNUC_CONST;
 
 GST_AUDIO_API
-void           gst_audio_format_fill_silence     (const GstAudioFormatInfo *info,
-                                                  gpointer dest, gsize length);
+void           gst_audio_format_info_fill_silence (const GstAudioFormatInfo *info,
+                                                   gpointer dest, gsize length);
+GST_AUDIO_API G_DEPRECATED_FOR(gst_audio_format_info_fill_silence)
+void           gst_audio_format_fill_silence      (const GstAudioFormatInfo *info,
+                                                   gpointer dest, gsize length);
 
 /**
  * GST_AUDIO_RATE_RANGE:
diff --git a/gst-libs/gst/audio/audio-info.c b/gst-libs/gst/audio/audio-info.c
index b18c2d9325..a37e3cf025 100644
--- a/gst-libs/gst/audio/audio-info.c
+++ b/gst-libs/gst/audio/audio-info.c
@@ -101,7 +101,7 @@ gst_audio_info_new (void)
 
 /**
  * gst_audio_info_init:
- * @info: a #GstAudioInfo
+ * @info: (out caller-allocates): a #GstAudioInfo
  *
  * Initialize @info with default values.
  */
@@ -181,7 +181,7 @@ gst_audio_info_set_format (GstAudioInfo * info, GstAudioFormat format,
 
 /**
  * gst_audio_info_from_caps:
- * @info: a #GstAudioInfo
+ * @info: (out caller-allocates): a #GstAudioInfo
  * @caps: a #GstCaps
  *
  * Parse @caps and update @info.
@@ -320,6 +320,28 @@ invalid_channel_mask:
   }
 }
 
+/**
+ * gst_audio_info_new_from_caps:
+ * @caps: a #GstCaps
+ *
+ * Parse @caps to generate a #GstAudioInfo.
+ *
+ * Returns: (nullable): A #GstAudioInfo, or %NULL if @caps couldn't be parsed
+ * Since: 1.20
+ */
+GstAudioInfo *
+gst_audio_info_new_from_caps (const GstCaps * caps)
+{
+  GstAudioInfo *ret = gst_audio_info_new ();
+
+  if (gst_audio_info_from_caps (ret, caps)) {
+    return ret;
+  } else {
+    gst_audio_info_free (ret);
+    return NULL;
+  }
+}
+
 /**
  * gst_audio_info_to_caps:
  * @info: a #GstAudioInfo
diff --git a/gst-libs/gst/audio/audio-info.h b/gst-libs/gst/audio/audio-info.h
index cc9e972220..51264b9304 100644
--- a/gst-libs/gst/audio/audio-info.h
+++ b/gst-libs/gst/audio/audio-info.h
@@ -93,7 +93,7 @@ GType gst_audio_info_get_type                (void);
 #define GST_AUDIO_INFO_IS_BIG_ENDIAN(i)      (GST_AUDIO_FORMAT_INFO_IS_BIG_ENDIAN((i)->finfo))
 
 #define GST_AUDIO_INFO_FLAGS(info)           ((info)->flags)
-#define GST_AUDIO_INFO_IS_UNPOSITIONED(info) ((info)->flags & GST_AUDIO_FLAG_UNPOSITIONED)
+#define GST_AUDIO_INFO_IS_UNPOSITIONED(info) (((info)->flags & GST_AUDIO_FLAG_UNPOSITIONED) != 0)
 #define GST_AUDIO_INFO_LAYOUT(info)          ((info)->layout)
 
 #define GST_AUDIO_INFO_RATE(info)            ((info)->rate)
@@ -104,6 +104,9 @@ GType gst_audio_info_get_type                (void);
 GST_AUDIO_API
 GstAudioInfo * gst_audio_info_new         (void);
 
+GST_AUDIO_API
+GstAudioInfo * gst_audio_info_new_from_caps (const GstCaps * caps);
+
 GST_AUDIO_API
 void           gst_audio_info_init        (GstAudioInfo *info);
 
diff --git a/gst-libs/gst/audio/audio-quantize.c b/gst-libs/gst/audio/audio-quantize.c
index 8c627173bc..e4c33ba6a1 100644
--- a/gst-libs/gst/audio/audio-quantize.c
+++ b/gst-libs/gst/audio/audio-quantize.c
@@ -54,6 +54,7 @@ struct _GstAudioQuantize
 
   /* last random number generated per channel for hifreq TPDF dither */
   gpointer last_random;
+  guint32 random_state;
   /* contains the past quantization errors, error[channels][count] */
   guint error_size;
   gpointer error_buf;
@@ -92,27 +93,28 @@ gst_audio_quantize_quantize_int_none_none (GstAudioQuantize * quant,
       samples * quant->stride);
 }
 
-/* This is the base function, implementing a linear congruential generator
- * and returning a pseudo random number between 0 and 2^32 - 1.
- */
+/* 32 bit xorshift PRNG, see https://en.wikipedia.org/wiki/Xorshift */
 static inline guint32
-gst_fast_random_uint32 (void)
+gst_fast_random_uint32 (guint32 * state)
 {
-  static guint32 state = 0xdeadbeef;
-  return (state = state * 1103515245 + 12345);
+  guint64 x = *state;
+  x ^= x << 13;
+  x ^= x >> 17;
+  x ^= x << 5;
+  return (*state = x);
 }
 
 static inline gint32
-gst_fast_random_int32 (void)
+gst_fast_random_int32 (guint32 * state)
 {
-  return (gint32) gst_fast_random_uint32 ();
+  return (gint32) gst_fast_random_uint32 (state);
 }
 
 /* Assuming dither == 2^n,
  * returns one of 2^(n+1) possible random values:
  * -dither <= retval < dither */
-#define RANDOM_INT_DITHER(dither)                                       \
-  (- dither + (gst_fast_random_int32 () & ((dither << 1) - 1)))
+#define RANDOM_INT_DITHER(state, dither)                                       \
+  (- dither + (gst_fast_random_int32 (state) & ((dither << 1) - 1)))
 
 static void
 setup_dither_buf (GstAudioQuantize * quant, gint samples)
@@ -144,13 +146,15 @@ setup_dither_buf (GstAudioQuantize * quant, gint samples)
     case GST_AUDIO_DITHER_RPDF:
       dither = 1 << (shift);
       for (i = 0; i < len; i++)
-        d[i] = bias + RANDOM_INT_DITHER (dither);
+        d[i] = bias + RANDOM_INT_DITHER (&quant->random_state, dither);
       break;
 
     case GST_AUDIO_DITHER_TPDF:
       dither = 1 << (shift - 1);
       for (i = 0; i < len; i++)
-        d[i] = bias + RANDOM_INT_DITHER (dither) + RANDOM_INT_DITHER (dither);
+        d[i] =
+            bias + RANDOM_INT_DITHER (&quant->random_state,
+            dither) + RANDOM_INT_DITHER (&quant->random_state, dither);
       break;
 
     case GST_AUDIO_DITHER_TPDF_HF:
@@ -159,7 +163,7 @@ setup_dither_buf (GstAudioQuantize * quant, gint samples)
 
       dither = 1 << (shift - 1);
       for (i = 0; i < len; i++) {
-        tmp = RANDOM_INT_DITHER (dither);
+        tmp = RANDOM_INT_DITHER (&quant->random_state, dither);
         d[i] = bias + tmp - last_random[i % stride];
         last_random[i % stride] = tmp;
       }
@@ -369,6 +373,9 @@ gst_audio_quantize_setup_noise_shaping (GstAudioQuantize * quant)
 static void
 gst_audio_quantize_setup_dither (GstAudioQuantize * quant)
 {
+  /* Some non-zero number */
+  quant->random_state = 0xc2d6038f;
+
   switch (quant->dither) {
     case GST_AUDIO_DITHER_TPDF_HF:
       quant->last_random = g_new0 (gint32, quant->stride);
diff --git a/gst-libs/gst/audio/audio-resampler.c b/gst-libs/gst/audio/audio-resampler.c
index c67f860523..a612d85ad2 100644
--- a/gst-libs/gst/audio/audio-resampler.c
+++ b/gst-libs/gst/audio/audio-resampler.c
@@ -1342,8 +1342,7 @@ gst_audio_resampler_options_set_quality (GstAudioResamplerMethod method,
  *
  * Make a new resampler.
  *
- * Returns: (skip) (transfer full): The new #GstAudioResampler, or
- * %NULL on failure.
+ * Returns: (skip) (transfer full): The new #GstAudioResampler.
  */
 GstAudioResampler *
 gst_audio_resampler_new (GstAudioResamplerMethod method,
diff --git a/gst-libs/gst/audio/audio.c b/gst-libs/gst/audio/audio.c
index 440a4e87da..1180326c92 100644
--- a/gst-libs/gst/audio/audio.c
+++ b/gst-libs/gst/audio/audio.c
@@ -69,7 +69,7 @@ ensure_debug_category (void)
  * After calling this function the caller does not own a reference to
  * @buffer anymore.
  *
- * Returns: (transfer full): %NULL if the buffer is completely outside the configured segment,
+ * Returns: (transfer full) (nullable): %NULL if the buffer is completely outside the configured segment,
  * otherwise the clipped buffer is returned.
  *
  * If the buffer has no timestamp, it is assumed to be inside the segment and
@@ -91,7 +91,7 @@ gst_audio_buffer_clip (GstBuffer * buffer, const GstSegment * segment,
       segment->format == GST_FORMAT_DEFAULT, buffer);
   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
 
-  if (!GST_BUFFER_TIMESTAMP_IS_VALID (buffer))
+  if (!GST_BUFFER_PTS_IS_VALID (buffer))
     /* No timestamp - assume the buffer is completely in the segment */
     return buffer;
 
@@ -109,7 +109,7 @@ gst_audio_buffer_clip (GstBuffer * buffer, const GstSegment * segment,
   if (!size)
     return buffer;
 
-  timestamp = GST_BUFFER_TIMESTAMP (buffer);
+  timestamp = GST_BUFFER_PTS (buffer);
   GST_DEBUG ("timestamp %" GST_TIME_FORMAT, GST_TIME_ARGS (timestamp));
   if (GST_BUFFER_DURATION_IS_VALID (buffer)) {
     duration = GST_BUFFER_DURATION (buffer);
@@ -214,9 +214,9 @@ gst_audio_buffer_clip (GstBuffer * buffer, const GstSegment * segment,
   if (trim == 0 && size == osize) {
     ret = buffer;
 
-    if (GST_BUFFER_TIMESTAMP (ret) != timestamp) {
+    if (GST_BUFFER_PTS (ret) != timestamp) {
       ret = gst_buffer_make_writable (ret);
-      GST_BUFFER_TIMESTAMP (ret) = timestamp;
+      GST_BUFFER_PTS (ret) = timestamp;
     }
     if (GST_BUFFER_DURATION (ret) != duration) {
       ret = gst_buffer_make_writable (ret);
@@ -229,7 +229,7 @@ gst_audio_buffer_clip (GstBuffer * buffer, const GstSegment * segment,
 
     GST_DEBUG ("timestamp %" GST_TIME_FORMAT, GST_TIME_ARGS (timestamp));
     if (ret) {
-      GST_BUFFER_TIMESTAMP (ret) = timestamp;
+      GST_BUFFER_PTS (ret) = timestamp;
 
       if (change_duration)
         GST_BUFFER_DURATION (ret) = duration;
@@ -258,11 +258,16 @@ gst_audio_buffer_clip (GstBuffer * buffer, const GstSegment * segment,
  * the necessary amount of samples from the end and @trim number of samples
  * from the beginning.
  *
+ * This function does not know the audio rate, therefore the caller is
+ * responsible for re-setting the correct timestamp and duration to the
+ * buffer. However, timestamp will be preserved if trim == 0, and duration
+ * will also be preserved if there is no trimming to be done. Offset and
+ * offset end will be preserved / updated.
+ *
  * After calling this function the caller does not own a reference to
  * @buffer anymore.
  *
- * Returns: (transfer full): the truncated buffer or %NULL if the arguments
- *   were invalid
+ * Returns: (transfer full): the truncated buffer
  *
  * Since: 1.16
  */
@@ -274,11 +279,14 @@ gst_audio_buffer_truncate (GstBuffer * buffer, gint bpf, gsize trim,
   GstBuffer *ret = NULL;
   gsize orig_samples;
   gint i;
+  GstClockTime orig_ts, orig_offset;
 
   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
 
   meta = gst_buffer_get_audio_meta (buffer);
   orig_samples = meta ? meta->samples : gst_buffer_get_size (buffer) / bpf;
+  orig_ts = GST_BUFFER_PTS (buffer);
+  orig_offset = GST_BUFFER_OFFSET (buffer);
 
   g_return_val_if_fail (trim < orig_samples, NULL);
   g_return_val_if_fail (samples == -1 || trim + samples <= orig_samples, NULL);
@@ -312,5 +320,22 @@ gst_audio_buffer_truncate (GstBuffer * buffer, gint bpf, gsize trim,
     }
   }
 
+  GST_BUFFER_DTS (ret) = GST_CLOCK_TIME_NONE;
+  if (GST_CLOCK_TIME_IS_VALID (orig_ts) && trim == 0) {
+    GST_BUFFER_PTS (ret) = orig_ts;
+  } else {
+    GST_BUFFER_PTS (ret) = GST_CLOCK_TIME_NONE;
+  }
+  /* If duration was the same, it would have meant there's no trimming to be
+   * done, so we have an early return further up */
+  GST_BUFFER_DURATION (ret) = GST_CLOCK_TIME_NONE;
+  if (orig_offset != GST_BUFFER_OFFSET_NONE) {
+    GST_BUFFER_OFFSET (ret) = orig_offset + trim;
+    GST_BUFFER_OFFSET_END (ret) = GST_BUFFER_OFFSET (ret) + samples;
+  } else {
+    GST_BUFFER_OFFSET (ret) = GST_BUFFER_OFFSET_NONE;
+    GST_BUFFER_OFFSET_END (ret) = GST_BUFFER_OFFSET_NONE;
+  }
+
   return ret;
 }
diff --git a/gst-libs/gst/audio/gstaudiobasesink.c b/gst-libs/gst/audio/gstaudiobasesink.c
index e40989ab00..891941d128 100644
--- a/gst-libs/gst/audio/gstaudiobasesink.c
+++ b/gst-libs/gst/audio/gstaudiobasesink.c
@@ -685,6 +685,7 @@ gst_audio_base_sink_set_alignment_threshold (GstAudioBaseSink * sink,
     GstClockTime alignment_threshold)
 {
   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (alignment_threshold));
 
   GST_OBJECT_LOCK (sink);
   sink->priv->alignment_threshold = alignment_threshold;
@@ -725,6 +726,7 @@ gst_audio_base_sink_set_discont_wait (GstAudioBaseSink * sink,
     GstClockTime discont_wait)
 {
   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (discont_wait));
 
   GST_OBJECT_LOCK (sink);
   sink->priv->discont_wait = discont_wait;
@@ -1864,7 +1866,7 @@ gst_audio_base_sink_render (GstBaseSink * bsink, GstBuffer * buf)
 
   samples = size / bpf;
 
-  time = GST_BUFFER_TIMESTAMP (buf);
+  time = GST_BUFFER_PTS (buf);
 
   /* Last ditch attempt to ensure that we only play silence if
    * we are in trickmode no-audio mode (or if a buffer is marked as a GAP)
@@ -2254,7 +2256,7 @@ sync_latency_failed:
  * call the ::create_ringbuffer vmethod and will set @sink as the parent of
  * the returned buffer (see gst_object_set_parent()).
  *
- * Returns: (transfer none): The new ringbuffer of @sink.
+ * Returns: (transfer none) (nullable): The new ringbuffer of @sink.
  */
 GstAudioRingBuffer *
 gst_audio_base_sink_create_ringbuffer (GstAudioBaseSink * sink)
diff --git a/gst-libs/gst/audio/gstaudiobasesink.h b/gst-libs/gst/audio/gstaudiobasesink.h
index 0c009fd4a6..883ed6ecef 100644
--- a/gst-libs/gst/audio/gstaudiobasesink.h
+++ b/gst-libs/gst/audio/gstaudiobasesink.h
@@ -110,7 +110,7 @@ typedef struct _GstAudioBaseSinkPrivate GstAudioBaseSinkPrivate;
  * @GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH: Samples have been flushed
  * @GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY: Sink was synchronized to the estimated latency (occurs during initialization)
  * @GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT: Aligning buffers failed because the timestamps are too discontinuous
- * @GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE: Audio output device experienced and recovered from an error but introduced latency in the process (see also @gst_audio_base_sink_report_device_failure())
+ * @GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE: Audio output device experienced and recovered from an error but introduced latency in the process (see also gst_audio_base_sink_report_device_failure())
  *
  * Different possible reasons for discontinuities. This enum is useful for the custom
  * slave method.
diff --git a/gst-libs/gst/audio/gstaudiobasesrc.c b/gst-libs/gst/audio/gstaudiobasesrc.c
index 3480ee7b8d..0dd7654e03 100644
--- a/gst-libs/gst/audio/gstaudiobasesrc.c
+++ b/gst-libs/gst/audio/gstaudiobasesrc.c
@@ -40,7 +40,7 @@
 #include <gst/audio/audio.h>
 #include "gstaudiobasesrc.h"
 
-#include "gst/gst-i18n-plugin.h"
+#include <glib/gi18n-lib.h>
 
 GST_DEBUG_CATEGORY_STATIC (gst_audio_base_src_debug);
 #define GST_CAT_DEFAULT gst_audio_base_src_debug
@@ -518,7 +518,8 @@ gst_audio_base_src_setcaps (GstBaseSrc * bsrc, GstCaps * caps)
 
   spec = &src->ringbuffer->spec;
 
-  if (G_UNLIKELY (spec->caps && gst_caps_is_equal (spec->caps, caps))) {
+  if (G_UNLIKELY (gst_audio_ring_buffer_is_acquired (src->ringbuffer)
+          && gst_caps_is_equal (spec->caps, caps))) {
     GST_DEBUG_OBJECT (src,
         "Ringbuffer caps haven't changed, skipping reconfiguration");
     return TRUE;
@@ -1031,7 +1032,7 @@ gst_audio_base_src_create (GstBaseSrc * bsrc, guint64 offset, guint length,
 no_sync:
   GST_OBJECT_UNLOCK (src);
 
-  GST_BUFFER_TIMESTAMP (buf) = timestamp;
+  GST_BUFFER_PTS (buf) = timestamp;
   GST_BUFFER_DURATION (buf) = duration;
   GST_BUFFER_OFFSET (buf) = sample;
   GST_BUFFER_OFFSET_END (buf) = sample + samples;
@@ -1039,7 +1040,7 @@ no_sync:
   *outbuf = buf;
 
   GST_LOG_OBJECT (src, "Pushed buffer timestamp %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
+      GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
 
   return GST_FLOW_OK;
 
@@ -1085,7 +1086,7 @@ got_error:
  * the ::create_ringbuffer vmethod and will set @src as the parent of the
  * returned buffer (see gst_object_set_parent()).
  *
- * Returns: (transfer none): The new ringbuffer of @src.
+ * Returns: (transfer none) (nullable): The new ringbuffer of @src.
  */
 GstAudioRingBuffer *
 gst_audio_base_src_create_ringbuffer (GstAudioBaseSrc * src)
diff --git a/gst-libs/gst/audio/gstaudiocdsrc.c b/gst-libs/gst/audio/gstaudiocdsrc.c
index 81421d327b..437bebb5dd 100644
--- a/gst-libs/gst/audio/gstaudiocdsrc.c
+++ b/gst-libs/gst/audio/gstaudiocdsrc.c
@@ -96,7 +96,7 @@
 #include <gst/tag/tag.h>
 #include <gst/audio/audio.h>
 #include "gstaudiocdsrc.h"
-#include "gst/gst-i18n-plugin.h"
+#include <glib/gi18n-lib.h>
 
 GST_DEBUG_CATEGORY_STATIC (gst_audio_cd_src_debug);
 #define GST_CAT_DEFAULT gst_audio_cd_src_debug
@@ -1764,7 +1764,7 @@ gst_audio_cd_src_create (GstPushSrc * pushsrc, GstBuffer ** buffer)
         GST_SECOND, 44100);
   }
 
-  GST_BUFFER_TIMESTAMP (buf) = position;
+  GST_BUFFER_PTS (buf) = position;
   GST_BUFFER_DURATION (buf) = duration;
 
   GST_LOG_OBJECT (src, "pushing sector %d with timestamp %" GST_TIME_FORMAT,
diff --git a/gst-libs/gst/audio/gstaudiodecoder.c b/gst-libs/gst/audio/gstaudiodecoder.c
index 47e9e1f53c..9396a9ff49 100644
--- a/gst-libs/gst/audio/gstaudiodecoder.c
+++ b/gst-libs/gst/audio/gstaudiodecoder.c
@@ -180,6 +180,8 @@ typedef struct _GstAudioDecoderContext
   /* MT-protected (with LOCK) */
   GstClockTime min_latency;
   GstClockTime max_latency;
+  /* Tracks whether the latency message was posted at least once */
+  gboolean posted_latency_msg;
 
   GstAllocator *allocator;
   GstAllocationParams params;
@@ -555,6 +557,7 @@ gst_audio_decoder_reset (GstAudioDecoder * dec, gboolean full)
     memset (&dec->priv->ctx, 0, sizeof (dec->priv->ctx));
 
     gst_audio_info_init (&dec->priv->ctx.info);
+    dec->priv->ctx.posted_latency_msg = FALSE;
     GST_OBJECT_UNLOCK (dec);
     dec->priv->ctx.had_output_data = FALSE;
     dec->priv->ctx.had_input_data = FALSE;
@@ -978,12 +981,12 @@ gst_audio_decoder_push_forward (GstAudioDecoder * dec, GstBuffer * buf)
   }
 
   ctx->had_output_data = TRUE;
-  ts = GST_BUFFER_TIMESTAMP (buf);
+  ts = GST_BUFFER_PTS (buf);
 
   GST_LOG_OBJECT (dec,
       "clipping buffer of size %" G_GSIZE_FORMAT " with ts %" GST_TIME_FORMAT
       ", duration %" GST_TIME_FORMAT, gst_buffer_get_size (buf),
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+      GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 
   /* clip buffer */
@@ -1012,11 +1015,11 @@ gst_audio_decoder_push_forward (GstAudioDecoder * dec, GstBuffer * buf)
   }
 
   /* track where we are */
-  if (G_LIKELY (GST_BUFFER_TIMESTAMP_IS_VALID (buf))) {
+  if (G_LIKELY (GST_BUFFER_PTS_IS_VALID (buf))) {
     /* duration should always be valid for raw audio */
     g_assert (GST_BUFFER_DURATION_IS_VALID (buf));
     dec->output_segment.position =
-        GST_BUFFER_TIMESTAMP (buf) + GST_BUFFER_DURATION (buf);
+        GST_BUFFER_PTS (buf) + GST_BUFFER_DURATION (buf);
   }
 
   if (klass->pre_push) {
@@ -1034,7 +1037,7 @@ gst_audio_decoder_push_forward (GstAudioDecoder * dec, GstBuffer * buf)
   GST_LOG_OBJECT (dec,
       "pushing buffer of size %" G_GSIZE_FORMAT " with ts %" GST_TIME_FORMAT
       ", duration %" GST_TIME_FORMAT, gst_buffer_get_size (buf),
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+      GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 
   ret = gst_pad_push (dec->srcpad, buf);
@@ -1061,7 +1064,7 @@ gst_audio_decoder_output (GstAudioDecoder * dec, GstBuffer * buf)
     GST_LOG_OBJECT (dec,
         "output buffer of size %" G_GSIZE_FORMAT " with ts %" GST_TIME_FORMAT
         ", duration %" GST_TIME_FORMAT, gst_buffer_get_size (buf),
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+        GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
   }
 
@@ -1079,9 +1082,9 @@ again:
       /* forcibly send current */
       assemble = TRUE;
       GST_LOG_OBJECT (dec, "forcing fragment flush");
-    } else if (av && (!GST_BUFFER_TIMESTAMP_IS_VALID (buf) ||
+    } else if (av && (!GST_BUFFER_PTS_IS_VALID (buf) ||
             !GST_CLOCK_TIME_IS_VALID (priv->out_ts) ||
-            ((diff = GST_CLOCK_DIFF (GST_BUFFER_TIMESTAMP (buf),
+            ((diff = GST_CLOCK_DIFF (GST_BUFFER_PTS (buf),
                         priv->out_ts + priv->out_dur)) > tol) || diff < -tol)) {
       assemble = TRUE;
       GST_LOG_OBJECT (dec, "buffer %d ms apart from current fragment",
@@ -1090,7 +1093,7 @@ again:
       /* add or start collecting */
       if (!av) {
         GST_LOG_OBJECT (dec, "starting new fragment");
-        priv->out_ts = GST_BUFFER_TIMESTAMP (buf);
+        priv->out_ts = GST_BUFFER_PTS (buf);
       } else {
         GST_LOG_OBJECT (dec, "adding to fragment");
       }
@@ -1105,7 +1108,7 @@ again:
       GST_LOG_OBJECT (dec, "assembling fragment");
       inbuf = buf;
       buf = gst_adapter_take_buffer (priv->adapter_out, av);
-      GST_BUFFER_TIMESTAMP (buf) = priv->out_ts;
+      GST_BUFFER_PTS (buf) = priv->out_ts;
       GST_BUFFER_DURATION (buf) = priv->out_dur;
       priv->out_ts = GST_CLOCK_TIME_NONE;
       priv->out_dur = 0;
@@ -1245,7 +1248,8 @@ foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
   const GstMetaInfo *info = (*meta)->info;
   gboolean do_copy = FALSE;
 
-  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)) {
+  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)
+      || gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory_reference)) {
     /* never call the transform_meta with memory specific metadata */
     GST_DEBUG_OBJECT (decoder, "not copying memory specific metadata %s",
         g_type_name (info->api));
@@ -1271,7 +1275,7 @@ foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
 /**
  * gst_audio_decoder_finish_subframe:
  * @dec: a #GstAudioDecoder
- * @buf: (transfer full) (allow-none): decoded data
+ * @buf: (transfer full) (nullable): decoded data
  *
  * Collects decoded data and pushes it downstream. This function may be called
  * multiple times for a given input frame.
@@ -1305,7 +1309,7 @@ gst_audio_decoder_finish_subframe (GstAudioDecoder * dec, GstBuffer * buf)
 /**
  * gst_audio_decoder_finish_frame:
  * @dec: a #GstAudioDecoder
- * @buf: (transfer full) (allow-none): decoded data
+ * @buf: (transfer full) (nullable): decoded data
  * @frames: number of decoded frames represented by decoded data
  *
  * Collects decoded data and pushes it downstream.
@@ -1420,7 +1424,7 @@ gst_audio_decoder_finish_frame_or_subframe (GstAudioDecoder * dec,
   }
 
   if (G_LIKELY (priv->frames.length))
-    ts = GST_BUFFER_TIMESTAMP (priv->frames.head->data);
+    ts = GST_BUFFER_PTS (priv->frames.head->data);
   else
     ts = GST_CLOCK_TIME_NONE;
 
@@ -1499,14 +1503,14 @@ gst_audio_decoder_finish_frame_or_subframe (GstAudioDecoder * dec,
 
   buf = gst_buffer_make_writable (buf);
   if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (priv->base_ts))) {
-    GST_BUFFER_TIMESTAMP (buf) =
+    GST_BUFFER_PTS (buf) =
         priv->base_ts +
         GST_FRAMES_TO_CLOCK_TIME (priv->samples, ctx->info.rate);
     GST_BUFFER_DURATION (buf) = priv->base_ts +
         GST_FRAMES_TO_CLOCK_TIME (priv->samples + samples, ctx->info.rate) -
-        GST_BUFFER_TIMESTAMP (buf);
+        GST_BUFFER_PTS (buf);
   } else {
-    GST_BUFFER_TIMESTAMP (buf) = GST_CLOCK_TIME_NONE;
+    GST_BUFFER_PTS (buf) = GST_CLOCK_TIME_NONE;
     GST_BUFFER_DURATION (buf) =
         GST_FRAMES_TO_CLOCK_TIME (samples, ctx->info.rate);
   }
@@ -1624,7 +1628,7 @@ gst_audio_decoder_handle_frame (GstAudioDecoder * dec,
     /* keep around for admin */
     GST_LOG_OBJECT (dec,
         "tracking frame size %" G_GSIZE_FORMAT ", ts %" GST_TIME_FORMAT, size,
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)));
+        GST_TIME_ARGS (GST_BUFFER_PTS (buffer)));
     g_queue_push_tail (&dec->priv->frames, buffer);
     dec->priv->ctx.delay = dec->priv->frames.length;
     GST_OBJECT_LOCK (dec);
@@ -1718,7 +1722,7 @@ gst_audio_decoder_push_buffers (GstAudioDecoder * dec, gboolean force)
       }
       buffer = gst_adapter_take_buffer (priv->adapter, len);
       buffer = gst_buffer_make_writable (buffer);
-      GST_BUFFER_TIMESTAMP (buffer) = ts;
+      GST_BUFFER_PTS (buffer) = ts;
       flush += len;
       priv->force = FALSE;
     } else {
@@ -1952,7 +1956,7 @@ gst_audio_decoder_flush_decode (GstAudioDecoder * dec)
     GstBuffer *buf = GST_BUFFER_CAST (walk->data);
 
     GST_DEBUG_OBJECT (dec, "decoding buffer %p, ts %" GST_TIME_FORMAT,
-        buf, GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)));
+        buf, GST_TIME_ARGS (GST_BUFFER_PTS (buf)));
 
     next = g_list_next (walk);
     /* decode buffer, resulting data prepended to output queue */
@@ -1993,13 +1997,13 @@ gst_audio_decoder_flush_decode (GstAudioDecoder * dec)
         timestamp = 0;
     }
 
-    if (!GST_BUFFER_TIMESTAMP_IS_VALID (buf)) {
+    if (!GST_BUFFER_PTS_IS_VALID (buf)) {
       GST_LOG_OBJECT (dec, "applying reverse interpolated ts %"
           GST_TIME_FORMAT, GST_TIME_ARGS (timestamp));
-      GST_BUFFER_TIMESTAMP (buf) = timestamp;
+      GST_BUFFER_PTS (buf) = timestamp;
     } else {
       /* track otherwise */
-      timestamp = GST_BUFFER_TIMESTAMP (buf);
+      timestamp = GST_BUFFER_PTS (buf);
       GST_LOG_OBJECT (dec, "tracking ts %" GST_TIME_FORMAT,
           GST_TIME_ARGS (timestamp));
     }
@@ -2007,7 +2011,7 @@ gst_audio_decoder_flush_decode (GstAudioDecoder * dec)
     if (G_LIKELY (res == GST_FLOW_OK)) {
       GST_DEBUG_OBJECT (dec, "pushing buffer %p of size %" G_GSIZE_FORMAT ", "
           "time %" GST_TIME_FORMAT ", dur %" GST_TIME_FORMAT, buf,
-          gst_buffer_get_size (buf), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+          gst_buffer_get_size (buf), GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
           GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
       /* should be already, but let's be sure */
       buf = gst_buffer_make_writable (buf);
@@ -2050,7 +2054,7 @@ gst_audio_decoder_chain_reverse (GstAudioDecoder * dec, GstBuffer * buf)
   if (G_LIKELY (buf)) {
     GST_DEBUG_OBJECT (dec, "gathering buffer %p of size %" G_GSIZE_FORMAT ", "
         "time %" GST_TIME_FORMAT ", dur %" GST_TIME_FORMAT, buf,
-        gst_buffer_get_size (buf), GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+        gst_buffer_get_size (buf), GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 
     /* add buffer to gather queue */
@@ -2071,7 +2075,7 @@ gst_audio_decoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   GST_LOG_OBJECT (dec,
       "received buffer of size %" G_GSIZE_FORMAT " with ts %" GST_TIME_FORMAT
       ", duration %" GST_TIME_FORMAT, gst_buffer_get_size (buffer),
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
+      GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
 
   GST_AUDIO_DECODER_STREAM_LOCK (dec);
@@ -2096,8 +2100,7 @@ gst_audio_decoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
     /* buffer may claim DISCONT loudly, if it can't tell us where we are now,
      * we'll stick to where we were ...
      * Particularly useful/needed for upstream BYTE based */
-    if (dec->input_segment.rate > 0.0
-        && !GST_BUFFER_TIMESTAMP_IS_VALID (buffer)) {
+    if (dec->input_segment.rate > 0.0 && !GST_BUFFER_PTS_IS_VALID (buffer)) {
       GST_DEBUG_OBJECT (dec, "... but restoring previous ts tracking");
       dec->priv->base_ts = ts;
       dec->priv->samples = samples;
@@ -2293,7 +2296,7 @@ gst_audio_decoder_handle_gap (GstAudioDecoder * dec, GstEvent * event)
 
     /* hand subclass empty frame with duration that needs covering */
     buf = gst_buffer_new ();
-    GST_BUFFER_TIMESTAMP (buf) = timestamp;
+    GST_BUFFER_PTS (buf) = timestamp;
     GST_BUFFER_DURATION (buf) = duration;
     /* best effort, not much error handling */
     gst_audio_decoder_handle_frame (dec, klass, buf);
@@ -2762,8 +2765,8 @@ gst_audio_decoder_propose_allocation_default (GstAudioDecoder * dec,
 /**
  * gst_audio_decoder_proxy_getcaps:
  * @decoder: a #GstAudioDecoder
- * @caps: (allow-none): initial caps
- * @filter: (allow-none): filter caps
+ * @caps: (nullable): initial caps
+ * @filter: (nullable): filter caps
  *
  * Returns caps that express @caps (or sink template caps if @caps == NULL)
  * restricted to rate/channels/... combinations supported by downstream
@@ -3271,7 +3274,7 @@ _gst_audio_decoder_error (GstAudioDecoder * dec, gint weight,
  * gst_audio_decoder_get_audio_info:
  * @dec: a #GstAudioDecoder
  *
- * Returns: a #GstAudioInfo describing the input audio format
+ * Returns: (transfer none): a #GstAudioInfo describing the input audio format
  */
 GstAudioInfo *
 gst_audio_decoder_get_audio_info (GstAudioDecoder * dec)
@@ -3391,31 +3394,50 @@ gst_audio_decoder_get_max_errors (GstAudioDecoder * dec)
  * @min: minimum latency
  * @max: maximum latency
  *
- * Sets decoder latency.
+ * Sets decoder latency. If the provided values changed from
+ * previously provided ones, this will also post a LATENCY message on the bus
+ * so the pipeline can reconfigure its global latency.
  */
 void
 gst_audio_decoder_set_latency (GstAudioDecoder * dec,
     GstClockTime min, GstClockTime max)
 {
+  gboolean post_message = FALSE;
+
   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (min));
   g_return_if_fail (min <= max);
 
+  GST_DEBUG_OBJECT (dec,
+      "min_latency:%" GST_TIME_FORMAT " max_latency:%" GST_TIME_FORMAT,
+      GST_TIME_ARGS (min), GST_TIME_ARGS (max));
+
   GST_OBJECT_LOCK (dec);
-  dec->priv->ctx.min_latency = min;
-  dec->priv->ctx.max_latency = max;
+  if (dec->priv->ctx.min_latency != min) {
+    dec->priv->ctx.min_latency = min;
+    post_message = TRUE;
+  }
+  if (dec->priv->ctx.max_latency != max) {
+    dec->priv->ctx.max_latency = max;
+    post_message = TRUE;
+  }
+  if (!dec->priv->ctx.posted_latency_msg) {
+    dec->priv->ctx.posted_latency_msg = TRUE;
+    post_message = TRUE;
+  }
   GST_OBJECT_UNLOCK (dec);
 
   /* post latency message on the bus */
-  gst_element_post_message (GST_ELEMENT (dec),
-      gst_message_new_latency (GST_OBJECT (dec)));
+  if (post_message)
+    gst_element_post_message (GST_ELEMENT (dec),
+        gst_message_new_latency (GST_OBJECT (dec)));
 }
 
 /**
  * gst_audio_decoder_get_latency:
  * @dec: a #GstAudioDecoder
- * @min: (out) (allow-none): a pointer to storage to hold minimum latency
- * @max: (out) (allow-none): a pointer to storage to hold maximum latency
+ * @min: (out) (optional): a pointer to storage to hold minimum latency
+ * @max: (out) (optional): a pointer to storage to hold maximum latency
  *
  * Sets the variables pointed to by @min and @max to the currently configured
  * latency.
@@ -3457,7 +3479,7 @@ gst_audio_decoder_get_parse_state (GstAudioDecoder * dec,
 /**
  * gst_audio_decoder_set_allocation_caps:
  * @dec: a #GstAudioDecoder
- * @allocation_caps: (allow-none): a #GstCaps or %NULL
+ * @allocation_caps: (nullable): a #GstCaps or %NULL
  *
  * Sets a caps in allocation query which are different from the set
  * pad's caps. Use this function before calling
@@ -3534,6 +3556,7 @@ void
 gst_audio_decoder_set_min_latency (GstAudioDecoder * dec, GstClockTime num)
 {
   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (num));
 
   GST_OBJECT_LOCK (dec);
   dec->priv->latency = num;
@@ -3577,6 +3600,7 @@ void
 gst_audio_decoder_set_tolerance (GstAudioDecoder * dec, GstClockTime tolerance)
 {
   g_return_if_fail (GST_IS_AUDIO_DECODER (dec));
+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (tolerance));
 
   GST_OBJECT_LOCK (dec);
   dec->priv->tolerance = tolerance;
@@ -3704,7 +3728,7 @@ gst_audio_decoder_get_needs_format (GstAudioDecoder * dec)
 /**
  * gst_audio_decoder_merge_tags:
  * @dec: a #GstAudioDecoder
- * @tags: (allow-none): a #GstTagList to merge, or NULL
+ * @tags: (nullable): a #GstTagList to merge, or NULL
  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
  *
  * Sets the audio decoder tags and how they should be merged with any
@@ -3794,9 +3818,9 @@ fallback:
 /**
  * gst_audio_decoder_get_allocator:
  * @dec: a #GstAudioDecoder
- * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
+ * @allocator: (out) (optional) (nullable) (transfer full): the #GstAllocator
  * used
- * @params: (out) (allow-none) (transfer full): the
+ * @params: (out) (optional) (transfer full): the
  * #GstAllocationParams of @allocator
  *
  * Lets #GstAudioDecoder sub-classes to know the memory @allocator
diff --git a/gst-libs/gst/audio/gstaudiodecoder.h b/gst-libs/gst/audio/gstaudiodecoder.h
index b2f36648a7..03fb675390 100644
--- a/gst-libs/gst/audio/gstaudiodecoder.h
+++ b/gst-libs/gst/audio/gstaudiodecoder.h
@@ -147,7 +147,7 @@ G_STMT_START {                                                              \
  *
  * Default maximum number of errors tolerated before signaling error.
  */
-#define GST_AUDIO_DECODER_MAX_ERRORS     10
+#define GST_AUDIO_DECODER_MAX_ERRORS     -1
 
 /**
  * GstAudioDecoder:
@@ -272,6 +272,11 @@ struct _GstAudioDecoderClass
   gboolean      (*set_format)         (GstAudioDecoder *dec,
                                        GstCaps *caps);
 
+  /**
+   * GstAudioDecoderClass::parse:
+   * @offset: (out):
+   * @length: (out):
+   */
   GstFlowReturn (*parse)              (GstAudioDecoder *dec,
                                        GstAdapter *adapter,
                                        gint *offset, gint *length);
diff --git a/gst-libs/gst/audio/gstaudioencoder.c b/gst-libs/gst/audio/gstaudioencoder.c
index 5b9f7410c9..f77216709b 100644
--- a/gst-libs/gst/audio/gstaudioencoder.c
+++ b/gst-libs/gst/audio/gstaudioencoder.c
@@ -171,6 +171,10 @@ typedef struct _GstAudioEncoderContext
   /* MT-protected (with LOCK) */
   GstClockTime min_latency;
   GstClockTime max_latency;
+  /* Tracks whether the latency message was posted at least once */
+  gboolean posted_latency_msg;
+
+  gboolean negotiated;
 
   GList *headers;
   gboolean new_headers;
@@ -239,6 +243,11 @@ struct _GstAudioEncoderPrivate
 
   /* pending serialized sink events, will be sent from finish_frame() */
   GList *pending_events;
+
+  /* these are initial events or events that came in while there was nothing
+   * in the adapter. these events shall be sent after negotiation but before
+   * we push the following buffer. */
+  GList *early_pending_events;
 };
 
 
@@ -487,6 +496,7 @@ gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full)
 
     memset (&enc->priv->ctx, 0, sizeof (enc->priv->ctx));
     gst_audio_info_init (&enc->priv->ctx.info);
+    enc->priv->ctx.posted_latency_msg = FALSE;
     GST_OBJECT_UNLOCK (enc);
 
     if (enc->priv->upstream_tags) {
@@ -499,8 +509,11 @@ gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full)
     enc->priv->tags_merge_mode = GST_TAG_MERGE_APPEND;
     enc->priv->tags_changed = FALSE;
 
-    g_list_foreach (enc->priv->pending_events, (GFunc) gst_event_unref, NULL);
-    g_list_free (enc->priv->pending_events);
+    g_list_free_full (enc->priv->early_pending_events,
+        (GDestroyNotify) gst_event_unref);
+    enc->priv->early_pending_events = NULL;
+    g_list_free_full (enc->priv->pending_events,
+        (GDestroyNotify) gst_event_unref);
     enc->priv->pending_events = NULL;
   }
 
@@ -597,11 +610,31 @@ gst_audio_encoder_push_event (GstAudioEncoder * enc, GstEvent * event)
   return gst_pad_push_event (enc->srcpad, event);
 }
 
+static inline void
+gst_audio_encoder_push_early_pending_events (GstAudioEncoder * enc)
+{
+  GstAudioEncoderPrivate *priv = enc->priv;
+
+  if (priv->early_pending_events) {
+    GList *pending_events, *l;
+
+    pending_events = priv->early_pending_events;
+    priv->early_pending_events = NULL;
+
+    GST_DEBUG_OBJECT (enc, "Pushing early pending events");
+    for (l = pending_events; l; l = l->next)
+      gst_audio_encoder_push_event (enc, l->data);
+    g_list_free (pending_events);
+  }
+}
+
 static inline void
 gst_audio_encoder_push_pending_events (GstAudioEncoder * enc)
 {
   GstAudioEncoderPrivate *priv = enc->priv;
 
+  gst_audio_encoder_push_early_pending_events (enc);
+
   if (priv->pending_events) {
     GList *pending_events, *l;
 
@@ -706,7 +739,8 @@ foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
   const GstMetaInfo *info = (*meta)->info;
   gboolean do_copy = FALSE;
 
-  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)) {
+  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)
+      || gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory_reference)) {
     /* never call the transform_meta with memory specific metadata */
     GST_DEBUG_OBJECT (encoder, "not copying memory specific metadata %s",
         g_type_name (info->api));
@@ -732,7 +766,7 @@ foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
 /**
  * gst_audio_encoder_finish_frame:
  * @enc: a #GstAudioEncoder
- * @buffer: (transfer full) (allow-none): encoded data
+ * @buffer: (transfer full) (nullable): encoded data
  * @samples: number of samples (per channel) represented by encoded data
  *
  * Collects encoded data and pushes encoded data downstream.
@@ -795,9 +829,9 @@ gst_audio_encoder_finish_frame (GstAudioEncoder * enc, GstBuffer * buf,
   if (G_LIKELY (buf))
     priv->got_data = TRUE;
 
-  gst_audio_encoder_push_pending_events (enc);
+  gst_audio_encoder_push_early_pending_events (enc);
 
-  /* send after pending events, which likely includes segment event */
+  /* send after early pending events, which likely includes segment event */
   gst_audio_encoder_check_and_push_pending_tags (enc);
 
   /* remove corresponding samples from input */
@@ -937,16 +971,16 @@ gst_audio_encoder_finish_frame (GstAudioEncoder * enc, GstBuffer * buf,
       /* FIXME ? lookahead could lead to weird ts and duration ?
        * (particularly if not in perfect mode) */
       /* mind sample rounding and produce perfect output */
-      GST_BUFFER_TIMESTAMP (buf) = priv->base_ts +
+      GST_BUFFER_PTS (buf) = priv->base_ts +
           gst_util_uint64_scale (priv->samples - ctx->lookahead, GST_SECOND,
           ctx->info.rate);
-      GST_BUFFER_DTS (buf) = GST_BUFFER_TIMESTAMP (buf);
+      GST_BUFFER_DTS (buf) = GST_BUFFER_PTS (buf);
       GST_DEBUG_OBJECT (enc, "out samples %d", samples);
       if (G_LIKELY (samples > 0)) {
         priv->samples += samples;
         GST_BUFFER_DURATION (buf) = priv->base_ts +
             gst_util_uint64_scale (priv->samples - ctx->lookahead, GST_SECOND,
-            ctx->info.rate) - GST_BUFFER_TIMESTAMP (buf);
+            ctx->info.rate) - GST_BUFFER_PTS (buf);
         priv->last_duration = GST_BUFFER_DURATION (buf);
       } else {
         /* duration forecast in case of handling remainder;
@@ -1008,11 +1042,15 @@ gst_audio_encoder_finish_frame (GstAudioEncoder * enc, GstBuffer * buf,
     GST_LOG_OBJECT (enc,
         "pushing buffer of size %" G_GSIZE_FORMAT " with ts %" GST_TIME_FORMAT
         ", duration %" GST_TIME_FORMAT, size,
-        GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buf)),
+        GST_TIME_ARGS (GST_BUFFER_PTS (buf)),
         GST_TIME_ARGS (GST_BUFFER_DURATION (buf)));
 
     ret = gst_pad_push (enc->srcpad, buf);
     GST_LOG_OBJECT (enc, "buffer pushed: %s", gst_flow_get_name (ret));
+
+    /* Now push the events that followed after the buffer got into the
+     * adapter. */
+    gst_audio_encoder_push_pending_events (enc);
   } else {
     /* merely advance samples, most work for that already done above */
     priv->samples += samples;
@@ -1236,7 +1274,7 @@ gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   GST_LOG_OBJECT (enc,
       "received buffer of size %" G_GSIZE_FORMAT " with ts %" GST_TIME_FORMAT
       ", duration %" GST_TIME_FORMAT, size,
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
+      GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
 
   /* input should be whole number of sample frames */
@@ -1282,11 +1320,11 @@ gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   GST_LOG_OBJECT (enc,
       "buffer after segment clipping has size %" G_GSIZE_FORMAT " with ts %"
       GST_TIME_FORMAT ", duration %" GST_TIME_FORMAT, size,
-      GST_TIME_ARGS (GST_BUFFER_TIMESTAMP (buffer)),
+      GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)));
 
   if (!GST_CLOCK_TIME_IS_VALID (priv->base_ts)) {
-    priv->base_ts = GST_BUFFER_TIMESTAMP (buffer);
+    priv->base_ts = GST_BUFFER_PTS (buffer);
     GST_DEBUG_OBJECT (enc, "new base ts %" GST_TIME_FORMAT,
         GST_TIME_ARGS (priv->base_ts));
     gst_audio_encoder_set_base_gp (enc);
@@ -1298,7 +1336,7 @@ gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
     GstClockTimeDiff diff = 0;
     GstClockTime next_ts = 0;
 
-    if (GST_BUFFER_TIMESTAMP_IS_VALID (buffer) &&
+    if (GST_BUFFER_PTS_IS_VALID (buffer) &&
         GST_CLOCK_TIME_IS_VALID (priv->base_ts)) {
       guint64 samples;
 
@@ -1310,7 +1348,7 @@ gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
           " samples past base_ts %" GST_TIME_FORMAT
           ", expected ts %" GST_TIME_FORMAT, samples,
           GST_TIME_ARGS (priv->base_ts), GST_TIME_ARGS (next_ts));
-      diff = GST_CLOCK_DIFF (next_ts, GST_BUFFER_TIMESTAMP (buffer));
+      diff = GST_CLOCK_DIFF (next_ts, GST_BUFFER_PTS (buffer));
       GST_LOG_OBJECT (enc, "ts diff %d ms", (gint) (diff / GST_MSECOND));
       /* if within tolerance,
        * discard buffer ts and carry on producing perfect stream,
@@ -1339,7 +1377,7 @@ gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
         buffer = gst_buffer_make_writable (buffer);
         gst_buffer_resize (buffer, diff_bytes, size - diff_bytes);
 
-        GST_BUFFER_TIMESTAMP (buffer) += diff;
+        GST_BUFFER_PTS (buffer) += diff;
         /* care even less about duration after this */
       } else {
         /* drain stuff prior to resync */
@@ -1352,13 +1390,13 @@ gst_audio_encoder_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
           gst_util_uint64_scale (gst_adapter_available (priv->adapter),
           GST_SECOND, ctx->info.rate * ctx->info.bpf);
 
-      if (G_UNLIKELY (shift > GST_BUFFER_TIMESTAMP (buffer))) {
+      if (G_UNLIKELY (shift > GST_BUFFER_PTS (buffer))) {
         /* ERROR */
         goto wrong_time;
       }
       /* arrange for newly added samples to come out with the ts
        * of the incoming buffer that adds these */
-      priv->base_ts = GST_BUFFER_TIMESTAMP (buffer) - shift;
+      priv->base_ts = GST_BUFFER_PTS (buffer) - shift;
       priv->samples = 0;
       gst_audio_encoder_set_base_gp (enc);
       priv->discont |= discont;
@@ -1497,8 +1535,8 @@ refuse_caps:
 /**
  * gst_audio_encoder_proxy_getcaps:
  * @enc: a #GstAudioEncoder
- * @caps: (allow-none): initial caps
- * @filter: (allow-none): filter caps
+ * @caps: (nullable): initial caps
+ * @filter: (nullable): filter caps
  *
  * Returns caps that express @caps (or sink template caps if @caps == NULL)
  * restricted to channel/rate combinations supported by downstream elements
@@ -1578,8 +1616,8 @@ gst_audio_encoder_sink_event_default (GstAudioEncoder * enc, GstEvent * event)
       /* and follow along with segment */
       enc->input_segment = seg;
 
-      enc->priv->pending_events =
-          g_list_append (enc->priv->pending_events, event);
+      enc->priv->early_pending_events =
+          g_list_append (enc->priv->early_pending_events, event);
       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
 
       res = TRUE;
@@ -1696,8 +1734,13 @@ gst_audio_encoder_sink_event_default (GstAudioEncoder * enc, GstEvent * event)
             gst_pad_event_default (enc->sinkpad, GST_OBJECT_CAST (enc), event);
       } else {
         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
-        enc->priv->pending_events =
-            g_list_append (enc->priv->pending_events, event);
+        if (gst_adapter_available (enc->priv->adapter) == 0) {
+          enc->priv->early_pending_events =
+              g_list_append (enc->priv->early_pending_events, event);
+        } else {
+          enc->priv->pending_events =
+              g_list_append (enc->priv->pending_events, event);
+        }
         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
         res = TRUE;
       }
@@ -2150,7 +2193,7 @@ gst_audio_encoder_sink_activate_mode (GstPad * pad, GstObject * parent,
  * gst_audio_encoder_get_audio_info:
  * @enc: a #GstAudioEncoder
  *
- * Returns: a #GstAudioInfo describing the input audio format
+ * Returns: (transfer none): a #GstAudioInfo describing the input audio format
  */
 GstAudioInfo *
 gst_audio_encoder_get_audio_info (GstAudioEncoder * enc)
@@ -2307,34 +2350,50 @@ gst_audio_encoder_get_lookahead (GstAudioEncoder * enc)
  * @min: minimum latency
  * @max: maximum latency
  *
- * Sets encoder latency.
+ * Sets encoder latency. If the provided values changed from
+ * previously provided ones, this will also post a LATENCY message on the bus
+ * so the pipeline can reconfigure its global latency.
  */
 void
 gst_audio_encoder_set_latency (GstAudioEncoder * enc,
     GstClockTime min, GstClockTime max)
 {
+  gboolean post_message = FALSE;
+
   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (min));
   g_return_if_fail (min <= max);
 
+  GST_DEBUG_OBJECT (enc,
+      "min_latency:%" GST_TIME_FORMAT " max_latency:%" GST_TIME_FORMAT,
+      GST_TIME_ARGS (min), GST_TIME_ARGS (max));
+
   GST_OBJECT_LOCK (enc);
-  enc->priv->ctx.min_latency = min;
-  enc->priv->ctx.max_latency = max;
+  if (enc->priv->ctx.min_latency != min) {
+    enc->priv->ctx.min_latency = min;
+    post_message = TRUE;
+  }
+  if (enc->priv->ctx.max_latency != max) {
+    enc->priv->ctx.max_latency = max;
+    post_message = TRUE;
+  }
+  if (!enc->priv->ctx.posted_latency_msg) {
+    enc->priv->ctx.posted_latency_msg = TRUE;
+    post_message = TRUE;
+  }
   GST_OBJECT_UNLOCK (enc);
 
-  GST_LOG_OBJECT (enc, "set to %" GST_TIME_FORMAT "-%" GST_TIME_FORMAT,
-      GST_TIME_ARGS (min), GST_TIME_ARGS (max));
-
   /* post latency message on the bus */
-  gst_element_post_message (GST_ELEMENT (enc),
-      gst_message_new_latency (GST_OBJECT (enc)));
+  if (post_message)
+    gst_element_post_message (GST_ELEMENT (enc),
+        gst_message_new_latency (GST_OBJECT (enc)));
 }
 
 /**
  * gst_audio_encoder_get_latency:
  * @enc: a #GstAudioEncoder
- * @min: (out) (allow-none): a pointer to storage to hold minimum latency
- * @max: (out) (allow-none): a pointer to storage to hold maximum latency
+ * @min: (out) (optional): a pointer to storage to hold minimum latency
+ * @max: (out) (optional): a pointer to storage to hold maximum latency
  *
  * Sets the variables pointed to by @min and @max to the currently configured
  * latency.
@@ -2377,7 +2436,7 @@ gst_audio_encoder_set_headers (GstAudioEncoder * enc, GList * headers)
 /**
  * gst_audio_encoder_set_allocation_caps:
  * @enc: a #GstAudioEncoder
- * @allocation_caps: (allow-none): a #GstCaps or %NULL
+ * @allocation_caps: (nullable): a #GstCaps or %NULL
  *
  * Sets a caps in allocation query which are different from the set
  * pad's caps. Use this function before calling
@@ -2544,6 +2603,7 @@ void
 gst_audio_encoder_set_tolerance (GstAudioEncoder * enc, GstClockTime tolerance)
 {
   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (tolerance));
 
   GST_OBJECT_LOCK (enc);
   enc->priv->tolerance = tolerance;
@@ -2671,7 +2731,7 @@ gst_audio_encoder_get_drainable (GstAudioEncoder * enc)
 /**
  * gst_audio_encoder_merge_tags:
  * @enc: a #GstAudioEncoder
- * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
+ * @tags: (nullable): a #GstTagList to merge, or NULL to unset
  *     previously-set tags
  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
  *
@@ -2731,10 +2791,10 @@ gst_audio_encoder_negotiate_default (GstAudioEncoder * enc)
 
   GST_DEBUG_OBJECT (enc, "Setting srcpad caps %" GST_PTR_FORMAT, caps);
 
-  if (enc->priv->pending_events) {
+  if (enc->priv->early_pending_events) {
     GList **pending_events, *l;
 
-    pending_events = &enc->priv->pending_events;
+    pending_events = &enc->priv->early_pending_events;
 
     GST_DEBUG_OBJECT (enc, "Pushing pending events");
     for (l = *pending_events; l;) {
@@ -2813,6 +2873,8 @@ gst_audio_encoder_negotiate_unlocked (GstAudioEncoder * enc)
   if (G_LIKELY (klass->negotiate))
     ret = klass->negotiate (enc);
 
+  enc->priv->ctx.negotiated = TRUE;
+
   return ret;
 }
 
@@ -2948,9 +3010,9 @@ fallback:
 /**
  * gst_audio_encoder_get_allocator:
  * @enc: a #GstAudioEncoder
- * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
+ * @allocator: (out) (optional) (nullable) (transfer full): the #GstAllocator
  * used
- * @params: (out) (allow-none) (transfer full): the
+ * @params: (out) (optional) (transfer full): the
  * #GstAllocationParams of @allocator
  *
  * Lets #GstAudioEncoder sub-classes to know the memory @allocator
diff --git a/gst-libs/gst/audio/gstaudiofilter.c b/gst-libs/gst/audio/gstaudiofilter.c
index e6ad740bff..0039833407 100644
--- a/gst-libs/gst/audio/gstaudiofilter.c
+++ b/gst-libs/gst/audio/gstaudiofilter.c
@@ -180,6 +180,11 @@ gst_audio_filter_submit_input_buffer (GstBaseTransform * btrans,
   GstAudioFilter *filter = GST_AUDIO_FILTER (btrans);
 
   if (btrans->segment.format == GST_FORMAT_TIME) {
+    if (!GST_AUDIO_INFO_IS_VALID (&filter->info)) {
+      GST_WARNING_OBJECT (filter, "Got buffer, but not negotiated yet!");
+      return GST_FLOW_NOT_NEGOTIATED;
+    }
+
     input =
         gst_audio_buffer_clip (input, &btrans->segment, filter->info.rate,
         filter->info.bpf);
diff --git a/gst-libs/gst/audio/gstaudiometa.c b/gst-libs/gst/audio/gstaudiometa.c
index e010ca3375..5605dc7b4c 100644
--- a/gst-libs/gst/audio/gstaudiometa.c
+++ b/gst-libs/gst/audio/gstaudiometa.c
@@ -492,3 +492,131 @@ gst_audio_meta_get_info (void)
   }
   return audio_meta_info;
 }
+
+/**
+ * gst_audio_level_meta_api_get_type:
+ *
+ * Return the #GType associated with #GstAudioLevelMeta.
+ *
+ * Returns: a #GType
+ *
+ * Since: 1.20
+ */
+GType
+gst_audio_level_meta_api_get_type (void)
+{
+  static GType type = 0;
+  static const gchar *tags[] = { NULL };
+
+  if (g_once_init_enter (&type)) {
+    GType _type = gst_meta_api_type_register ("GstAudioLevelMetaAPI", tags);
+    g_once_init_leave (&type, _type);
+  }
+  return type;
+}
+
+static gboolean
+gst_audio_level_meta_init (GstMeta * meta, gpointer params, GstBuffer * buffer)
+{
+  GstAudioLevelMeta *dmeta = (GstAudioLevelMeta *) meta;
+
+  dmeta->level = 127;
+  dmeta->voice_activity = FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+gst_audio_level_meta_transform (GstBuffer * dst, GstMeta * meta,
+    GstBuffer * src, GQuark type, gpointer data)
+{
+  if (GST_META_TRANSFORM_IS_COPY (type)) {
+    GstAudioLevelMeta *smeta = (GstAudioLevelMeta *) meta;
+    GstAudioLevelMeta *dmeta;
+
+    dmeta = gst_buffer_add_audio_level_meta (dst, smeta->level,
+        smeta->voice_activity);
+    if (dmeta == NULL)
+      return FALSE;
+  } else {
+    /* return FALSE, if transform type is not supported */
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+/**
+ * gst_audio_level_meta_get_info:
+ *
+ * Return the #GstMetaInfo associated with #GstAudioLevelMeta.
+ *
+ * Returns: (transfer none): a #GstMetaInfo
+ *
+ * Since: 1.20
+ */
+const GstMetaInfo *
+gst_audio_level_meta_get_info (void)
+{
+  static const GstMetaInfo *audio_level_meta_info = NULL;
+
+  if (g_once_init_enter (&audio_level_meta_info)) {
+    const GstMetaInfo *meta = gst_meta_register (GST_AUDIO_LEVEL_META_API_TYPE,
+        "GstAudioLevelMeta",
+        sizeof (GstAudioLevelMeta),
+        gst_audio_level_meta_init,
+        (GstMetaFreeFunction) NULL,
+        gst_audio_level_meta_transform);
+    g_once_init_leave (&audio_level_meta_info, meta);
+  }
+  return audio_level_meta_info;
+}
+
+/**
+ * gst_buffer_add_audio_level_meta:
+ * @buffer: a #GstBuffer
+ * @level: the -dBov from 0-127 (127 is silence).
+ * @voice_activity: whether the buffer contains voice activity.
+ *
+ * Attaches audio level information to @buffer. (RFC 6464)
+ *
+ * Returns: (transfer none) (nullable): the #GstAudioLevelMeta on @buffer.
+ *
+ * Since: 1.20
+ */
+GstAudioLevelMeta *
+gst_buffer_add_audio_level_meta (GstBuffer * buffer, guint8 level,
+    gboolean voice_activity)
+{
+  GstAudioLevelMeta *meta;
+
+  g_return_val_if_fail (buffer != NULL, NULL);
+
+  meta = (GstAudioLevelMeta *) gst_buffer_add_meta (buffer,
+      GST_AUDIO_LEVEL_META_INFO, NULL);
+  if (!meta)
+    return NULL;
+
+  meta->level = level;
+  meta->voice_activity = voice_activity;
+
+  return meta;
+}
+
+/**
+ * gst_buffer_get_audio_level_meta:
+ * @buffer: a #GstBuffer
+ *
+ * Find the #GstAudioLevelMeta on @buffer.
+ *
+ * Returns: (transfer none) (nullable): the #GstAudioLevelMeta or %NULL when
+ * there is no such metadata on @buffer.
+ *
+ * Since: 1.20
+ */
+GstAudioLevelMeta *
+gst_buffer_get_audio_level_meta (GstBuffer * buffer)
+{
+  return (GstAudioLevelMeta *) gst_buffer_get_meta (buffer,
+      gst_audio_level_meta_api_get_type ());
+}
diff --git a/gst-libs/gst/audio/gstaudiometa.h b/gst-libs/gst/audio/gstaudiometa.h
index 0b1b48bf07..94954d1940 100644
--- a/gst-libs/gst/audio/gstaudiometa.h
+++ b/gst-libs/gst/audio/gstaudiometa.h
@@ -198,6 +198,55 @@ GstAudioMeta * gst_buffer_add_audio_meta (GstBuffer *buffer,
                                           const GstAudioInfo *info,
                                           gsize samples, gsize offsets[]);
 
+/**
+ * GST_AUDIO_LEVEL_META_API_TYPE:
+ *
+ * The #GType associated with #GstAudioLevelMeta.
+ *
+ * Since: 1.20
+ */
+#define GST_AUDIO_LEVEL_META_API_TYPE  (gst_audio_level_meta_api_get_type())
+/**
+ * GST_AUDIO_LEVEL_META_INFO:
+ *
+ * The #GstMetaInfo associated with #GstAudioLevelMeta.
+ *
+ * Since: 1.20
+ */
+#define GST_AUDIO_LEVEL_META_INFO  (gst_audio_level_meta_get_info())
+typedef struct _GstAudioLevelMeta GstAudioLevelMeta;
+
+/**
+ * GstAudioLevelMeta:
+ * @meta: parent #GstMeta
+ * @level: the -dBov from 0-127 (127 is silence).
+ * @voice_activity: whether the buffer contains voice activity
+ *
+ * Meta containing Audio Level Indication: https://tools.ietf.org/html/rfc6464
+ *
+ * Since: 1.20
+ */
+struct _GstAudioLevelMeta
+{
+  GstMeta meta;
+
+  guint8 level;
+  gboolean voice_activity;
+};
+
+GST_AUDIO_API
+GType                  gst_audio_level_meta_api_get_type                (void);
+
+GST_AUDIO_API
+const GstMetaInfo *    gst_audio_level_meta_get_info                    (void);
+
+GST_AUDIO_API
+GstAudioLevelMeta * gst_buffer_add_audio_level_meta                     (GstBuffer * buffer,
+                                                                         guint8 level,
+                                                                         gboolean voice_activity);
+GST_AUDIO_API
+GstAudioLevelMeta * gst_buffer_get_audio_level_meta                     (GstBuffer * buffer);
+
 G_END_DECLS
 
 #endif /* __GST_AUDIO_META_H__ */
diff --git a/gst-libs/gst/audio/gstaudioringbuffer.c b/gst-libs/gst/audio/gstaudioringbuffer.c
index 16d7739434..ac71dd06a7 100644
--- a/gst-libs/gst/audio/gstaudioringbuffer.c
+++ b/gst-libs/gst/audio/gstaudioringbuffer.c
@@ -656,7 +656,7 @@ gst_audio_ring_buffer_acquire (GstAudioRingBuffer * buf,
   buf->empty_seg = g_malloc (segsize);
 
   if (buf->spec.type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW) {
-    gst_audio_format_fill_silence (buf->spec.info.finfo, buf->empty_seg,
+    gst_audio_format_info_fill_silence (buf->spec.info.finfo, buf->empty_seg,
         segsize);
   } else {
     /* FIXME, non-raw formats get 0 as the empty sample */
@@ -1675,7 +1675,7 @@ not_started:
 /**
  * gst_audio_ring_buffer_commit:
  * @buf: the #GstAudioRingBuffer to commit
- * @sample: the sample position of the data
+ * @sample: (inout): the sample position of the data
  * @data: (array length=in_samples): the data to commit
  * @in_samples: the number of samples in the data to commit
  * @out_samples: the number of samples to write to the ringbuffer
diff --git a/gst-libs/gst/audio/gstaudiosink.c b/gst-libs/gst/audio/gstaudiosink.c
index 5103f2d00f..d7b26f1d9d 100644
--- a/gst-libs/gst/audio/gstaudiosink.c
+++ b/gst-libs/gst/audio/gstaudiosink.c
@@ -254,6 +254,9 @@ audioringbuffer_thread_func (GstAudioRingBuffer * buf)
               GST_DEBUG_FUNCPTR_NAME (writefunc),
               (errno > 1 ? g_strerror (errno) : "unknown"), left, written);
           break;
+        } else if (written == 0 && G_UNLIKELY (g_atomic_int_get (&buf->state) !=
+                GST_AUDIO_RING_BUFFER_STATE_STARTED)) {
+          break;
         }
         left -= written;
         readptr += written;
@@ -414,7 +417,7 @@ gst_audio_sink_ring_buffer_acquire (GstAudioRingBuffer * buf,
   buf->memory = g_malloc (buf->size);
 
   if (buf->spec.type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW) {
-    gst_audio_format_fill_silence (buf->spec.info.finfo, buf->memory,
+    gst_audio_format_info_fill_silence (buf->spec.info.finfo, buf->memory,
         buf->size);
   } else {
     /* FIXME, non-raw formats get 0 as the empty sample */
diff --git a/gst-libs/gst/audio/gstaudiosink.h b/gst-libs/gst/audio/gstaudiosink.h
index 06f65ffa33..0fce413b35 100644
--- a/gst-libs/gst/audio/gstaudiosink.h
+++ b/gst-libs/gst/audio/gstaudiosink.h
@@ -98,7 +98,12 @@ struct _GstAudioSinkClass {
   gboolean (*unprepare) (GstAudioSink *sink);
   /* close the device */
   gboolean (*close)     (GstAudioSink *sink);
-  /* write samples to the device */
+  /**
+   * GstAudioSinkClass::write:
+   * @data: (type guint8) (array length=length): the sample data
+   *
+   * Write samples to the device.
+   */
   gint     (*write)     (GstAudioSink *sink, gpointer data, guint length);
   /* get number of frames queued in the device */
   guint    (*delay)     (GstAudioSink *sink);
diff --git a/gst-libs/gst/audio/gstaudiosrc.c b/gst-libs/gst/audio/gstaudiosrc.c
index fccdeac29b..a676155cd2 100644
--- a/gst-libs/gst/audio/gstaudiosrc.c
+++ b/gst-libs/gst/audio/gstaudiosrc.c
@@ -384,7 +384,7 @@ gst_audio_src_ring_buffer_acquire (GstAudioRingBuffer * buf,
   buf->size = spec->segtotal * spec->segsize;
   buf->memory = g_malloc (buf->size);
   if (buf->spec.type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW) {
-    gst_audio_format_fill_silence (buf->spec.info.finfo, buf->memory,
+    gst_audio_format_info_fill_silence (buf->spec.info.finfo, buf->memory,
         buf->size);
   } else {
     /* FIXME, non-raw formats get 0 as the empty sample */
diff --git a/gst-libs/gst/audio/gstaudiosrc.h b/gst-libs/gst/audio/gstaudiosrc.h
index 93cb5d06eb..41c7b38403 100644
--- a/gst-libs/gst/audio/gstaudiosrc.h
+++ b/gst-libs/gst/audio/gstaudiosrc.h
@@ -84,7 +84,13 @@ struct _GstAudioSrcClass {
   gboolean (*unprepare) (GstAudioSrc *src);
   /* close the device */
   gboolean (*close)     (GstAudioSrc *src);
-  /* read samples from the device */
+  /**
+   * GstAudioSrcClass::read:
+   * @data: (type guint8) (array length=length): the sample data
+   * @timestamp: (out): a #GstClockTime
+   *
+   * Read samples from the device.
+   */
   guint    (*read)      (GstAudioSrc *src, gpointer data, guint length,
       GstClockTime *timestamp);
   /* get number of frames queued in the device */
diff --git a/gst-libs/gst/audio/gstaudiostreamalign.c b/gst-libs/gst/audio/gstaudiostreamalign.c
index 3eaa74bc97..caabc842ed 100644
--- a/gst-libs/gst/audio/gstaudiostreamalign.c
+++ b/gst-libs/gst/audio/gstaudiostreamalign.c
@@ -86,6 +86,8 @@ gst_audio_stream_align_new (gint rate, GstClockTime alignment_threshold,
   GstAudioStreamAlign *align;
 
   g_return_val_if_fail (rate != 0, NULL);
+  g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (alignment_threshold), NULL);
+  g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (discont_wait), NULL);
 
   align = g_new0 (GstAudioStreamAlign, 1);
   align->rate = rate;
@@ -172,7 +174,7 @@ gst_audio_stream_align_set_rate (GstAudioStreamAlign * align, gint rate)
  * Since: 1.14
  */
 gint
-gst_audio_stream_align_get_rate (GstAudioStreamAlign * align)
+gst_audio_stream_align_get_rate (const GstAudioStreamAlign * align)
 {
   g_return_val_if_fail (align != NULL, 0);
 
@@ -193,6 +195,7 @@ gst_audio_stream_align_set_alignment_threshold (GstAudioStreamAlign *
     align, GstClockTime alignment_threshold)
 {
   g_return_if_fail (align != NULL);
+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (alignment_threshold));
 
   align->alignment_threshold = alignment_threshold;
 }
@@ -208,7 +211,8 @@ gst_audio_stream_align_set_alignment_threshold (GstAudioStreamAlign *
  * Since: 1.14
  */
 GstClockTime
-gst_audio_stream_align_get_alignment_threshold (GstAudioStreamAlign * align)
+gst_audio_stream_align_get_alignment_threshold (const GstAudioStreamAlign *
+    align)
 {
   g_return_val_if_fail (align != NULL, 0);
 
@@ -229,6 +233,7 @@ gst_audio_stream_align_set_discont_wait (GstAudioStreamAlign * align,
     GstClockTime discont_wait)
 {
   g_return_if_fail (align != NULL);
+  g_return_if_fail (GST_CLOCK_TIME_IS_VALID (discont_wait));
 
   align->discont_wait = discont_wait;
 }
@@ -244,7 +249,7 @@ gst_audio_stream_align_set_discont_wait (GstAudioStreamAlign * align,
  * Since: 1.14
  */
 GstClockTime
-gst_audio_stream_align_get_discont_wait (GstAudioStreamAlign * align)
+gst_audio_stream_align_get_discont_wait (const GstAudioStreamAlign * align)
 {
   g_return_val_if_fail (align != NULL, 0);
 
@@ -280,7 +285,8 @@ gst_audio_stream_align_mark_discont (GstAudioStreamAlign * align)
  * Since: 1.14
  */
 GstClockTime
-gst_audio_stream_align_get_timestamp_at_discont (GstAudioStreamAlign * align)
+gst_audio_stream_align_get_timestamp_at_discont (const GstAudioStreamAlign *
+    align)
 {
   g_return_val_if_fail (align != NULL, GST_CLOCK_TIME_NONE);
 
@@ -299,7 +305,8 @@ gst_audio_stream_align_get_timestamp_at_discont (GstAudioStreamAlign * align)
  * Since: 1.14
  */
 guint64
-gst_audio_stream_align_get_samples_since_discont (GstAudioStreamAlign * align)
+gst_audio_stream_align_get_samples_since_discont (const GstAudioStreamAlign *
+    align)
 {
   g_return_val_if_fail (align != NULL, 0);
 
diff --git a/gst-libs/gst/audio/gstaudiostreamalign.h b/gst-libs/gst/audio/gstaudiostreamalign.h
index 80b83f927d..080e9ea44b 100644
--- a/gst-libs/gst/audio/gstaudiostreamalign.h
+++ b/gst-libs/gst/audio/gstaudiostreamalign.h
@@ -54,29 +54,29 @@ GST_AUDIO_API
 void                    gst_audio_stream_align_set_rate                  (GstAudioStreamAlign * align,
                                                                           gint rate);
 GST_AUDIO_API
-gint                    gst_audio_stream_align_get_rate                  (GstAudioStreamAlign * align);
+gint                    gst_audio_stream_align_get_rate                  (const GstAudioStreamAlign * align);
 
 GST_AUDIO_API
 void                    gst_audio_stream_align_set_alignment_threshold   (GstAudioStreamAlign * align,
                                                                           GstClockTime alignment_threshold);
 GST_AUDIO_API
-GstClockTime            gst_audio_stream_align_get_alignment_threshold   (GstAudioStreamAlign * align);
+GstClockTime            gst_audio_stream_align_get_alignment_threshold   (const GstAudioStreamAlign * align);
 
 GST_AUDIO_API
 void                    gst_audio_stream_align_set_discont_wait          (GstAudioStreamAlign * align,
                                                                           GstClockTime discont_wait);
 GST_AUDIO_API
-GstClockTime            gst_audio_stream_align_get_discont_wait          (GstAudioStreamAlign * align);
+GstClockTime            gst_audio_stream_align_get_discont_wait          (const GstAudioStreamAlign * align);
 
 
 GST_AUDIO_API
 void                    gst_audio_stream_align_mark_discont              (GstAudioStreamAlign * align);
 
 GST_AUDIO_API
-GstClockTime            gst_audio_stream_align_get_timestamp_at_discont  (GstAudioStreamAlign * align);
+GstClockTime            gst_audio_stream_align_get_timestamp_at_discont  (const GstAudioStreamAlign * align);
 
 GST_AUDIO_API
-guint64                 gst_audio_stream_align_get_samples_since_discont (GstAudioStreamAlign * align);
+guint64                 gst_audio_stream_align_get_samples_since_discont (const GstAudioStreamAlign * align);
 
 GST_AUDIO_API
 gboolean                gst_audio_stream_align_process                   (GstAudioStreamAlign * align,
diff --git a/gst-libs/gst/audio/gstaudioutilsprivate.c b/gst-libs/gst/audio/gstaudioutilsprivate.c
index 1db4601f0e..1f704efad4 100644
--- a/gst-libs/gst/audio/gstaudioutilsprivate.c
+++ b/gst-libs/gst/audio/gstaudioutilsprivate.c
@@ -51,7 +51,6 @@ __gst_audio_element_proxy_caps (GstElement * element, GstCaps * templ_caps,
       const GstStructure *caps_s = gst_caps_get_structure (caps, j);
       const GValue *val;
       GstStructure *s;
-      GstCaps *tmp = gst_caps_new_empty ();
 
       s = gst_structure_new_id_empty (q_name);
       if ((val = gst_structure_get_value (caps_s, "rate")))
@@ -61,9 +60,8 @@ __gst_audio_element_proxy_caps (GstElement * element, GstCaps * templ_caps,
       if ((val = gst_structure_get_value (caps_s, "channels-mask")))
         gst_structure_set_value (s, "channels-mask", val);
 
-      gst_caps_append_structure_full (tmp, s,
+      result = gst_caps_merge_structure_full (result, s,
           gst_caps_features_copy (features));
-      result = gst_caps_merge (result, tmp);
     }
   }
 
@@ -128,13 +126,15 @@ __gst_audio_element_proxy_getcaps (GstElement * element, GstPad * sinkpad,
 
   filter_caps = __gst_audio_element_proxy_caps (element, templ_caps, allowed);
 
-  fcaps = gst_caps_intersect (filter_caps, templ_caps);
+  fcaps = gst_caps_intersect_full (filter_caps, templ_caps,
+      GST_CAPS_INTERSECT_FIRST);
   gst_caps_unref (filter_caps);
   gst_caps_unref (templ_caps);
 
   if (filter) {
     GST_LOG_OBJECT (element, "intersecting with %" GST_PTR_FORMAT, filter);
-    filter_caps = gst_caps_intersect (fcaps, filter);
+    filter_caps = gst_caps_intersect_full (fcaps, filter,
+        GST_CAPS_INTERSECT_FIRST);
     gst_caps_unref (fcaps);
     fcaps = filter_caps;
   }
diff --git a/gst-libs/gst/meson.build b/gst-libs/gst/meson.build
index cd3b5b0436..42c0a6fcab 100644
--- a/gst-libs/gst/meson.build
+++ b/gst-libs/gst/meson.build
@@ -3,9 +3,9 @@ subdir('fft')
 subdir('video')
 subdir('audio')
 subdir('rtp')
+subdir('pbutils')
 subdir('sdp')
 subdir('rtsp')
-subdir('pbutils')
 subdir('riff')
 subdir('app')
 subdir('allocators')
diff --git a/gst-libs/gst/pbutils/codec-utils.c b/gst-libs/gst/pbutils/codec-utils.c
index 3d6d30a1fb..a89f3b051e 100644
--- a/gst-libs/gst/pbutils/codec-utils.c
+++ b/gst-libs/gst/pbutils/codec-utils.c
@@ -43,6 +43,27 @@
 
 #include <string.h>
 
+#ifndef GST_DISABLE_GST_DEBUG
+#define GST_CAT_DEFAULT gst_pb_utils_codec_utils_ensure_debug_category()
+
+static GstDebugCategory *
+gst_pb_utils_codec_utils_ensure_debug_category (void)
+{
+  static gsize cat_gonce = 0;
+
+  if (g_once_init_enter (&cat_gonce)) {
+    GstDebugCategory *cat = NULL;
+
+    GST_DEBUG_CATEGORY_INIT (cat, "codec-utils", 0,
+        "GstPbUtils codec helper functions");
+
+    g_once_init_leave (&cat_gonce, (gsize) cat);
+  }
+
+  return (GstDebugCategory *) cat_gonce;
+}
+#endif /* GST_DISABLE_GST_DEBUG */
+
 #define GST_SIMPLE_CAPS_HAS_NAME(caps,name) \
     gst_structure_has_name(gst_caps_get_structure((caps),0),(name))
 
@@ -256,7 +277,7 @@ gst_codec_utils_aac_get_channels (const guint8 * audio_config, guint len)
  * normally determined using the AudioObjectType field which is in the first
  * 5 bits of @audio_config
  *
- * Returns: The profile as a const string and %NULL if the profile could not be
+ * Returns: (nullable): The profile as a const string and %NULL if the profile could not be
  * determined.
  */
 const gchar *
@@ -319,7 +340,7 @@ gst_codec_utils_aac_get_profile (const guint8 * audio_config, guint len)
  *     fields are appropriately shifted).
  *   * Bit 9:12 contains the channel configuration
  *
- * Returns: The level as a const string and %NULL if the level could not be
+ * Returns: (nullable): The level as a const string and %NULL if the level could not be
  * determined.
  */
 const gchar *
@@ -448,7 +469,7 @@ gst_codec_utils_aac_get_level (const guint8 * audio_config, guint len)
   else
     rcu += (rcu_ref + (rcu_ref - 1) * ((2 * num_cpe) - 1));
 
-  num_channels = num_sce + (2 * num_cpe) + num_lfe;
+  num_channels = num_sce + (2 * num_cpe);
 
   if (audio_object_type == 2) {
     /* AAC LC => return the level as per the 'AAC Profile' */
@@ -564,7 +585,7 @@ gst_codec_utils_aac_caps_set_level_and_profile (GstCaps * caps,
  * * Bit 13:15 - Reserved
  * * Bit 16:24 - Level indication
  *
- * Returns: The profile as a const string, or %NULL if there is an error.
+ * Returns: (nullable): The profile as a const string, or %NULL if there is an error.
  */
 const gchar *
 gst_codec_utils_h264_get_profile (const guint8 * sps, guint len)
@@ -665,7 +686,7 @@ gst_codec_utils_h264_get_profile (const guint8 * sps, guint len)
  * sequence parameter set into a string. The SPS is expected to have the
  * same format as for gst_codec_utils_h264_get_profile().
  *
- * Returns: The level as a const string, or %NULL if there is an error.
+ * Returns: (nullable): The level as a const string, or %NULL if there is an error.
  */
 const gchar *
 gst_codec_utils_h264_get_level (const guint8 * sps, guint len)
@@ -818,6 +839,59 @@ gst_codec_utils_h264_caps_set_level_and_profile (GstCaps * caps,
   return (level != NULL && profile != NULL);
 }
 
+/**
+ * gst_codec_utils_h264_get_profile_flags_level:
+ * @codec_data: (array length=len): H264 AVCC extradata
+ * @len: length of @codec_data
+ * @profile: (optional) (out): return location for h264 profile_idc or %NULL
+ * @flags: (optional) (out): return location for h264 constraint set flags or %NULL
+ * @level: (optional) (out): return location h264 level_idc or %NULL
+ *
+ * Parses profile, flags, and level from a H264 AVCC extradata/sequence_header.
+ * These are most commonly retrieved from a video/x-h264 caps with a codec_data
+ * buffer.
+ *
+ * The format of H264 AVCC extradata/sequence_header is documented in the
+ * ITU-T H.264 specification section 7.3.2.1.1 as well as in ISO/IEC 14496-15
+ * section 5.3.3.1.2.
+ *
+ * Returns: %TRUE on success, %FALSE on failure
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_codec_utils_h264_get_profile_flags_level (const guint8 * codec_data,
+    guint len, guint8 * profile, guint8 * flags, guint8 * level)
+{
+  gboolean ret = FALSE;
+
+  g_return_val_if_fail (codec_data != NULL, FALSE);
+
+  if (len < 7) {
+    GST_WARNING ("avc codec data is too small");
+    goto done;
+  }
+  if (codec_data[0] != 1) {
+    GST_WARNING ("failed to parse avc codec version, must be 1");
+    goto done;
+  }
+
+  if (profile) {
+    *profile = codec_data[1];
+  }
+  if (flags) {
+    *flags = codec_data[2];
+  }
+  if (level) {
+    *level = codec_data[3];
+  }
+
+  ret = TRUE;
+
+done:
+  return ret;
+}
+
 /* forked from gsth265parse.c */
 typedef struct
 {
@@ -1127,7 +1201,7 @@ utils_get_scalable_format_range_extensions_profile (GstH265ExtensionProfile *
  * * Bit 44:87 - See below
  * * Bit 88:95 - general_level_idc
  *
- * Returns: The profile as a const string, or %NULL if there is an error.
+ * Returns: (nullable): The profile as a const string, or %NULL if there is an error.
  *
  * Since: 1.4
  */
@@ -1293,7 +1367,7 @@ gst_codec_utils_h265_get_profile (const guint8 * profile_tier_level, guint len)
  * profile_tier_level structure into a string. The profile_tier_level
  * is expected to have the same format as for gst_codec_utils_h264_get_profile().
  *
- * Returns: The tier as a const string, or %NULL if there is an error.
+ * Returns: (nullable): The tier as a const string, or %NULL if there is an error.
  *
  * Since: 1.4
  */
@@ -1330,7 +1404,7 @@ gst_codec_utils_h265_get_tier (const guint8 * profile_tier_level, guint len)
  * profile_tier_level structure into a string. The profiel_tier_level is
  * expected to have the same format as for gst_codec_utils_h264_get_profile().
  *
- * Returns: The level as a const string, or %NULL if there is an error.
+ * Returns: (nullable): The level as a const string, or %NULL if there is an error.
  *
  * Since: 1.4
  */
@@ -1480,7 +1554,7 @@ gst_codec_utils_h265_caps_set_level_tier_and_profile (GstCaps * caps,
  * object sequence start code. Only the first byte
  * (profile_and_level_indication) is used.
  *
- * Returns: The profile as a const string, or NULL if there is an error.
+ * Returns: (nullable): The profile as a const string, or NULL if there is an error.
  */
 const gchar *
 gst_codec_utils_mpeg4video_get_profile (const guint8 * vis_obj_seq, guint len)
@@ -1553,7 +1627,7 @@ gst_codec_utils_mpeg4video_get_profile (const guint8 * vis_obj_seq, guint len)
  * object sequence start code. Only the first byte
  * (profile_and_level_indication) is used.
  *
- * Returns: The level as a const string, or NULL if there is an error.
+ * Returns: (nullable): The level as a const string, or NULL if there is an error.
  */
 const gchar *
 gst_codec_utils_mpeg4video_get_level (const guint8 * vis_obj_seq, guint len)
@@ -1677,12 +1751,12 @@ gst_codec_utils_mpeg4video_caps_set_level_and_profile (GstCaps * caps,
 /**
  * gst_codec_utils_opus_parse_caps:
  * @caps: the #GstCaps to parse the data from
- * @rate: (out): the sample rate
- * @channels: (out): the number of channels
- * @channel_mapping_family: (out): the channel mapping family
- * @stream_count: (out): the number of independent streams
- * @coupled_count: (out): the number of stereo streams
- * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
+ * @rate: (optional) (out): the sample rate
+ * @channels: (optional) (out): the number of channels
+ * @channel_mapping_family: (optional) (out): the channel mapping family
+ * @stream_count: (optional) (out): the number of independent streams
+ * @coupled_count: (optional) (out): the number of stereo streams
+ * @channel_mapping: (optional) (out) (array fixed-size=256): the mapping between the streams
  *
  * Parses Opus caps and fills the different fields with defaults if possible.
  *
@@ -1798,11 +1872,11 @@ gst_codec_utils_opus_parse_caps (GstCaps * caps,
  * @channel_mapping_family: the channel mapping family
  * @stream_count: the number of independent streams
  * @coupled_count: the number of stereo streams
- * @channel_mapping: (allow-none) (array): the mapping between the streams
+ * @channel_mapping: (nullable) (array): the mapping between the streams
  *
  * Creates Opus caps from the given parameters.
  *
- * Returns: The #GstCaps, or %NULL if the parameters would lead to
+ * Returns: (transfer full) (nullable): The #GstCaps, or %NULL if the parameters would lead to
  * invalid Opus caps.
  *
  * Since: 1.8
@@ -1963,12 +2037,12 @@ _gst_caps_set_buffer_array (GstCaps * caps, const gchar * field,
 /**
  * gst_codec_utils_opus_create_caps_from_header:
  * @header: OpusHead header
- * @comments: (allow-none): Comment header or NULL
+ * @comments: (nullable): Comment header or NULL
  *
  * Creates Opus caps from the given OpusHead @header and comment header
  * @comments.
  *
- * Returns: The #GstCaps.
+ * Returns: (transfer full) (nullable): The #GstCaps.
  *
  * Since: 1.8
  */
@@ -2022,13 +2096,13 @@ gst_codec_utils_opus_create_caps_from_header (GstBuffer * header,
  * @channel_mapping_family: the channel mapping family
  * @stream_count: the number of independent streams
  * @coupled_count: the number of stereo streams
- * @channel_mapping: (allow-none) (array): the mapping between the streams
+ * @channel_mapping: (nullable) (array): the mapping between the streams
  * @pre_skip: Pre-skip in 48kHz samples or 0
  * @output_gain: Output gain or 0
  *
  * Creates OpusHead header from the given parameters.
  *
- * Returns: The #GstBuffer containing the OpusHead.
+ * Returns: (transfer full) (nullable): The #GstBuffer containing the OpusHead.
  *
  * Since: 1.8
  */
@@ -2099,14 +2173,14 @@ gst_codec_utils_opus_create_header (guint32 rate,
 /**
  * gst_codec_utils_opus_parse_header:
  * @header: the OpusHead #GstBuffer
- * @rate: (out): the sample rate
- * @channels: (out): the number of channels
- * @channel_mapping_family: (out): the channel mapping family
- * @stream_count: (out): the number of independent streams
- * @coupled_count: (out): the number of stereo streams
- * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
- * @pre_skip: (out): Pre-skip in 48kHz samples or 0
- * @output_gain: (out): Output gain or 0
+ * @rate: (optional) (out): the sample rate
+ * @channels: (optional) (out): the number of channels
+ * @channel_mapping_family: (optional) (out): the channel mapping family
+ * @stream_count: (optional) (out): the number of independent streams
+ * @coupled_count: (optional) (out): the number of stereo streams
+ * @channel_mapping: (optional) (out) (array fixed-size=256): the mapping between the streams
+ * @pre_skip: (optional) (out): Pre-skip in 48kHz samples or 0
+ * @output_gain: (optional) (out): Output gain or 0
  *
  * Parses the OpusHead header.
  *
@@ -2205,3 +2279,602 @@ done:
 
   return ret;
 }
+
+static gboolean
+h264_caps_structure_get_profile_flags_level (GstStructure * caps_st,
+    guint8 * profile, guint8 * flags, guint8 * level)
+{
+  const GValue *codec_data_value = NULL;
+  GstBuffer *codec_data = NULL;
+  GstMapInfo map;
+  gboolean ret = FALSE;
+  guint8 *data = NULL;
+  gsize size;
+
+  codec_data_value = gst_structure_get_value (caps_st, "codec_data");
+  if (!codec_data_value) {
+    GST_DEBUG
+        ("video/x-h264 caps did not have codec_data set, cannot parse profile, flags and level");
+    return FALSE;
+  }
+
+  codec_data = gst_value_get_buffer (codec_data_value);
+  if (!gst_buffer_map (codec_data, &map, GST_MAP_READ)) {
+    return FALSE;
+  }
+  data = map.data;
+  size = map.size;
+
+  if (!gst_codec_utils_h264_get_profile_flags_level (data, (guint) size,
+          profile, flags, level)) {
+    GST_WARNING
+        ("Failed to parse profile, flags and level from h264 codec data");
+    goto done;
+  }
+
+  ret = TRUE;
+
+done:
+  gst_buffer_unmap (codec_data, &map);
+
+  return ret;
+}
+
+static gboolean
+aac_caps_structure_get_audio_object_type (GstStructure * caps_st,
+    guint8 * audio_object_type)
+{
+  gboolean ret = FALSE;
+  const GValue *codec_data_value = NULL;
+  GstBuffer *codec_data = NULL;
+  GstMapInfo map;
+  guint8 *data = NULL;
+  gsize size;
+  GstBitReader br;
+
+  codec_data_value = gst_structure_get_value (caps_st, "codec_data");
+  if (!codec_data_value) {
+    GST_DEBUG
+        ("audio/mpeg pad did not have codec_data set, cannot parse audio object type");
+    return FALSE;
+  }
+
+  codec_data = gst_value_get_buffer (codec_data_value);
+  if (!gst_buffer_map (codec_data, &map, GST_MAP_READ)) {
+    return FALSE;
+  }
+  data = map.data;
+  size = map.size;
+
+  if (size < 2) {
+    GST_WARNING ("aac codec data is too small");
+    goto done;
+  }
+
+  gst_bit_reader_init (&br, data, size);
+  ret = gst_codec_utils_aac_get_audio_object_type (&br, audio_object_type);
+
+done:
+  gst_buffer_unmap (codec_data, &map);
+
+  return ret;
+}
+
+static gboolean
+hevc_caps_get_mime_codec (GstCaps * caps, gchar ** mime_codec)
+{
+  GstStructure *caps_st = NULL;
+  const GValue *codec_data_value = NULL;
+  GstBuffer *codec_data = NULL;
+  GstMapInfo map;
+  gboolean ret = FALSE;
+  const gchar *stream_format;
+  guint8 *data = NULL;
+  gsize size;
+  guint16 profile_space;
+  guint8 tier_flag;
+  guint16 profile_idc;
+  guint32 compat_flags;
+  guchar constraint_indicator_flags[6];
+  guint8 level_idc;
+  guint32 compat_flag_parameter = 0;
+  GString *codec_string;
+  const guint8 *profile_tier_level;
+  gint last_flag_index;
+
+  caps_st = gst_caps_get_structure (caps, 0);
+  codec_data_value = gst_structure_get_value (caps_st, "codec_data");
+  stream_format = gst_structure_get_string (caps_st, "stream-format");
+  if (!codec_data_value) {
+    GST_DEBUG ("video/x-h265 caps did not have codec_data set, cannot parse");
+    return FALSE;
+  } else if (!stream_format) {
+    GST_DEBUG
+        ("video/x-h265 caps did not have stream-format set, cannot parse");
+    return FALSE;
+  }
+
+  codec_data = gst_value_get_buffer (codec_data_value);
+  if (!gst_buffer_map (codec_data, &map, GST_MAP_READ)) {
+    return FALSE;
+  }
+  data = map.data;
+  size = map.size;
+
+  /* HEVCDecoderConfigurationRecord is at a minimum 23 bytes long */
+  if (size < 23) {
+    GST_DEBUG ("Incomplete HEVCDecoderConfigurationRecord");
+    goto done;
+  }
+
+  if (!g_str_equal (stream_format, "hev1")
+      && !g_str_equal (stream_format, "hvc1")) {
+    GST_DEBUG ("Unknown stream-format %s", stream_format);
+    goto done;
+  }
+
+  profile_tier_level = data + 1;
+  profile_space = (profile_tier_level[0] & 0x11) >> 6;
+  tier_flag = (profile_tier_level[0] & 0x001) >> 5;
+  profile_idc = (profile_tier_level[0] & 0x1f);
+
+  compat_flags = GST_READ_UINT32_BE (data + 2);
+  for (unsigned i = 0; i < 6; ++i)
+    constraint_indicator_flags[i] = GST_READ_UINT8 (data + 6 + i);
+
+  level_idc = data[12];
+
+  /* The 32 bits of the compat_flags, but in reverse bit order */
+  compat_flags =
+      ((compat_flags & 0xaaaaaaaa) >> 1) | ((compat_flags & 0x55555555) << 1);
+  compat_flags =
+      ((compat_flags & 0xcccccccc) >> 2) | ((compat_flags & 0x33333333) << 2);
+  compat_flags =
+      ((compat_flags & 0xf0f0f0f0) >> 4) | ((compat_flags & 0x0f0f0f0f) << 4);
+  compat_flags =
+      ((compat_flags & 0xff00ff00) >> 8) | ((compat_flags & 0x00ff00ff) << 8);
+  compat_flag_parameter = (compat_flags >> 16) | (compat_flags << 16);
+
+  codec_string = g_string_new (stream_format);
+  codec_string = g_string_append_c (codec_string, '.');
+  if (profile_space)
+    codec_string = g_string_append_c (codec_string, 'A' + profile_space - 1);
+  g_string_append_printf (codec_string, "%" G_GUINT16_FORMAT ".%X.%c%d",
+      profile_idc, compat_flag_parameter, tier_flag ? 'H' : 'L', level_idc);
+
+  /* Each of the 6 bytes of the constraint flags, starting from the byte containing the
+   * progressive_source_flag, each encoded as a hexadecimal number, and the encoding
+   * of each byte separated by a period; trailing bytes that are zero may be omitted.
+   */
+  last_flag_index = 5;
+  while (last_flag_index >= 0
+      && (int) (constraint_indicator_flags[last_flag_index]) == 0)
+    --last_flag_index;
+  for (gint i = 0; i <= last_flag_index; ++i) {
+    g_string_append_printf (codec_string, ".%02X",
+        constraint_indicator_flags[i]);
+  }
+
+  *mime_codec = g_string_free (codec_string, FALSE);
+
+  ret = TRUE;
+
+done:
+  gst_buffer_unmap (codec_data, &map);
+  return ret;
+}
+
+/* https://www.webmproject.org/vp9/mp4/#codecs-parameter-string */
+static char *
+vp9_caps_get_mime_codec (GstCaps * caps)
+{
+  GstStructure *caps_st;
+  const char *profile_str, *chroma_format_str, *colorimetry_str;
+  guint bitdepth_luma, bitdepth_chroma;
+  guint8 profile = -1, chroma_format = -1, level = -1;
+  gboolean video_full_range;
+  GstVideoColorimetry cinfo = { 0, };
+  GString *codec_string;
+
+  caps_st = gst_caps_get_structure (caps, 0);
+  codec_string = g_string_new ("vp09");
+
+  profile_str = gst_structure_get_string (caps_st, "profile");
+  if (g_strcmp0 (profile_str, "0") == 0) {
+    profile = 0;
+  } else if (g_strcmp0 (profile_str, "1") == 0) {
+    profile = 1;
+  } else if (g_strcmp0 (profile_str, "2") == 0) {
+    profile = 2;
+  } else if (g_strcmp0 (profile_str, "3") == 0) {
+    profile = 3;
+  } else {
+    goto done;
+  }
+
+  /* XXX: hardcoded level */
+  level = 10;
+
+  gst_structure_get (caps_st, "bit-depth-luma", G_TYPE_UINT,
+      &bitdepth_luma, "bit-depth-chroma", G_TYPE_UINT, &bitdepth_chroma, NULL);
+
+  if (bitdepth_luma == 0)
+    goto done;
+  if (bitdepth_luma != bitdepth_chroma)
+    goto done;
+
+  /* mandatory elements */
+  g_string_append_printf (codec_string, ".%02u.%02u.%02u", profile, level,
+      bitdepth_luma);
+
+  colorimetry_str = gst_structure_get_string (caps_st, "colorimetry");
+  if (!colorimetry_str)
+    goto done;
+  if (!gst_video_colorimetry_from_string (&cinfo, colorimetry_str))
+    goto done;
+  video_full_range = cinfo.range == GST_VIDEO_COLOR_RANGE_0_255;
+
+  chroma_format_str = gst_structure_get_string (caps_st, "chroma-format");
+  if (g_strcmp0 (chroma_format_str, "4:2:0") == 0) {
+    const char *chroma_site_str;
+    GstVideoChromaSite chroma_site;
+
+    chroma_site_str = gst_structure_get_string (caps_st, "chroma-site");
+    if (chroma_site_str)
+      chroma_site = gst_video_chroma_site_from_string (chroma_site_str);
+    else
+      chroma_site = GST_VIDEO_CHROMA_SITE_UNKNOWN;
+    if (chroma_site == GST_VIDEO_CHROMA_SITE_V_COSITED) {
+      chroma_format = 0;
+    } else if (chroma_site == GST_VIDEO_CHROMA_SITE_COSITED) {
+      chroma_format = 1;
+    } else {
+      chroma_format = 1;
+    }
+  } else if (g_strcmp0 (chroma_format_str, "4:2:2") == 0) {
+    chroma_format = 2;
+  } else if (g_strcmp0 (chroma_format_str, "4:4:4") == 0) {
+    chroma_format = 3;
+  } else {
+    goto done;
+  }
+
+  /* optional but all or nothing */
+  g_string_append_printf (codec_string, ".%02u.%02u.%02u.%02u.%02u",
+      chroma_format, gst_video_color_primaries_to_iso (cinfo.primaries),
+      gst_video_transfer_function_to_iso (cinfo.transfer),
+      gst_video_color_matrix_to_iso (cinfo.matrix), video_full_range);
+
+done:
+  return g_string_free (codec_string, FALSE);
+}
+
+/**
+ * gst_codec_utils_caps_get_mime_codec:
+ * @caps: A #GstCaps to convert to mime codec
+ *
+ * Converts @caps to a RFC 6381 compatible codec string if possible.
+ *
+ * Useful for providing the 'codecs' field inside the 'Content-Type' HTTP
+ * header for containerized formats, such as mp4 or matroska.
+ *
+ * Registered codecs can be found at http://mp4ra.org/#/codecs
+ *
+ * Returns: (transfer full) (nullable): a RFC 6381 compatible codec string or %NULL
+ *
+ * Since: 1.20
+ */
+gchar *
+gst_codec_utils_caps_get_mime_codec (GstCaps * caps)
+{
+  gchar *mime_codec = NULL;
+  GstStructure *caps_st = NULL;
+  const gchar *media_type = NULL;
+
+  g_return_val_if_fail (caps != NULL, NULL);
+  g_return_val_if_fail (gst_caps_is_fixed (caps), NULL);
+
+  caps_st = gst_caps_get_structure (caps, 0);
+  if (caps_st == NULL) {
+    GST_WARNING ("Failed to get structure from caps");
+    goto done;
+  }
+
+  media_type = gst_structure_get_name (caps_st);
+
+  if (g_strcmp0 (media_type, "video/x-h264") == 0) {
+    /* avc1.AABBCC
+     *   AA = profile
+     *   BB = constraint set flags
+     *   CC = level
+     */
+    guint8 profile = 0;
+    guint8 flags = 0;
+    guint8 level = 0;
+
+    if (!h264_caps_structure_get_profile_flags_level (caps_st, &profile, &flags,
+            &level)) {
+      GST_DEBUG
+          ("h264 caps did not contain 'codec_data', cannot determine detailed codecs info");
+      mime_codec = g_strdup ("avc1");
+    } else {
+      mime_codec = g_strdup_printf ("avc1.%02X%02X%02X", profile, flags, level);
+    }
+  } else if (g_strcmp0 (media_type, "video/x-h265") == 0) {
+    if (!hevc_caps_get_mime_codec (caps, &mime_codec)) {
+      GST_DEBUG ("h265 caps parsing failed");
+      mime_codec = g_strdup ("hev1");
+    }
+  } else if (g_strcmp0 (media_type, "video/x-av1") == 0) {
+    /* TODO: Some browsers won't play the video unless more codec information is
+     * available in the mime codec for av1. This is documented in
+     * https://aomediacodec.github.io/av1-isobmff/#codecsparam */
+    mime_codec = g_strdup ("av01");
+  } else if (g_strcmp0 (media_type, "video/x-vp8") == 0) {
+    /* TODO: most browsers won't play the video unless more codec information is
+     * available in the mime codec for vp8. */
+    mime_codec = g_strdup ("vp08");
+  } else if (g_strcmp0 (media_type, "video/x-vp9") == 0) {
+    mime_codec = vp9_caps_get_mime_codec (caps);
+  } else if (g_strcmp0 (media_type, "image/jpeg") == 0) {
+    mime_codec = g_strdup ("mjpg");
+  } else if (g_strcmp0 (media_type, "audio/mpeg") == 0) {
+    guint8 audio_object_type = 0;
+    if (aac_caps_structure_get_audio_object_type (caps_st, &audio_object_type)) {
+      mime_codec = g_strdup_printf ("mp4a.40.%u", audio_object_type);
+    } else {
+      mime_codec = g_strdup ("mp4a.40");
+    }
+  } else if (g_strcmp0 (media_type, "audio/x-opus") == 0) {
+    mime_codec = g_strdup ("opus");
+  } else if (g_strcmp0 (media_type, "audio/x-mulaw") == 0) {
+    mime_codec = g_strdup ("ulaw");
+  } else if (g_strcmp0 (media_type, "audio/x-adpcm") == 0) {
+    if (g_strcmp0 (gst_structure_get_string (caps_st, "layout"), "g726") == 0) {
+      mime_codec = g_strdup ("g726");
+    }
+  }
+
+done:
+  return mime_codec;
+}
+
+static GstCaps *
+gst_codec_utils_caps_from_mime_codec_single (const gchar * codec)
+{
+  GstCaps *caps = NULL;
+  gchar **subcodec = NULL;
+  gchar *subcodec0;
+  guint32 codec_fourcc;
+
+  GST_DEBUG ("Analyzing codec '%s'", codec);
+
+  /* rfc 6381 3.3
+   *
+   * For the ISO Base Media File Format, and the QuickTime movie file
+   * format, the first element of a 'codecs' parameter value is a sample
+   * description entry four-character code as registered by the MP4
+   * Registration Authority [MP4RA].
+   *
+   * See Also : http://mp4ra.org/#/codecs
+   */
+  if (strlen (codec) < 4) {
+    GST_WARNING ("Invalid codec (smaller than 4 characters) : '%s'", codec);
+    goto beach;
+  }
+
+  subcodec = g_strsplit (codec, ".", 0);
+  subcodec0 = subcodec[0];
+
+  if (subcodec0 == NULL)
+    goto beach;
+
+  /* Skip any leading spaces */
+  while (*subcodec0 == ' ')
+    subcodec0++;
+
+  if (strlen (subcodec0) < 4) {
+    GST_WARNING ("Invalid codec (smaller than 4 characters) : '%s'", subcodec0);
+    goto beach;
+  }
+
+  GST_LOG ("subcodec[0] '%s'", subcodec0);
+
+  codec_fourcc = GST_READ_UINT32_LE (subcodec0);
+  switch (codec_fourcc) {
+    case GST_MAKE_FOURCC ('a', 'v', 'c', '1'):
+    case GST_MAKE_FOURCC ('a', 'v', 'c', '2'):
+    case GST_MAKE_FOURCC ('a', 'v', 'c', '3'):
+    case GST_MAKE_FOURCC ('a', 'v', 'c', '4'):
+    {
+      guint8 sps[3];
+      guint64 spsint64;
+
+      /* ISO 14496-15 Annex E : Sub-parameters for the MIME type codecs
+       * parameter */
+      caps = gst_caps_new_empty_simple ("video/x-h264");
+
+      if (subcodec[1]) {
+        /* The second element is the hexadecimal representation of the following
+         * three bytes in the (subset) sequence parameter set Network
+         * Abstraction Layer (NAL) unit specified in [AVC]:
+         * * profile_idc
+         * * constraint_set flags
+         * * level_idc
+         * */
+        spsint64 = g_ascii_strtoull (subcodec[1], NULL, 16);
+        sps[0] = spsint64 >> 16;
+        sps[1] = (spsint64 >> 8) & 0xff;
+        sps[2] = spsint64 & 0xff;
+        gst_codec_utils_h264_caps_set_level_and_profile (caps,
+            (const guint8 *) &sps, 3);
+      }
+    }
+      break;
+    case GST_MAKE_FOURCC ('m', 'p', '4', 'a'):
+    {
+      guint64 oti;
+
+      if (!subcodec[1])
+        break;
+      oti = g_ascii_strtoull (subcodec[1], NULL, 16);
+      /* For mp4a, mp4v and mp4s, the second element is the hexadecimal
+       * representation of the MP4 Registration Authority
+       * ObjectTypeIndication */
+      switch (oti) {
+        case 0x40:
+        {
+          guint64 audio_oti;
+          const gchar *profile = NULL;
+
+          /* MPEG-4 Audio (ISO/IEC 14496-3 */
+          caps =
+              gst_caps_new_simple ("audio/mpeg", "mpegversion", G_TYPE_INT, 4,
+              NULL);
+
+          if (!subcodec[2])
+            break;
+          /* If present, last element is the audio object type */
+          audio_oti = g_ascii_strtoull (subcodec[2], NULL, 16);
+
+          switch (audio_oti) {
+            case 1:
+              profile = "main";
+              break;
+            case 2:
+              profile = "lc";
+              break;
+            case 3:
+              profile = "ssr";
+              break;
+            case 4:
+              profile = "ltp";
+              break;
+            default:
+              GST_WARNING ("Unhandled MPEG-4 Audio Object Type: 0x%"
+                  G_GUINT64_FORMAT "x", audio_oti);
+              break;
+          }
+          if (profile)
+            gst_caps_set_simple (caps, "profile", G_TYPE_STRING, profile, NULL);
+          break;
+        }
+        default:
+          GST_WARNING ("Unknown ObjectTypeIndication 0x%" G_GUINT64_FORMAT "x",
+              oti);
+          break;
+      }
+    }
+      break;
+    case GST_MAKE_FOURCC ('h', 'e', 'v', '1'):
+    case GST_MAKE_FOURCC ('h', 'v', 'c', '1'):
+    {
+      /* ISO 14496-15 Annex E : Sub-parameters for the MIME type codecs
+       * parameter */
+      caps = gst_caps_new_empty_simple ("video/x-h265");
+
+      /* FIXME : Extract information from the following component */
+      break;
+    }
+      /* Following are not defined in rfc 6831 but are registered MP4RA codecs */
+    case GST_MAKE_FOURCC ('a', 'c', '-', '3'):
+      /* ETSI TS 102 366 v1.4.1 - Digital Audio Compression (AC-3, Enhanced AC-3) Standard, Annex F */
+      caps = gst_caps_new_empty_simple ("audio/x-ac3");
+      break;
+    case GST_MAKE_FOURCC ('e', 'c', '+', '3'):
+      GST_FIXME
+          ("Signalling of ATMOS ('ec+3') isn't defined yet. Falling back to EAC3 caps");
+      /* withdrawn, unused, do not use (was enhanced AC-3 audio with JOC) */
+    case GST_MAKE_FOURCC ('e', 'c', '-', '3'):
+      /* ETSI TS 102 366 v1.4.1 - Digital Audio Compression (AC-3, Enhanced AC-3) Standard, Annex F */
+      caps = gst_caps_new_empty_simple ("audio/x-eac3");
+      break;
+    case GST_MAKE_FOURCC ('s', 't', 'p', 'p'):
+      /* IMSC1-conformant TTM XML */
+      caps = gst_caps_new_empty_simple ("application/ttml+xml");
+      break;
+    case GST_MAKE_FOURCC ('w', 'v', 't', 't'):
+      /* WebVTT subtitles */
+      caps = gst_caps_new_empty_simple ("application/x-subtitle-vtt");
+      break;
+    case GST_MAKE_FOURCC ('v', 'p', '0', '8'):
+      /* VP8 */
+      caps = gst_caps_new_empty_simple ("video/x-vp8");
+      break;
+    case GST_MAKE_FOURCC ('v', 'p', '0', '9'):
+      /* VP9 */
+      caps = gst_caps_new_empty_simple ("video/x-vp9");
+      break;
+    case GST_MAKE_FOURCC ('a', 'v', '0', '1'):
+      /* AV1 */
+      caps = gst_caps_new_empty_simple ("video/x-av1");
+      break;
+    case GST_MAKE_FOURCC ('o', 'p', 'u', 's'):
+      /* Opus */
+      caps = gst_caps_new_empty_simple ("audio/x-opus");
+      break;
+    case GST_MAKE_FOURCC ('u', 'l', 'a', 'w'):
+      /* ulaw */
+      caps = gst_caps_new_empty_simple ("audio/x-mulaw");
+      break;
+    case GST_MAKE_FOURCC ('g', '7', '2', '6'):
+      /* ulaw */
+      caps =
+          gst_caps_new_simple ("audio/x-adpcm", "layout", G_TYPE_STRING, "g726",
+          NULL);
+      break;
+    default:
+      GST_WARNING ("Unknown codec '%s' please file a bug", codec);
+      break;
+  }
+
+beach:
+  if (subcodec != NULL)
+    g_strfreev (subcodec);
+  return caps;
+}
+
+/**
+ * gst_codec_utils_caps_from_mime_codec:
+ * @codecs_field: A mime codec string field
+ *
+ * Converts a RFC 6381 compatible codec string to #GstCaps. More than one codec
+ * string can be present (separated by `,`).
+ *
+ * Registered codecs can be found at http://mp4ra.org/#/codecs
+ *
+ * Returns: (transfer full) (nullable): The corresponding #GstCaps or %NULL
+ *
+ * Since: 1.22
+ */
+GstCaps *
+gst_codec_utils_caps_from_mime_codec (const gchar * codecs_field)
+{
+  gchar **codecs = NULL;
+  GstCaps *caps = NULL;
+  guint i;
+
+  g_return_val_if_fail (codecs_field != NULL, NULL);
+
+  GST_LOG ("codecs_field '%s'", codecs_field);
+
+  codecs = g_strsplit (codecs_field, ",", 0);
+  if (codecs == NULL) {
+    GST_WARNING ("Invalid 'codecs' field : '%s'", codecs_field);
+    goto beach;
+  }
+
+  for (i = 0; codecs[i]; i++) {
+    const gchar *codec = codecs[i];
+    if (caps == NULL)
+      caps = gst_codec_utils_caps_from_mime_codec_single (codec);
+    else
+      gst_caps_append (caps,
+          gst_codec_utils_caps_from_mime_codec_single (codec));
+  }
+
+beach:
+  g_strfreev (codecs);
+  GST_LOG ("caps %" GST_PTR_FORMAT, caps);
+  return caps;
+}
diff --git a/gst-libs/gst/pbutils/codec-utils.h b/gst-libs/gst/pbutils/codec-utils.h
index 2d3dc0c966..43398c4eaa 100644
--- a/gst-libs/gst/pbutils/codec-utils.h
+++ b/gst-libs/gst/pbutils/codec-utils.h
@@ -68,6 +68,13 @@ gboolean      gst_codec_utils_h264_caps_set_level_and_profile (GstCaps      * ca
                                                                const guint8 * sps,
                                                                guint          len);
 
+GST_PBUTILS_API
+gboolean      gst_codec_utils_h264_get_profile_flags_level (const guint8 * codec_data,
+                                                            guint len,
+                                                            guint8 * profile,
+                                                            guint8 * flags,
+                                                            guint8 * level);
+
 /* H.265 */
 
 GST_PBUTILS_API
@@ -145,6 +152,13 @@ gboolean  gst_codec_utils_opus_parse_header (GstBuffer * header,
                                              guint16   * pre_skip,
                                              gint16    * output_gain);
 
+/* General */
+GST_PBUTILS_API
+gchar * gst_codec_utils_caps_get_mime_codec (GstCaps * caps);
+
+GST_PBUTILS_API
+GstCaps * gst_codec_utils_caps_from_mime_codec (const gchar *codecs_field);
+
 G_END_DECLS
 
 #endif /* __GST_PB_UTILS_CODEC_UTILS_H__ */
diff --git a/gst-libs/gst/pbutils/descriptions.c b/gst-libs/gst/pbutils/descriptions.c
index d79a6cc676..e5f0275b82 100644
--- a/gst-libs/gst/pbutils/descriptions.c
+++ b/gst-libs/gst/pbutils/descriptions.c
@@ -37,7 +37,7 @@
 # include "config.h"
 #endif
 
-#include "gst/gst-i18n-plugin.h"
+#include <glib/gi18n-lib.h>
 
 #include <gst/audio/audio.h>
 #include <gst/video/video.h>
@@ -56,7 +56,8 @@ typedef enum
   FLAG_IMAGE = (1 << 4),        /* format is an image format, or image container/tag  */
   FLAG_SUB = (1 << 5),          /* format is a subtitle format, or subtitle container */
   FLAG_TAG = (1 << 6),          /* format is a tag/container                          */
-  FLAG_GENERIC = (1 << 7)       /* format is a generic container (e.g. multipart)     */
+  FLAG_GENERIC = (1 << 7),      /* format is a generic container (e.g. multipart)     */
+  FLAG_METADATA = (1 << 8),     /* format is a metadata format, or metadata container/tag */
 } FormatFlags;
 
 typedef struct
@@ -330,7 +331,10 @@ static const FormatInfo formats[] = {
   {"video/x-svq", NULL, FLAG_VIDEO, ""},
   {"video/x-wmv", NULL, FLAG_VIDEO, ""},
   {"video/x-xan", NULL, FLAG_VIDEO, ""},
-  {"video/x-tscc", NULL, FLAG_VIDEO, ""}
+  {"video/x-tscc", NULL, FLAG_VIDEO, ""},
+  /* metadata */
+  {"application/x-onvif-metadata", "ONVIF Timed Metadata", FLAG_METADATA, ""},
+  {"meta/x-klv", "KLV Metadata", FLAG_METADATA, ""},
 };
 
 static const gchar *
@@ -649,7 +653,7 @@ format_info_get_desc (const FormatInfo * info, const GstCaps * caps)
       case 1:
       case 2:
       case 3:
-        if (str && strncmp (str, "MSS", 3)) {
+        if (str && !strncmp (str, "MSS", 3)) {
           return g_strdup_printf ("Windows Media Video %d Screen", ver + 6);
         } else {
           return g_strdup_printf ("Windows Media Video %d", ver + 6);
@@ -921,13 +925,13 @@ caps_are_rtp_caps (const GstCaps * caps, const gchar * media, gchar ** format)
  *
  * Returns a localised string describing a source element handling the protocol
  * specified in @protocol, for use in error dialogs or other messages to be
- * seen by the user. Should never return NULL unless @protocol is invalid.
+ * seen by the user.
  *
  * This function is mainly for internal use, applications would typically
  * use gst_missing_plugin_message_get_description() to get a description of
  * a missing feature from a missing-plugin message.
  *
- * Returns: a newly-allocated description string, or NULL on error. Free
+ * Returns: a newly-allocated description string. Free
  *          string with g_free() when not needed any longer.
  */
 gchar *
@@ -971,13 +975,13 @@ gst_pb_utils_get_source_description (const gchar * protocol)
  *
  * Returns a localised string describing a sink element handling the protocol
  * specified in @protocol, for use in error dialogs or other messages to be
- * seen by the user. Should never return NULL unless @protocol is invalid.
+ * seen by the user.
  *
  * This function is mainly for internal use, applications would typically
  * use gst_missing_plugin_message_get_description() to get a description of
  * a missing feature from a missing-plugin message.
  *
- * Returns: a newly-allocated description string, or NULL on error. Free
+ * Returns: a newly-allocated description string. Free
  *          string with g_free() when not needed any longer.
  */
 gchar *
@@ -1006,13 +1010,12 @@ gst_pb_utils_get_sink_description (const gchar * protocol)
  *
  * Returns a localised string describing an decoder for the format specified
  * in @caps, for use in error dialogs or other messages to be seen by the user.
- * Should never return NULL unless @factory_name or @caps are invalid.
  *
  * This function is mainly for internal use, applications would typically
  * use gst_missing_plugin_message_get_description() to get a description of
  * a missing feature from a missing-plugin message.
  *
- * Returns: a newly-allocated description string, or NULL on error. Free
+ * Returns: a newly-allocated description string. Free
  *          string with g_free() when not needed any longer.
  */
 gchar *
@@ -1061,13 +1064,12 @@ gst_pb_utils_get_decoder_description (const GstCaps * caps)
  *
  * Returns a localised string describing an encoder for the format specified
  * in @caps, for use in error dialogs or other messages to be seen by the user.
- * Should never return NULL unless @factory_name or @caps are invalid.
  *
  * This function is mainly for internal use, applications would typically
  * use gst_missing_plugin_message_get_description() to get a description of
  * a missing feature from a missing-plugin message.
  *
- * Returns: a newly-allocated description string, or NULL on error. Free
+ * Returns: a newly-allocated description string. Free
  *          string with g_free() when not needed any longer.
  */
 gchar *
@@ -1112,14 +1114,13 @@ gst_pb_utils_get_encoder_description (const GstCaps * caps)
  * @factory_name: the name of the element, e.g. "giosrc"
  *
  * Returns a localised string describing the given element, for use in
- * error dialogs or other messages to be seen by the user. Should never
- * return NULL unless @factory_name is invalid.
+ * error dialogs or other messages to be seen by the user.
  *
  * This function is mainly for internal use, applications would typically
  * use gst_missing_plugin_message_get_description() to get a description of
  * a missing feature from a missing-plugin message.
  *
- * Returns: a newly-allocated description string, or NULL on error. Free
+ * Returns: a newly-allocated description string. Free
  *          string with g_free() when not needed any longer.
  */
 gchar *
@@ -1141,7 +1142,7 @@ gst_pb_utils_get_element_description (const gchar * factory_name)
 /**
  * gst_pb_utils_add_codec_description_to_tag_list:
  * @taglist: a #GstTagList
- * @codec_tag: (allow-none): a GStreamer codec tag such as #GST_TAG_AUDIO_CODEC,
+ * @codec_tag: (nullable): a GStreamer codec tag such as #GST_TAG_AUDIO_CODEC,
  *             #GST_TAG_VIDEO_CODEC or #GST_TAG_CODEC. If none is specified,
  *             the function will attempt to detect the appropriate category.
  * @caps: the (fixed) #GstCaps for which a codec tag should be added.
@@ -1200,7 +1201,7 @@ gst_pb_utils_add_codec_description_to_tag_list (GstTagList * taglist,
  * Also see the convenience function
  * gst_pb_utils_add_codec_description_to_tag_list().
  *
- * Returns: a newly-allocated description string, or NULL on error. Free
+ * Returns: (nullable): a newly-allocated description string, or NULL on error. Free
  *          string with g_free() when not needed any longer.
  */
 gchar *
@@ -1287,6 +1288,75 @@ pb_utils_get_file_extension_from_caps (const GstCaps * caps)
   return ext;
 }
 
+/**
+ * gst_pb_utils_get_file_extension_from_caps:
+ * @caps: the (fixed) #GstCaps for which a file extension is needed
+ *
+ * Returns a possible file extension for the given caps, if known.
+ *
+ * Returns: (nullable): a newly-allocated file extension string, or NULL on error. Free
+ *          string with g_free() when not needed any longer.
+ *
+ * Since: 1.20
+ */
+gchar *
+gst_pb_utils_get_file_extension_from_caps (const GstCaps * caps)
+{
+  const gchar *extension = pb_utils_get_file_extension_from_caps (caps);
+  return extension ? g_strdup (extension) : NULL;
+}
+
+/**
+ * gst_pb_utils_get_caps_description_flags:
+ * @caps: the (fixed) #GstCaps for which flags are requested
+ *
+ * Returns flags that describe the format of the caps if known. No flags are
+ * set for unknown caps.
+ *
+ * Returns: #GstPbUtilsCapsDescriptionFlags that describe @caps, or no flags
+ *          if the caps are unknown.
+ *
+ * Since: 1.20
+ */
+GstPbUtilsCapsDescriptionFlags
+gst_pb_utils_get_caps_description_flags (const GstCaps * caps)
+{
+  GstCaps *tmp;
+  const FormatInfo *info;
+  GstPbUtilsCapsDescriptionFlags flags = 0;
+
+  g_return_val_if_fail (caps != NULL, 0);
+  g_return_val_if_fail (GST_IS_CAPS (caps), 0);
+  tmp = copy_and_clean_caps (caps);
+  g_return_val_if_fail (gst_caps_is_fixed (tmp), 0);
+
+  info = find_format_info (tmp);
+  /* A separate flags type is used because internally more flags are needed
+   * for filtering purposes, e.g. the SYSTEMSTREAM flag */
+  if (info) {
+    if ((info->flags & FLAG_CONTAINER))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_CONTAINER;
+    if ((info->flags & FLAG_AUDIO))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_AUDIO;
+    if ((info->flags & FLAG_VIDEO))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_VIDEO;
+    if ((info->flags & FLAG_IMAGE))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_IMAGE;
+    if ((info->flags & FLAG_SUB))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_SUBTITLE;
+    if ((info->flags & FLAG_TAG))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_TAG;
+    if ((info->flags & FLAG_GENERIC))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_GENERIC;
+    if ((info->flags & FLAG_METADATA))
+      flags |= GST_PBUTILS_CAPS_DESCRIPTION_FLAG_METADATA;
+  }
+
+  gst_caps_unref (tmp);
+
+  return flags;
+}
+
 gboolean
 pb_utils_is_tag (const GstCaps * caps)
 {
diff --git a/gst-libs/gst/pbutils/descriptions.h b/gst-libs/gst/pbutils/descriptions.h
index c03f46abbe..c1b7845f20 100644
--- a/gst-libs/gst/pbutils/descriptions.h
+++ b/gst-libs/gst/pbutils/descriptions.h
@@ -26,6 +26,49 @@
 
 G_BEGIN_DECLS
 
+/**
+ * GstPbUtilsCapsDescriptionFlags:
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_CONTAINER: Caps describe a container format.
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_AUDIO: Caps describe an audio format, or a
+ *     container format that can store audio.
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_VIDEO: Caps describe an video format, or a
+ *     container format that can store video.
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_IMAGE: Caps describe an image format, or a
+ *     container format that can store image.
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_SUBTITLE: Caps describe an subtitle format, or a
+ *     container format that can store subtitles.
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_TAG: Container format is a tags container.
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_GENERIC: Container format can store any kind of
+ *     stream type.
+ * @GST_PBUTILS_CAPS_DESCRIPTION_FLAG_METADATA: Caps describe a metadata
+ *     format, or a container format that can store metadata.
+ *
+ * Flags that are returned by gst_pb_utils_get_caps_description_flags() and
+ * describe the format of the caps.
+ *
+ * Since: 1.20
+ */
+typedef enum {
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_CONTAINER = 1 << 0,
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_AUDIO     = 1 << 1,
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_VIDEO     = 1 << 2,
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_IMAGE     = 1 << 3,
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_SUBTITLE  = 1 << 4,
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_TAG       = 1 << 5,
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_GENERIC   = 1 << 6,
+
+  /**
+   * GST_PBUTILS_CAPS_DESCRIPTION_FLAG_METADATA:
+   *
+   * Caps describe a metadata format, or a container format that can store
+   * metadata.
+   *
+   * Since: 1.22
+   */
+
+  GST_PBUTILS_CAPS_DESCRIPTION_FLAG_METADATA  = 1 << 7,
+} GstPbUtilsCapsDescriptionFlags;
+
 /*
  * functions for use by demuxers or decoders to add CODEC tags to tag lists
  * from caps
@@ -59,6 +102,11 @@ gchar    * gst_pb_utils_get_encoder_description (const GstCaps * caps);
 GST_PBUTILS_API
 gchar    * gst_pb_utils_get_element_description (const gchar * factory_name);
 
+GST_PBUTILS_API
+GstPbUtilsCapsDescriptionFlags gst_pb_utils_get_caps_description_flags (const GstCaps * caps);
+
+GST_PBUTILS_API
+gchar * gst_pb_utils_get_file_extension_from_caps (const GstCaps *caps);
 
 G_END_DECLS
 
diff --git a/gst-libs/gst/pbutils/pbutils-private.h b/gst-libs/gst/pbutils/pbutils-private.h
index 856b63f616..4a10167b95 100644
--- a/gst-libs/gst/pbutils/pbutils-private.h
+++ b/gst-libs/gst/pbutils/pbutils-private.h
@@ -31,12 +31,14 @@ struct _GstDiscovererStreamInfo {
   GstToc                *toc;
   gchar                 *stream_id;
   GstStructure          *misc;
+  gint                  stream_number;
 };
 
 struct _GstDiscovererContainerInfo {
   GstDiscovererStreamInfo parent;
 
   GList               *streams;
+  GstTagList          *tags;
 };
 
 struct _GstDiscovererAudioInfo {
@@ -96,6 +98,8 @@ struct _GstDiscovererInfo {
   gboolean seekable;
   GPtrArray *missing_elements_details;
 
+  gint stream_count;
+
   gchar *cachefile;
   gpointer from_cache;
 };
diff --git a/gst-libs/gst/pbutils/pbutils.c b/gst-libs/gst/pbutils/pbutils.c
index 8115de3560..a6408d82fb 100644
--- a/gst-libs/gst/pbutils/pbutils.c
+++ b/gst-libs/gst/pbutils/pbutils.c
@@ -59,7 +59,27 @@
 #include "pbutils.h"
 #include "pbutils-private.h"
 
-#include "gst/gst-i18n-plugin.h"
+#include <glib/gi18n-lib.h>
+
+#ifndef GST_DISABLE_GST_DEBUG
+#define GST_CAT_DEFAULT gst_pb_utils_ensure_debug_category()
+
+static GstDebugCategory *
+gst_pb_utils_ensure_debug_category (void)
+{
+  static gsize cat_gonce = 0;
+
+  if (g_once_init_enter (&cat_gonce)) {
+    GstDebugCategory *cat = NULL;
+
+    GST_DEBUG_CATEGORY_INIT (cat, "pbutils", 0, "GStreamer Plugins Base utils");
+
+    g_once_init_leave (&cat_gonce, (gsize) cat);
+  }
+
+  return (GstDebugCategory *) cat_gonce;
+}
+#endif /* GST_DISABLE_GST_DEBUG */
 
 static gpointer
 _init_locale_text_domain (gpointer data)
diff --git a/gst-libs/gst/rtp/gstrtcpbuffer.c b/gst-libs/gst/rtp/gstrtcpbuffer.c
index 29dfd82a0c..dea2a7933d 100644
--- a/gst-libs/gst/rtp/gstrtcpbuffer.c
+++ b/gst-libs/gst/rtp/gstrtcpbuffer.c
@@ -84,7 +84,7 @@ gst_rtcp_buffer_new_take_data (gpointer data, guint len)
 GstBuffer *
 gst_rtcp_buffer_new_copy_data (gconstpointer data, guint len)
 {
-  return gst_rtcp_buffer_new_take_data (g_memdup (data, len), len);
+  return gst_rtcp_buffer_new_take_data (g_memdup2 (data, len), len);
 }
 
 static gboolean
@@ -109,8 +109,7 @@ gst_rtcp_buffer_validate_data_internal (guint8 * data, guint len,
   if (G_UNLIKELY (header_mask != GST_RTCP_VALID_VALUE))
     goto wrong_mask;
 
-  /* no padding when mask succeeds */
-  padding = FALSE;
+  padding = data[0] & 0x20;
 
   /* store len */
   data_len = len;
@@ -129,7 +128,7 @@ gst_rtcp_buffer_validate_data_internal (guint8 * data, guint len,
     if (data_len < 4)
       break;
 
-    /* padding only allowed on last packet */
+    /* Version already checked for first packet through mask */
     if (padding)
       break;
 
@@ -1213,7 +1212,7 @@ gst_rtcp_packet_copy_profile_specific_ext (GstRTCPPacket * packet,
     if (data != NULL) {
       guint8 *ptr = packet->rtcp->map.data + packet->offset;
       ptr += ((packet->length + 1 - pse_len) * sizeof (guint32));
-      *data = g_memdup (ptr, pse_len * sizeof (guint32));
+      *data = g_memdup2 (ptr, pse_len * sizeof (guint32));
     }
 
     return TRUE;
@@ -1864,7 +1863,7 @@ gst_rtcp_packet_bye_get_reason_len (GstRTCPPacket * packet)
  *
  * Get the reason in @packet.
  *
- * Returns: The reason for the BYE @packet or NULL if the packet did not contain
+ * Returns: (nullable): The reason for the BYE @packet or NULL if the packet did not contain
  * a reason string. The string must be freed with g_free() after usage.
  */
 gchar *
@@ -2211,6 +2210,27 @@ gst_rtcp_sdes_type_to_name (GstRTCPSDESType type)
     case GST_RTCP_SDES_PRIV:
       result = "priv";
       break;
+    case GST_RTCP_SDES_H323_CADDR:
+      result = "h323-caddr";
+      break;
+    case GST_RTCP_SDES_APSI:
+      result = "apsi";
+      break;
+    case GST_RTCP_SDES_RGRP:
+      result = "rgrp";
+      break;
+    case GST_RTCP_SDES_REPAIRED_RTP_STREAM_ID:
+      result = "repaired-rtp-stream-id";
+      break;
+    case GST_RTCP_SDES_CCID:
+      result = "ccid";
+      break;
+    case GST_RTCP_SDES_RTP_STREAM_ID:
+      result = "rtp-stream-id";
+      break;
+    case GST_RTCP_SDES_MID:
+      result = "mid";
+      break;
     default:
       result = NULL;
       break;
@@ -2255,6 +2275,27 @@ gst_rtcp_sdes_name_to_type (const gchar * name)
   if (strcmp ("note", name) == 0)
     return GST_RTCP_SDES_NOTE;
 
+  if (strcmp ("h323-caddr", name) == 0)
+    return GST_RTCP_SDES_H323_CADDR;
+
+  if (strcmp ("apsi", name) == 0)
+    return GST_RTCP_SDES_APSI;
+
+  if (strcmp ("rgrp", name) == 0)
+    return GST_RTCP_SDES_RGRP;
+
+  if (strcmp ("rtp-stream-id", name) == 0)
+    return GST_RTCP_SDES_RTP_STREAM_ID;
+
+  if (strcmp ("repaired-rtp-stream-id", name) == 0)
+    return GST_RTCP_SDES_REPAIRED_RTP_STREAM_ID;
+
+  if (strcmp ("ccid", name) == 0)
+    return GST_RTCP_SDES_CCID;
+
+  if (strcmp ("mid", name) == 0)
+    return GST_RTCP_SDES_MID;
+
   return GST_RTCP_SDES_PRIV;
 }
 
diff --git a/gst-libs/gst/rtp/gstrtcpbuffer.h b/gst-libs/gst/rtp/gstrtcpbuffer.h
index 32291fa9de..b6410a5a1f 100644
--- a/gst-libs/gst/rtp/gstrtcpbuffer.h
+++ b/gst-libs/gst/rtp/gstrtcpbuffer.h
@@ -126,18 +126,74 @@ typedef enum
  *
  * Different types of SDES content.
  */
+/**
+ * GST_RTCP_SDES_H323_CADDR:
+ *
+ * H.323 callable address
+ *
+ * Since: 1.20:
+ */
+/**
+ * GST_RTCP_SDES_APSI:
+ *
+ * Application Specific Identifier (RFC6776)
+ *
+ * Since: 1.20:
+ */
+/**
+ * GST_RTCP_SDES_RGRP:
+ *
+ * Reporting Group Identifier (RFC8861)
+ *
+ * Since: 1.20:
+ */
+/**
+ * GST_RTCP_SDES_RTP_STREAM_ID:
+ *
+ * RtpStreamId SDES item (RFC8852).
+ *
+ * Since: 1.20:
+ */
+/**
+ * GST_RTCP_SDES_REPAIRED_RTP_STREAM_ID:
+ *
+ * RepairedRtpStreamId SDES item (RFC8852).
+ *
+ * Since: 1.20:
+ */
+/**
+ * GST_RTCP_SDES_CCID:
+ *
+ * CLUE CaptId (RFC8849)
+ *
+ * Since: 1.20:
+ */
+/**
+ * GST_RTCP_SDES_MID:
+ *
+ * MID SDES item (RFC8843).
+ *
+ * Since: 1.20:
+ */
 typedef enum
 {
-  GST_RTCP_SDES_INVALID  = -1,
-  GST_RTCP_SDES_END      = 0,
-  GST_RTCP_SDES_CNAME    = 1,
-  GST_RTCP_SDES_NAME     = 2,
-  GST_RTCP_SDES_EMAIL    = 3,
-  GST_RTCP_SDES_PHONE    = 4,
-  GST_RTCP_SDES_LOC      = 5,
-  GST_RTCP_SDES_TOOL     = 6,
-  GST_RTCP_SDES_NOTE     = 7,
-  GST_RTCP_SDES_PRIV     = 8
+  GST_RTCP_SDES_INVALID                 = -1,
+  GST_RTCP_SDES_END                     = 0,
+  GST_RTCP_SDES_CNAME                   = 1,
+  GST_RTCP_SDES_NAME                    = 2,
+  GST_RTCP_SDES_EMAIL                   = 3,
+  GST_RTCP_SDES_PHONE                   = 4,
+  GST_RTCP_SDES_LOC                     = 5,
+  GST_RTCP_SDES_TOOL                    = 6,
+  GST_RTCP_SDES_NOTE                    = 7,
+  GST_RTCP_SDES_PRIV                    = 8,
+  GST_RTCP_SDES_H323_CADDR              = 9,
+  GST_RTCP_SDES_APSI                    = 10,
+  GST_RTCP_SDES_RGRP                    = 11,
+  GST_RTCP_SDES_RTP_STREAM_ID           = 12,
+  GST_RTCP_SDES_REPAIRED_RTP_STREAM_ID  = 13,
+  GST_RTCP_SDES_CCID                    = 14,
+  GST_RTCP_SDES_MID                     = 15,
 } GstRTCPSDESType;
 
 /**
@@ -206,10 +262,10 @@ typedef enum
 /**
  * GST_RTCP_REDUCED_SIZE_VALID_MASK:
  *
- * Mask for version, padding bit and packet type pair allowing reduced size
+ * Mask for version and packet type pair allowing reduced size
  * packets, basically it accepts other types than RR and SR
  */
-#define GST_RTCP_REDUCED_SIZE_VALID_MASK (0xc000 | 0x2000 | 0xf8)
+#define GST_RTCP_REDUCED_SIZE_VALID_MASK (0xc000 | 0xf8)
 
 /**
  * GST_RTCP_VALID_VALUE:
diff --git a/gst-libs/gst/rtp/gstrtpbasedepayload.c b/gst-libs/gst/rtp/gstrtpbasedepayload.c
index 46b75b9200..0fd2d827a5 100644
--- a/gst-libs/gst/rtp/gstrtpbasedepayload.c
+++ b/gst-libs/gst/rtp/gstrtpbasedepayload.c
@@ -31,10 +31,14 @@
 
 #include "gstrtpbasedepayload.h"
 #include "gstrtpmeta.h"
+#include "gstrtphdrext.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpbasedepayload_debug);
 #define GST_CAT_DEFAULT (rtpbasedepayload_debug)
 
+static GstStaticCaps ntp_reference_timestamp_caps =
+GST_STATIC_CAPS ("timestamp/x-ntp");
+
 struct _GstRTPBaseDepayloadPrivate
 {
   GstClockTime npt_start;
@@ -49,11 +53,14 @@ struct _GstRTPBaseDepayloadPrivate
   GstClockTime dts;
   GstClockTime duration;
 
+  GstClockTime ref_ts;
+
   guint32 last_ssrc;
   guint32 last_seqnum;
   guint32 last_rtptime;
   guint32 next_seqnum;
   gint max_reorder;
+  gboolean auto_hdr_ext;
 
   gboolean negotiated;
 
@@ -65,17 +72,26 @@ struct _GstRTPBaseDepayloadPrivate
   GstBuffer *input_buffer;
 
   GstFlowReturn process_flow_ret;
+
+  /* array of GstRTPHeaderExtension's * */
+  GPtrArray *header_exts;
 };
 
 /* Filter signals and args */
 enum
 {
-  /* FILL ME */
+  SIGNAL_0,
+  SIGNAL_REQUEST_EXTENSION,
+  SIGNAL_ADD_EXTENSION,
+  SIGNAL_CLEAR_EXTENSIONS,
   LAST_SIGNAL
 };
 
+static guint gst_rtp_base_depayload_signals[LAST_SIGNAL] = { 0 };
+
 #define DEFAULT_SOURCE_INFO FALSE
 #define DEFAULT_MAX_REORDER 100
+#define DEFAULT_AUTO_HEADER_EXTENSION TRUE
 
 enum
 {
@@ -83,6 +99,7 @@ enum
   PROP_STATS,
   PROP_SOURCE_INFO,
   PROP_MAX_REORDER,
+  PROP_AUTO_HEADER_EXTENSION,
   PROP_LAST
 };
 
@@ -117,6 +134,11 @@ static void gst_rtp_base_depayload_init (GstRTPBaseDepayload * rtpbasepayload,
 static GstEvent *create_segment_event (GstRTPBaseDepayload * filter,
     guint rtptime, GstClockTime position);
 
+static void gst_rtp_base_depayload_add_extension (GstRTPBaseDepayload *
+    rtpbasepayload, GstRTPHeaderExtension * ext);
+static void gst_rtp_base_depayload_clear_extensions (GstRTPBaseDepayload *
+    rtpbasepayload);
+
 GType
 gst_rtp_base_depayload_get_type (void)
 {
@@ -154,6 +176,45 @@ gst_rtp_base_depayload_get_instance_private (GstRTPBaseDepayload * self)
   return (G_STRUCT_MEMBER_P (self, private_offset));
 }
 
+static GstRTPHeaderExtension *
+gst_rtp_base_depayload_request_extension_default (GstRTPBaseDepayload *
+    depayload, guint ext_id, const gchar * uri)
+{
+  GstRTPHeaderExtension *ext = NULL;
+
+  if (!depayload->priv->auto_hdr_ext)
+    return NULL;
+
+  ext = gst_rtp_header_extension_create_from_uri (uri);
+  if (ext) {
+    GST_DEBUG_OBJECT (depayload,
+        "Automatically enabled extension %s for uri \'%s\'",
+        GST_ELEMENT_NAME (ext), uri);
+
+    gst_rtp_header_extension_set_id (ext, ext_id);
+  } else {
+    GST_DEBUG_OBJECT (depayload,
+        "Didn't find any extension implementing uri \'%s\'", uri);
+  }
+
+  return ext;
+}
+
+static gboolean
+extension_accumulator (GSignalInvocationHint * ihint,
+    GValue * return_accu, const GValue * handler_return, gpointer data)
+{
+  gpointer ext;
+
+  /* Call default handler if user callback didn't create the extension */
+  ext = g_value_get_object (handler_return);
+  if (!ext)
+    return TRUE;
+
+  g_value_set_object (return_accu, ext);
+  return FALSE;
+}
+
 static void
 gst_rtp_base_depayload_class_init (GstRTPBaseDepayloadClass * klass)
 {
@@ -223,6 +284,73 @@ gst_rtp_base_depayload_class_init (GstRTPBaseDepayloadClass * klass)
           "Max seqnum reorder before assuming sender has restarted",
           0, G_MAXINT, DEFAULT_MAX_REORDER, G_PARAM_READWRITE));
 
+  /**
+   * GstRTPBaseDepayload:auto-header-extension:
+   *
+   * If enabled, the depayloader will automatically try to enable all the
+   * RTP header extensions provided in the sink caps, saving the application
+   * the need to handle these extensions manually using the
+   * GstRTPBaseDepayload::request-extension: signal.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (G_OBJECT_CLASS (klass),
+      PROP_AUTO_HEADER_EXTENSION, g_param_spec_boolean ("auto-header-extension",
+          "Automatic RTP header extension",
+          "Whether RTP header extensions should be automatically enabled, if an implementation is available",
+          DEFAULT_AUTO_HEADER_EXTENSION,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRTPBaseDepayload::request-extension:
+   * @object: the #GstRTPBaseDepayload
+   * @ext_id: the extension id being requested
+   * @ext_uri: (nullable): the extension URI being requested
+   *
+   * The returned @ext must be configured with the correct @ext_id and with the
+   * necessary attributes as required by the extension implementation.
+   *
+   * Returns: (transfer full) (nullable): the #GstRTPHeaderExtension for @ext_id, or %NULL
+   *
+   * Since: 1.20
+   */
+  gst_rtp_base_depayload_signals[SIGNAL_REQUEST_EXTENSION] =
+      g_signal_new_class_handler ("request-extension",
+      G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
+      G_CALLBACK (gst_rtp_base_depayload_request_extension_default),
+      extension_accumulator, NULL, NULL,
+      GST_TYPE_RTP_HEADER_EXTENSION, 2, G_TYPE_UINT, G_TYPE_STRING);
+
+  /**
+   * GstRTPBaseDepayload::add-extension:
+   * @object: the #GstRTPBaseDepayload
+   * @ext: (transfer full): the #GstRTPHeaderExtension
+   *
+   * Add @ext as an extension for reading part of an RTP header extension from
+   * incoming RTP packets.
+   *
+   * Since: 1.20
+   */
+  gst_rtp_base_depayload_signals[SIGNAL_ADD_EXTENSION] =
+      g_signal_new_class_handler ("add-extension", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_base_depayload_add_extension), NULL, NULL, NULL,
+      G_TYPE_NONE, 1, GST_TYPE_RTP_HEADER_EXTENSION);
+
+  /**
+   * GstRTPBaseDepayload::clear-extensions:
+   * @object: the #GstRTPBaseDepayload
+   *
+   * Clear all RTP header extensions used by this depayloader.
+   *
+   * Since: 1.20
+   */
+  gst_rtp_base_depayload_signals[SIGNAL_CLEAR_EXTENSIONS] =
+      g_signal_new_class_handler ("clear-extensions", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_base_depayload_clear_extensions), NULL, NULL, NULL,
+      G_TYPE_NONE, 0);
+
   gstelement_class->change_state = gst_rtp_base_depayload_change_state;
 
   klass->packet_lost = gst_rtp_base_depayload_packet_lost;
@@ -272,24 +400,52 @@ gst_rtp_base_depayload_init (GstRTPBaseDepayload * filter,
   priv->dts = -1;
   priv->pts = -1;
   priv->duration = -1;
+  priv->ref_ts = -1;
   priv->source_info = DEFAULT_SOURCE_INFO;
   priv->max_reorder = DEFAULT_MAX_REORDER;
+  priv->auto_hdr_ext = DEFAULT_AUTO_HEADER_EXTENSION;
 
   gst_segment_init (&filter->segment, GST_FORMAT_UNDEFINED);
+
+  priv->header_exts =
+      g_ptr_array_new_with_free_func ((GDestroyNotify) gst_object_unref);
 }
 
 static void
 gst_rtp_base_depayload_finalize (GObject * object)
 {
+  GstRTPBaseDepayload *rtpbasedepayload = GST_RTP_BASE_DEPAYLOAD (object);
+
+  g_ptr_array_unref (rtpbasedepayload->priv->header_exts);
+  rtpbasedepayload->priv->header_exts = NULL;
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
+static void
+add_and_ref_item (GstRTPHeaderExtension * ext, GPtrArray * ret)
+{
+  g_ptr_array_add (ret, gst_object_ref (ext));
+}
+
+static void
+remove_item_from (GstRTPHeaderExtension * ext, GPtrArray * ret)
+{
+  g_ptr_array_remove_fast (ret, ext);
+}
+
+static void
+add_item_to (GstRTPHeaderExtension * ext, GPtrArray * ret)
+{
+  g_ptr_array_add (ret, ext);
+}
+
 static gboolean
 gst_rtp_base_depayload_setcaps (GstRTPBaseDepayload * filter, GstCaps * caps)
 {
   GstRTPBaseDepayloadClass *bclass;
   GstRTPBaseDepayloadPrivate *priv;
-  gboolean res;
+  gboolean res = TRUE;
   GstStructure *caps_struct;
   const GValue *value;
 
@@ -355,6 +511,140 @@ gst_rtp_base_depayload_setcaps (GstRTPBaseDepayload * filter, GstCaps * caps)
   else
     priv->clock_base = -1;
 
+  {
+    /* ensure we have header extension implementations for the list in the
+     * caps */
+    guint i, j, n_fields = gst_structure_n_fields (caps_struct);
+    GPtrArray *header_exts = g_ptr_array_new_with_free_func (gst_object_unref);
+    GPtrArray *to_add = g_ptr_array_new ();
+    GPtrArray *to_remove = g_ptr_array_new ();
+
+    GST_OBJECT_LOCK (filter);
+    g_ptr_array_foreach (filter->priv->header_exts,
+        (GFunc) add_and_ref_item, header_exts);
+    GST_OBJECT_UNLOCK (filter);
+
+    for (i = 0; i < n_fields; i++) {
+      const gchar *field_name = gst_structure_nth_field_name (caps_struct, i);
+      if (g_str_has_prefix (field_name, "extmap-")) {
+        const GValue *val;
+        const gchar *uri = NULL;
+        gchar *nptr;
+        guint ext_id;
+        GstRTPHeaderExtension *ext = NULL;
+
+        errno = 0;
+        ext_id = g_ascii_strtoull (&field_name[strlen ("extmap-")], &nptr, 10);
+        if (errno != 0 || (ext_id == 0 && field_name == nptr)) {
+          GST_WARNING_OBJECT (filter, "could not parse id from %s", field_name);
+          res = FALSE;
+          goto ext_out;
+        }
+
+        val = gst_structure_get_value (caps_struct, field_name);
+        if (G_VALUE_HOLDS_STRING (val)) {
+          uri = g_value_get_string (val);
+        } else if (GST_VALUE_HOLDS_ARRAY (val)) {
+          /* the uri is the second value in the array */
+          const GValue *str = gst_value_array_get_value (val, 1);
+          if (G_VALUE_HOLDS_STRING (str)) {
+            uri = g_value_get_string (str);
+          }
+        }
+
+        if (!uri) {
+          GST_WARNING_OBJECT (filter, "could not get extmap uri for "
+              "field %s", field_name);
+          res = FALSE;
+          goto ext_out;
+        }
+
+        /* try to find if this extension mapping already exists */
+        for (j = 0; j < header_exts->len; j++) {
+          ext = g_ptr_array_index (header_exts, j);
+          if (gst_rtp_header_extension_get_id (ext) == ext_id) {
+            if (g_strcmp0 (uri, gst_rtp_header_extension_get_uri (ext)) == 0) {
+              /* still matching, we're good, set attributes from caps in case
+               * the caps have changed */
+              if (!gst_rtp_header_extension_set_attributes_from_caps (ext,
+                      caps)) {
+                GST_WARNING_OBJECT (filter,
+                    "Failed to configure rtp header " "extension %"
+                    GST_PTR_FORMAT " attributes from caps %" GST_PTR_FORMAT,
+                    ext, caps);
+                res = FALSE;
+                goto ext_out;
+              }
+              break;
+            } else {
+              GST_DEBUG_OBJECT (filter, "extension id %u"
+                  "was replaced with a different extension uri "
+                  "original:\'%s' vs \'%s\'", ext_id,
+                  gst_rtp_header_extension_get_uri (ext), uri);
+              g_ptr_array_add (to_remove, ext);
+              ext = NULL;
+              break;
+            }
+          } else {
+            ext = NULL;
+          }
+        }
+
+        /* if no extension, attempt to request one */
+        if (!ext) {
+          GST_DEBUG_OBJECT (filter, "requesting extension for id %u"
+              " and uri %s", ext_id, uri);
+          g_signal_emit (filter,
+              gst_rtp_base_depayload_signals[SIGNAL_REQUEST_EXTENSION], 0,
+              ext_id, uri, &ext);
+          GST_DEBUG_OBJECT (filter, "request returned extension %p \'%s\' "
+              "for id %u and uri %s", ext,
+              ext ? GST_OBJECT_NAME (ext) : "", ext_id, uri);
+
+          /* We require the caller to set the appropriate extension if it's required */
+          if (ext && gst_rtp_header_extension_get_id (ext) != ext_id) {
+            g_warning ("\'request-extension\' signal provided an rtp header "
+                "extension for uri \'%s\' that does not match the requested "
+                "extension id %u", uri, ext_id);
+            gst_clear_object (&ext);
+          }
+
+          if (ext && !gst_rtp_header_extension_set_attributes_from_caps (ext,
+                  caps)) {
+            GST_WARNING_OBJECT (filter,
+                "Failed to configure rtp header " "extension %"
+                GST_PTR_FORMAT " attributes from caps %" GST_PTR_FORMAT,
+                ext, caps);
+            res = FALSE;
+            g_clear_object (&ext);
+            goto ext_out;
+          }
+
+          if (ext)
+            g_ptr_array_add (to_add, ext);
+        }
+      }
+    }
+
+    /* Note: we intentionally don't remove extensions that are not listed
+     * in caps */
+
+    GST_OBJECT_LOCK (filter);
+    g_ptr_array_foreach (to_remove, (GFunc) remove_item_from,
+        filter->priv->header_exts);
+    g_ptr_array_foreach (to_add, (GFunc) add_item_to,
+        filter->priv->header_exts);
+    GST_OBJECT_UNLOCK (filter);
+
+  ext_out:
+    g_ptr_array_unref (to_add);
+    g_ptr_array_unref (to_remove);
+    g_ptr_array_unref (header_exts);
+
+    if (!res)
+      return res;
+  }
+
   if (bclass->set_caps) {
     res = bclass->set_caps (filter, caps);
     if (!res) {
@@ -395,6 +685,8 @@ gst_rtp_base_depayload_handle_buffer (GstRTPBaseDepayload * filter,
   gboolean discont, buf_discont;
   gint gap;
   GstRTPBuffer rtp = { NULL };
+  GstReferenceTimestampMeta *meta;
+  GstCaps *ref_caps;
 
   priv = filter->priv;
   priv->process_flow_ret = GST_FLOW_OK;
@@ -406,6 +698,21 @@ gst_rtp_base_depayload_handle_buffer (GstRTPBaseDepayload * filter,
   if (G_UNLIKELY (!priv->negotiated))
     goto not_negotiated;
 
+  /* Check for duplicate reference timestamp metadata */
+  ref_caps = gst_static_caps_get (&ntp_reference_timestamp_caps);
+  meta = gst_buffer_get_reference_timestamp_meta (in, ref_caps);
+  gst_caps_unref (ref_caps);
+  if (meta) {
+    guint64 ref_ts = meta->timestamp;
+    if (ref_ts == priv->ref_ts) {
+      /* Drop the redundant/duplicate reference timstamp metadata */
+      in = gst_buffer_make_writable (in);
+      gst_buffer_remove_meta (in, GST_META_CAST (meta));
+    } else {
+      priv->ref_ts = ref_ts;
+    }
+  }
+
   if (G_UNLIKELY (!gst_rtp_buffer_map (in, GST_MAP_READ, &rtp)))
     goto invalid_buffer;
 
@@ -639,6 +946,7 @@ gst_rtp_base_depayload_handle_event (GstRTPBaseDepayload * filter,
 
       filter->need_newsegment = !filter->priv->onvif_mode;
       filter->priv->next_seqnum = -1;
+      filter->priv->ref_ts = -1;
       gst_event_replace (&filter->priv->segment_event, NULL);
       break;
     case GST_EVENT_CAPS:
@@ -834,30 +1142,170 @@ add_rtp_source_meta (GstBuffer * outbuf, GstBuffer * rtpbuf)
   gst_rtp_buffer_unmap (&rtp);
 }
 
+static void
+gst_rtp_base_depayload_add_extension (GstRTPBaseDepayload * rtpbasepayload,
+    GstRTPHeaderExtension * ext)
+{
+  g_return_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext));
+  g_return_if_fail (gst_rtp_header_extension_get_id (ext) > 0);
+
+  /* XXX: check for duplicate ids? */
+  GST_OBJECT_LOCK (rtpbasepayload);
+  g_ptr_array_add (rtpbasepayload->priv->header_exts, gst_object_ref (ext));
+  GST_OBJECT_UNLOCK (rtpbasepayload);
+}
+
+static void
+gst_rtp_base_depayload_clear_extensions (GstRTPBaseDepayload * rtpbasepayload)
+{
+  GST_OBJECT_LOCK (rtpbasepayload);
+  g_ptr_array_set_size (rtpbasepayload->priv->header_exts, 0);
+  GST_OBJECT_UNLOCK (rtpbasepayload);
+}
+
+static gboolean
+read_rtp_header_extensions (GstRTPBaseDepayload * depayload,
+    GstBuffer * input, GstBuffer * output)
+{
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  guint16 bit_pattern;
+  guint8 *pdata;
+  guint wordlen;
+  gboolean needs_src_caps_update = FALSE;
+
+  if (!input) {
+    GST_DEBUG_OBJECT (depayload, "no input buffer");
+    return needs_src_caps_update;
+  }
+
+  if (!gst_rtp_buffer_map (input, GST_MAP_READ, &rtp)) {
+    GST_WARNING_OBJECT (depayload, "Failed to map buffer");
+    return needs_src_caps_update;
+  }
+
+  if (gst_rtp_buffer_get_extension_data (&rtp, &bit_pattern, (gpointer) & pdata,
+          &wordlen)) {
+    GstRTPHeaderExtensionFlags ext_flags = 0;
+    gsize bytelen = wordlen * 4;
+    guint hdr_unit_bytes;
+    gsize offset = 0;
+
+    if (bit_pattern == 0xBEDE) {
+      /* one byte extensions */
+      hdr_unit_bytes = 1;
+      ext_flags |= GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+    } else if (bit_pattern >> 4 == 0x100) {
+      /* two byte extensions */
+      hdr_unit_bytes = 2;
+      ext_flags |= GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+    } else {
+      GST_DEBUG_OBJECT (depayload, "unknown extension bit pattern 0x%02x%02x",
+          bit_pattern >> 8, bit_pattern & 0xff);
+      goto out;
+    }
+
+    while (TRUE) {
+      guint8 read_id, read_len;
+      GstRTPHeaderExtension *ext = NULL;
+      guint i;
+
+      if (offset + hdr_unit_bytes >= bytelen)
+        /* not enough remaning data */
+        break;
+
+      if (ext_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+        read_id = GST_READ_UINT8 (pdata + offset) >> 4;
+        read_len = (GST_READ_UINT8 (pdata + offset) & 0x0F) + 1;
+        offset += 1;
+
+        if (read_id == 0)
+          /* padding */
+          continue;
+
+        if (read_id == 15)
+          /* special id for possible future expansion */
+          break;
+      } else {
+        read_id = GST_READ_UINT8 (pdata + offset);
+        offset += 1;
+
+        if (read_id == 0)
+          /* padding */
+          continue;
+
+        read_len = GST_READ_UINT8 (pdata + offset);
+        offset += 1;
+      }
+      GST_TRACE_OBJECT (depayload, "found rtp header extension with id %u and "
+          "length %u", read_id, read_len);
+
+      /* Ignore extension headers where the size does not fit */
+      if (offset + read_len > bytelen) {
+        GST_WARNING_OBJECT (depayload, "Extension length extends past the "
+            "size of the extension data");
+        break;
+      }
+
+      GST_OBJECT_LOCK (depayload);
+      for (i = 0; i < depayload->priv->header_exts->len; i++) {
+        ext = g_ptr_array_index (depayload->priv->header_exts, i);
+        if (read_id == gst_rtp_header_extension_get_id (ext)) {
+          gst_object_ref (ext);
+          break;
+        }
+        ext = NULL;
+      }
+
+      if (ext) {
+        if (!gst_rtp_header_extension_read (ext, ext_flags, &pdata[offset],
+                read_len, output)) {
+          GST_WARNING_OBJECT (depayload, "RTP header extension (%s) could "
+              "not read payloaded data", GST_OBJECT_NAME (ext));
+          gst_object_unref (ext);
+          goto out;
+        }
+
+        if (gst_rtp_header_extension_wants_update_non_rtp_src_caps (ext)) {
+          needs_src_caps_update = TRUE;
+        }
+
+        gst_object_unref (ext);
+      }
+      GST_OBJECT_UNLOCK (depayload);
+
+      offset += read_len;
+    }
+  }
+
+out:
+  gst_rtp_buffer_unmap (&rtp);
+
+  return needs_src_caps_update;
+}
+
 static gboolean
-set_headers (GstBuffer ** buffer, guint idx, GstRTPBaseDepayload * depayload)
+gst_rtp_base_depayload_set_headers (GstRTPBaseDepayload * depayload,
+    GstBuffer * buffer)
 {
   GstRTPBaseDepayloadPrivate *priv = depayload->priv;
   GstClockTime pts, dts, duration;
 
-  *buffer = gst_buffer_make_writable (*buffer);
-
-  pts = GST_BUFFER_PTS (*buffer);
-  dts = GST_BUFFER_DTS (*buffer);
-  duration = GST_BUFFER_DURATION (*buffer);
+  pts = GST_BUFFER_PTS (buffer);
+  dts = GST_BUFFER_DTS (buffer);
+  duration = GST_BUFFER_DURATION (buffer);
 
   /* apply last incoming timestamp and duration to outgoing buffer if
    * not otherwise set. */
   if (!GST_CLOCK_TIME_IS_VALID (pts))
-    GST_BUFFER_PTS (*buffer) = priv->pts;
+    GST_BUFFER_PTS (buffer) = priv->pts;
   if (!GST_CLOCK_TIME_IS_VALID (dts))
-    GST_BUFFER_DTS (*buffer) = priv->dts;
+    GST_BUFFER_DTS (buffer) = priv->dts;
   if (!GST_CLOCK_TIME_IS_VALID (duration))
-    GST_BUFFER_DURATION (*buffer) = priv->duration;
+    GST_BUFFER_DURATION (buffer) = priv->duration;
 
   if (G_UNLIKELY (depayload->priv->discont)) {
     GST_LOG_OBJECT (depayload, "Marking DISCONT on output buffer");
-    GST_BUFFER_FLAG_SET (*buffer, GST_BUFFER_FLAG_DISCONT);
+    GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
     depayload->priv->discont = FALSE;
   }
 
@@ -866,24 +1314,20 @@ set_headers (GstBuffer ** buffer, guint idx, GstRTPBaseDepayload * depayload)
   priv->dts = GST_CLOCK_TIME_NONE;
   priv->duration = GST_CLOCK_TIME_NONE;
 
-  if (priv->source_info && priv->input_buffer)
-    add_rtp_source_meta (*buffer, priv->input_buffer);
+  if (priv->input_buffer) {
+    if (priv->source_info)
+      add_rtp_source_meta (buffer, priv->input_buffer);
 
-  return TRUE;
+    return read_rtp_header_extensions (depayload, priv->input_buffer, buffer);
+  }
+
+  return FALSE;
 }
 
 static GstFlowReturn
-gst_rtp_base_depayload_prepare_push (GstRTPBaseDepayload * filter,
+gst_rtp_base_depayload_finish_push (GstRTPBaseDepayload * filter,
     gboolean is_list, gpointer obj)
 {
-  if (is_list) {
-    GstBufferList **blist = obj;
-    gst_buffer_list_foreach (*blist, (GstBufferListFunc) set_headers, filter);
-  } else {
-    GstBuffer **buf = obj;
-    set_headers (buf, 0, filter);
-  }
-
   /* if this is the first buffer send a NEWSEGMENT */
   if (G_UNLIKELY (filter->priv->segment_event)) {
     gst_pad_push_event (filter->srcpad, filter->priv->segment_event);
@@ -891,13 +1335,125 @@ gst_rtp_base_depayload_prepare_push (GstRTPBaseDepayload * filter,
     GST_DEBUG_OBJECT (filter, "Pushed newsegment event on this first buffer");
   }
 
-  return GST_FLOW_OK;
+  if (is_list) {
+    GstBufferList *blist = obj;
+    return gst_pad_push_list (filter->srcpad, blist);
+  } else {
+    GstBuffer *buf = obj;
+    return gst_pad_push (filter->srcpad, buf);
+  }
+}
+
+static gboolean
+gst_rtp_base_depayload_set_src_caps_from_hdrext (GstRTPBaseDepayload * filter)
+{
+  gboolean update_ok = TRUE;
+  GstCaps *src_caps = gst_pad_get_current_caps (filter->srcpad);
+
+  if (src_caps) {
+    GstCaps *new_caps;
+    gint i;
+
+    new_caps = gst_caps_copy (src_caps);
+    for (i = 0; i < filter->priv->header_exts->len; i++) {
+      GstRTPHeaderExtension *ext;
+
+      ext = g_ptr_array_index (filter->priv->header_exts, i);
+      update_ok =
+          gst_rtp_header_extension_update_non_rtp_src_caps (ext, new_caps);
+
+      if (!update_ok) {
+        GST_ELEMENT_ERROR (filter, STREAM, DECODE,
+            ("RTP header extension (%s) could not update src caps",
+                GST_OBJECT_NAME (ext)), (NULL));
+        break;
+      }
+    }
+
+    if (G_UNLIKELY (update_ok && !gst_caps_is_equal (src_caps, new_caps))) {
+      gst_pad_set_caps (filter->srcpad, new_caps);
+    }
+
+    gst_caps_unref (src_caps);
+    gst_caps_unref (new_caps);
+  }
+
+  return update_ok;
+}
+
+static GstFlowReturn
+gst_rtp_base_depayload_do_push (GstRTPBaseDepayload * filter, gboolean is_list,
+    gpointer obj)
+{
+  GstFlowReturn res;
+
+  if (is_list) {
+    GstBufferList *blist = obj;
+    guint i;
+    guint first_not_pushed_idx = 0;
+
+    for (i = 0; i < gst_buffer_list_length (blist); ++i) {
+      GstBuffer *buf = gst_buffer_list_get_writable (blist, i);
+
+      if (G_UNLIKELY (gst_rtp_base_depayload_set_headers (filter, buf))) {
+        /* src caps have changed; push the buffers preceding the current one,
+         * then apply the new caps on the src pad */
+        guint j;
+
+        for (j = first_not_pushed_idx; j < i; ++j) {
+          res = gst_rtp_base_depayload_finish_push (filter, FALSE,
+              gst_buffer_ref (gst_buffer_list_get (blist, j)));
+          if (G_UNLIKELY (res != GST_FLOW_OK)) {
+            goto error_list;
+          }
+        }
+        first_not_pushed_idx = i;
+
+        if (!gst_rtp_base_depayload_set_src_caps_from_hdrext (filter)) {
+          res = GST_FLOW_ERROR;
+          goto error_list;
+        }
+      }
+    }
+
+    if (G_LIKELY (first_not_pushed_idx == 0)) {
+      res = gst_rtp_base_depayload_finish_push (filter, TRUE, blist);
+      blist = NULL;
+    } else {
+      for (i = first_not_pushed_idx; i < gst_buffer_list_length (blist); ++i) {
+        res = gst_rtp_base_depayload_finish_push (filter, FALSE,
+            gst_buffer_ref (gst_buffer_list_get (blist, i)));
+        if (G_UNLIKELY (res != GST_FLOW_OK)) {
+          break;
+        }
+      }
+    }
+
+  error_list:
+    gst_clear_buffer_list (&blist);
+  } else {
+    GstBuffer *buf = obj;
+    if (G_UNLIKELY (gst_rtp_base_depayload_set_headers (filter, buf))) {
+      if (!gst_rtp_base_depayload_set_src_caps_from_hdrext (filter)) {
+        res = GST_FLOW_ERROR;
+        goto error_buffer;
+      }
+    }
+
+    res = gst_rtp_base_depayload_finish_push (filter, FALSE, buf);
+    buf = NULL;
+
+  error_buffer:
+    gst_clear_buffer (&buf);
+  }
+
+  return res;
 }
 
 /**
  * gst_rtp_base_depayload_push:
  * @filter: a #GstRTPBaseDepayload
- * @out_buf: a #GstBuffer
+ * @out_buf: (transfer full): a #GstBuffer
  *
  * Push @out_buf to the peer of @filter. This function takes ownership of
  * @out_buf.
@@ -912,12 +1468,7 @@ gst_rtp_base_depayload_push (GstRTPBaseDepayload * filter, GstBuffer * out_buf)
 {
   GstFlowReturn res;
 
-  res = gst_rtp_base_depayload_prepare_push (filter, FALSE, &out_buf);
-
-  if (G_LIKELY (res == GST_FLOW_OK))
-    res = gst_pad_push (filter->srcpad, out_buf);
-  else
-    gst_buffer_unref (out_buf);
+  res = gst_rtp_base_depayload_do_push (filter, FALSE, out_buf);
 
   if (res != GST_FLOW_OK)
     filter->priv->process_flow_ret = res;
@@ -928,7 +1479,7 @@ gst_rtp_base_depayload_push (GstRTPBaseDepayload * filter, GstBuffer * out_buf)
 /**
  * gst_rtp_base_depayload_push_list:
  * @filter: a #GstRTPBaseDepayload
- * @out_list: a #GstBufferList
+ * @out_list: (transfer full): a #GstBufferList
  *
  * Push @out_list to the peer of @filter. This function takes ownership of
  * @out_list.
@@ -941,12 +1492,7 @@ gst_rtp_base_depayload_push_list (GstRTPBaseDepayload * filter,
 {
   GstFlowReturn res;
 
-  res = gst_rtp_base_depayload_prepare_push (filter, TRUE, &out_list);
-
-  if (G_LIKELY (res == GST_FLOW_OK))
-    res = gst_pad_push_list (filter->srcpad, out_list);
-  else
-    gst_buffer_list_unref (out_list);
+  res = gst_rtp_base_depayload_do_push (filter, TRUE, out_list);
 
   if (res != GST_FLOW_OK)
     filter->priv->process_flow_ret = res;
@@ -992,6 +1538,7 @@ gst_rtp_base_depayload_packet_lost (GstRTPBaseDepayload * filter,
           &might_have_been_fec) || !might_have_been_fec) {
     /* send GAP event */
     sevent = gst_event_new_gap (timestamp, duration);
+    gst_event_set_gap_flags (sevent, GST_GAP_FLAG_MISSING_DATA);
     res = gst_pad_push_event (filter->srcpad, sevent);
   }
 
@@ -1019,6 +1566,7 @@ gst_rtp_base_depayload_change_state (GstElement * element,
       priv->play_speed = 1.0;
       priv->play_scale = 1.0;
       priv->clock_base = -1;
+      priv->ref_ts = -1;
       priv->onvif_mode = FALSE;
       priv->next_seqnum = -1;
       priv->negotiated = FALSE;
@@ -1099,6 +1647,9 @@ gst_rtp_base_depayload_set_property (GObject * object, guint prop_id,
     case PROP_MAX_REORDER:
       priv->max_reorder = g_value_get_int (value);
       break;
+    case PROP_AUTO_HEADER_EXTENSION:
+      priv->auto_hdr_ext = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1127,6 +1678,9 @@ gst_rtp_base_depayload_get_property (GObject * object, guint prop_id,
     case PROP_MAX_REORDER:
       g_value_set_int (value, priv->max_reorder);
       break;
+    case PROP_AUTO_HEADER_EXTENSION:
+      g_value_set_boolean (value, priv->auto_hdr_ext);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
diff --git a/gst-libs/gst/rtp/gstrtpbasepayload.c b/gst-libs/gst/rtp/gstrtpbasepayload.c
index 0f5feb44e9..02d0f51d23 100644
--- a/gst-libs/gst/rtp/gstrtpbasepayload.c
+++ b/gst-libs/gst/rtp/gstrtpbasepayload.c
@@ -30,12 +30,11 @@
 
 #include "gstrtpbasepayload.h"
 #include "gstrtpmeta.h"
+#include "gstrtphdrext.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpbasepayload_debug);
 #define GST_CAT_DEFAULT (rtpbasepayload_debug)
 
-static gboolean enable_experimental_twcc = FALSE;
-
 struct _GstRTPBasePayloadPrivate
 {
   gboolean ts_offset_random;
@@ -49,13 +48,13 @@ struct _GstRTPBasePayloadPrivate
 
   gboolean source_info;
   GstBuffer *input_meta_buffer;
-  guint8 twcc_ext_id;
 
   guint64 base_offset;
   gint64 base_rtime;
   guint64 base_rtime_hz;
   guint64 running_time;
   gboolean scale_rtptime;
+  gboolean auto_hdr_ext;
 
   gint64 prop_max_ptime;
   gint64 caps_max_ptime;
@@ -64,20 +63,35 @@ struct _GstRTPBasePayloadPrivate
 
   gboolean negotiated;
 
+  /* We need to know whether negotiate was called in order to decide
+   * whether we should store the input buffer as input meta in case
+   * negotiate() gets called from the subclass' handle_buffer() implementation,
+   * as negotiate() is where we instantiate header extensions.
+   */
+  gboolean negotiate_called;
+
   gboolean delay_segment;
   GstEvent *pending_segment;
 
   GstCaps *subclass_srccaps;
   GstCaps *sinkcaps;
+
+  /* array of GstRTPHeaderExtension's * */
+  GPtrArray *header_exts;
 };
 
 /* RTPBasePayload signals and args */
 enum
 {
-  /* FILL ME */
+  SIGNAL_0,
+  SIGNAL_REQUEST_EXTENSION,
+  SIGNAL_ADD_EXTENSION,
+  SIGNAL_CLEAR_EXTENSIONS,
   LAST_SIGNAL
 };
 
+static guint gst_rtp_base_payload_signals[LAST_SIGNAL] = { 0 };
+
 /* FIXME 0.11, a better default is the Ethernet MTU of
  * 1500 - sizeof(headers) as pointed out by marcelm in IRC:
  * So an Ethernet MTU of 1500, minus 60 for the max IP, minus 8 for UDP, gives
@@ -96,8 +110,13 @@ enum
 #define DEFAULT_RUNNING_TIME            GST_CLOCK_TIME_NONE
 #define DEFAULT_SOURCE_INFO             FALSE
 #define DEFAULT_ONVIF_NO_RATE_CONTROL   FALSE
-#define DEFAULT_TWCC_EXT_ID             0
 #define DEFAULT_SCALE_RTPTIME           TRUE
+#define DEFAULT_AUTO_HEADER_EXTENSION   TRUE
+
+#define RTP_HEADER_EXT_ONE_BYTE_MAX_SIZE 16
+#define RTP_HEADER_EXT_TWO_BYTE_MAX_SIZE 256
+#define RTP_HEADER_EXT_ONE_BYTE_MAX_ID 14
+#define RTP_HEADER_EXT_TWO_BYTE_MAX_ID 255
 
 enum
 {
@@ -116,8 +135,8 @@ enum
   PROP_STATS,
   PROP_SOURCE_INFO,
   PROP_ONVIF_NO_RATE_CONTROL,
-  PROP_TWCC_EXT_ID,
   PROP_SCALE_RTPTIME,
+  PROP_AUTO_HEADER_EXTENSION,
   PROP_LAST
 };
 
@@ -154,6 +173,9 @@ static GstStateChangeReturn gst_rtp_base_payload_change_state (GstElement *
 
 static gboolean gst_rtp_base_payload_negotiate (GstRTPBasePayload * payload);
 
+static void gst_rtp_base_payload_add_extension (GstRTPBasePayload * payload,
+    GstRTPHeaderExtension * ext);
+static void gst_rtp_base_payload_clear_extensions (GstRTPBasePayload * payload);
 
 static GstElementClass *parent_class = NULL;
 static gint private_offset = 0;
@@ -194,6 +216,45 @@ gst_rtp_base_payload_get_instance_private (GstRTPBasePayload * self)
   return (G_STRUCT_MEMBER_P (self, private_offset));
 }
 
+static GstRTPHeaderExtension *
+gst_rtp_base_payload_request_extension_default (GstRTPBasePayload * payload,
+    guint ext_id, const gchar * uri)
+{
+  GstRTPHeaderExtension *ext = NULL;
+
+  if (!payload->priv->auto_hdr_ext)
+    return NULL;
+
+  ext = gst_rtp_header_extension_create_from_uri (uri);
+  if (ext) {
+    GST_DEBUG_OBJECT (payload,
+        "Automatically enabled extension %s for uri \'%s\'",
+        GST_ELEMENT_NAME (ext), uri);
+
+    gst_rtp_header_extension_set_id (ext, ext_id);
+  } else {
+    GST_DEBUG_OBJECT (payload,
+        "Didn't find any extension implementing uri \'%s\'", uri);
+  }
+
+  return ext;
+}
+
+static gboolean
+extension_accumulator (GSignalInvocationHint * ihint,
+    GValue * return_accu, const GValue * handler_return, gpointer data)
+{
+  gpointer ext;
+
+  /* Call default handler if user callback didn't create the extension */
+  ext = g_value_get_object (handler_return);
+  if (!ext)
+    return TRUE;
+
+  g_value_set_object (return_accu, ext);
+  return FALSE;
+}
+
 static void
 gst_rtp_base_payload_class_init (GstRTPBasePayloadClass * klass)
 {
@@ -203,9 +264,6 @@ gst_rtp_base_payload_class_init (GstRTPBasePayloadClass * klass)
   gobject_class = (GObjectClass *) klass;
   gstelement_class = (GstElementClass *) klass;
 
-  if (g_getenv ("GST_RTP_ENABLE_EXPERIMENTAL_TWCC_PROPERTY"))
-    enable_experimental_twcc = TRUE;
-
   if (private_offset != 0)
     g_type_class_adjust_private_offset (klass, &private_offset);
 
@@ -348,32 +406,6 @@ gst_rtp_base_payload_class_init (GstRTPBasePayloadClass * klass)
           DEFAULT_ONVIF_NO_RATE_CONTROL,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
-  /**
-   * GstRTPBasePayload:twcc-ext-id:
-   *
-   * The RTP header-extension ID used for tagging buffers with Transport-Wide
-   * Congestion Control sequence-numbers.
-   * 
-   * To use this across multiple bundled streams (transport wide), the
-   * GstRTPFunnel can mux TWCC sequence-numbers together.
-   * 
-   * This is experimental and requires setting the
-   * 'GST_RTP_ENABLE_EXPERIMENTAL_TWCC_PROPERTY' environment variable as it is
-   * still a draft and not yet a standard.  This property may also be removed
-   * in the future for 1.20.
-   *
-   * Since: 1.18
-   */
-  if (enable_experimental_twcc) {
-    g_object_class_install_property (gobject_class, PROP_TWCC_EXT_ID,
-        g_param_spec_uint ("twcc-ext-id",
-            "Transport-wide Congestion Control Extension ID (experimental)",
-            "The RTP header-extension ID to use for tagging buffers with "
-            "Transport-wide Congestion Control sequencenumbers (0 = disable)",
-            0, 15, DEFAULT_TWCC_EXT_ID,
-            G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
-  }
-
   /**
    * GstRTPBasePayload:scale-rtptime:
    *
@@ -393,6 +425,73 @@ gst_rtp_base_payload_class_init (GstRTPBasePayloadClass * klass)
           "Whether the RTP timestamp should be scaled with the rate (speed)",
           DEFAULT_SCALE_RTPTIME, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRTPBasePayload:auto-header-extension:
+   *
+   * If enabled, the payloader will automatically try to enable all the
+   * RTP header extensions provided in the src caps, saving the application
+   * the need to handle these extensions manually using the
+   * GstRTPBasePayload::request-extension: signal.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (G_OBJECT_CLASS (klass),
+      PROP_AUTO_HEADER_EXTENSION, g_param_spec_boolean ("auto-header-extension",
+          "Automatic RTP header extension",
+          "Whether RTP header extensions should be automatically enabled, if an implementation is available",
+          DEFAULT_AUTO_HEADER_EXTENSION,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRTPBasePayload::add-extension:
+   * @object: the #GstRTPBasePayload
+   * @ext: (transfer full): the #GstRTPHeaderExtension
+   *
+   * Add @ext as an extension for writing part of an RTP header extension onto
+   * outgoing RTP packets.
+   *
+   * Since: 1.20
+   */
+  gst_rtp_base_payload_signals[SIGNAL_ADD_EXTENSION] =
+      g_signal_new_class_handler ("add-extension", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_base_payload_add_extension), NULL, NULL, NULL,
+      G_TYPE_NONE, 1, GST_TYPE_RTP_HEADER_EXTENSION);
+
+  /**
+   * GstRTPBasePayload::request-extension:
+   * @object: the #GstRTPBasePayload
+   * @ext_id: the extension id being requested
+   * @ext_uri: the extension URI being requested
+   *
+   * The returned @ext must be configured with the correct @ext_id and with the
+   * necessary attributes as required by the extension implementation.
+   *
+   * Returns: (transfer full) (nullable): the #GstRTPHeaderExtension for @ext_id, or %NULL
+   *
+   * Since: 1.20
+   */
+  gst_rtp_base_payload_signals[SIGNAL_REQUEST_EXTENSION] =
+      g_signal_new_class_handler ("request-extension",
+      G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
+      G_CALLBACK (gst_rtp_base_payload_request_extension_default),
+      extension_accumulator, NULL, NULL,
+      GST_TYPE_RTP_HEADER_EXTENSION, 2, G_TYPE_UINT, G_TYPE_STRING);
+
+  /**
+   * GstRTPBasePayload::clear-extensions:
+   * @object: the #GstRTPBasePayload
+   *
+   * Clear all RTP header extensions used by this payloader.
+   *
+   * Since: 1.20
+   */
+  gst_rtp_base_payload_signals[SIGNAL_CLEAR_EXTENSIONS] =
+      g_signal_new_class_handler ("clear-extensions", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_base_payload_clear_extensions), NULL, NULL, NULL,
+      G_TYPE_NONE, 0);
+
   gstelement_class->change_state = gst_rtp_base_payload_change_state;
 
   klass->get_caps = gst_rtp_base_payload_getcaps_default;
@@ -455,6 +554,7 @@ gst_rtp_base_payload_init (GstRTPBasePayload * rtpbasepayload, gpointer g_class)
   rtpbasepayload->priv->base_rtime_hz = GST_BUFFER_OFFSET_NONE;
   rtpbasepayload->priv->onvif_no_rate_control = DEFAULT_ONVIF_NO_RATE_CONTROL;
   rtpbasepayload->priv->scale_rtptime = DEFAULT_SCALE_RTPTIME;
+  rtpbasepayload->priv->auto_hdr_ext = DEFAULT_AUTO_HEADER_EXTENSION;
 
   rtpbasepayload->media = NULL;
   rtpbasepayload->encoding_name = NULL;
@@ -463,6 +563,8 @@ gst_rtp_base_payload_init (GstRTPBasePayload * rtpbasepayload, gpointer g_class)
 
   rtpbasepayload->priv->caps_max_ptime = DEFAULT_MAX_PTIME;
   rtpbasepayload->priv->prop_max_ptime = DEFAULT_MAX_PTIME;
+  rtpbasepayload->priv->header_exts =
+      g_ptr_array_new_with_free_func ((GDestroyNotify) gst_object_unref);
 }
 
 static void
@@ -480,6 +582,9 @@ gst_rtp_base_payload_finalize (GObject * object)
   gst_caps_replace (&rtpbasepayload->priv->subclass_srccaps, NULL);
   gst_caps_replace (&rtpbasepayload->priv->sinkcaps, NULL);
 
+  g_ptr_array_unref (rtpbasepayload->priv->header_exts);
+  rtpbasepayload->priv->header_exts = NULL;
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
@@ -741,13 +846,15 @@ gst_rtp_base_payload_chain (GstPad * pad, GstObject * parent,
   if (!rtpbasepayload->priv->negotiated)
     goto not_negotiated;
 
-  if (rtpbasepayload->priv->source_info) {
+  if (rtpbasepayload->priv->source_info
+      || rtpbasepayload->priv->header_exts->len > 0
+      || !rtpbasepayload->priv->negotiate_called) {
     /* Save a copy of meta (instead of taking an extra reference before
      * handle_buffer) to make the meta available when allocating a output
      * buffer. */
     rtpbasepayload->priv->input_meta_buffer = gst_buffer_new ();
     gst_buffer_copy_into (rtpbasepayload->priv->input_meta_buffer, buffer,
-        GST_BUFFER_COPY_META, 0, -1);
+        GST_BUFFER_COPY_METADATA, 0, -1);
   }
 
   if (gst_pad_check_reconfigure (GST_RTP_BASE_PAYLOAD_SRCPAD (rtpbasepayload))) {
@@ -849,22 +956,28 @@ update_max_ptime (GstRTPBasePayload * rtpbasepayload)
     rtpbasepayload->max_ptime = DEFAULT_MAX_PTIME;
 }
 
+static gboolean
+_set_caps (GQuark field_id, const GValue * value, GstCaps * caps)
+{
+  gst_caps_set_value (caps, g_quark_to_string (field_id), value);
+
+  return TRUE;
+}
+
 /**
- * gst_rtp_base_payload_set_outcaps:
+ * gst_rtp_base_payload_set_outcaps_structure:
  * @payload: a #GstRTPBasePayload
- * @fieldname: the first field name or %NULL
- * @...: field values
- *
- * Configure the output caps with the optional parameters.
+ * @s: (nullable): a #GstStructure with the caps fields
  *
- * Variable arguments should be in the form field name, field type
- * (as a GType), value(s).  The last variable argument should be NULL.
+ * Configure the output caps with the optional fields.
  *
  * Returns: %TRUE if the caps could be set.
+ *
+ * Since: 1.20
  */
 gboolean
-gst_rtp_base_payload_set_outcaps (GstRTPBasePayload * payload,
-    const gchar * fieldname, ...)
+gst_rtp_base_payload_set_outcaps_structure (GstRTPBasePayload * payload,
+    GstStructure * s)
 {
   GstCaps *srccaps;
 
@@ -876,21 +989,80 @@ gst_rtp_base_payload_set_outcaps (GstRTPBasePayload * payload,
 
   GST_DEBUG_OBJECT (payload, "defaults: %" GST_PTR_FORMAT, srccaps);
 
+  if (s && gst_structure_n_fields (s) > 0) {
+    gst_structure_foreach (s, (GstStructureForeachFunc) _set_caps, srccaps);
+
+    GST_DEBUG_OBJECT (payload, "custom added: %" GST_PTR_FORMAT, srccaps);
+  }
+
+  gst_caps_replace (&payload->priv->subclass_srccaps, srccaps);
+  gst_caps_unref (srccaps);
+
+  return gst_rtp_base_payload_negotiate (payload);
+}
+
+/**
+ * gst_rtp_base_payload_set_outcaps:
+ * @payload: a #GstRTPBasePayload
+ * @fieldname: the first field name or %NULL
+ * @...: field values
+ *
+ * Configure the output caps with the optional parameters.
+ *
+ * Variable arguments should be in the form field name, field type
+ * (as a GType), value(s).  The last variable argument should be NULL.
+ *
+ * Returns: %TRUE if the caps could be set.
+ */
+gboolean
+gst_rtp_base_payload_set_outcaps (GstRTPBasePayload * payload,
+    const gchar * fieldname, ...)
+{
+  gboolean result;
+  GstStructure *s = NULL;
+
   if (fieldname) {
     va_list varargs;
 
+    s = gst_structure_new_empty ("unused");
+
     /* override with custom properties */
     va_start (varargs, fieldname);
-    gst_caps_set_simple_valist (srccaps, fieldname, varargs);
+    gst_structure_set_valist (s, fieldname, varargs);
     va_end (varargs);
-
-    GST_DEBUG_OBJECT (payload, "custom added: %" GST_PTR_FORMAT, srccaps);
   }
 
-  gst_caps_replace (&payload->priv->subclass_srccaps, srccaps);
-  gst_caps_unref (srccaps);
+  result = gst_rtp_base_payload_set_outcaps_structure (payload, s);
 
-  return gst_rtp_base_payload_negotiate (payload);
+  gst_clear_structure (&s);
+
+  return result;
+}
+
+static void
+add_and_ref_item (GstRTPHeaderExtension * ext, GPtrArray * ret)
+{
+  g_ptr_array_add (ret, gst_object_ref (ext));
+}
+
+static void
+remove_item_from (GstRTPHeaderExtension * ext, GPtrArray * ret)
+{
+  g_ptr_array_remove_fast (ret, ext);
+}
+
+static void
+add_item_to (GstRTPHeaderExtension * ext, GPtrArray * ret)
+{
+  g_ptr_array_add (ret, ext);
+}
+
+static void
+add_header_ext_to_caps (GstRTPHeaderExtension * ext, GstCaps * caps)
+{
+  if (!gst_rtp_header_extension_set_caps_from_attributes (ext, caps)) {
+    GST_WARNING ("Failed to set caps from rtp header extension");
+  }
 }
 
 static gboolean
@@ -898,7 +1070,7 @@ gst_rtp_base_payload_negotiate (GstRTPBasePayload * payload)
 {
   GstCaps *templ, *peercaps, *srccaps;
   GstStructure *s, *d;
-  gboolean res;
+  gboolean res = TRUE;
 
   payload->priv->caps_max_ptime = DEFAULT_MAX_PTIME;
   payload->ptime = 0;
@@ -1183,21 +1355,168 @@ gst_rtp_base_payload_negotiate (GstRTPBasePayload * payload)
 
   update_max_ptime (payload);
 
+  {
+    /* try to find header extension implementations for the list in the
+     * caps */
+    GstStructure *s = gst_caps_get_structure (srccaps, 0);
+    guint i, j, n_fields = gst_structure_n_fields (s);
+    GPtrArray *header_exts = g_ptr_array_new_with_free_func (gst_object_unref);
+    GPtrArray *to_add = g_ptr_array_new ();
+    GPtrArray *to_remove = g_ptr_array_new ();
+
+    GST_OBJECT_LOCK (payload);
+    g_ptr_array_foreach (payload->priv->header_exts,
+        (GFunc) add_and_ref_item, header_exts);
+    GST_OBJECT_UNLOCK (payload);
+
+    for (i = 0; i < n_fields; i++) {
+      const gchar *field_name = gst_structure_nth_field_name (s, i);
+      if (g_str_has_prefix (field_name, "extmap-")) {
+        const GValue *val;
+        const gchar *uri = NULL;
+        gchar *nptr;
+        guint ext_id;
+        GstRTPHeaderExtension *ext = NULL;
+
+        errno = 0;
+        ext_id = g_ascii_strtoull (&field_name[strlen ("extmap-")], &nptr, 10);
+        if (errno != 0 || (ext_id == 0 && field_name == nptr)) {
+          GST_WARNING_OBJECT (payload, "could not parse id from %s",
+              field_name);
+          res = FALSE;
+          goto ext_out;
+        }
 
-  if (enable_experimental_twcc && payload->priv->twcc_ext_id > 0) {
-    /* TODO: put this as a separate utility-function for RTP extensions */
-    gchar *name = g_strdup_printf ("extmap-%u", payload->priv->twcc_ext_id);
-    gst_caps_set_simple (srccaps, name, G_TYPE_STRING,
-        "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
-        NULL);
-    g_free (name);
+        val = gst_structure_get_value (s, field_name);
+        if (G_VALUE_HOLDS_STRING (val)) {
+          uri = g_value_get_string (val);
+        } else if (GST_VALUE_HOLDS_ARRAY (val)) {
+          /* the uri is the second value in the array */
+          const GValue *str = gst_value_array_get_value (val, 1);
+          if (G_VALUE_HOLDS_STRING (str)) {
+            uri = g_value_get_string (str);
+          }
+        }
+
+        if (!uri) {
+          GST_WARNING_OBJECT (payload, "could not get extmap uri for "
+              "field %s", field_name);
+          res = FALSE;
+          goto ext_out;
+        }
+
+        /* try to find if this extension mapping already exists */
+        for (j = 0; j < header_exts->len; j++) {
+          ext = g_ptr_array_index (header_exts, j);
+          if (gst_rtp_header_extension_get_id (ext) == ext_id) {
+            if (g_strcmp0 (uri, gst_rtp_header_extension_get_uri (ext)) == 0) {
+              /* still matching, we're good, set attributes from caps in case
+               * the caps have been updated */
+              if (!gst_rtp_header_extension_set_attributes_from_caps (ext,
+                      srccaps)) {
+                GST_WARNING_OBJECT (payload,
+                    "Failed to configure rtp header " "extension %"
+                    GST_PTR_FORMAT " attributes from caps %" GST_PTR_FORMAT,
+                    ext, srccaps);
+                res = FALSE;
+                goto ext_out;
+              }
+              break;
+            } else {
+              GST_DEBUG_OBJECT (payload, "extension id %u"
+                  "was replaced with a different extension uri "
+                  "original:\'%s' vs \'%s\'", ext_id,
+                  gst_rtp_header_extension_get_uri (ext), uri);
+              g_ptr_array_add (to_remove, ext);
+              ext = NULL;
+              break;
+            }
+          } else {
+            ext = NULL;
+          }
+        }
+
+        /* if no extension, attempt to request one */
+        if (!ext) {
+          GST_DEBUG_OBJECT (payload, "requesting extension for id %u"
+              " and uri %s", ext_id, uri);
+          g_signal_emit (payload,
+              gst_rtp_base_payload_signals[SIGNAL_REQUEST_EXTENSION], 0,
+              ext_id, uri, &ext);
+          GST_DEBUG_OBJECT (payload, "request returned extension %p \'%s\' "
+              "for id %u and uri %s", ext,
+              ext ? GST_OBJECT_NAME (ext) : "", ext_id, uri);
+
+          /* We require caller to set the appropriate extension if it's required */
+          if (ext && gst_rtp_header_extension_get_id (ext) != ext_id) {
+            g_warning ("\'request-extension\' signal provided an rtp header "
+                "extension for uri \'%s\' that does not match the requested "
+                "extension id %u", uri, ext_id);
+            gst_clear_object (&ext);
+          }
+
+          if (ext && !gst_rtp_header_extension_set_attributes_from_caps (ext,
+                  srccaps)) {
+            GST_WARNING_OBJECT (payload,
+                "Failed to configure rtp header " "extension %"
+                GST_PTR_FORMAT " attributes from caps %" GST_PTR_FORMAT,
+                ext, srccaps);
+            res = FALSE;
+            g_clear_object (&ext);
+            goto ext_out;
+          }
+
+          if (ext) {
+            g_ptr_array_add (to_add, ext);
+          }
+        }
+      }
+    }
+
+    GST_OBJECT_LOCK (payload);
+    g_ptr_array_foreach (to_remove, (GFunc) remove_item_from,
+        payload->priv->header_exts);
+    g_ptr_array_foreach (to_add, (GFunc) add_item_to,
+        payload->priv->header_exts);
+    /* let extensions update their internal state from sinkcaps */
+    if (payload->priv->sinkcaps) {
+      gint i;
+
+      for (i = 0; i < payload->priv->header_exts->len; i++) {
+        GstRTPHeaderExtension *ext;
+
+        ext = g_ptr_array_index (payload->priv->header_exts, i);
+        if (!gst_rtp_header_extension_set_non_rtp_sink_caps (ext,
+                payload->priv->sinkcaps)) {
+          GST_WARNING_OBJECT (payload,
+              "Failed to update rtp header extension (%s) from sink caps",
+              GST_OBJECT_NAME (ext));
+          res = FALSE;
+          GST_OBJECT_UNLOCK (payload);
+          goto ext_out;
+        }
+      }
+    }
+    /* add extension information to srccaps */
+    g_ptr_array_foreach (payload->priv->header_exts,
+        (GFunc) add_header_ext_to_caps, srccaps);
+    GST_OBJECT_UNLOCK (payload);
+
+  ext_out:
+    g_ptr_array_unref (to_add);
+    g_ptr_array_unref (to_remove);
+    g_ptr_array_unref (header_exts);
   }
 
-  res = gst_pad_set_caps (GST_RTP_BASE_PAYLOAD_SRCPAD (payload), srccaps);
+  GST_DEBUG_OBJECT (payload, "configuring caps %" GST_PTR_FORMAT, srccaps);
+
+  if (res)
+    res = gst_pad_set_caps (GST_RTP_BASE_PAYLOAD_SRCPAD (payload), srccaps);
   gst_caps_unref (srccaps);
   gst_caps_unref (templ);
 
 out:
+  payload->priv->negotiate_called = TRUE;
 
   if (!res)
     gst_pad_mark_reconfigure (GST_RTP_BASE_PAYLOAD_SRCPAD (payload));
@@ -1240,7 +1559,6 @@ typedef struct
   GstClockTime pts;
   guint64 offset;
   guint32 rtptime;
-  guint8 twcc_ext_id;
 } HeaderData;
 
 static gboolean
@@ -1260,30 +1578,213 @@ find_timestamp (GstBuffer ** buffer, guint idx, gpointer user_data)
 }
 
 static void
-_set_twcc_seq (GstRTPBuffer * rtp, guint16 seq, guint8 ext_id)
+gst_rtp_base_payload_add_extension (GstRTPBasePayload * payload,
+    GstRTPHeaderExtension * ext)
+{
+  g_return_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext));
+  g_return_if_fail (gst_rtp_header_extension_get_id (ext) > 0);
+
+  /* XXX: check for duplicate ids? */
+  GST_OBJECT_LOCK (payload);
+  g_ptr_array_add (payload->priv->header_exts, gst_object_ref (ext));
+  gst_pad_mark_reconfigure (GST_RTP_BASE_PAYLOAD_SRCPAD (payload));
+  GST_OBJECT_UNLOCK (payload);
+}
+
+static void
+gst_rtp_base_payload_clear_extensions (GstRTPBasePayload * payload)
 {
-  guint16 data;
-  if (ext_id == 0 || ext_id > 14)
+  GST_OBJECT_LOCK (payload);
+  g_ptr_array_set_size (payload->priv->header_exts, 0);
+  GST_OBJECT_UNLOCK (payload);
+}
+
+typedef struct
+{
+  GstRTPBasePayload *payload;
+  GstRTPHeaderExtensionFlags flags;
+  GstBuffer *output;
+  guint8 *data;
+  gsize allocated_size;
+  gsize written_size;
+  gsize hdr_unit_size;
+  gboolean abort;
+} HeaderExt;
+
+static void
+determine_header_extension_flags_size (GstRTPHeaderExtension * ext,
+    gpointer user_data)
+{
+  HeaderExt *hdr = user_data;
+  guint ext_id;
+  gsize max_size;
+
+  hdr->flags &= gst_rtp_header_extension_get_supported_flags (ext);
+  max_size =
+      gst_rtp_header_extension_get_max_size (ext,
+      hdr->payload->priv->input_meta_buffer);
+
+  if (max_size > RTP_HEADER_EXT_ONE_BYTE_MAX_SIZE)
+    hdr->flags &= ~GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+  if (max_size > RTP_HEADER_EXT_TWO_BYTE_MAX_SIZE)
+    hdr->flags &= ~GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+
+  ext_id = gst_rtp_header_extension_get_id (ext);
+  if (ext_id > RTP_HEADER_EXT_ONE_BYTE_MAX_ID)
+    hdr->flags &= ~GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+  if (ext_id > RTP_HEADER_EXT_TWO_BYTE_MAX_ID)
+    hdr->flags &= ~GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+
+  hdr->allocated_size += max_size;
+}
+
+static void
+write_header_extension (GstRTPHeaderExtension * ext, gpointer user_data)
+{
+  HeaderExt *hdr = user_data;
+  gsize remaining =
+      hdr->allocated_size - hdr->written_size - hdr->hdr_unit_size;
+  gsize offset = hdr->written_size + hdr->hdr_unit_size;
+  gssize written;
+  guint ext_id;
+
+  if (hdr->abort)
     return;
-  GST_WRITE_UINT16_BE (&data, seq);
-  gst_rtp_buffer_add_extension_onebyte_header (rtp, ext_id, &data, 2);
+
+  written = gst_rtp_header_extension_write (ext,
+      hdr->payload->priv->input_meta_buffer, hdr->flags, hdr->output,
+      &hdr->data[offset], remaining);
+
+  GST_TRACE_OBJECT (hdr->payload, "extension %" GST_PTR_FORMAT " wrote %"
+      G_GSIZE_FORMAT, ext, written);
+
+  if (written == 0) {
+    /* extension wrote no data */
+    return;
+  } else if (written < 0) {
+    GST_WARNING_OBJECT (hdr->payload, "%s failed to write extension data",
+        GST_OBJECT_NAME (ext));
+    goto error;
+  } else if (written > remaining) {
+    /* wrote too much! */
+    g_error ("Overflow detected writing rtp header extensions. One of the "
+        "instances likely did not report a large enough maximum size. "
+        "Memory corruption has occured. Aborting");
+    goto error;
+  }
+
+  ext_id = gst_rtp_header_extension_get_id (ext);
+
+  /* move to the beginning of the extension header */
+  offset -= hdr->hdr_unit_size;
+
+  /* write extension header */
+  if (hdr->flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+    if (written > RTP_HEADER_EXT_ONE_BYTE_MAX_SIZE) {
+      g_critical ("Amount of data written by %s is larger than allowed with "
+          "a one byte header.", GST_OBJECT_NAME (ext));
+      goto error;
+    }
+
+    hdr->data[offset] = ((ext_id & 0x0F) << 4) | ((written - 1) & 0x0F);
+  } else if (hdr->flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) {
+    if (written > RTP_HEADER_EXT_TWO_BYTE_MAX_SIZE) {
+      g_critical ("Amount of data written by %s is larger than allowed with "
+          "a two byte header.", GST_OBJECT_NAME (ext));
+      goto error;
+    }
+
+    hdr->data[offset] = ext_id & 0xFF;
+    hdr->data[offset + 1] = written & 0xFF;
+  } else {
+    g_critical ("Don't know how to write extension data with flags 0x%x!",
+        hdr->flags);
+    goto error;
+  }
+
+  hdr->written_size += written + hdr->hdr_unit_size;
+
+  return;
+
+error:
+  hdr->abort = TRUE;
+  return;
 }
 
 static gboolean
 set_headers (GstBuffer ** buffer, guint idx, gpointer user_data)
 {
   HeaderData *data = user_data;
+  HeaderExt hdrext = { NULL, };
   GstRTPBuffer rtp = { NULL, };
 
-  if (!gst_rtp_buffer_map (*buffer, GST_MAP_WRITE, &rtp))
+  if (!gst_rtp_buffer_map (*buffer, GST_MAP_READWRITE, &rtp))
     goto map_failed;
 
   gst_rtp_buffer_set_ssrc (&rtp, data->ssrc);
   gst_rtp_buffer_set_payload_type (&rtp, data->pt);
   gst_rtp_buffer_set_seq (&rtp, data->seqnum);
   gst_rtp_buffer_set_timestamp (&rtp, data->rtptime);
-  if (enable_experimental_twcc)
-    _set_twcc_seq (&rtp, data->seqnum, data->twcc_ext_id);
+
+  GST_OBJECT_LOCK (data->payload);
+  if (data->payload->priv->header_exts->len > 0
+      && data->payload->priv->input_meta_buffer) {
+    guint wordlen;
+    gsize extlen;
+    guint16 bit_pattern;
+
+    /* write header extensions */
+    hdrext.payload = data->payload;
+    hdrext.output = *buffer;
+    /* XXX: pre-calculate these flags and sizes? */
+    hdrext.flags =
+        GST_RTP_HEADER_EXTENSION_ONE_BYTE | GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+    g_ptr_array_foreach (data->payload->priv->header_exts,
+        (GFunc) determine_header_extension_flags_size, &hdrext);
+    hdrext.hdr_unit_size = 0;
+    if (hdrext.flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+      /* prefer the one byte header */
+      hdrext.hdr_unit_size = 1;
+      /* TODO: support mixed size writing modes, i.e. RFC8285 */
+      hdrext.flags &= ~GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+      bit_pattern = 0xBEDE;
+    } else if (hdrext.flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) {
+      hdrext.hdr_unit_size = 2;
+      bit_pattern = 0x1000;
+    } else {
+      goto unsupported_flags;
+    }
+
+    extlen =
+        hdrext.hdr_unit_size * data->payload->priv->header_exts->len +
+        hdrext.allocated_size;
+    wordlen = extlen / 4 + ((extlen % 4) ? 1 : 0);
+
+    /* XXX: do we need to add to any existing extension data instead of
+     * overwriting everything? */
+    gst_rtp_buffer_set_extension_data (&rtp, bit_pattern, wordlen);
+    gst_rtp_buffer_get_extension_data (&rtp, NULL, (gpointer) & hdrext.data,
+        &wordlen);
+
+    /* from 32-bit words to bytes */
+    hdrext.allocated_size = wordlen * 4;
+
+    g_ptr_array_foreach (data->payload->priv->header_exts,
+        (GFunc) write_header_extension, &hdrext);
+
+    if (hdrext.written_size > 0) {
+      wordlen = hdrext.written_size / 4 + ((hdrext.written_size % 4) ? 1 : 0);
+
+      /* zero-fill the hdrext padding bytes */
+      memset (&hdrext.data[hdrext.written_size], 0,
+          wordlen * 4 - hdrext.written_size);
+
+      gst_rtp_buffer_set_extension_data (&rtp, bit_pattern, wordlen);
+    } else {
+      gst_rtp_buffer_remove_extension_data (&rtp);
+    }
+  }
+  GST_OBJECT_UNLOCK (data->payload);
   gst_rtp_buffer_unmap (&rtp);
 
   /* increment the seqnum for each buffer */
@@ -1296,6 +1797,14 @@ map_failed:
     GST_ERROR ("failed to map buffer %p", *buffer);
     return FALSE;
   }
+
+unsupported_flags:
+  {
+    GST_OBJECT_UNLOCK (data->payload);
+    gst_rtp_buffer_unmap (&rtp);
+    GST_ERROR ("Cannot add rtp header extensions with mixed header types");
+    return FALSE;
+  }
 }
 
 static gboolean
@@ -1340,7 +1849,6 @@ gst_rtp_base_payload_prepare_push (GstRTPBasePayload * payload,
   data.seqnum = payload->seqnum;
   data.ssrc = payload->current_ssrc;
   data.pt = payload->pt;
-  data.twcc_ext_id = priv->twcc_ext_id;
 
   /* find the first buffer with a timestamp */
   if (is_list) {
@@ -1461,7 +1969,7 @@ no_rate:
 /**
  * gst_rtp_base_payload_push_list:
  * @payload: a #GstRTPBasePayload
- * @list: a #GstBufferList
+ * @list: (transfer full): a #GstBufferList
  *
  * Push @list to the peer element of the payloader. The SSRC, payload type,
  * seqnum and timestamp of the RTP buffer will be updated first.
@@ -1495,7 +2003,7 @@ gst_rtp_base_payload_push_list (GstRTPBasePayload * payload,
 /**
  * gst_rtp_base_payload_push:
  * @payload: a #GstRTPBasePayload
- * @buffer: a #GstBuffer
+ * @buffer: (transfer full): a #GstBuffer
  *
  * Push @buffer to the peer element of the payloader. The SSRC, payload type,
  * seqnum and timestamp of the RTP buffer will be updated first.
@@ -1658,12 +2166,12 @@ gst_rtp_base_payload_set_property (GObject * object, guint prop_id,
     case PROP_ONVIF_NO_RATE_CONTROL:
       priv->onvif_no_rate_control = g_value_get_boolean (value);
       break;
-    case PROP_TWCC_EXT_ID:
-      priv->twcc_ext_id = g_value_get_uint (value);
-      break;
     case PROP_SCALE_RTPTIME:
       priv->scale_rtptime = g_value_get_boolean (value);
       break;
+    case PROP_AUTO_HEADER_EXTENSION:
+      priv->auto_hdr_ext = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1734,12 +2242,12 @@ gst_rtp_base_payload_get_property (GObject * object, guint prop_id,
     case PROP_ONVIF_NO_RATE_CONTROL:
       g_value_set_boolean (value, priv->onvif_no_rate_control);
       break;
-    case PROP_TWCC_EXT_ID:
-      g_value_set_uint (value, priv->twcc_ext_id);
-      break;
     case PROP_SCALE_RTPTIME:
       g_value_set_boolean (value, priv->scale_rtptime);
       break;
+    case PROP_AUTO_HEADER_EXTENSION:
+      g_value_set_boolean (value, priv->auto_hdr_ext);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1786,6 +2294,7 @@ gst_rtp_base_payload_change_state (GstElement * element,
       g_atomic_int_set (&rtpbasepayload->priv->notified_first_timestamp, 1);
       priv->base_offset = GST_BUFFER_OFFSET_NONE;
       priv->negotiated = FALSE;
+      priv->negotiate_called = FALSE;
       gst_caps_replace (&rtpbasepayload->priv->subclass_srccaps, NULL);
       gst_caps_replace (&rtpbasepayload->priv->sinkcaps, NULL);
       break;
diff --git a/gst-libs/gst/rtp/gstrtpbasepayload.h b/gst-libs/gst/rtp/gstrtpbasepayload.h
index 8cc78528d8..00bf99e196 100644
--- a/gst-libs/gst/rtp/gstrtpbasepayload.h
+++ b/gst-libs/gst/rtp/gstrtpbasepayload.h
@@ -160,6 +160,10 @@ GST_RTP_API
 gboolean        gst_rtp_base_payload_set_outcaps        (GstRTPBasePayload *payload,
                                                          const gchar *fieldname, ...);
 
+GST_RTP_API
+gboolean        gst_rtp_base_payload_set_outcaps_structure (GstRTPBasePayload *payload,
+                                                            GstStructure *s);
+
 GST_RTP_API
 gboolean        gst_rtp_base_payload_is_filled          (GstRTPBasePayload *payload,
                                                          guint size, GstClockTime duration);
diff --git a/gst-libs/gst/rtp/gstrtpbuffer.c b/gst-libs/gst/rtp/gstrtpbuffer.c
index ae519f313c..ec4b53bd7b 100644
--- a/gst-libs/gst/rtp/gstrtpbuffer.c
+++ b/gst-libs/gst/rtp/gstrtpbuffer.c
@@ -158,7 +158,7 @@ gst_rtp_buffer_allocate_data (GstBuffer * buffer, guint payload_len,
  * respectively. @data will be freed when the buffer is unreffed, so this
  * function transfers ownership of @data to the new buffer.
  *
- * Returns: A newly allocated buffer with @data and of size @len.
+ * Returns: (transfer full): A newly allocated buffer with @data and of size @len.
  */
 GstBuffer *
 gst_rtp_buffer_new_take_data (gpointer data, gsize len)
@@ -179,12 +179,12 @@ gst_rtp_buffer_new_take_data (gpointer data, gsize len)
  * bytes of @data and the size to @len. The data will be freed when the buffer
  * is freed.
  *
- * Returns: A newly allocated buffer with a copy of @data and of size @len.
+ * Returns: (transfer full): A newly allocated buffer with a copy of @data and of size @len.
  */
 GstBuffer *
 gst_rtp_buffer_new_copy_data (gconstpointer data, gsize len)
 {
-  return gst_rtp_buffer_new_take_data (g_memdup (data, len), len);
+  return gst_rtp_buffer_new_take_data (g_memdup2 (data, len), len);
 }
 
 /**
@@ -197,7 +197,7 @@ gst_rtp_buffer_new_copy_data (gconstpointer data, gsize len)
  * @csrc_count CSRCs, a payload length of @payload_len and padding of @pad_len.
  * All other RTP header fields will be set to 0/FALSE.
  *
- * Returns: A newly allocated buffer that can hold an RTP packet with given
+ * Returns: (transfer full): A newly allocated buffer that can hold an RTP packet with given
  * parameters.
  */
 GstBuffer *
@@ -225,7 +225,7 @@ gst_rtp_buffer_new_allocate (guint payload_len, guint8 pad_len,
  * @csrc_count and can be calculated with gst_rtp_buffer_calc_payload_len().
  * All RTP header fields will be set to 0/FALSE.
  *
- * Returns: A newly allocated buffer that can hold an RTP packet of @packet_len.
+ * Returns: (transfer full): A newly allocated buffer that can hold an RTP packet of @packet_len.
  */
 GstBuffer *
 gst_rtp_buffer_new_allocate_len (guint packet_len, guint8 pad_len,
@@ -684,9 +684,9 @@ gst_rtp_buffer_set_extension (GstRTPBuffer * rtp, gboolean extension)
 /**
  * gst_rtp_buffer_get_extension_data: (skip)
  * @rtp: the RTP packet
- * @bits: (out): location for result bits
- * @data: (out) (array) (element-type guint8) (transfer none): location for data
- * @wordlen: (out): location for length of @data in 32 bits words
+ * @bits: (optional) (out): location for result bits
+ * @data: (optional) (out) (array) (element-type guint8) (transfer none): location for data
+ * @wordlen: (optional) (out): location for length of @data in 32 bits words
  *
  * Get the extension data. @bits will contain the extension 16 bits of custom
  * data. @data will point to the data in the extension and @wordlen will contain
@@ -733,7 +733,7 @@ gst_rtp_buffer_get_extension_data (GstRTPBuffer * rtp, guint16 * bits,
  * @bits unchanged. If there is an extension header but no extension data then
  * an empty #GBytes will be returned.
  *
- * Returns: (transfer full): A new #GBytes if an extension header was present
+ * Returns: (transfer full) (nullable): A new #GBytes if an extension header was present
  * and %NULL otherwise.
  *
  * Since: 1.2
@@ -833,6 +833,8 @@ ensure_buffers (GstRTPBuffer * rtp)
  * extension header. If the existing extension data is not large enough, it will
  * be made larger.
  *
+ * Will also shorten the extension data from 1.20.
+ *
  * Returns: True if done.
  */
 gboolean
@@ -856,15 +858,23 @@ gst_rtp_buffer_set_extension_data (GstRTPBuffer * rtp, guint16 bits,
     mem = gst_allocator_alloc (NULL, min_size, NULL);
 
     if (rtp->data[1]) {
-      /* copy old data */
+      /* copy old data & initialize the remainder of the new buffer */
       gst_memory_map (mem, &map, GST_MAP_WRITE);
       memcpy (map.data, rtp->data[1], rtp->size[1]);
+      if (min_size > rtp->size[1]) {
+        memset (map.data + rtp->size[1], 0, min_size - rtp->size[1]);
+      }
       gst_memory_unmap (mem, &map);
 
       /* unmap old */
       gst_buffer_unmap (rtp->buffer, &rtp->map[1]);
       gst_buffer_replace_memory (rtp->buffer, 1, mem);
     } else {
+      /* don't leak data from uninitialized memory via the padding */
+      gst_memory_map (mem, &map, GST_MAP_WRITE);
+      memset (map.data, 0, map.size);
+      gst_memory_unmap (mem, &map);
+
       /* we didn't have extension data, add */
       gst_buffer_insert_memory (rtp->buffer, 1, mem);
     }
@@ -874,6 +884,15 @@ gst_rtp_buffer_set_extension_data (GstRTPBuffer * rtp, guint16 bits,
     gst_memory_ref (mem);
     rtp->data[1] = rtp->map[1].data;
     rtp->size[1] = rtp->map[1].size;
+  } else if (min_size < rtp->size[1]) {
+    GstMemory *mem = rtp->map[1].memory;
+
+    gst_memory_ref (mem);
+    gst_buffer_unmap (rtp->buffer, &rtp->map[1]);
+    gst_memory_resize (mem, 0, min_size);
+    gst_memory_map (mem, &rtp->map[1], GST_MAP_READWRITE);
+    rtp->data[1] = rtp->map[1].data;
+    rtp->size[1] = rtp->map[1].size;
   }
 
   /* now we can set the extension bit */
@@ -887,6 +906,37 @@ gst_rtp_buffer_set_extension_data (GstRTPBuffer * rtp, guint16 bits,
   return TRUE;
 }
 
+/**
+ * gst_rtp_buffer_remove_extension_data:
+ * @rtp: the RTP packet
+ *
+ * Unsets the extension bit of the RTP buffer and removes the extension header
+ * and data.
+ *
+ * If the RTP buffer has no header extension data, the action has no effect.
+ * The RTP buffer must be mapped READWRITE only once and the underlying
+ * GstBuffer must be writable.
+ *
+ * Since: 1.20
+ */
+void
+gst_rtp_buffer_remove_extension_data (GstRTPBuffer * rtp)
+{
+  g_return_if_fail (gst_buffer_is_writable (rtp->buffer));
+  g_return_if_fail (rtp->map[0].flags & GST_MAP_WRITE);
+
+  if (rtp->data[1] != NULL) {
+    GstBuffer *buf = rtp->buffer;
+
+    ensure_buffers (rtp);
+
+    GST_RTP_HEADER_EXTENSION (rtp->data[0]) = FALSE;
+    gst_rtp_buffer_unmap (rtp);
+    gst_buffer_remove_memory (buf, 1);
+    gst_rtp_buffer_map (buf, GST_MAP_READWRITE, rtp);
+  }
+}
+
 /**
  * gst_rtp_buffer_get_ssrc:
  * @rtp: the RTP packet
@@ -1090,7 +1140,7 @@ gst_rtp_buffer_set_timestamp (GstRTPBuffer * rtp, guint32 timestamp)
  * are skipped in the payload and the subbuffer will be of size @len.
  * If @len is -1 the total payload starting from @offset is subbuffered.
  *
- * Returns: A new buffer with the specified data of the payload.
+ * Returns: (transfer full): A new buffer with the specified data of the payload.
  */
 GstBuffer *
 gst_rtp_buffer_get_payload_subbuffer (GstRTPBuffer * rtp, guint offset,
@@ -1130,7 +1180,7 @@ wrong_offset:
  * will internally create a subbuffer of @buffer so that a memcpy can be
  * avoided.
  *
- * Returns: A new buffer with the data of the payload.
+ * Returns: (transfer full): A new buffer with the data of the payload.
  */
 GstBuffer *
 gst_rtp_buffer_get_payload_buffer (GstRTPBuffer * rtp)
@@ -1160,7 +1210,7 @@ gst_rtp_buffer_get_payload_len (GstRTPBuffer * rtp)
  * Get a pointer to the payload data in @buffer. This pointer is valid as long
  * as a reference to @buffer is held.
  *
- * Returns: (array) (element-type guint8) (transfer none): A pointer
+ * Returns: (array) (element-type guint8) (transfer none) (nullable): A pointer
  * to the payload data in @buffer.
  */
 gpointer
@@ -1183,7 +1233,7 @@ gst_rtp_buffer_get_payload (GstRTPBuffer * rtp)
  * bindings usage. The return value is a pointer to a #GBytes structure
  * containing the payload data in @rtp.
  *
- * Returns: (transfer full): A new #GBytes containing the payload data in @rtp.
+ * Returns: (transfer full) (nullable): A new #GBytes containing the payload data in @rtp.
  *
  * Since: 1.2
  */
@@ -1276,7 +1326,7 @@ gst_rtp_buffer_ext_timestamp (guint64 * exttimestamp, guint32 timestamp)
   ext = *exttimestamp;
 
   if (ext == -1) {
-    result = timestamp;
+    result = (G_GUINT64_CONSTANT (1) << 32) + timestamp;
   } else {
     /* pick wraparound counter from previous timestamp and add to new timestamp */
     result = timestamp + (ext & ~(G_GUINT64_CONSTANT (0xffffffff)));
@@ -1407,9 +1457,9 @@ gst_rtp_buffer_get_extension_onebyte_header_from_bytes (GBytes * bytes,
  * @rtp: the RTP packet
  * @id: The ID of the header extension to be read (between 1 and 14).
  * @nth: Read the nth extension packet with the requested ID
- * @data: (out) (array length=size) (element-type guint8) (transfer none):
+ * @data: (optional) (out) (array length=size) (element-type guint8) (transfer none):
  *   location for data
- * @size: (out): the size of the data in bytes
+ * @size: (optional) (out): the size of the data in bytes
  *
  * Parses RFC 5285 style header extensions with a one byte header. It will
  * return the nth extension with the requested id.
@@ -1437,12 +1487,12 @@ gst_rtp_buffer_get_extension_onebyte_header (GstRTPBuffer * rtp, guint8 id,
 /**
  * gst_rtp_buffer_get_extension_twobytes_header:
  * @rtp: the RTP packet
- * @appbits: (out): Application specific bits
+ * @appbits: (optional) (out): Application specific bits
  * @id: The ID of the header extension to be read (between 1 and 14).
  * @nth: Read the nth extension packet with the requested ID
- * @data: (out) (array length=size) (element-type guint8) (transfer none):
+ * @data: (optional) (out) (array length=size) (element-type guint8) (transfer none):
  *   location for data
- * @size: (out): the size of the data in bytes
+ * @size: (optional) (out): the size of the data in bytes
  *
  * Parses RFC 5285 style header extensions with a two bytes header. It will
  * return the nth extension with the requested id.
diff --git a/gst-libs/gst/rtp/gstrtpbuffer.h b/gst-libs/gst/rtp/gstrtpbuffer.h
index ae3af14389..cac8998c2b 100644
--- a/gst-libs/gst/rtp/gstrtpbuffer.h
+++ b/gst-libs/gst/rtp/gstrtpbuffer.h
@@ -135,6 +135,9 @@ GBytes*         gst_rtp_buffer_get_extension_bytes   (GstRTPBuffer *rtp, guint16
 GST_RTP_API
 gboolean        gst_rtp_buffer_set_extension_data    (GstRTPBuffer *rtp, guint16 bits, guint16 length);
 
+GST_RTP_API
+void            gst_rtp_buffer_remove_extension_data (GstRTPBuffer *rtp);
+
 GST_RTP_API
 guint32         gst_rtp_buffer_get_ssrc              (GstRTPBuffer *rtp);
 
diff --git a/gst-libs/gst/rtp/gstrtphdrext.c b/gst-libs/gst/rtp/gstrtphdrext.c
index f653f2f3df..fd683c5c6d 100644
--- a/gst-libs/gst/rtp/gstrtphdrext.c
+++ b/gst-libs/gst/rtp/gstrtphdrext.c
@@ -1,5 +1,6 @@
 /* GStreamer
  * Copyright (C) <2012> Wim Taymans <wim.taymans@gmail.com>
+ * Copyright (C) <2020> Matthew Waters <matthew@centricular.com>
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Library General Public
@@ -33,6 +34,26 @@
 #include <stdlib.h>
 #include <string.h>
 
+static gboolean
+gst_rtp_header_extension_set_caps_from_attributes_default (GstRTPHeaderExtension
+    * ext, GstCaps * caps);
+
+GST_DEBUG_CATEGORY_STATIC (rtphderext_debug);
+#define GST_CAT_DEFAULT (rtphderext_debug)
+
+#define MAX_RTP_EXT_ID 256
+
+#define GST_RTP_HEADER_EXTENSION_DIRECTION_DEFAULT      \
+  (GST_RTP_HEADER_EXTENSION_DIRECTION_SENDRECV |        \
+      GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED)
+
+typedef struct
+{
+  guint ext_id;
+  gboolean wants_update_non_rtp_src_caps;
+  GstRTPHeaderExtensionDirection direction;
+} GstRTPHeaderExtensionPrivate;
+
 /**
  * gst_rtp_hdrext_set_ntp_64:
  * @data: the data to write to
@@ -135,3 +156,761 @@ gst_rtp_hdrext_get_ntp_56 (gpointer data, guint size, guint64 * ntptime)
   }
   return TRUE;
 }
+
+#define gst_rtp_header_extension_parent_class parent_class
+G_DEFINE_TYPE_EXTENDED (GstRTPHeaderExtension, gst_rtp_header_extension,
+    GST_TYPE_ELEMENT, G_TYPE_FLAG_ABSTRACT,
+    G_ADD_PRIVATE (GstRTPHeaderExtension)
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "rtphdrext", 0,
+        "RTP Header Extensions")
+    );
+
+/**
+ * gst_rtp_header_extension_class_set_uri:
+ * @klass: the #GstRTPHeaderExtensionClass
+ * @uri: the RTP Header extension uri for @klass
+ *
+ * Set the URI for this RTP header extension implementation.
+ *
+ * Since: 1.20
+ */
+void
+gst_rtp_header_extension_class_set_uri (GstRTPHeaderExtensionClass * klass,
+    const gchar * uri)
+{
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+
+  gst_element_class_add_metadata (element_class,
+      GST_RTP_HEADER_EXTENSION_URI_METADATA_KEY, uri);
+}
+
+static void
+gst_rtp_header_extension_class_init (GstRTPHeaderExtensionClass * klass)
+{
+  klass->set_caps_from_attributes =
+      gst_rtp_header_extension_set_caps_from_attributes_default;
+}
+
+static void
+gst_rtp_header_extension_init (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  priv->ext_id = G_MAXUINT32;
+  priv->direction = GST_RTP_HEADER_EXTENSION_DIRECTION_DEFAULT;
+}
+
+/**
+ * gst_rtp_header_extension_get_uri:
+ * @ext: a #GstRTPHeaderExtension
+ *
+ * Returns: (nullable): the RTP extension URI for this object
+ *
+ * Since: 1.20
+ */
+const gchar *
+gst_rtp_header_extension_get_uri (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionClass *klass;
+  GstElementClass *element_class;
+
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), NULL);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+  element_class = GST_ELEMENT_CLASS (klass);
+
+  return gst_element_class_get_metadata (element_class,
+      GST_RTP_HEADER_EXTENSION_URI_METADATA_KEY);
+}
+
+/**
+ * gst_rtp_header_extension_get_supported_flags:
+ * @ext: a #GstRTPHeaderExtension
+ *
+ * Returns: the flags supported by this instance of @ext
+ *
+ * Since: 1.20
+ */
+GstRTPHeaderExtensionFlags
+gst_rtp_header_extension_get_supported_flags (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionClass *klass;
+
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), 0);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+  g_return_val_if_fail (klass->get_supported_flags != NULL, 0);
+
+  return klass->get_supported_flags (ext);
+}
+
+/**
+ * gst_rtp_header_extension_get_max_size:
+ * @ext: a #GstRTPHeaderExtension
+ * @input_meta: a #GstBuffer
+ *
+ * This is used to know how much data a certain header extension will need for
+ * both allocating the resulting data, and deciding how much payload data can
+ * be generated.
+ *
+ * Implementations should return as accurate a value as is possible using the
+ * information given in the input @buffer.
+ *
+ * Returns: the maximum size of the data written by this extension
+ *
+ * Since: 1.20
+ */
+gsize
+gst_rtp_header_extension_get_max_size (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta)
+{
+  GstRTPHeaderExtensionClass *klass;
+
+  g_return_val_if_fail (GST_IS_BUFFER (input_meta), 0);
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), 0);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+  g_return_val_if_fail (klass->get_max_size != NULL, 0);
+
+  return klass->get_max_size (ext, input_meta);
+}
+
+/**
+ * gst_rtp_header_extension_write:
+ * @ext: a #GstRTPHeaderExtension
+ * @input_meta: the input #GstBuffer to read information from if necessary
+ * @write_flags: #GstRTPHeaderExtensionFlags for how the extension should
+ *               be written
+ * @output: output RTP #GstBuffer
+ * @data: (array length=size): location to write the rtp header extension into
+ * @size: size of @data
+ *
+ * Writes the RTP header extension to @data using information available from
+ * the @input_meta.  @data will be sized to be at least the value returned
+ * from gst_rtp_header_extension_get_max_size().
+ *
+ * Returns: the size of the data written, < 0 on failure
+ *
+ * Since: 1.20
+ */
+gssize
+gst_rtp_header_extension_write (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+  GstRTPHeaderExtensionClass *klass;
+
+  g_return_val_if_fail (GST_IS_BUFFER (input_meta), -1);
+  g_return_val_if_fail (GST_IS_BUFFER (output), -1);
+  g_return_val_if_fail (gst_buffer_is_writable (output), -1);
+  g_return_val_if_fail (data != NULL, -1);
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), -1);
+  g_return_val_if_fail (priv->ext_id <= MAX_RTP_EXT_ID, -1);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+  g_return_val_if_fail (klass->write != NULL, -1);
+
+  return klass->write (ext, input_meta, write_flags, output, data, size);
+}
+
+/**
+ * gst_rtp_header_extension_read:
+ * @ext: a #GstRTPHeaderExtension
+ * @read_flags: #GstRTPHeaderExtensionFlags for how the extension should
+ *               be written
+ * @data: (array length=size): location to read the rtp header extension from
+ * @size: size of @data
+ * @buffer: a #GstBuffer to modify if necessary
+ *
+ * Read the RTP header extension from @data.
+ *
+ * Returns: whether the extension could be read from @data
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_rtp_header_extension_read (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionFlags read_flags, const guint8 * data, gsize size,
+    GstBuffer * buffer)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+  GstRTPHeaderExtensionClass *klass;
+
+  g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
+  g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
+  g_return_val_if_fail (data != NULL, FALSE);
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), FALSE);
+  g_return_val_if_fail (priv->ext_id <= MAX_RTP_EXT_ID, FALSE);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+  g_return_val_if_fail (klass->read != NULL, FALSE);
+
+  return klass->read (ext, read_flags, data, size, buffer);
+}
+
+/**
+ * gst_rtp_header_extension_get_id:
+ * @ext: a #GstRTPHeaderExtension
+ *
+ * Returns: the RTP extension id configured on @ext
+ *
+ * Since: 1.20
+ */
+guint
+gst_rtp_header_extension_get_id (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), 0);
+
+  return priv->ext_id;
+}
+
+/**
+ * gst_rtp_header_extension_set_id:
+ * @ext: a #GstRTPHeaderExtension
+ * @ext_id: The id of this extension
+ *
+ * sets the RTP extension id on @ext
+ *
+ * Since: 1.20
+ */
+void
+gst_rtp_header_extension_set_id (GstRTPHeaderExtension * ext, guint ext_id)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  g_return_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext));
+  g_return_if_fail (ext_id < MAX_RTP_EXT_ID);
+
+  priv->ext_id = ext_id;
+}
+
+static int
+strcasecmp0 (const gchar * str1, const gchar * str2)
+{
+  if (!str1)
+    return -(str1 != str2);
+  if (!str2)
+    return str1 != str2;
+
+  return g_ascii_strcasecmp (str1, str2);
+}
+
+/**
+ * gst_rtp_header_extension_set_attributes_from_caps:
+ * @ext: a #GstRTPHeaderExtension
+ * @caps: the #GstCaps to configure this extension with
+ *
+ * gst_rtp_header_extension_set_id() must have been called with a valid
+ * extension id that is contained in these caps.
+ *
+ * The only current known caps format is based on the SDP standard as produced
+ * by gst_sdp_media_attributes_to_caps().
+ *
+ * Returns: whether the @caps could be successfully set on @ext.
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_rtp_header_extension_set_attributes_from_caps (GstRTPHeaderExtension * ext,
+    const GstCaps * caps)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+  GstRTPHeaderExtensionClass *klass;
+  GstStructure *structure;
+  gchar *field_name;
+  const GValue *val;
+  GstRTPHeaderExtensionDirection direction =
+      GST_RTP_HEADER_EXTENSION_DIRECTION_DEFAULT;
+  const gchar *attributes = "";
+  gboolean ret = FALSE;
+
+  g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
+  g_return_val_if_fail (gst_caps_is_fixed (caps), FALSE);
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), FALSE);
+  g_return_val_if_fail (priv->ext_id <= MAX_RTP_EXT_ID, FALSE);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+
+  structure = gst_caps_get_structure (caps, 0);
+  g_return_val_if_fail (structure != NULL, FALSE);
+  field_name = g_strdup_printf ("extmap-%u", priv->ext_id);
+  g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
+
+  val = gst_structure_get_value (structure, field_name);
+
+  if (G_VALUE_HOLDS_STRING (val)) {
+    const gchar *ext_uri = g_value_get_string (val);
+
+    if (strcasecmp0 (ext_uri, gst_rtp_header_extension_get_uri (ext)) != 0) {
+      /* incompatible extension uri for this instance */
+      GST_WARNING_OBJECT (ext, "Field %s, URI doesn't match RTP Header"
+          " extension:  \"%s\", expected \"%s\"", field_name, ext_uri,
+          gst_rtp_header_extension_get_uri (ext));
+      goto done;
+    }
+  } else if (GST_VALUE_HOLDS_ARRAY (val)
+      && gst_value_array_get_size (val) == 3) {
+    const GValue *inner_val;
+
+    inner_val = gst_value_array_get_value (val, 0);
+    if (G_VALUE_HOLDS_STRING (inner_val)) {
+      const gchar *dir = g_value_get_string (inner_val);
+
+      if (!strcasecmp0 (dir, ""))
+        direction = GST_RTP_HEADER_EXTENSION_DIRECTION_DEFAULT;
+      else if (!strcasecmp0 (dir, "sendrecv"))
+        direction = GST_RTP_HEADER_EXTENSION_DIRECTION_SENDRECV;
+      else if (!strcasecmp0 (dir, "sendonly"))
+        direction = GST_RTP_HEADER_EXTENSION_DIRECTION_SENDONLY;
+      else if (!strcasecmp0 (dir, "recvonly"))
+        direction = GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY;
+      else if (!strcasecmp0 (dir, "inactive"))
+        direction = GST_RTP_HEADER_EXTENSION_DIRECTION_INACTIVE;
+      else {
+        GST_WARNING_OBJECT (ext, "Unexpected direction \"%s\", expected one"
+            " of: sendrecv, sendonly, recvonly or inactive", dir);
+        goto done;
+      }
+    } else {
+      GST_WARNING_OBJECT (ext, "Caps should hold an array of 3 strings, "
+          "but first member is %s instead", G_VALUE_TYPE_NAME (inner_val));
+      goto done;
+    }
+
+    inner_val = gst_value_array_get_value (val, 1);
+    if (!G_VALUE_HOLDS_STRING (inner_val)) {
+      GST_WARNING_OBJECT (ext, "Caps should hold an array of 3 strings, "
+          "but second member is %s instead", G_VALUE_TYPE_NAME (inner_val));
+
+      goto done;
+    }
+    if (strcasecmp0 (g_value_get_string (inner_val),
+            gst_rtp_header_extension_get_uri (ext)) != 0) {
+      GST_WARNING_OBJECT (ext, "URI doesn't match RTP Header extension:"
+          " \"%s\", expected \"%s\"", g_value_get_string (inner_val),
+          gst_rtp_header_extension_get_uri (ext));
+      goto done;
+    }
+
+    inner_val = gst_value_array_get_value (val, 2);
+    if (!G_VALUE_HOLDS_STRING (inner_val)) {
+      GST_WARNING_OBJECT (ext, "Caps should hold an array of 3 strings, "
+          "but third member is %s instead", G_VALUE_TYPE_NAME (inner_val));
+      goto done;
+    }
+
+    attributes = g_value_get_string (inner_val);
+  } else {
+    GST_WARNING_OBJECT (ext, "Caps field %s should be either a string"
+        " containing the URI or an array of 3 strings containing the"
+        " direction, URI and attributes, but contains %s", field_name,
+        G_VALUE_TYPE_NAME (val));
+    goto done;
+  }
+
+  /* If the caps don't include directions, use the ones that were
+   * previously set by the application.
+   */
+  if (direction == GST_RTP_HEADER_EXTENSION_DIRECTION_DEFAULT &&
+      priv->direction & GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED)
+    direction = priv->direction;
+
+  if (klass->set_attributes)
+    ret = klass->set_attributes (ext, direction, attributes);
+  else
+    ret = TRUE;
+
+  if (ret)
+    priv->direction = direction;
+
+done:
+
+  g_free (field_name);
+  return ret;
+}
+
+/**
+ * gst_rtp_header_extension_wants_update_non_rtp_src_caps:
+ * @ext: a #GstRTPHeaderExtension
+ *
+ * Call this function after gst_rtp_header_extension_read() to check if
+ * the depayloader's src caps need updating with data received in the last RTP
+ * packet.
+ *
+ * Returns: Whether @ext wants to update depayloader's src caps.
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_rtp_header_extension_wants_update_non_rtp_src_caps (GstRTPHeaderExtension *
+    ext)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), FALSE);
+
+  return priv->wants_update_non_rtp_src_caps;
+}
+
+/**
+ * gst_rtp_header_extension_set_wants_update_non_rtp_src_caps:
+ * @ext: a #GstRTPHeaderExtension
+ * @state: TRUE if caps update is needed
+ *
+ * Call this function in a subclass from #GstRTPHeaderExtensionClass::read to
+ * tell the depayloader whether the data just parsed from RTP packet require
+ * updating its src (non-RTP) caps. If @state is TRUE, #GstRTPBaseDepayload will
+ * eventually invoke gst_rtp_header_extension_update_non_rtp_src_caps() to
+ * have the caps update applied. Applying the update also flips the internal
+ * "wants update" flag back to FALSE.
+ *
+ * Since: 1.20
+ */
+void gst_rtp_header_extension_set_wants_update_non_rtp_src_caps
+    (GstRTPHeaderExtension * ext, gboolean state)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  g_return_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext));
+
+  priv->wants_update_non_rtp_src_caps = state;
+}
+
+/**
+ * gst_rtp_header_extension_set_non_rtp_sink_caps:
+ * @ext: a #GstRTPHeaderExtension
+ * @caps: sink #GstCaps
+ *
+ * Passes RTP payloader's sink (i.e. not payloaded) @caps to the header
+ * extension.
+ *
+ * Returns: Whether @caps could be read successfully
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_rtp_header_extension_set_non_rtp_sink_caps (GstRTPHeaderExtension * ext,
+    const GstCaps * caps)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+  GstRTPHeaderExtensionClass *klass;
+
+  g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), FALSE);
+  g_return_val_if_fail (priv->ext_id <= MAX_RTP_EXT_ID, FALSE);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+
+  if (klass->set_non_rtp_sink_caps) {
+    return klass->set_non_rtp_sink_caps (ext, caps);
+  }
+
+  return TRUE;
+}
+
+/**
+ * gst_rtp_header_extension_update_non_rtp_src_caps:
+ * @ext: a #GstRTPHeaderExtension
+ * @caps: src #GstCaps to modify
+ *
+ * Updates depayloader src caps based on the information received in RTP header.
+ * @caps must be writable as this function may modify them.
+ *
+ * Returns: whether @caps were modified successfully
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_rtp_header_extension_update_non_rtp_src_caps (GstRTPHeaderExtension * ext,
+    GstCaps * caps)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+  GstRTPHeaderExtensionClass *klass;
+
+  g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
+  g_return_val_if_fail (gst_caps_is_writable (caps), FALSE);
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), FALSE);
+  g_return_val_if_fail (priv->ext_id <= MAX_RTP_EXT_ID, FALSE);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+
+  priv->wants_update_non_rtp_src_caps = FALSE;
+
+  if (klass->update_non_rtp_src_caps) {
+    return klass->update_non_rtp_src_caps (ext, caps);
+  }
+
+  return TRUE;
+}
+
+/**
+ * gst_rtp_header_extension_set_caps_from_attributes:
+ * @ext: a #GstRTPHeaderExtension
+ * @caps: writable #GstCaps to modify
+ *
+ * gst_rtp_header_extension_set_id() must have been called with a valid
+ * extension id that is contained in these caps.
+ *
+ * The only current known caps format is based on the SDP standard as produced
+ * by gst_sdp_media_attributes_to_caps().
+ *
+ * Returns: whether the configured attributes on @ext can successfully be set on
+ * 	@caps
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_rtp_header_extension_set_caps_from_attributes (GstRTPHeaderExtension * ext,
+    GstCaps * caps)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+  GstRTPHeaderExtensionClass *klass;
+
+  g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
+  g_return_val_if_fail (gst_caps_is_writable (caps), FALSE);
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), FALSE);
+  g_return_val_if_fail (priv->ext_id <= MAX_RTP_EXT_ID, FALSE);
+  klass = GST_RTP_HEADER_EXTENSION_GET_CLASS (ext);
+  g_return_val_if_fail (klass->set_caps_from_attributes != NULL, FALSE);
+
+  return klass->set_caps_from_attributes (ext, caps);
+}
+
+/**
+ * gst_rtp_header_extension_get_sdp_caps_field_name:
+ * @ext: the #GstRTPHeaderExtension
+ *
+ * Returns: (transfer full): the #GstStructure field name used in SDP-like #GstCaps for this @ext configuration
+ *
+ * Since: 1.20
+ */
+gchar *
+gst_rtp_header_extension_get_sdp_caps_field_name (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext), NULL);
+  g_return_val_if_fail (priv->ext_id <= MAX_RTP_EXT_ID, NULL);
+
+  return g_strdup_printf ("extmap-%u", priv->ext_id);
+}
+
+/**
+ * gst_rtp_header_extension_set_caps_from_attributes_helper:
+ * @ext: the #GstRTPHeaderExtension
+ * @caps: #GstCaps to write fields into
+ *
+ * Helper implementation for GstRTPExtensionClass::set_caps_from_attributes
+ * that sets the @ext uri on caps with the specified extension id as required
+ * for sdp #GstCaps.
+ *
+ * Requires that the extension does not have any attributes or direction
+ * advertised in @caps.
+ *
+ * Returns: whether the @ext attributes could be set on @caps.
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_rtp_header_extension_set_caps_from_attributes_helper (GstRTPHeaderExtension
+    * ext, GstCaps * caps, const gchar * attributes)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+  gchar *field_name = gst_rtp_header_extension_get_sdp_caps_field_name (ext);
+  GstStructure *s = gst_caps_get_structure (caps, 0);
+
+  if (priv->direction & GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED &&
+      (attributes == NULL || attributes[0] == 0)) {
+    gst_structure_set (s, field_name, G_TYPE_STRING,
+        gst_rtp_header_extension_get_uri (ext), NULL);
+  } else {
+    GValue arr = G_VALUE_INIT;
+    GValue val = G_VALUE_INIT;
+
+    g_value_init (&arr, GST_TYPE_ARRAY);
+    g_value_init (&val, G_TYPE_STRING);
+
+    if (priv->direction & GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED) {
+      g_value_set_string (&val, "");
+    } else {
+      if ((priv->direction & GST_RTP_HEADER_EXTENSION_DIRECTION_SENDRECV) ==
+          GST_RTP_HEADER_EXTENSION_DIRECTION_SENDRECV)
+        g_value_set_string (&val, "sendrecv");
+      else if (priv->direction & GST_RTP_HEADER_EXTENSION_DIRECTION_SENDONLY)
+        g_value_set_string (&val, "sendonly");
+      else if (priv->direction & GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY)
+        g_value_set_string (&val, "recvonly");
+      else
+        g_value_set_string (&val, "inactive");
+    }
+    gst_value_array_append_value (&arr, &val);
+
+    /* uri */
+    g_value_set_string (&val, gst_rtp_header_extension_get_uri (ext));
+    gst_value_array_append_value (&arr, &val);
+
+    /* attributes */
+    g_value_set_string (&val, attributes);
+    gst_value_array_append_value (&arr, &val);
+
+    gst_structure_set_value (s, field_name, &arr);
+
+    GST_DEBUG_OBJECT (ext, "%" GST_PTR_FORMAT, caps);
+
+    g_value_unset (&val);
+    g_value_unset (&arr);
+  }
+
+  g_free (field_name);
+  return TRUE;
+}
+
+static gboolean
+gst_rtp_header_extension_set_caps_from_attributes_default (GstRTPHeaderExtension
+    * ext, GstCaps * caps)
+{
+  return gst_rtp_header_extension_set_caps_from_attributes_helper (ext, caps,
+      NULL);
+}
+
+static gboolean
+gst_rtp_ext_list_filter (GstPluginFeature * feature, gpointer user_data)
+{
+  GstElementFactory *factory;
+  gchar *uri = user_data;
+  const gchar *klass, *factory_uri;
+  guint rank;
+
+  /* we only care about element factories */
+  if (!GST_IS_ELEMENT_FACTORY (feature))
+    return FALSE;
+
+  factory = GST_ELEMENT_FACTORY (feature);
+
+  /* only select elements with autoplugging rank */
+  rank = gst_plugin_feature_get_rank (feature);
+  if (rank < GST_RANK_MARGINAL)
+    return FALSE;
+
+  klass =
+      gst_element_factory_get_metadata (factory, GST_ELEMENT_METADATA_KLASS);
+  if (!strstr (klass, "Network") || !strstr (klass, "Extension") ||
+      !strstr (klass, "RTPHeader"))
+    return FALSE;
+
+  factory_uri =
+      gst_element_factory_get_metadata (factory,
+      GST_RTP_HEADER_EXTENSION_URI_METADATA_KEY);
+  if (!factory_uri)
+    return FALSE;
+
+  if (uri && g_strcmp0 (uri, factory_uri) != 0)
+    return FALSE;
+
+  return TRUE;
+}
+
+/**
+ * gst_rtp_get_header_extension_list:
+ *
+ * Retrieve all the factories of the currently registered RTP header
+ * extensions.  Call gst_element_factory_create() with each factory to create
+ * the associated #GstRTPHeaderExtension.
+ *
+ * Returns: (transfer full) (element-type GstElementFactory): a #GList of
+ *     #GstElementFactory's. Use gst_plugin_feature_list_free() after use
+ *
+ * Since: 1.20
+ */
+GList *
+gst_rtp_get_header_extension_list (void)
+{
+  return gst_registry_feature_filter (gst_registry_get (),
+      (GstPluginFeatureFilter) gst_rtp_ext_list_filter, FALSE, NULL);
+}
+
+/**
+ * gst_rtp_header_extension_create_from_uri:
+ * @uri: the rtp header extension URI to search for
+ *
+ * Returns: (transfer full) (nullable): the #GstRTPHeaderExtension for @uri or %NULL
+ *
+ * Since: 1.20
+ */
+GstRTPHeaderExtension *
+gst_rtp_header_extension_create_from_uri (const gchar * uri)
+{
+  GList *l;
+
+  l = gst_registry_feature_filter (gst_registry_get (),
+      (GstPluginFeatureFilter) gst_rtp_ext_list_filter, TRUE, (gpointer) uri);
+  if (l) {
+    GstElementFactory *factory = GST_ELEMENT_FACTORY (l->data);
+    GstElement *element = gst_element_factory_create (factory, NULL);
+
+    g_list_free_full (l, (GDestroyNotify) gst_object_unref);
+
+    gst_object_ref_sink (element);
+
+    return GST_RTP_HEADER_EXTENSION (element);
+  }
+
+  return NULL;
+}
+
+/**
+ * gst_rtp_header_extension_set_direction:
+ * @ext: the #GstRTPHeaderExtension
+ * @direction: The direction
+ *
+ * Set the direction that this header extension should be used in.
+ * If #GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED is included, the
+ * direction will not be included in the caps (as it shouldn't be in the
+ * extmap line in the SDP).
+ *
+ * Since: 1.20
+ */
+
+void
+gst_rtp_header_extension_set_direction (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionDirection direction)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  g_return_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext));
+  g_return_if_fail (direction <= GST_RTP_HEADER_EXTENSION_DIRECTION_DEFAULT);
+
+  priv->direction = direction;
+}
+
+/**
+ * gst_rtp_header_extension_get_direction:
+ * @ext: the #GstRTPHeaderExtension
+ *
+ * Retrieve the direction
+ *
+ * Returns: The direction
+ *
+ * Since: 1.20
+ */
+
+GstRTPHeaderExtensionDirection
+gst_rtp_header_extension_get_direction (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionPrivate *priv =
+      gst_rtp_header_extension_get_instance_private (ext);
+
+  g_return_val_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext),
+      GST_RTP_HEADER_EXTENSION_DIRECTION_DEFAULT);
+
+  return priv->direction;
+}
diff --git a/gst-libs/gst/rtp/gstrtphdrext.h b/gst-libs/gst/rtp/gstrtphdrext.h
index df36fe616b..442c27af60 100644
--- a/gst-libs/gst/rtp/gstrtphdrext.h
+++ b/gst-libs/gst/rtp/gstrtphdrext.h
@@ -1,5 +1,6 @@
 /* GStreamer
  * Copyright (C) <2012> Wim Taymans <wim.taymans@gmail.com>
+ * Copyright (C) <2020> Matthew Waters <matthew@centricular.com>
  *
  * gstrtphdrext.h: RTP header extensions
  *
@@ -50,6 +51,243 @@ gboolean       gst_rtp_hdrext_set_ntp_56  (gpointer data, guint size, guint64 nt
 GST_RTP_API
 gboolean       gst_rtp_hdrext_get_ntp_56  (gpointer data, guint size, guint64 *ntptime);
 
+/**
+ * GST_RTP_HDREXT_ELEMENT_CLASS:
+ *
+ * Constant string used in element classification to signal that this element
+ * is a RTP header extension.
+ *
+ * Since: 1.20
+ */
+#define GST_RTP_HDREXT_ELEMENT_CLASS "Network/Extension/RTPHeader"
+
+GST_RTP_API
+GType gst_rtp_header_extension_get_type (void);
+#define GST_TYPE_RTP_HEADER_EXTENSION (gst_rtp_header_extension_get_type())
+#define GST_RTP_HEADER_EXTENSION(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_HEADER_EXTENSION,GstRTPHeaderExtension))
+#define GST_RTP_HEADER_EXTENSION_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_HEADER_EXTENSION,GstRTPHeaderExtensionClass))
+#define GST_RTP_HEADER_EXTENSION_GET_CLASS(obj) \
+        (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_RTP_HEADER_EXTENSION,GstRTPHeaderExtensionClass))
+#define GST_IS_RTP_HEADER_EXTENSION(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_HEADER_EXTENSION))
+#define GST_IS_RTP_HEADER_EXTENSION_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_HEADER_EXTENSION))
+/**
+ * GST_RTP_HEADER_EXTENSION_CAST:
+ *
+ * Since: 1.20
+ */
+#define GST_RTP_HEADER_EXTENSION_CAST(obj) ((GstRTPHeaderExtension *)(obj))
+
+typedef struct _GstRTPHeaderExtension      GstRTPHeaderExtension;
+typedef struct _GstRTPHeaderExtensionClass GstRTPHeaderExtensionClass;
+
+/**
+ * GstRTPHeaderExtensionFlags:
+ * @GST_RTP_HEADER_EXTENSION_ONE_BYTE: The one byte rtp extension header.
+ *              1-16 data bytes per extension with a maximum of
+ *              14 extension ids in total.
+ * @GST_RTP_HEADER_EXTENSION_TWO_BYTE: The two byte rtp extension header.
+ *              256 data bytes per extension with a maximum of 255 (or 256
+ *              including appbits) extensions in total.
+ *
+ * Flags that apply to a RTP Audio/Video header extension.
+ *
+ * Since: 1.20
+ */
+typedef enum /*< underscore_name=gst_rtp_header_extension_flags >*/
+{
+  GST_RTP_HEADER_EXTENSION_ONE_BYTE = (1 << 0),
+  GST_RTP_HEADER_EXTENSION_TWO_BYTE = (1 << 1),
+} GstRTPHeaderExtensionFlags;
+
+/**
+ * GstRTPHeaderExtensionDirection:
+ * @GST_RTP_HEADER_EXTENSION_DIRECTION_INACTIVE: Neither send nor
+ * receive RTP Header Extensions
+ * @GST_RTP_HEADER_EXTENSION_DIRECTION_SENDONLY: Only send RTP Header
+ * Extensions @GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY: Only
+ * receive RTP Header Extensions
+ * @GST_RTP_HEADER_EXTENSION_DIRECTION_SENDRECV: Send and receive RTP
+ * Header Extensions ext
+ * @GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED: RTP header extension
+ * direction is inherited from the stream
+ *
+ * Direction to which to apply the RTP Header Extension
+ *
+ * Since: 1.20
+ */
+typedef enum /*< underscore_name=gst_rtp_header_extension_direction >*/
+{
+  GST_RTP_HEADER_EXTENSION_DIRECTION_INACTIVE = 0,
+  GST_RTP_HEADER_EXTENSION_DIRECTION_SENDONLY = (1 << 0),
+  GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY = (1 << 1),
+  GST_RTP_HEADER_EXTENSION_DIRECTION_SENDRECV = (
+    GST_RTP_HEADER_EXTENSION_DIRECTION_SENDONLY |
+    GST_RTP_HEADER_EXTENSION_DIRECTION_RECVONLY),
+  GST_RTP_HEADER_EXTENSION_DIRECTION_INHERITED = (1 << 2)
+} GstRTPHeaderExtensionDirection;
+
+/**
+ * GstRTPHeaderExtension:
+ * @parent: the parent #GObject
+ * @ext_id: the configured extension id
+ *
+ * Instance struct for a RTP Audio/Video header extension.
+ *
+ * Since: 1.20
+ */
+struct _GstRTPHeaderExtension
+{
+  GstElement parent;
+
+  /*< private >*/
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+/**
+ * GstRTPHeaderExtensionClass:
+ * @parent_class: the parent class
+ * @get_uri: retrieve the RTP extension uri
+ * @get_supported_flags: retrieve the supported flags
+ * @get_max_size: retrieve the maximum size for this extension based on the
+ *     information available from input_meta.  Implementations should attempt
+ *     to provide as accurate information as possible as the returned value
+ *     will be used to control the amount of possible data in the payload.
+ *     Implementations must return the maximum as the allocated size for
+ *     writing the extension will be at least the size of the returned value.
+ *     Return the amount of data read or <0 on failure.
+ * @write: write into @data the information for this extension.  Various
+ *     information is provided to help writing extensions in particular cases.
+ * @read: read from a rtp payloaded buffer and extract the extension
+ *     information, optionally adding some meta onto the output buffer.
+ * @set_non_rtp_sink_caps: read any information from sink caps that the header
+ *     extension needs for its function.
+ * @update_non_rtp_src_caps: update depayloader non-RTP (depayloaded) caps with
+ *     the information parsed from RTP header.
+ * @set_attributes: set the necessary attributes that may be signaled e.g. with
+ *     an SDP.
+ * @set_caps_from_attributes: write the necessary caps field/s for the configured
+ *     attributes e.g. as signalled with SDP.
+ *
+ * Base class for RTP Header extensions.
+ *
+ * Since: 1.20
+ */
+
+struct _GstRTPHeaderExtensionClass
+{
+  GstElementClass parent_class;
+
+  /*< public >*/
+  GstRTPHeaderExtensionFlags (*get_supported_flags) (GstRTPHeaderExtension * ext);
+
+  gsize                 (*get_max_size)             (GstRTPHeaderExtension * ext,
+                                                     const GstBuffer * input_meta);
+
+  gssize                (*write)                    (GstRTPHeaderExtension * ext,
+                                                     const GstBuffer * input_meta,
+                                                     GstRTPHeaderExtensionFlags write_flags,
+                                                     GstBuffer * output,
+                                                     guint8 * data,
+                                                     gsize size);
+
+  gboolean              (*read)                     (GstRTPHeaderExtension * ext,
+                                                     GstRTPHeaderExtensionFlags read_flags,
+                                                     const guint8 * data,
+                                                     gsize size,
+                                                     GstBuffer * buffer);
+  gboolean              (*set_non_rtp_sink_caps)    (GstRTPHeaderExtension * ext,
+                                                     const GstCaps * caps);
+  gboolean              (*update_non_rtp_src_caps)  (GstRTPHeaderExtension * ext,
+                                                     GstCaps * caps);
+  gboolean              (*set_attributes)            (GstRTPHeaderExtension * ext,
+                                                      GstRTPHeaderExtensionDirection direction,
+                                                      const gchar * attributes);
+  gboolean              (*set_caps_from_attributes) (GstRTPHeaderExtension * ext,
+                                                     GstCaps * caps);
+
+  /*< private >*/
+  gpointer _gst_reserved[GST_PADDING_LARGE];
+};
+
+G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstRTPHeaderExtension, gst_object_unref)
+
+/**
+ * GST_RTP_HEADER_EXTENSION_URI_METADATA_KEY:
+ *
+ * Since: 1.20
+ */
+#define GST_RTP_HEADER_EXTENSION_URI_METADATA_KEY "RTP-Header-Extension-URI"
+
+GST_RTP_API
+void                gst_rtp_header_extension_class_set_uri      (GstRTPHeaderExtensionClass *klass,
+                                                                 const gchar * uri);
+
+GST_RTP_API
+const gchar *       gst_rtp_header_extension_get_uri            (GstRTPHeaderExtension * ext);
+GST_RTP_API
+gsize               gst_rtp_header_extension_get_max_size       (GstRTPHeaderExtension * ext,
+                                                                 const GstBuffer * input_meta);
+GST_RTP_API
+GstRTPHeaderExtensionFlags gst_rtp_header_extension_get_supported_flags (GstRTPHeaderExtension * ext);
+GST_RTP_API
+guint               gst_rtp_header_extension_get_id             (GstRTPHeaderExtension * ext);
+GST_RTP_API
+void                gst_rtp_header_extension_set_id             (GstRTPHeaderExtension * ext,
+                                                                 guint ext_id);
+GST_RTP_API
+gssize              gst_rtp_header_extension_write              (GstRTPHeaderExtension * ext,
+                                                                 const GstBuffer * input_meta,
+                                                                 GstRTPHeaderExtensionFlags write_flags,
+                                                                 GstBuffer * output,
+                                                                 guint8 * data,
+                                                                 gsize size);
+GST_RTP_API
+gboolean            gst_rtp_header_extension_read               (GstRTPHeaderExtension * ext,
+                                                                 GstRTPHeaderExtensionFlags read_flags,
+                                                                 const guint8 * data,
+                                                                 gsize size,
+                                                                 GstBuffer * buffer);
+GST_RTP_API
+gboolean            gst_rtp_header_extension_set_non_rtp_sink_caps (GstRTPHeaderExtension * ext,
+                                                                    const GstCaps * caps);
+GST_RTP_API
+gboolean            gst_rtp_header_extension_wants_update_non_rtp_src_caps (GstRTPHeaderExtension * ext);
+GST_RTP_API
+void                gst_rtp_header_extension_set_wants_update_non_rtp_src_caps (GstRTPHeaderExtension * ext,
+                                                                                gboolean state);
+GST_RTP_API
+gboolean            gst_rtp_header_extension_update_non_rtp_src_caps (GstRTPHeaderExtension * ext,
+                                                                      GstCaps * caps);
+GST_RTP_API
+gboolean            gst_rtp_header_extension_set_caps_from_attributes (GstRTPHeaderExtension * ext,
+                                                                       GstCaps * caps);
+GST_RTP_API
+gboolean            gst_rtp_header_extension_set_attributes_from_caps (GstRTPHeaderExtension * ext,
+                                                                       const GstCaps * caps);
+
+GST_RTP_API
+GList *             gst_rtp_get_header_extension_list           (void);
+GST_RTP_API
+GstRTPHeaderExtension * gst_rtp_header_extension_create_from_uri (const gchar * uri);
+
+GST_RTP_API
+gchar *	            gst_rtp_header_extension_get_sdp_caps_field_name (GstRTPHeaderExtension * ext);
+
+GST_RTP_API
+void	            gst_rtp_header_extension_set_direction (GstRTPHeaderExtension * ext,
+                                                            GstRTPHeaderExtensionDirection direction);
+GST_RTP_API
+GstRTPHeaderExtensionDirection	gst_rtp_header_extension_get_direction (GstRTPHeaderExtension * ext);
+
+GST_RTP_API
+gboolean    gst_rtp_header_extension_set_caps_from_attributes_helper (GstRTPHeaderExtension * ext,
+                                                                      GstCaps * caps,
+                                                                      const gchar * attributes);
+
 G_END_DECLS
 
 #endif /* __GST_RTPHDREXT_H__ */
diff --git a/gst-libs/gst/rtp/gstrtpmeta.c b/gst-libs/gst/rtp/gstrtpmeta.c
index 1968f49643..76941efd08 100644
--- a/gst-libs/gst/rtp/gstrtpmeta.c
+++ b/gst-libs/gst/rtp/gstrtpmeta.c
@@ -34,8 +34,8 @@
 /**
  * gst_buffer_add_rtp_source_meta:
  * @buffer: a #GstBuffer
- * @ssrc: (allow-none) (transfer none): pointer to the SSRC
- * @csrc: (allow-none) (transfer none): pointer to the CSRCs
+ * @ssrc: (nullable) (transfer none): pointer to the SSRC
+ * @csrc: (nullable) (transfer none) (array length=csrc_count): pointer to the CSRCs
  * @csrc_count: number of elements in @csrc
  *
  * Attaches RTP source information to @buffer.
@@ -81,7 +81,7 @@ gst_buffer_add_rtp_source_meta (GstBuffer * buffer, const guint32 * ssrc,
  *
  * Find the #GstRTPSourceMeta on @buffer.
  *
- * Returns: (transfer none): the #GstRTPSourceMeta or %NULL when there
+ * Returns: (transfer none) (nullable): the #GstRTPSourceMeta or %NULL when there
  * is no such metadata on @buffer.
  *
  * Since: 1.16
@@ -137,7 +137,7 @@ gst_rtp_source_meta_get_source_count (const GstRTPSourceMeta * meta)
 /**
  * gst_rtp_source_meta_set_ssrc:
  * @meta: a #GstRTPSourceMeta
- * @ssrc: (allow-none) (transfer none): pointer to the SSRC
+ * @ssrc: (nullable) (transfer none): pointer to the SSRC
  *
  * Sets @ssrc in @meta. If @ssrc is %NULL the ssrc of @meta will be unset.
  *
@@ -161,7 +161,7 @@ gst_rtp_source_meta_set_ssrc (GstRTPSourceMeta * meta, guint32 * ssrc)
 /**
  * gst_rtp_source_meta_append_csrc:
  * @meta: a #GstRTPSourceMeta
- * @csrc: the csrcs to append
+ * @csrc: (array length=csrc_count): the csrcs to append
  * @csrc_count: number of elements in @csrc
  *
  * Appends @csrc to the list of contributing sources in @meta.
diff --git a/gst-libs/gst/rtp/gstrtppayloads.c b/gst-libs/gst/rtp/gstrtppayloads.c
index 76ac069c63..1ab579d4d4 100644
--- a/gst-libs/gst/rtp/gstrtppayloads.c
+++ b/gst-libs/gst/rtp/gstrtppayloads.c
@@ -185,7 +185,7 @@ static const GstRTPPayloadInfo info[] = {
  * mostly used to get the default clock-rate and bandwidth for static payload
  * types specified with @payload_type.
  *
- * Returns: a #GstRTPPayloadInfo or NULL when no info could be found.
+ * Returns: (nullable): a #GstRTPPayloadInfo or NULL when no info could be found.
  */
 const GstRTPPayloadInfo *
 gst_rtp_payload_info_for_pt (guint8 payload_type)
@@ -213,7 +213,7 @@ gst_rtp_payload_info_for_pt (guint8 payload_type)
  *
  * The search for @encoding_name will be performed in a case insensitive way.
  *
- * Returns: a #GstRTPPayloadInfo or NULL when no info could be found.
+ * Returns: (nullable): a #GstRTPPayloadInfo or NULL when no info could be found.
  */
 const GstRTPPayloadInfo *
 gst_rtp_payload_info_for_name (const gchar * media, const gchar * encoding_name)
diff --git a/gst-libs/gst/sdp/gstmikey.c b/gst-libs/gst/sdp/gstmikey.c
index 4f8a313890..641f25e06f 100644
--- a/gst-libs/gst/sdp/gstmikey.c
+++ b/gst-libs/gst/sdp/gstmikey.c
@@ -66,7 +66,7 @@ G_STMT_START {                    \
 #define INIT_MEMDUP(field, data, len)            \
 G_STMT_START {                                   \
   g_free ((field));                              \
-  (field) = g_memdup (data, len);                \
+  (field) = g_memdup2 (data, len);                \
 } G_STMT_END
 #define FREE_MEMDUP(field)                       \
 G_STMT_START {                                   \
@@ -177,7 +177,7 @@ gst_mikey_payload_kemac_get_n_sub (const GstMIKEYPayload * payload)
  * Get the sub payload of @payload at @idx. @payload should be of type
  * %GST_MIKEY_PT_KEMAC.
  *
- * Returns: (transfer none): the #GstMIKEYPayload at @idx.
+ * Returns: (transfer none) (nullable): the #GstMIKEYPayload at @idx.
  *
  * Since: 1.4
  */
@@ -458,7 +458,7 @@ gst_mikey_payload_sp_get_n_params (const GstMIKEYPayload * payload)
  * Get the Security Policy parameter in a %GST_MIKEY_PT_SP @payload
  * at @idx.
  *
- * Returns: the #GstMIKEYPayloadSPParam at @idx in @payload
+ * Returns: (transfer none) (nullable): the #GstMIKEYPayloadSPParam at @idx in @payload
  *
  * Since: 1.4
  */
@@ -763,7 +763,7 @@ mikey_payload_free (GstMIKEYPayload * payload)
  *
  * Make a new #GstMIKEYPayload with @type.
  *
- * Returns: (nullable): a new #GstMIKEYPayload or %NULL on failure.
+ * Returns: (transfer full) (nullable): a new #GstMIKEYPayload or %NULL on failure.
  *
  * Since: 1.4
  */
@@ -870,7 +870,7 @@ mikey_message_free (GstMIKEYMessage * msg)
  *
  * Make a new MIKEY message.
  *
- * Returns: a new #GstMIKEYMessage on success
+ * Returns: (transfer full): a new #GstMIKEYMessage on success
  *
  * Since: 1.4
  */
@@ -899,7 +899,7 @@ gst_mikey_message_new (void)
  *
  * Make a new #GstMIKEYMessage from @bytes.
  *
- * Returns: a new #GstMIKEYMessage
+ * Returns: (transfer full): a new #GstMIKEYMessage
  *
  * Since: 1.4
  */
@@ -974,7 +974,7 @@ gst_mikey_message_get_n_cs (const GstMIKEYMessage * msg)
  *
  * Get the policy information of @msg at @idx.
  *
- * Returns: a #GstMIKEYMapSRTP
+ * Returns: (transfer none) (nullable): a #GstMIKEYMapSRTP
  *
  * Since: 1.4
  */
@@ -1125,7 +1125,7 @@ gst_mikey_message_get_n_payloads (const GstMIKEYMessage * msg)
  *
  * Get the #GstMIKEYPayload at @idx in @msg
  *
- * Returns: (transfer none): the #GstMIKEYPayload at @idx. The payload
+ * Returns: (transfer none) (nullable): the #GstMIKEYPayload at @idx. The payload
  * remains valid for as long as it is part of @msg.
  *
  * Since: 1.4
@@ -1149,7 +1149,7 @@ gst_mikey_message_get_payload (const GstMIKEYMessage * msg, guint idx)
  *
  * Find the @nth occurrence of the payload with @type in @msg.
  *
- * Returns: the @nth #GstMIKEYPayload of @type.
+ * Returns: (transfer none) (nullable): the @nth #GstMIKEYPayload of @type.
  *
  * Since: 1.4
  */
@@ -1667,7 +1667,7 @@ payloads_to_bytes (GArray * payloads, GByteArray * arr, guint8 ** ptr,
  *
  * Convert @msg to a #GBytes.
  *
- * Returns: a new #GBytes for @msg.
+ * Returns: (transfer full): a new #GBytes for @msg.
  *
  * Since: 1.4
  */
@@ -2053,7 +2053,7 @@ invalid_data:
  * Parse @size bytes from @data into a #GstMIKEYMessage. @info contains the
  * parameters to decrypt and verify the data.
  *
- * Returns: a #GstMIKEYMessage on success or %NULL when parsing failed and
+ * Returns: (transfer full): a #GstMIKEYMessage on success or %NULL when parsing failed and
  * @error will be set.
  *
  * Since: 1.4
@@ -2238,7 +2238,7 @@ auth_key_length_from_auth_cipher_name (const gchar * auth, const gchar * cipher,
  *  - Key Data Transport Payload
  *  - Key Data Sub-Payload
  *
- * Returns: (transfer full): a #GstMIKEYMessage,
+ * Returns: (transfer full) (nullable): a #GstMIKEYMessage,
  * or %NULL if there is no srtp information in the caps.
  *
  * Since: 1.8
@@ -2490,9 +2490,7 @@ gst_mikey_message_to_caps (const GstMIKEYMessage * msg, GstCaps * caps)
       goto done;
 
     pkd = (GstMIKEYPayloadKeyData *) sub;
-    buf =
-        gst_buffer_new_wrapped (g_memdup (pkd->key_data, pkd->key_len),
-        pkd->key_len);
+    buf = gst_buffer_new_memdup (pkd->key_data, pkd->key_len);
     gst_caps_set_simple (caps, "srtp-key", GST_TYPE_BUFFER, buf, NULL);
     gst_buffer_unref (buf);
   }
diff --git a/gst-libs/gst/sdp/gstsdpmessage.c b/gst-libs/gst/sdp/gstsdpmessage.c
index 80870f1135..1de3849281 100644
--- a/gst-libs/gst/sdp/gstsdpmessage.c
+++ b/gst-libs/gst/sdp/gstsdpmessage.c
@@ -61,6 +61,7 @@
 #include <gio/gio.h>
 
 #include <gst/rtp/gstrtppayloads.h>
+#include <gst/pbutils/pbutils.h>
 #include "gstsdpmessage.h"
 
 #define FREE_STRING(field)              g_free (field); (field) = NULL
@@ -262,7 +263,7 @@ gst_sdp_message_new_from_text (const gchar * text, GstSDPMessage ** msg)
 
 /**
  * gst_sdp_message_init:
- * @msg: a #GstSDPMessage
+ * @msg: (out caller-allocates): a #GstSDPMessage
  *
  * Initialize @msg so that its contents are as if it was freshly allocated
  * with gst_sdp_message_new(). This function is mostly used to initialize a message
@@ -339,16 +340,12 @@ gst_sdp_message_uninit (GstSDPMessage * msg)
 GstSDPResult
 gst_sdp_message_copy (const GstSDPMessage * msg, GstSDPMessage ** copy)
 {
-  GstSDPResult ret;
   GstSDPMessage *cp;
   guint i, len;
 
-  if (msg == NULL)
-    return GST_SDP_EINVAL;
+  g_return_val_if_fail (msg != NULL, GST_SDP_EINVAL);
 
-  ret = gst_sdp_message_new (copy);
-  if (ret != GST_SDP_OK)
-    return ret;
+  gst_sdp_message_new (copy);
 
   cp = *copy;
 
@@ -488,7 +485,7 @@ gst_sdp_address_is_multicast (const gchar * nettype, const gchar * addrtype,
  *
  * Convert the contents of @msg to a text string.
  *
- * Returns: A dynamically allocated string representing the SDP description.
+ * Returns: (transfer full): A dynamically allocated string representing the SDP description.
  */
 gchar *
 gst_sdp_message_as_text (const GstSDPMessage * msg)
@@ -623,7 +620,7 @@ hex_to_int (gchar c)
 /**
  * gst_sdp_message_parse_uri:
  * @uri: the start of the uri
- * @msg: the result #GstSDPMessage
+ * @msg: (transfer none): the result #GstSDPMessage
  *
  * Parse the null-terminated @uri and store the result in @msg.
  *
@@ -735,7 +732,7 @@ static const gchar hex[16] = "0123456789ABCDEF";
  *
  *  Where each value is url encoded.
  *
- * Returns: a uri for @msg.
+ * Returns: (transfer full): a uri for @msg.
  */
 gchar *
 gst_sdp_message_as_uri (const gchar * scheme, const GstSDPMessage * msg)
@@ -1630,7 +1627,7 @@ DEFINE_ARRAY_GETTER (attribute, attributes, GstSDPAttribute);
  *
  * Get the @nth attribute with key @key in @msg.
  *
- * Returns: the attribute value of the @nth attribute with @key.
+ * Returns: (nullable): the attribute value of the @nth attribute with @key.
  */
 const gchar *
 gst_sdp_message_get_attribute_val_n (const GstSDPMessage * msg,
@@ -1662,7 +1659,7 @@ gst_sdp_message_get_attribute_val_n (const GstSDPMessage * msg,
  *
  * Get the first attribute with key @key in @msg.
  *
- * Returns: the attribute value of the first attribute with @key.
+ * Returns: (nullable): the attribute value of the first attribute with @key.
  */
 const gchar *
 gst_sdp_message_get_attribute_val (const GstSDPMessage * msg, const gchar * key)
@@ -1819,7 +1816,7 @@ gst_sdp_media_new (GstSDPMedia ** media)
 
 /**
  * gst_sdp_media_init:
- * @media: a #GstSDPMedia
+ * @media: (out caller-allocates): a #GstSDPMedia
  *
  * Initialize @media so that its contents are as if it was freshly allocated
  * with gst_sdp_media_new(). This function is mostly used to initialize a media
@@ -1909,16 +1906,12 @@ gst_sdp_media_free (GstSDPMedia * media)
 GstSDPResult
 gst_sdp_media_copy (const GstSDPMedia * media, GstSDPMedia ** copy)
 {
-  GstSDPResult ret;
   GstSDPMedia *cp;
   guint i, len;
 
-  if (media == NULL)
-    return GST_SDP_EINVAL;
+  g_return_val_if_fail (media != NULL, GST_SDP_EINVAL);
 
-  ret = gst_sdp_media_new (copy);
-  if (ret != GST_SDP_OK)
-    return ret;
+  gst_sdp_media_new (copy);
 
   cp = *copy;
 
@@ -1965,7 +1958,7 @@ gst_sdp_media_copy (const GstSDPMedia * media, GstSDPMedia ** copy)
  *
  * Convert the contents of @media to a text string.
  *
- * Returns: A dynamically allocated string representing the media.
+ * Returns: (transfer full): A dynamically allocated string representing the media.
  */
 gchar *
 gst_sdp_media_as_text (const GstSDPMedia * media)
@@ -2802,7 +2795,7 @@ gst_sdp_media_get_attribute (const GstSDPMedia * media, guint idx)
  *
  * Get the @nth attribute value for @key in @media.
  *
- * Returns: the @nth attribute value.
+ * Returns: (nullable): the @nth attribute value.
  */
 const gchar *
 gst_sdp_media_get_attribute_val_n (const GstSDPMedia * media, const gchar * key,
@@ -2834,7 +2827,7 @@ gst_sdp_media_get_attribute_val_n (const GstSDPMedia * media, const gchar * key,
  *
  * Get the first attribute value for @key in @media.
  *
- * Returns: the first attribute value for @key.
+ * Returns: (nullable): the first attribute value for @key.
  */
 const gchar *
 gst_sdp_media_get_attribute_val (const GstSDPMedia * media, const gchar * key)
@@ -3128,7 +3121,7 @@ gst_sdp_parse_line (SDPContext * c, gchar type, gchar * buffer)
  * gst_sdp_message_parse_buffer:
  * @data: (array length=size): the start of the buffer
  * @size: the size of the buffer
- * @msg: the result #GstSDPMessage
+ * @msg: (transfer none): the result #GstSDPMessage
  *
  * Parse the contents of @size bytes pointed to by @data and store the result in
  * @msg.
@@ -3446,7 +3439,7 @@ gst_sdp_parse_rtpmap (const gchar * rtpmap, gint * payload, gchar ** name,
     *params = NULL;
     goto out;
   } else {
-    *name = strdup (*name);
+    *name = g_strdup (*name);
   }
 
   t = p;
@@ -3540,6 +3533,35 @@ gst_sdp_media_add_rtcp_fb_attributes_from_media (const GstSDPMedia * media,
   return GST_SDP_OK;
 }
 
+static void
+gst_sdp_media_caps_adjust_h264 (GstCaps * caps)
+{
+  long int spsint;
+  guint8 sps[2];
+  const gchar *profile_level_id;
+  GstStructure *s = gst_caps_get_structure (caps, 0);
+
+  if (g_strcmp0 (gst_structure_get_string (s, "encoding-name"), "H264") ||
+      g_strcmp0 (gst_structure_get_string (s, "level-asymmetry-allowed"), "1"))
+    return;
+
+  profile_level_id = gst_structure_get_string (s, "profile-level-id");
+  if (!profile_level_id)
+    return;
+
+  spsint = strtol (profile_level_id, NULL, 16);
+  sps[0] = spsint >> 16;
+  sps[1] = spsint >> 8;
+
+  GST_DEBUG ("'level-asymmetry-allowed' is set so we shouldn't care about "
+      "'profile-level-id' and only set a 'profile' instead");
+  gst_structure_set (s, "profile", G_TYPE_STRING,
+      gst_codec_utils_h264_get_profile (sps, 2), NULL);
+
+  gst_structure_remove_fields (s, "level-asymmetry-allowed", "profile-level-id",
+      NULL);
+}
+
 /**
  * gst_sdp_media_get_caps_from_media:
  * @media: a #GstSDPMedia
@@ -3553,9 +3575,9 @@ gst_sdp_media_add_rtcp_fb_attributes_from_media (const GstSDPMedia * media,
  *
  * a=fmtp:(payload) (param)[=(value)];...
  *
- * Note that the extmap attribute is set only by gst_sdp_media_attributes_to_caps().
+ * Note that the extmap, ssrc and rid attributes are set only by gst_sdp_media_attributes_to_caps().
  *
- * Returns: a #GstCaps, or %NULL if an error happened
+ * Returns: (transfer full) (nullable): a #GstCaps, or %NULL if an error happened
  *
  * Since: 1.8
  */
@@ -3714,6 +3736,8 @@ gst_sdp_media_get_caps_from_media (const GstSDPMedia * media, gint pt)
     }
   }
 
+  gst_sdp_media_caps_adjust_h264 (caps);
+
   /* parse rtcp-fb: field */
   gst_sdp_media_add_rtcp_fb_attributes_from_media (media, pt, caps);
 
@@ -3742,7 +3766,7 @@ no_rate:
 /**
  * gst_sdp_media_set_media_from_caps:
  * @caps: a #GstCaps
- * @media: a #GstSDPMedia
+ * @media: (out caller-allocates): a #GstSDPMedia
  *
  * Mapping of caps to SDP fields:
  *
@@ -3767,7 +3791,7 @@ gst_sdp_media_set_media_from_caps (const GstCaps * caps, GstSDPMedia * media)
   gchar *tmp;
   gint caps_pt, caps_rate;
   guint n_fields, j;
-  gboolean first, nack, nack_pli, ccm_fir;
+  gboolean first, nack, nack_pli, ccm_fir, transport_cc;
   GString *fmtp;
   GstStructure *s;
 
@@ -3782,15 +3806,25 @@ gst_sdp_media_set_media_from_caps (const GstCaps * caps, GstSDPMedia * media)
 
   /* get media type and payload for the m= line */
   caps_str = gst_structure_get_string (s, "media");
+  if (!caps_str) {
+    GST_ERROR ("ignoring stream without media type");
+    goto error;
+  }
   gst_sdp_media_set_media (media, caps_str);
 
-  gst_structure_get_int (s, "payload", &caps_pt);
+  if (!gst_structure_get_int (s, "payload", &caps_pt)) {
+    GST_ERROR ("ignoring stream without payload type");
+    goto error;
+  }
   tmp = g_strdup_printf ("%d", caps_pt);
   gst_sdp_media_add_format (media, tmp);
   g_free (tmp);
 
   /* get clock-rate, media type and params for the rtpmap attribute */
-  gst_structure_get_int (s, "clock-rate", &caps_rate);
+  if (!gst_structure_get_int (s, "clock-rate", &caps_rate)) {
+    GST_ERROR ("ignoring stream without payload type");
+    goto error;
+  }
   caps_enc = gst_structure_get_string (s, "encoding-name");
   caps_params = gst_structure_get_string (s, "encoding-params");
 
@@ -3833,6 +3867,15 @@ gst_sdp_media_set_media_from_caps (const GstCaps * caps, GstSDPMedia * media)
     }
   }
 
+  if (gst_structure_get_boolean (s, "rtcp-fb-transport-cc", &transport_cc)) {
+    if (transport_cc) {
+      tmp = g_strdup_printf ("%d transport-cc", caps_pt);
+      gst_sdp_media_add_attribute (media, "rtcp-fb", tmp);
+      g_free (tmp);
+      GST_DEBUG ("adding rtcp-fb-transport-cc to pt=%d", caps_pt);
+    }
+  }
+
   /* collect all other properties and add them to fmtp, extmap or attributes */
   fmtp = g_string_new ("");
   g_string_append_printf (fmtp, "%d ", caps_pt);
@@ -3950,7 +3993,63 @@ gst_sdp_media_set_media_from_caps (const GstCaps * caps, GstSDPMedia * media)
       continue;
     }
 
+    /* rid values */
+    if (g_str_has_prefix (fname, "rid-")) {
+      const char *rid_id = &fname[strlen ("rid-")];
+      const GValue *arr;
+
+      if (!rid_id || !*rid_id)
+        continue;
+
+      if ((fval = gst_structure_get_string (s, fname))) {
+        char *rid_val = g_strdup_printf ("%s %s", rid_id, fval);
+        gst_sdp_media_add_attribute (media, "rid", rid_val);
+        g_free (rid_val);
+      } else if ((arr = gst_structure_get_value (s, fname))
+          && GST_VALUE_HOLDS_ARRAY (arr)
+          && gst_value_array_get_size (arr) > 1) {
+        const gchar *direction, *param;
+        GString *str;
+        guint i, n;
+
+        str = g_string_new (NULL);
+
+        g_string_append_printf (str, "%s ", rid_id);
+
+        n = gst_value_array_get_size (arr);
+        for (i = 0; i < n; i++) {
+          const GValue *val = gst_value_array_get_value (arr, i);
+          if (i == 0) {
+            direction = g_value_get_string (val);
+            g_string_append_printf (str, "%s", direction);
+          } else {
+            param = g_value_get_string (val);
+            if (i == 1)
+              g_string_append_c (str, ' ');
+            else
+              g_string_append_c (str, ';');
+            g_string_append_printf (str, "%s", param);
+          }
+        }
+        gst_sdp_media_add_attribute (media, "rid", str->str);
+        g_string_free (str, TRUE);
+      } else {
+        GST_WARNING ("caps field %s is an unsupported format", fname);
+      }
+      continue;
+    }
+
     if ((fval = gst_structure_get_string (s, fname))) {
+
+      /* "profile" is our internal representation of the notion of
+       * "level-asymmetry-allowed" with caps, convert it back to the SDP
+       * representation */
+      if (!g_strcmp0 (gst_structure_get_string (s, "encoding-name"), "H264")
+          && !g_strcmp0 (fname, "profile")) {
+        fname = "level-asymmetry-allowed";
+        fval = "1";
+      }
+
       g_string_append_printf (fmtp, "%s%s=%s", first ? "" : ";", fname, fval);
       first = FALSE;
     }
@@ -4119,6 +4218,10 @@ sdp_add_attributes_to_caps (GArray * attributes, GstCaps * caps)
         continue;
       if (!strcmp (key, "extmap"))
         continue;
+      if (!strcmp (key, "ssrc"))
+        continue;
+      if (!strcmp (key, "rid"))
+        continue;
 
       /* string must be valid UTF8 */
       if (!g_utf8_validate (attr->value, -1, NULL))
@@ -4244,6 +4347,205 @@ gst_sdp_media_add_extmap_attributes (GArray * attributes, GstCaps * caps)
   return GST_SDP_OK;
 }
 
+/* parses Source-specific media SDP attributes (RFC5576) into caps */
+static GstSDPResult
+gst_sdp_media_add_ssrc_attributes (GArray * attributes, GstCaps * caps)
+{
+  gchar *p, *tmp, *to_free;
+  guint i;
+  GstStructure *s;
+
+  g_return_val_if_fail (attributes != NULL, GST_SDP_EINVAL);
+  g_return_val_if_fail (caps != NULL && GST_IS_CAPS (caps), GST_SDP_EINVAL);
+
+  s = gst_caps_get_structure (caps, 0);
+
+  for (i = 0; i < attributes->len; i++) {
+    const gchar *value;
+    GstSDPAttribute *attr;
+    guint32 ssrc;
+    gchar *ssrc_val, *ssrc_attr;
+    gchar *key;
+
+    attr = &g_array_index (attributes, GstSDPAttribute, i);
+    if (strcmp (attr->key, "ssrc") != 0)
+      continue;
+
+    value = attr->value;
+
+    /* p is now of the format ssrc attribute[:value] */
+    to_free = p = g_strdup (value);
+
+    ssrc = strtoul (p, &tmp, 10);
+    if (*tmp != ' ') {
+      GST_ERROR ("Invalid ssrc attribute '%s'", to_free);
+      goto next;
+    }
+
+    /* At the space */
+    p = tmp;
+
+    SKIP_SPACES (p);
+
+    tmp = strstr (p, ":");
+    if (tmp == NULL) {
+      ssrc_attr = tmp;
+      ssrc_val = (gchar *) "";
+    } else {
+      ssrc_attr = p;
+      *tmp = '\0';
+      p = tmp + 1;
+      ssrc_val = p;
+    }
+
+    if (ssrc_attr == NULL || *ssrc_attr == '\0') {
+      GST_ERROR ("Invalid ssrc attribute '%s'", to_free);
+      goto next;
+    }
+
+    key = g_strdup_printf ("ssrc-%u-%s", ssrc, ssrc_attr);
+    gst_structure_set (s, key, G_TYPE_STRING, ssrc_val, NULL);
+    GST_DEBUG ("adding caps: %s=%s", key, ssrc_val);
+    g_free (key);
+
+  next:
+    g_free (to_free);
+  }
+  return GST_SDP_OK;
+}
+
+/* parses RID SDP attributes (RFC8851) into caps */
+static GstSDPResult
+gst_sdp_media_add_rid_attributes (GArray * attributes, GstCaps * caps)
+{
+  const gchar *rid;
+  char *p, *to_free;
+  guint i;
+  GstStructure *s;
+
+  g_return_val_if_fail (attributes != NULL, GST_SDP_EINVAL);
+  g_return_val_if_fail (caps != NULL && GST_IS_CAPS (caps), GST_SDP_EINVAL);
+  g_return_val_if_fail (gst_caps_is_writable (caps), GST_SDP_EINVAL);
+
+  s = gst_caps_get_structure (caps, 0);
+
+  for (i = 0; i < attributes->len; i++) {
+    GstSDPAttribute *attr;
+    const char *direction, *params, *id;
+    const char *tmp;
+
+    attr = &g_array_index (attributes, GstSDPAttribute, i);
+    if (strcmp (attr->key, "rid") != 0)
+      continue;
+
+    rid = attr->value;
+
+    /* p is now of the format id dir ;-separated-params */
+    to_free = p = g_strdup (rid);
+
+    PARSE_STRING (p, " ", id);
+    if (id == NULL || *id == '\0') {
+      GST_ERROR ("Invalid rid \'%s\'", to_free);
+      goto next;
+    }
+    tmp = id;
+    while (*tmp && (*tmp == '-' || *tmp == '_' || g_ascii_isalnum (*tmp)))
+      tmp++;
+    if (*tmp != '\0') {
+      GST_ERROR ("Invalid rid-id \'%s\'", id);
+      goto next;
+    }
+
+    SKIP_SPACES (p);
+
+    PARSE_STRING (p, " ", direction);
+    if (direction == NULL || *direction == '\0') {
+      direction = p;
+      params = NULL;
+    } else {
+      SKIP_SPACES (p);
+
+      params = p;
+    }
+
+    if (direction == NULL || *direction == '\0'
+        || (g_strcmp0 (direction, "send") != 0
+            && g_strcmp0 (direction, "recv") != 0)) {
+      GST_ERROR ("Invalid rid direction \'%s\'", p);
+      goto next;
+    }
+
+    if (params && *params != '\0') {
+      GValue arr = G_VALUE_INIT;
+      GValue val = G_VALUE_INIT;
+      gchar *key;
+#if !defined(GST_DISABLE_DEBUG)
+      GString *debug_params = g_string_new (NULL);
+      int i = 0;
+#endif
+
+      key = g_strdup_printf ("rid-%s", id);
+
+      g_value_init (&arr, GST_TYPE_ARRAY);
+      g_value_init (&val, G_TYPE_STRING);
+
+      g_value_set_string (&val, direction);
+      gst_value_array_append_and_take_value (&arr, &val);
+      val = (GValue) G_VALUE_INIT;
+
+      while (*p) {
+        const char *param;
+        gboolean done = FALSE;
+
+        PARSE_STRING (p, ";", param);
+
+        if (param) {
+        } else if (*p) {
+          param = p;
+          done = TRUE;
+        } else {
+          break;
+        }
+
+        g_value_init (&val, G_TYPE_STRING);
+        g_value_set_string (&val, param);
+        gst_value_array_append_and_take_value (&arr, &val);
+        val = (GValue) G_VALUE_INIT;
+#if !defined(GST_DISABLE_DEBUG)
+        if (i++ > 0)
+          g_string_append_c (debug_params, ',');
+        g_string_append (debug_params, param);
+#endif
+
+        if (done)
+          break;
+      }
+
+      gst_structure_take_value (s, key, &arr);
+      arr = (GValue) G_VALUE_INIT;
+#if !defined(GST_DISABLE_DEBUG)
+      {
+        char *debug_str = g_string_free (debug_params, FALSE);
+        GST_DEBUG ("adding caps: %s=<%s,%s>", key, direction, debug_str);
+        g_free (debug_str);
+      }
+#endif
+      g_free (key);
+    } else {
+      gchar *key;
+
+      key = g_strdup_printf ("rid-%s", id);
+      gst_structure_set (s, key, G_TYPE_STRING, direction, NULL);
+      GST_DEBUG ("adding caps: %s=%s", key, direction);
+      g_free (key);
+    }
+
+  next:
+    g_clear_pointer (&to_free, g_free);
+  }
+  return GST_SDP_OK;
+}
+
 /**
  * gst_sdp_message_attributes_to_caps:
  * @msg: a #GstSDPMessage
@@ -4320,6 +4622,16 @@ gst_sdp_media_attributes_to_caps (const GstSDPMedia * media, GstCaps * caps)
     res = gst_sdp_media_add_extmap_attributes (media->attributes, caps);
   }
 
+  if (res == GST_SDP_OK) {
+    /* parse media ssrc field */
+    res = gst_sdp_media_add_ssrc_attributes (media->attributes, caps);
+  }
+
+  if (res == GST_SDP_OK) {
+    /* parse media rid fields */
+    res = gst_sdp_media_add_rid_attributes (media->attributes, caps);
+  }
+
 done:
   if (mikey)
     gst_mikey_message_unref (mikey);
diff --git a/gst-libs/gst/sdp/meson.build b/gst-libs/gst/sdp/meson.build
index 24cdb52937..ab747e3313 100644
--- a/gst-libs/gst/sdp/meson.build
+++ b/gst-libs/gst/sdp/meson.build
@@ -7,7 +7,7 @@ gst_sdp_headers = [
 ]
 install_headers(gst_sdp_headers, subdir : 'gstreamer-1.0/gst/sdp/')
 
-rtsp_deps = [rtp_dep, gst_dep, gio_dep]
+rtsp_deps = [rtp_dep, gst_dep, gio_dep, pbutils_dep]
 gst_sdp_sources = ['gstsdpmessage.c', 'gstmikey.c']
 gstsdp = library('gstsdp-@0@'.format(api_version),
   gst_sdp_sources,
diff --git a/gst-libs/gst/video/convertframe.c b/gst-libs/gst/video/convertframe.c
index bc55c6caf2..56db5d3432 100644
--- a/gst-libs/gst/video/convertframe.c
+++ b/gst-libs/gst/video/convertframe.c
@@ -24,6 +24,9 @@
 
 #include <string.h>
 #include "video.h"
+#ifdef HAVE_GL
+#include <gst/gl/gstglmemory.h>
+#endif
 
 static gboolean
 caps_are_raw (const GstCaps * caps)
@@ -117,8 +120,17 @@ build_convert_frame_pipeline (GstElement ** src_element,
 {
   GstElement *vcrop = NULL, *csp = NULL, *csp2 = NULL, *vscale = NULL;
   GstElement *src = NULL, *sink = NULL, *encoder = NULL, *pipeline;
+  GstElement *dl = NULL;
   GstVideoInfo info;
   GError *error = NULL;
+#ifdef HAVE_GL
+  GstCapsFeatures *features;
+
+  features = gst_caps_get_features (from_caps, 0);
+  if (gst_caps_features_contains (features, GST_CAPS_FEATURE_MEMORY_GL_MEMORY))
+    if (!create_element ("gldownload", &dl, &error))
+      goto no_elements;
+#endif
 
   if (cmeta) {
     if (!create_element ("videocrop", &vcrop, &error)) {
@@ -150,6 +162,8 @@ build_convert_frame_pipeline (GstElement ** src_element,
   gst_bin_add_many (GST_BIN (pipeline), src, csp, vscale, sink, NULL);
   if (vcrop)
     gst_bin_add_many (GST_BIN (pipeline), vcrop, csp2, NULL);
+  if (dl)
+    gst_bin_add (GST_BIN (pipeline), dl);
 
   /* set caps */
   g_object_set (src, "caps", from_caps, NULL);
@@ -168,9 +182,19 @@ build_convert_frame_pipeline (GstElement ** src_element,
 
   /* FIXME: linking is still way too expensive, profile this properly */
   if (vcrop) {
-    GST_DEBUG ("linking src->csp2");
-    if (!gst_element_link_pads (src, "src", csp2, "sink"))
-      goto link_failed;
+    if (!dl) {
+      GST_DEBUG ("linking src->csp2");
+      if (!gst_element_link_pads (src, "src", csp2, "sink"))
+        goto link_failed;
+    } else {
+      GST_DEBUG ("linking src->dl");
+      if (!gst_element_link_pads (src, "src", dl, "sink"))
+        goto link_failed;
+
+      GST_DEBUG ("linking dl->csp2");
+      if (!gst_element_link_pads (dl, "src", csp2, "sink"))
+        goto link_failed;
+    }
 
     GST_DEBUG ("linking csp2->vcrop");
     if (!gst_element_link_pads (csp2, "src", vcrop, "sink"))
@@ -181,8 +205,18 @@ build_convert_frame_pipeline (GstElement ** src_element,
       goto link_failed;
   } else {
     GST_DEBUG ("linking src->csp");
-    if (!gst_element_link_pads (src, "src", csp, "sink"))
-      goto link_failed;
+    if (!dl) {
+      if (!gst_element_link_pads (src, "src", csp, "sink"))
+        goto link_failed;
+    } else {
+      GST_DEBUG ("linking src->dl");
+      if (!gst_element_link_pads (src, "src", dl, "sink"))
+        goto link_failed;
+
+      GST_DEBUG ("linking dl->csp");
+      if (!gst_element_link_pads (dl, "src", csp, "sink"))
+        goto link_failed;
+    }
   }
 
   GST_DEBUG ("linking csp->vscale");
diff --git a/gst-libs/gst/video/gstvideocodecalphameta.c b/gst-libs/gst/video/gstvideocodecalphameta.c
new file mode 100644
index 0000000000..027f5435e7
--- /dev/null
+++ b/gst-libs/gst/video/gstvideocodecalphameta.c
@@ -0,0 +1,155 @@
+/* GStreamer
+ * Copyright (C) 2021 Collabora Ltd.
+ *   Author: Nicolas Dufresne <nicolas.dufresne@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstvideocodecalphameta.h"
+
+/**
+ * SECTION:gstvideocodecalphameta
+ * @title: GstVideoCodecAlphaMeta
+ * @short_description: GstMeta that can carry an extra buffer holding  an
+ * encoded a frame whith luma that can be used as an alpha channel.
+ *
+ * This meta is primarily for internal use in GStreamer elements to support
+ * VP8/VP9 transparent video stored into WebM or Matroska containers, or
+ * transparent static AV1 images. Nothing prevents you from using this meta
+ * for custom purposes, but it generally can't be used to easily to add support
+ * for alpha channels to CODECs or formats that don't support that out of the
+ * box.
+ *
+ * Since: 1.20
+ */
+
+/**
+ * gst_video_codec_alpha_meta_api_get_type:
+ *
+ * Returns: #GType for the #GstVideoCodecAlphaMeta structure.
+ *
+ * Since: 1.20
+ */
+GType
+gst_video_codec_alpha_meta_api_get_type (void)
+{
+  static GType type = 0;
+  static const gchar *tags[] = { GST_META_TAG_VIDEO_STR, NULL };
+
+  if (g_once_init_enter (&type)) {
+    GType _type =
+        gst_meta_api_type_register ("GstVideoCodecAlphaMetaAPI", tags);
+    g_once_init_leave (&type, _type);
+  }
+  return type;
+}
+
+static gboolean
+gst_video_codec_alpha_meta_transform (GstBuffer * dest,
+    GstMeta * meta, GstBuffer * buffer, GQuark type, gpointer data)
+{
+  GstVideoCodecAlphaMeta *dmeta, *smeta;
+
+  smeta = (GstVideoCodecAlphaMeta *) meta;
+
+  if (GST_META_TRANSFORM_IS_COPY (type)) {
+    dmeta =
+        (GstVideoCodecAlphaMeta *) gst_buffer_add_meta (dest,
+        GST_VIDEO_CODEC_ALPHA_META_INFO, NULL);
+
+    if (!dmeta)
+      return FALSE;
+
+    dmeta->buffer = gst_buffer_ref (smeta->buffer);
+  }
+  return TRUE;
+}
+
+static gboolean
+gst_video_codec_alpha_meta_init (GstMeta * meta, gpointer params,
+    GstBuffer * buffer)
+{
+  GstVideoCodecAlphaMeta *ca_meta = (GstVideoCodecAlphaMeta *) meta;
+
+  /* the buffer ownership is transfered to the Meta */
+  ca_meta->buffer = (GstBuffer *) params;
+
+  return TRUE;
+}
+
+static void
+gst_video_codec_alpha_meta_free (GstMeta * meta, GstBuffer * buffer)
+{
+  GstVideoCodecAlphaMeta *ca_meta = (GstVideoCodecAlphaMeta *) meta;
+  gst_clear_buffer (&ca_meta->buffer);
+}
+
+/**
+ * gst_video_codec_alpha_meta_get_info:
+ *
+ * Returns: #GstMetaInfo pointer that describes #GstVideoCodecAlphaMeta.
+ *
+ * Since: 1.20
+ */
+const GstMetaInfo *
+gst_video_codec_alpha_meta_get_info (void)
+{
+  static const GstMetaInfo *info = NULL;
+
+  if (g_once_init_enter ((GstMetaInfo **) & info)) {
+    const GstMetaInfo *meta =
+        gst_meta_register (GST_VIDEO_CODEC_ALPHA_META_API_TYPE,
+        "GstVideoCodecAlphaMeta",
+        sizeof (GstVideoCodecAlphaMeta),
+        gst_video_codec_alpha_meta_init,
+        gst_video_codec_alpha_meta_free,
+        gst_video_codec_alpha_meta_transform);
+    g_once_init_leave ((GstMetaInfo **) & info, (GstMetaInfo *) meta);
+  }
+
+  return info;
+}
+
+/**
+ * gst_buffer_add_video_codec_alpha_meta:
+ * @buffer: (transfer none): a #GstBuffer
+ * @alpha_buffer: (transfer full): a #GstBuffer
+ *
+ * Attaches a #GstVideoCodecAlphaMeta metadata to @buffer with
+ * the given alpha buffer.
+ *
+ * Returns: (transfer none): the #GstVideoCodecAlphaMeta on @buffer.
+ *
+ * Since: 1.20
+ */
+GstVideoCodecAlphaMeta *
+gst_buffer_add_video_codec_alpha_meta (GstBuffer * buffer,
+    GstBuffer * alpha_buffer)
+{
+  GstVideoCodecAlphaMeta *meta;
+
+  g_return_val_if_fail (buffer != NULL, NULL);
+  g_return_val_if_fail (alpha_buffer != NULL, NULL);
+
+  meta =
+      (GstVideoCodecAlphaMeta *) gst_buffer_add_meta (buffer,
+      GST_VIDEO_CODEC_ALPHA_META_INFO, alpha_buffer);
+
+  return meta;
+}
diff --git a/gst-libs/gst/video/gstvideocodecalphameta.h b/gst-libs/gst/video/gstvideocodecalphameta.h
new file mode 100644
index 0000000000..14e371c393
--- /dev/null
+++ b/gst-libs/gst/video/gstvideocodecalphameta.h
@@ -0,0 +1,88 @@
+/* GStreamer
+ * Copyright (C) 2021 Collabora Ltd.
+ *   Author: Nicolas Dufresne <nicolas.dufresne@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_VIDEO_CODEC_ALPHA_META_H__
+#define __GST_VIDEO_CODEC_ALPHA_META_H__
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GST_VIDEO_CODEC_ALPHA_META_API_TYPE:
+ *
+ * Since: 1.20
+ */
+#define GST_VIDEO_CODEC_ALPHA_META_API_TYPE (gst_video_codec_alpha_meta_api_get_type())
+
+/**
+ * GST_VIDEO_CODEC_ALPHA_META_INFO:
+ *
+ * Since: 1.20
+ */
+#define GST_VIDEO_CODEC_ALPHA_META_INFO  (gst_video_codec_alpha_meta_get_info())
+
+typedef struct _GstVideoCodecAlphaMeta GstVideoCodecAlphaMeta;
+
+/**
+ * GstVideoCodecAlphaMeta:
+ * @meta: parent #GstMeta
+ * @buffer: the encoded alpha frame
+ *
+ * Encapsulate an extra frame containing the encoded alpha channel for the
+ * currently negotiated CODEC. The streams must be of the same dimention as
+ * the original one.
+ *
+ * Since: 1.20
+ */
+struct _GstVideoCodecAlphaMeta
+{
+  GstMeta meta;
+
+  GstBuffer *buffer;
+};
+
+GST_VIDEO_API
+GType gst_video_codec_alpha_meta_api_get_type          (void);
+
+GST_VIDEO_API
+const GstMetaInfo *gst_video_codec_alpha_meta_get_info (void);
+
+/**
+ * gst_buffer_get_video_codec_alpha_meta:
+ * @b: A #GstBuffer pointer, must be writable.
+ *
+ * Helper macro to get #GstVideoCodecAlphaMeta from an existing #GstBuffer.
+ *
+ * Returns: (nullable): the #GstVideoCodecAlphaMeta pointer, or %NULL if none.
+ *
+ * Since: 1.20
+ */
+#define gst_buffer_get_video_codec_alpha_meta(b) \
+    ((GstVideoCodecAlphaMeta *)gst_buffer_get_meta((b),GST_VIDEO_CODEC_ALPHA_META_API_TYPE))
+
+GST_VIDEO_API
+GstVideoCodecAlphaMeta *gst_buffer_add_video_codec_alpha_meta (GstBuffer * buffer,
+                                                               GstBuffer * alpha_buffer);
+
+G_END_DECLS
+
+#endif /* __GST_VIDEO_CODEC_ALPHA_META_H__ */
diff --git a/gst-libs/gst/video/gstvideodecoder.c b/gst-libs/gst/video/gstvideodecoder.c
index 36f19de6df..016aa7dd9f 100644
--- a/gst-libs/gst/video/gstvideodecoder.c
+++ b/gst-libs/gst/video/gstvideodecoder.c
@@ -57,14 +57,29 @@
  *
  *   * Each input frame is provided in turn to the subclass' @handle_frame
  *     callback.
- *     The ownership of the frame is given to the @handle_frame callback.
+ *   * When the subclass enables the subframe mode with `gst_video_decoder_set_subframe_mode`,
+ *     the base class will provide to the subclass the same input frame with
+ *     different input buffers to the subclass @handle_frame
+ *     callback. During this call, the subclass needs to take
+ *     ownership of the input_buffer as @GstVideoCodecFrame.input_buffer
+ *     will have been changed before the next subframe buffer is received.
+ *     The subclass will call `gst_video_decoder_have_last_subframe`
+ *     when a new input frame can be created by the base class.
+ *     Every subframe will share the same @GstVideoCodecFrame.output_buffer
+ *     to write the decoding result. The subclass is responsible to protect
+ *     its access.
  *
  *   * If codec processing results in decoded data, the subclass should call
- *     @gst_video_decoder_finish_frame to have decoded data pushed.
- *     downstream. Otherwise, the subclass must call
- *     @gst_video_decoder_drop_frame, to allow the base class to do timestamp
- *     and offset tracking, and possibly to requeue the frame for a later
- *     attempt in the case of reverse playback.
+ *     @gst_video_decoder_finish_frame to have decoded data pushed
+ *     downstream. In subframe mode
+ *     the subclass should call @gst_video_decoder_finish_subframe until the
+ *     last subframe where it should call @gst_video_decoder_finish_frame.
+ *     The subclass can detect the last subframe using GST_VIDEO_BUFFER_FLAG_MARKER
+ *     on buffers or using its own logic to collect the subframes.
+ *     In case of decoding failure, the subclass must call
+ *     @gst_video_decoder_drop_frame or @gst_video_decoder_drop_subframe,
+ *     to allow the base class to do timestamp and offset tracking, and possibly
+ *     to requeue the frame for a later attempt in the case of reverse playback.
  *
  * ## Shutdown phase
  *
@@ -290,12 +305,25 @@ GST_DEBUG_CATEGORY (videodecoder_debug);
 /* properties */
 #define DEFAULT_QOS                 TRUE
 #define DEFAULT_MAX_ERRORS          GST_VIDEO_DECODER_MAX_ERRORS
+#define DEFAULT_MIN_FORCE_KEY_UNIT_INTERVAL 0
+#define DEFAULT_DISCARD_CORRUPTED_FRAMES FALSE
+#define DEFAULT_AUTOMATIC_REQUEST_SYNC_POINTS FALSE
+#define DEFAULT_AUTOMATIC_REQUEST_SYNC_POINT_FLAGS (GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT | GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT)
+
+/* Used for request_sync_point_frame_number. These are out of range for the
+ * frame numbers and can be given special meaning */
+#define REQUEST_SYNC_POINT_PENDING G_MAXUINT + 1
+#define REQUEST_SYNC_POINT_UNSET G_MAXUINT64
 
 enum
 {
   PROP_0,
   PROP_QOS,
   PROP_MAX_ERRORS,
+  PROP_MIN_FORCE_KEY_UNIT_INTERVAL,
+  PROP_DISCARD_CORRUPTED_FRAMES,
+  PROP_AUTOMATIC_REQUEST_SYNC_POINTS,
+  PROP_AUTOMATIC_REQUEST_SYNC_POINT_FLAGS,
 };
 
 struct _GstVideoDecoderPrivate
@@ -319,6 +347,9 @@ struct _GstVideoDecoderPrivate
   /* Whether input is considered packetized or not */
   gboolean packetized;
 
+  /* whether input is considered as subframes */
+  gboolean subframe_mode;
+
   /* Error handling */
   gint max_errors;
   gint error_count;
@@ -334,7 +365,7 @@ struct _GstVideoDecoderPrivate
   GstSegmentFlags decode_flags;
 
   /* ... being tracked here;
-   * only available during parsing */
+   * only available during parsing or when doing subframe decoding */
   GstVideoCodecFrame *current_frame;
   /* events that should apply to the current frame */
   /* FIXME 2.0: Use a GQueue or similar, see GstVideoCodecFrame::events */
@@ -375,9 +406,20 @@ struct _GstVideoDecoderPrivate
   /* combine with base_picture_number, framerate and calcs to yield (presentation) ts */
   GstClockTime base_timestamp;
 
-  /* FIXME : reorder_depth is never set */
-  int reorder_depth;
-  int distance_from_sync;
+  /* Properties */
+  GstClockTime min_force_key_unit_interval;
+  gboolean discard_corrupted_frames;
+
+  /* Key unit related state */
+  gboolean needs_sync_point;
+  GstVideoDecoderRequestSyncPointFlags request_sync_point_flags;
+  guint64 request_sync_point_frame_number;
+  GstClockTime last_force_key_unit_time;
+  /* -1 if we saw no sync point yet */
+  guint64 distance_from_sync;
+
+  gboolean automatic_request_sync_points;
+  GstVideoDecoderRequestSyncPointFlags automatic_request_sync_point_flags;
 
   guint32 system_frame_number;
   guint32 decode_frame_number;
@@ -404,6 +446,9 @@ struct _GstVideoDecoderPrivate
   gint64 min_latency;
   gint64 max_latency;
 
+  /* Tracks whether the latency message was posted at least once */
+  gboolean posted_latency_msg;
+
   /* upstream stream tags (global tags are passed through as-is) */
   GstTagList *upstream_tags;
 
@@ -494,6 +539,16 @@ static gboolean gst_video_decoder_src_query_default (GstVideoDecoder * decoder,
 static gboolean gst_video_decoder_transform_meta_default (GstVideoDecoder *
     decoder, GstVideoCodecFrame * frame, GstMeta * meta);
 
+static gboolean gst_video_decoder_handle_missing_data_default (GstVideoDecoder *
+    decoder, GstClockTime timestamp, GstClockTime duration);
+
+static void gst_video_decoder_copy_metas (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame, GstBuffer * src_buffer,
+    GstBuffer * dest_buffer);
+
+static void gst_video_decoder_request_sync_point_internal (GstVideoDecoder *
+    dec, GstClockTime deadline, GstVideoDecoderRequestSyncPointFlags flags);
+
 /* we can't use G_DEFINE_ABSTRACT_TYPE because we need the klass in the _init
  * method to get to the padtemplates */
 GType
@@ -564,6 +619,7 @@ gst_video_decoder_class_init (GstVideoDecoderClass * klass)
   klass->sink_query = gst_video_decoder_sink_query_default;
   klass->src_query = gst_video_decoder_src_query_default;
   klass->transform_meta = gst_video_decoder_transform_meta_default;
+  klass->handle_missing_data = gst_video_decoder_handle_missing_data_default;
 
   /**
    * GstVideoDecoder:qos:
@@ -594,6 +650,75 @@ gst_video_decoder_class_init (GstVideoDecoderClass * klass)
           -1, G_MAXINT, DEFAULT_MAX_ERRORS,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstVideoDecoder:min-force-key-unit-interval:
+   *
+   * Minimum interval between force-key-unit events sent upstream by the
+   * decoder. Setting this to 0 will cause every event to be handled, setting
+   * this to %GST_CLOCK_TIME_NONE will cause every event to be ignored.
+   *
+   * See gst_video_event_new_upstream_force_key_unit() for more details about
+   * force-key-unit events.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_MIN_FORCE_KEY_UNIT_INTERVAL,
+      g_param_spec_uint64 ("min-force-key-unit-interval",
+          "Minimum Force Keyunit Interval",
+          "Minimum interval between force-keyunit requests in nanoseconds", 0,
+          G_MAXUINT64, DEFAULT_MIN_FORCE_KEY_UNIT_INTERVAL,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVideoDecoder:discard-corrupted-frames:
+   *
+   * If set to %TRUE the decoder will discard frames that are marked as
+   * corrupted instead of outputting them.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_DISCARD_CORRUPTED_FRAMES,
+      g_param_spec_boolean ("discard-corrupted-frames",
+          "Discard Corrupted Frames",
+          "Discard frames marked as corrupted instead of outputting them",
+          DEFAULT_DISCARD_CORRUPTED_FRAMES,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVideoDecoder:automatic-request-sync-points:
+   *
+   * If set to %TRUE the decoder will automatically request sync points when
+   * it seems like a good idea, e.g. if the first frames are not key frames or
+   * if packet loss was reported by upstream.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_AUTOMATIC_REQUEST_SYNC_POINTS,
+      g_param_spec_boolean ("automatic-request-sync-points",
+          "Automatic Request Sync Points",
+          "Automatically request sync points when it would be useful",
+          DEFAULT_AUTOMATIC_REQUEST_SYNC_POINTS,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVideoDecoder:automatic-request-sync-point-flags:
+   *
+   * GstVideoDecoderRequestSyncPointFlags to use for the automatically
+   * requested sync points if `automatic-request-sync-points` is enabled.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_AUTOMATIC_REQUEST_SYNC_POINT_FLAGS,
+      g_param_spec_flags ("automatic-request-sync-point-flags",
+          "Automatic Request Sync Point Flags",
+          "Flags to use when automatically requesting sync points",
+          GST_TYPE_VIDEO_DECODER_REQUEST_SYNC_POINT_FLAGS,
+          DEFAULT_AUTOMATIC_REQUEST_SYNC_POINT_FLAGS,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   meta_tag_video_quark = g_quark_from_static_string (GST_META_TAG_VIDEO_STR);
 }
 
@@ -652,6 +777,11 @@ gst_video_decoder_init (GstVideoDecoder * decoder, GstVideoDecoderClass * klass)
   decoder->priv->min_latency = 0;
   decoder->priv->max_latency = 0;
 
+  decoder->priv->automatic_request_sync_points =
+      DEFAULT_AUTOMATIC_REQUEST_SYNC_POINTS;
+  decoder->priv->automatic_request_sync_point_flags =
+      DEFAULT_AUTOMATIC_REQUEST_SYNC_POINT_FLAGS;
+
   gst_video_decoder_reset (decoder, TRUE, TRUE);
 }
 
@@ -710,18 +840,8 @@ _new_output_state (GstVideoFormat fmt, GstVideoInterlaceMode interlace_mode,
     if (copy_interlace_mode)
       tgt->interlace_mode = ref->interlace_mode;
     tgt->flags = ref->flags;
-    /* only copy values that are not unknown so that we don't override the
-     * defaults. subclasses should really fill these in when they know. */
-    if (ref->chroma_site)
-      tgt->chroma_site = ref->chroma_site;
-    if (ref->colorimetry.range)
-      tgt->colorimetry.range = ref->colorimetry.range;
-    if (ref->colorimetry.matrix)
-      tgt->colorimetry.matrix = ref->colorimetry.matrix;
-    if (ref->colorimetry.transfer)
-      tgt->colorimetry.transfer = ref->colorimetry.transfer;
-    if (ref->colorimetry.primaries)
-      tgt->colorimetry.primaries = ref->colorimetry.primaries;
+    tgt->chroma_site = ref->chroma_site;
+    tgt->colorimetry = ref->colorimetry;
     GST_DEBUG ("reference par %d/%d fps %d/%d",
         ref->par_n, ref->par_d, ref->fps_n, ref->fps_d);
     tgt->par_n = ref->par_n;
@@ -866,6 +986,18 @@ gst_video_decoder_get_property (GObject * object, guint property_id,
     case PROP_MAX_ERRORS:
       g_value_set_int (value, gst_video_decoder_get_max_errors (dec));
       break;
+    case PROP_MIN_FORCE_KEY_UNIT_INTERVAL:
+      g_value_set_uint64 (value, priv->min_force_key_unit_interval);
+      break;
+    case PROP_DISCARD_CORRUPTED_FRAMES:
+      g_value_set_boolean (value, priv->discard_corrupted_frames);
+      break;
+    case PROP_AUTOMATIC_REQUEST_SYNC_POINTS:
+      g_value_set_boolean (value, priv->automatic_request_sync_points);
+      break;
+    case PROP_AUTOMATIC_REQUEST_SYNC_POINT_FLAGS:
+      g_value_set_flags (value, priv->automatic_request_sync_point_flags);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -886,6 +1018,18 @@ gst_video_decoder_set_property (GObject * object, guint property_id,
     case PROP_MAX_ERRORS:
       gst_video_decoder_set_max_errors (dec, g_value_get_int (value));
       break;
+    case PROP_MIN_FORCE_KEY_UNIT_INTERVAL:
+      priv->min_force_key_unit_interval = g_value_get_uint64 (value);
+      break;
+    case PROP_DISCARD_CORRUPTED_FRAMES:
+      priv->discard_corrupted_frames = g_value_get_boolean (value);
+      break;
+    case PROP_AUTOMATIC_REQUEST_SYNC_POINTS:
+      priv->automatic_request_sync_points = g_value_get_boolean (value);
+      break;
+    case PROP_AUTOMATIC_REQUEST_SYNC_POINT_FLAGS:
+      priv->automatic_request_sync_point_flags = g_value_get_flags (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
       break;
@@ -1166,14 +1310,43 @@ caps_error:
   }
 }
 
+static gboolean
+gst_video_decoder_handle_missing_data_default (GstVideoDecoder *
+    decoder, GstClockTime timestamp, GstClockTime duration)
+{
+  GstVideoDecoderPrivate *priv;
+
+  priv = decoder->priv;
+
+  if (priv->automatic_request_sync_points) {
+    GstClockTime deadline =
+        gst_segment_to_running_time (&decoder->input_segment, GST_FORMAT_TIME,
+        timestamp);
+
+    GST_DEBUG_OBJECT (decoder,
+        "Requesting sync point for missing data at running time %"
+        GST_TIME_FORMAT " timestamp %" GST_TIME_FORMAT " with duration %"
+        GST_TIME_FORMAT, GST_TIME_ARGS (deadline), GST_TIME_ARGS (timestamp),
+        GST_TIME_ARGS (duration));
+
+    gst_video_decoder_request_sync_point_internal (decoder, deadline,
+        priv->automatic_request_sync_point_flags);
+  }
+
+  return TRUE;
+}
+
 static gboolean
 gst_video_decoder_sink_event_default (GstVideoDecoder * decoder,
     GstEvent * event)
 {
+  GstVideoDecoderClass *decoder_class;
   GstVideoDecoderPrivate *priv;
   gboolean ret = FALSE;
   gboolean forward_immediate = FALSE;
 
+  decoder_class = GST_VIDEO_DECODER_GET_CLASS (decoder);
+
   priv = decoder->priv;
 
   switch (GST_EVENT_TYPE (event)) {
@@ -1216,7 +1389,7 @@ gst_video_decoder_sink_event_default (GstVideoDecoder * decoder,
       GstFlowReturn flow_ret = GST_FLOW_OK;
 
       GST_VIDEO_DECODER_STREAM_LOCK (decoder);
-      flow_ret = gst_video_decoder_drain_out (decoder, TRUE);
+      flow_ret = gst_video_decoder_drain_out (decoder, FALSE);
       GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
       ret = (flow_ret == GST_FLOW_OK);
 
@@ -1261,54 +1434,70 @@ gst_video_decoder_sink_event_default (GstVideoDecoder * decoder,
     }
     case GST_EVENT_GAP:
     {
+      GstClockTime timestamp, duration;
+      GstGapFlags gap_flags = 0;
       GstFlowReturn flow_ret = GST_FLOW_OK;
       gboolean needs_reconfigure = FALSE;
       GList *events;
       GList *frame_events;
 
-      GST_VIDEO_DECODER_STREAM_LOCK (decoder);
-      if (decoder->input_segment.flags & GST_SEEK_FLAG_TRICKMODE_KEY_UNITS)
-        flow_ret = gst_video_decoder_drain_out (decoder, FALSE);
-      ret = (flow_ret == GST_FLOW_OK);
+      gst_event_parse_gap (event, &timestamp, &duration);
+      gst_event_parse_gap_flags (event, &gap_flags);
 
-      /* Ensure we have caps before forwarding the event */
-      if (!decoder->priv->output_state) {
-        if (!gst_video_decoder_negotiate_default_caps (decoder)) {
-          GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
-          GST_ELEMENT_ERROR (decoder, STREAM, FORMAT, (NULL),
-              ("Decoder output not negotiated before GAP event."));
-          forward_immediate = TRUE;
-          break;
+      GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+      /* If this is not missing data, or the subclass does not handle it
+       * specifically, then drain out the decoder and forward the event
+       * directly. */
+      if ((gap_flags & GST_GAP_FLAG_MISSING_DATA) == 0
+          || !decoder_class->handle_missing_data
+          || decoder_class->handle_missing_data (decoder, timestamp,
+              duration)) {
+        if (decoder->input_segment.flags & GST_SEEK_FLAG_TRICKMODE_KEY_UNITS)
+          flow_ret = gst_video_decoder_drain_out (decoder, FALSE);
+        ret = (flow_ret == GST_FLOW_OK);
+
+        /* Ensure we have caps before forwarding the event */
+        if (!decoder->priv->output_state) {
+          if (!gst_video_decoder_negotiate_default_caps (decoder)) {
+            GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+            GST_ELEMENT_ERROR (decoder, STREAM, FORMAT, (NULL),
+                ("Decoder output not negotiated before GAP event."));
+            forward_immediate = TRUE;
+            break;
+          }
+          needs_reconfigure = TRUE;
         }
-        needs_reconfigure = TRUE;
-      }
 
-      needs_reconfigure = gst_pad_check_reconfigure (decoder->srcpad)
-          || needs_reconfigure;
-      if (decoder->priv->output_state_changed || needs_reconfigure) {
-        if (!gst_video_decoder_negotiate_unlocked (decoder)) {
-          GST_WARNING_OBJECT (decoder, "Failed to negotiate with downstream");
-          gst_pad_mark_reconfigure (decoder->srcpad);
+        needs_reconfigure = gst_pad_check_reconfigure (decoder->srcpad)
+            || needs_reconfigure;
+        if (decoder->priv->output_state_changed || needs_reconfigure) {
+          if (!gst_video_decoder_negotiate_unlocked (decoder)) {
+            GST_WARNING_OBJECT (decoder, "Failed to negotiate with downstream");
+            gst_pad_mark_reconfigure (decoder->srcpad);
+          }
         }
-      }
 
-      GST_DEBUG_OBJECT (decoder, "Pushing all pending serialized events"
-          " before the gap");
-      events = decoder->priv->pending_events;
-      frame_events = decoder->priv->current_frame_events;
-      decoder->priv->pending_events = NULL;
-      decoder->priv->current_frame_events = NULL;
+        GST_DEBUG_OBJECT (decoder, "Pushing all pending serialized events"
+            " before the gap");
+        events = decoder->priv->pending_events;
+        frame_events = decoder->priv->current_frame_events;
+        decoder->priv->pending_events = NULL;
+        decoder->priv->current_frame_events = NULL;
 
-      GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+        GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
 
-      gst_video_decoder_push_event_list (decoder, events);
-      gst_video_decoder_push_event_list (decoder, frame_events);
+        gst_video_decoder_push_event_list (decoder, events);
+        gst_video_decoder_push_event_list (decoder, frame_events);
 
-      /* Forward GAP immediately. Everything is drained after
-       * the GAP event and we can forward this event immediately
-       * now without having buffers out of order.
-       */
-      forward_immediate = TRUE;
+        /* Forward GAP immediately. Everything is drained after
+         * the GAP event and we can forward this event immediately
+         * now without having buffers out of order.
+         */
+        forward_immediate = TRUE;
+      } else {
+        GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+        gst_clear_event (&event);
+      }
       break;
     }
     case GST_EVENT_CUSTOM_DOWNSTREAM:
@@ -1850,8 +2039,8 @@ gst_video_decoder_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
 /**
  * gst_video_decoder_proxy_getcaps:
  * @decoder: a #GstVideoDecoder
- * @caps: (allow-none): initial caps
- * @filter: (allow-none): filter caps
+ * @caps: (nullable): initial caps
+ * @filter: (nullable): filter caps
  *
  * Returns caps that express @caps (or sink template caps if @caps == NULL)
  * restricted to resolution/format/... combinations supported by downstream
@@ -2045,6 +2234,12 @@ gst_video_decoder_add_buffer_info (GstVideoDecoder * decoder,
   ts->flags = GST_BUFFER_FLAGS (buffer);
 
   g_queue_push_tail (&priv->timestamps, ts);
+
+  if (g_queue_get_length (&priv->timestamps) > 40) {
+    GST_WARNING_OBJECT (decoder,
+        "decoder timestamp list getting long: %d timestamps,"
+        "possible internal leaking?", g_queue_get_length (&priv->timestamps));
+  }
 }
 
 static void
@@ -2089,18 +2284,6 @@ gst_video_decoder_get_buffer_info_at_offset (GstVideoDecoder *
       GST_TIME_ARGS (*pts), GST_TIME_ARGS (*dts), *flags, got_offset, offset);
 }
 
-#if !GLIB_CHECK_VERSION(2, 60, 0)
-#define g_queue_clear_full queue_clear_full
-static void
-queue_clear_full (GQueue * queue, GDestroyNotify free_func)
-{
-  gpointer data;
-
-  while ((data = g_queue_pop_head (queue)) != NULL)
-    free_func (data);
-}
-#endif
-
 static void
 gst_video_decoder_clear_queues (GstVideoDecoder * dec)
 {
@@ -2158,7 +2341,12 @@ gst_video_decoder_reset (GstVideoDecoder * decoder, gboolean full,
     priv->earliest_time = GST_CLOCK_TIME_NONE;
     priv->proportion = 0.5;
     priv->decode_flags_override = FALSE;
+
+    priv->request_sync_point_flags = 0;
+    priv->request_sync_point_frame_number = REQUEST_SYNC_POINT_UNSET;
+    priv->last_force_key_unit_time = GST_CLOCK_TIME_NONE;
     GST_OBJECT_UNLOCK (decoder);
+    priv->distance_from_sync = -1;
   }
 
   if (full) {
@@ -2187,6 +2375,8 @@ gst_video_decoder_reset (GstVideoDecoder * decoder, gboolean full,
     priv->dropped = 0;
     priv->processed = 0;
 
+    priv->posted_latency_msg = FALSE;
+
     priv->decode_frame_number = 0;
     priv->base_picture_number = 0;
 
@@ -2257,22 +2447,43 @@ gst_video_decoder_chain_forward (GstVideoDecoder * decoder,
   priv->input_offset += gst_buffer_get_size (buf);
 
   if (priv->packetized) {
+    GstVideoCodecFrame *frame;
     gboolean was_keyframe = FALSE;
+
+    frame = priv->current_frame;
+
+    frame->abidata.ABI.num_subframes++;
+    if (gst_video_decoder_get_subframe_mode (decoder)) {
+      /* End the frame if the marker flag is set */
+      if (!GST_BUFFER_FLAG_IS_SET (buf, GST_VIDEO_BUFFER_FLAG_MARKER)
+          && (decoder->input_segment.rate > 0.0))
+        priv->current_frame = gst_video_codec_frame_ref (frame);
+      else
+        priv->current_frame = NULL;
+    } else {
+      priv->current_frame = frame;
+    }
+
     if (!GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT)) {
       was_keyframe = TRUE;
-      GST_LOG_OBJECT (decoder, "Marking current_frame as sync point");
-      GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (priv->current_frame);
+      GST_DEBUG_OBJECT (decoder, "Marking current_frame as sync point");
+      GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (frame);
     }
 
-    priv->current_frame->input_buffer = buf;
+    if (frame->input_buffer) {
+      gst_video_decoder_copy_metas (decoder, frame, frame->input_buffer, buf);
+      gst_buffer_unref (frame->input_buffer);
+    }
+    frame->input_buffer = buf;
 
     if (decoder->input_segment.rate < 0.0) {
-      priv->parse_gather =
-          g_list_prepend (priv->parse_gather, priv->current_frame);
+      priv->parse_gather = g_list_prepend (priv->parse_gather, frame);
+      priv->current_frame = NULL;
     } else {
-      ret = gst_video_decoder_decode_frame (decoder, priv->current_frame);
+      ret = gst_video_decoder_decode_frame (decoder, frame);
+      if (!gst_video_decoder_get_subframe_mode (decoder))
+        priv->current_frame = NULL;
     }
-    priv->current_frame = NULL;
     /* If in trick mode and it was a keyframe, drain decoder to avoid extra
      * latency. Only do this for forwards playback as reverse playback handles
      * draining on keyframes in flush_parse(), and would otherwise call back
@@ -2301,13 +2512,37 @@ gst_video_decoder_flush_decode (GstVideoDecoder * dec)
   GstVideoDecoderPrivate *priv = dec->priv;
   GstFlowReturn res = GST_FLOW_OK;
   GList *walk;
-
+  GstVideoCodecFrame *current_frame = NULL;
+  gboolean last_subframe;
   GST_DEBUG_OBJECT (dec, "flushing buffers to decode");
 
   walk = priv->decode;
   while (walk) {
     GList *next;
     GstVideoCodecFrame *frame = (GstVideoCodecFrame *) (walk->data);
+    last_subframe = TRUE;
+    /* In subframe mode, we need to get rid of intermediary frames
+     * created during the buffer gather stage. That's why that we keep a current
+     * frame as the main frame and drop all the frame afterwhile until the end
+     * of the subframes batch.
+     * */
+    if (gst_video_decoder_get_subframe_mode (dec)) {
+      if (current_frame == NULL) {
+        current_frame = gst_video_codec_frame_ref (frame);
+      } else {
+        if (current_frame->input_buffer) {
+          gst_video_decoder_copy_metas (dec, current_frame,
+              current_frame->input_buffer, current_frame->output_buffer);
+          gst_buffer_unref (current_frame->input_buffer);
+        }
+        current_frame->input_buffer = gst_buffer_ref (frame->input_buffer);
+        gst_video_codec_frame_unref (frame);
+      }
+      last_subframe = GST_BUFFER_FLAG_IS_SET (current_frame->input_buffer,
+          GST_VIDEO_BUFFER_FLAG_MARKER);
+    } else {
+      current_frame = frame;
+    }
 
     GST_DEBUG_OBJECT (dec, "decoding frame %p buffer %p, PTS %" GST_TIME_FORMAT
         ", DTS %" GST_TIME_FORMAT, frame, frame->input_buffer,
@@ -2319,10 +2554,12 @@ gst_video_decoder_flush_decode (GstVideoDecoder * dec)
     priv->decode = g_list_delete_link (priv->decode, walk);
 
     /* decode buffer, resulting data prepended to queue */
-    res = gst_video_decoder_decode_frame (dec, frame);
+    res = gst_video_decoder_decode_frame (dec, current_frame);
     if (res != GST_FLOW_OK)
       break;
-
+    if (!gst_video_decoder_get_subframe_mode (dec)
+        || last_subframe)
+      current_frame = NULL;
     walk = next;
   }
 
@@ -2751,9 +2988,9 @@ gst_video_decoder_prepare_finish_frame (GstVideoDecoder *
   sync = GST_VIDEO_CODEC_FRAME_IS_SYNC_POINT (frame);
 
   GST_LOG_OBJECT (decoder,
-      "finish frame %p (#%d) sync:%d PTS:%" GST_TIME_FORMAT " DTS:%"
+      "finish frame %p (#%d)(sub=#%d) sync:%d PTS:%" GST_TIME_FORMAT " DTS:%"
       GST_TIME_FORMAT,
-      frame, frame->system_frame_number,
+      frame, frame->system_frame_number, frame->abidata.ABI.num_subframes,
       sync, GST_TIME_ARGS (frame->pts), GST_TIME_ARGS (frame->dts));
 
   /* Push all pending events that arrived before this frame */
@@ -2891,11 +3128,17 @@ gst_video_decoder_prepare_finish_frame (GstVideoDecoder *
     if (frame->duration != GST_CLOCK_TIME_NONE) {
       if (GST_CLOCK_TIME_IS_VALID (priv->last_timestamp_out))
         frame->pts = priv->last_timestamp_out + frame->duration;
-      else if (decoder->output_segment.rate > 0.0)
+      else if (frame->dts != GST_CLOCK_TIME_NONE) {
+        frame->pts = frame->dts;
+        GST_LOG_OBJECT (decoder,
+            "Setting DTS as PTS %" GST_TIME_FORMAT " for frame...",
+            GST_TIME_ARGS (frame->pts));
+      } else if (decoder->output_segment.rate > 0.0)
         frame->pts = decoder->output_segment.start;
-      GST_LOG_OBJECT (decoder,
-          "Guessing timestamp %" GST_TIME_FORMAT " for frame...",
-          GST_TIME_ARGS (frame->pts));
+      GST_INFO_OBJECT (decoder,
+          "Guessing PTS=%" GST_TIME_FORMAT " for frame... DTS=%"
+          GST_TIME_FORMAT, GST_TIME_ARGS (frame->pts),
+          GST_TIME_ARGS (frame->dts));
     } else if (sync && frame->dts != GST_CLOCK_TIME_NONE) {
       frame->pts = frame->dts;
       GST_LOG_OBJECT (decoder,
@@ -3011,6 +3254,10 @@ gst_video_decoder_drop_frame (GstVideoDecoder * dec, GstVideoCodecFrame * frame)
 {
   GST_LOG_OBJECT (dec, "drop frame %p", frame);
 
+  if (gst_video_decoder_get_subframe_mode (dec))
+    GST_DEBUG_OBJECT (dec, "Drop subframe %d. Must be the last one.",
+        frame->abidata.ABI.num_subframes);
+
   GST_VIDEO_DECODER_STREAM_LOCK (dec);
 
   gst_video_decoder_prepare_finish_frame (dec, frame, TRUE);
@@ -3023,6 +3270,41 @@ gst_video_decoder_drop_frame (GstVideoDecoder * dec, GstVideoCodecFrame * frame)
   /* now free the frame */
   gst_video_decoder_release_frame (dec, frame);
 
+  /* store that we have valid decoded data */
+  dec->priv->had_output_data = TRUE;
+
+  GST_VIDEO_DECODER_STREAM_UNLOCK (dec);
+
+  return GST_FLOW_OK;
+}
+
+/**
+ * gst_video_decoder_drop_subframe:
+ * @dec: a #GstVideoDecoder
+ * @frame: (transfer full): the #GstVideoCodecFrame
+ *
+ * Drops input data.
+ * The frame is not considered finished until the whole frame
+ * is finished or dropped by the subclass.
+ *
+ * Returns: a #GstFlowReturn, usually GST_FLOW_OK.
+ *
+ * Since: 1.20
+ */
+GstFlowReturn
+gst_video_decoder_drop_subframe (GstVideoDecoder * dec,
+    GstVideoCodecFrame * frame)
+{
+  g_return_val_if_fail (gst_video_decoder_get_subframe_mode (dec),
+      GST_FLOW_NOT_SUPPORTED);
+
+  GST_LOG_OBJECT (dec, "drop subframe %p num=%d", frame->input_buffer,
+      gst_video_decoder_get_input_subframe_index (dec, frame));
+
+  GST_VIDEO_DECODER_STREAM_LOCK (dec);
+
+  gst_video_codec_frame_unref (frame);
+
   GST_VIDEO_DECODER_STREAM_UNLOCK (dec);
 
   return GST_FLOW_OK;
@@ -3059,6 +3341,7 @@ typedef struct
 {
   GstVideoDecoder *decoder;
   GstVideoCodecFrame *frame;
+  GstBuffer *buffer;
 } CopyMetaData;
 
 static gboolean
@@ -3068,10 +3351,12 @@ foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
   GstVideoDecoder *decoder = data->decoder;
   GstVideoDecoderClass *klass = GST_VIDEO_DECODER_GET_CLASS (decoder);
   GstVideoCodecFrame *frame = data->frame;
+  GstBuffer *buffer = data->buffer;
   const GstMetaInfo *info = (*meta)->info;
   gboolean do_copy = FALSE;
 
-  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)) {
+  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)
+      || gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory_reference)) {
     /* never call the transform_meta with memory specific metadata */
     GST_DEBUG_OBJECT (decoder, "not copying memory specific metadata %s",
         g_type_name (info->api));
@@ -3088,12 +3373,34 @@ foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
     GstMetaTransformCopy copy_data = { FALSE, 0, -1 };
     GST_DEBUG_OBJECT (decoder, "copy metadata %s", g_type_name (info->api));
     /* simply copy then */
-    info->transform_func (frame->output_buffer, *meta, inbuf,
-        _gst_meta_transform_copy, &copy_data);
+
+    info->transform_func (buffer, *meta, inbuf, _gst_meta_transform_copy,
+        &copy_data);
   }
   return TRUE;
 }
 
+static void
+gst_video_decoder_copy_metas (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame, GstBuffer * src_buffer, GstBuffer * dest_buffer)
+{
+  GstVideoDecoderClass *decoder_class = GST_VIDEO_DECODER_GET_CLASS (decoder);
+
+  if (decoder_class->transform_meta) {
+    if (G_LIKELY (frame)) {
+      CopyMetaData data;
+
+      data.decoder = decoder;
+      data.frame = frame;
+      data.buffer = dest_buffer;
+      gst_buffer_foreach_meta (src_buffer, foreach_metadata, &data);
+    } else {
+      GST_WARNING_OBJECT (decoder,
+          "Can't copy metadata because input frame disappeared");
+    }
+  }
+}
+
 /**
  * gst_video_decoder_finish_frame:
  * @decoder: a #GstVideoDecoder
@@ -3115,7 +3422,6 @@ gst_video_decoder_finish_frame (GstVideoDecoder * decoder,
     GstVideoCodecFrame * frame)
 {
   GstFlowReturn ret = GST_FLOW_OK;
-  GstVideoDecoderClass *decoder_class = GST_VIDEO_DECODER_GET_CLASS (decoder);
   GstVideoDecoderPrivate *priv = decoder->priv;
   GstBuffer *output_buffer;
   gboolean needs_reconfigure = FALSE;
@@ -3153,7 +3459,40 @@ gst_video_decoder_finish_frame (GstVideoDecoder * decoder,
 
   /* no buffer data means this frame is skipped */
   if (!frame->output_buffer || GST_VIDEO_CODEC_FRAME_IS_DECODE_ONLY (frame)) {
-    GST_DEBUG_OBJECT (decoder, "skipping frame %" GST_TIME_FORMAT,
+    GST_DEBUG_OBJECT (decoder,
+        "skipping frame %" GST_TIME_FORMAT " because not output was produced",
+        GST_TIME_ARGS (frame->pts));
+    goto done;
+  }
+
+  /* Mark output as corrupted if the subclass requested so and we're either
+   * still before the sync point after the request, or we don't even know the
+   * frame number of the sync point yet (it is 0) */
+  GST_OBJECT_LOCK (decoder);
+  if (frame->system_frame_number <= priv->request_sync_point_frame_number
+      && priv->request_sync_point_frame_number != REQUEST_SYNC_POINT_UNSET) {
+    if (priv->request_sync_point_flags &
+        GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT) {
+      GST_DEBUG_OBJECT (decoder,
+          "marking frame %" GST_TIME_FORMAT
+          " as corrupted because it is still before the sync point",
+          GST_TIME_ARGS (frame->pts));
+      GST_VIDEO_CODEC_FRAME_FLAG_SET (frame,
+          GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED);
+    }
+  } else {
+    /* Reset to -1 to mark it as unset now that we've reached the frame */
+    priv->request_sync_point_frame_number = REQUEST_SYNC_POINT_UNSET;
+  }
+  GST_OBJECT_UNLOCK (decoder);
+
+  if (priv->discard_corrupted_frames
+      && (GST_VIDEO_CODEC_FRAME_FLAG_IS_SET (frame,
+              GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED)
+          || GST_BUFFER_FLAG_IS_SET (frame->output_buffer,
+              GST_BUFFER_FLAG_CORRUPTED))) {
+    GST_DEBUG_OBJECT (decoder,
+        "skipping frame %" GST_TIME_FORMAT " because it is corrupted",
         GST_TIME_ARGS (frame->pts));
     goto done;
   }
@@ -3175,19 +3514,17 @@ gst_video_decoder_finish_frame (GstVideoDecoder * decoder,
     GST_BUFFER_FLAG_SET (output_buffer, GST_BUFFER_FLAG_DISCONT);
   }
 
-  if (decoder_class->transform_meta) {
-    if (G_LIKELY (frame->input_buffer)) {
-      CopyMetaData data;
-
-      data.decoder = decoder;
-      data.frame = frame;
-      gst_buffer_foreach_meta (frame->input_buffer, foreach_metadata, &data);
-    } else {
-      GST_WARNING_OBJECT (decoder,
-          "Can't copy metadata because input frame disappeared");
-    }
+  if (GST_VIDEO_CODEC_FRAME_FLAG_IS_SET (frame,
+          GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED)) {
+    GST_DEBUG_OBJECT (decoder,
+        "marking frame %" GST_TIME_FORMAT " as corrupted",
+        GST_TIME_ARGS (frame->pts));
+    GST_BUFFER_FLAG_SET (output_buffer, GST_BUFFER_FLAG_CORRUPTED);
   }
 
+  gst_video_decoder_copy_metas (decoder, frame, frame->input_buffer,
+      frame->output_buffer);
+
   /* Get an additional ref to the buffer, which is going to be pushed
    * downstream, the original ref is owned by the frame
    */
@@ -3215,6 +3552,39 @@ done:
   return ret;
 }
 
+/**
+ * gst_video_decoder_finish_subframe:
+ * @decoder: a #GstVideoDecoder
+ * @frame: (transfer full): the #GstVideoCodecFrame
+ *
+ * Indicate that a subframe has been finished to be decoded
+ * by the subclass. This method should be called for all subframes
+ * except the last subframe where @gst_video_decoder_finish_frame
+ * should be called instead.
+ *
+ * Returns: a #GstFlowReturn, usually GST_FLOW_OK.
+ *
+ * Since: 1.20
+ */
+GstFlowReturn
+gst_video_decoder_finish_subframe (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame)
+{
+  g_return_val_if_fail (gst_video_decoder_get_subframe_mode (decoder),
+      GST_FLOW_NOT_SUPPORTED);
+
+  GST_LOG_OBJECT (decoder, "finish subframe %p num=%d", frame->input_buffer,
+      gst_video_decoder_get_input_subframe_index (decoder, frame));
+
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+  frame->abidata.ABI.subframes_processed++;
+  gst_video_codec_frame_unref (frame);
+
+  GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+
+  return GST_FLOW_OK;
+}
+
 /* With stream lock, takes the frame reference */
 static GstFlowReturn
 gst_video_decoder_clip_and_push_buf (GstVideoDecoder * decoder, GstBuffer * buf)
@@ -3351,7 +3721,7 @@ gst_video_decoder_clip_and_push_buf (GstVideoDecoder * decoder, GstBuffer * buf)
   }
 #endif
 
-  /* release STREAM_LOCK not to block upstream 
+  /* release STREAM_LOCK not to block upstream
    * while pushing buffer downstream */
   GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
   ret = gst_pad_push (decoder->srcpad, buf);
@@ -3471,6 +3841,11 @@ gst_video_decoder_have_frame (GstVideoDecoder * decoder)
     buffer = gst_buffer_new_and_alloc (0);
   }
 
+  if (priv->current_frame->input_buffer) {
+    gst_video_decoder_copy_metas (decoder, priv->current_frame,
+        priv->current_frame->input_buffer, buffer);
+    gst_buffer_unref (priv->current_frame->input_buffer);
+  }
   priv->current_frame->input_buffer = buffer;
 
   gst_video_decoder_get_buffer_info_at_offset (decoder,
@@ -3487,20 +3862,36 @@ gst_video_decoder_have_frame (GstVideoDecoder * decoder)
       GST_TIME_ARGS (duration));
 
   if (!GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT)) {
-    GST_LOG_OBJECT (decoder, "Marking as sync point");
+    GST_DEBUG_OBJECT (decoder, "Marking as sync point");
     GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (priv->current_frame);
   }
 
+  if (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_CORRUPTED)) {
+    GST_DEBUG_OBJECT (decoder, "Marking as corrupted");
+    GST_VIDEO_CODEC_FRAME_FLAG_SET (priv->current_frame,
+        GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED);
+  }
+
   /* In reverse playback, just capture and queue frames for later processing */
   if (decoder->input_segment.rate < 0.0) {
     priv->parse_gather =
         g_list_prepend (priv->parse_gather, priv->current_frame);
+    priv->current_frame = NULL;
   } else {
-    /* Otherwise, decode the frame, which gives away our ref */
-    ret = gst_video_decoder_decode_frame (decoder, priv->current_frame);
+    GstVideoCodecFrame *frame = priv->current_frame;
+    frame->abidata.ABI.num_subframes++;
+    /* In subframe mode, we keep a ref for ourselves
+     * as this frame will be kept during the data collection
+     * in parsed mode. The frame reference will be released by
+     * finish_(sub)frame or drop_(sub)frame.*/
+    if (gst_video_decoder_get_subframe_mode (decoder))
+      gst_video_codec_frame_ref (priv->current_frame);
+    else
+      priv->current_frame = NULL;
+
+    /* Decode the frame, which gives away our ref */
+    ret = gst_video_decoder_decode_frame (decoder, frame);
   }
-  /* Current frame is gone now, either way */
-  priv->current_frame = NULL;
 
   GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
 
@@ -3523,46 +3914,89 @@ gst_video_decoder_decode_frame (GstVideoDecoder * decoder,
   /* FIXME : This should only have to be checked once (either the subclass has an
    * implementation, or it doesn't) */
   g_return_val_if_fail (decoder_class->handle_frame != NULL, GST_FLOW_ERROR);
+  g_return_val_if_fail (frame != NULL, GST_FLOW_ERROR);
 
-  frame->distance_from_sync = priv->distance_from_sync;
-  priv->distance_from_sync++;
   frame->pts = GST_BUFFER_PTS (frame->input_buffer);
   frame->dts = GST_BUFFER_DTS (frame->input_buffer);
   frame->duration = GST_BUFFER_DURATION (frame->input_buffer);
+  frame->deadline =
+      gst_segment_to_running_time (&decoder->input_segment, GST_FORMAT_TIME,
+      frame->pts);
 
   /* For keyframes, PTS = DTS + constant_offset, usually 0 to 3 frame
    * durations. */
   /* FIXME upstream can be quite wrong about the keyframe aspect,
    * so we could be going off here as well,
    * maybe let subclass decide if it really is/was a keyframe */
-  if (GST_VIDEO_CODEC_FRAME_IS_SYNC_POINT (frame) &&
-      GST_CLOCK_TIME_IS_VALID (frame->pts)
-      && GST_CLOCK_TIME_IS_VALID (frame->dts)) {
-    /* just in case they are not equal as might ideally be,
-     * e.g. quicktime has a (positive) delta approach */
-    priv->pts_delta = frame->pts - frame->dts;
-    GST_DEBUG_OBJECT (decoder, "PTS delta %d ms",
-        (gint) (priv->pts_delta / GST_MSECOND));
+  if (GST_VIDEO_CODEC_FRAME_IS_SYNC_POINT (frame)) {
+    priv->distance_from_sync = 0;
+
+    GST_OBJECT_LOCK (decoder);
+    priv->request_sync_point_flags &=
+        ~GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT;
+    if (priv->request_sync_point_frame_number == REQUEST_SYNC_POINT_PENDING)
+      priv->request_sync_point_frame_number = frame->system_frame_number;
+    GST_OBJECT_UNLOCK (decoder);
+
+    if (GST_CLOCK_TIME_IS_VALID (frame->pts)
+        && GST_CLOCK_TIME_IS_VALID (frame->dts)) {
+      /* just in case they are not equal as might ideally be,
+       * e.g. quicktime has a (positive) delta approach */
+      priv->pts_delta = frame->pts - frame->dts;
+      GST_DEBUG_OBJECT (decoder, "PTS delta %d ms",
+          (gint) (priv->pts_delta / GST_MSECOND));
+    }
+  } else {
+    if (priv->distance_from_sync == -1 && priv->automatic_request_sync_points) {
+      GST_DEBUG_OBJECT (decoder,
+          "Didn't receive a keyframe yet, requesting sync point");
+      gst_video_decoder_request_sync_point (decoder, frame,
+          priv->automatic_request_sync_point_flags);
+    }
+
+    GST_OBJECT_LOCK (decoder);
+    if ((priv->needs_sync_point && priv->distance_from_sync == -1)
+        || (priv->request_sync_point_flags &
+            GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT)) {
+      GST_WARNING_OBJECT (decoder,
+          "Subclass requires a sync point but we didn't receive one yet, discarding input");
+      GST_OBJECT_UNLOCK (decoder);
+      if (priv->automatic_request_sync_points) {
+        gst_video_decoder_request_sync_point (decoder, frame,
+            priv->automatic_request_sync_point_flags);
+      }
+      gst_video_decoder_release_frame (decoder, frame);
+      return GST_FLOW_OK;
+    }
+    GST_OBJECT_UNLOCK (decoder);
+
+    priv->distance_from_sync++;
   }
 
-  frame->abidata.ABI.ts = frame->dts;
-  frame->abidata.ABI.ts2 = frame->pts;
+  frame->distance_from_sync = priv->distance_from_sync;
 
-  GST_LOG_OBJECT (decoder, "PTS %" GST_TIME_FORMAT ", DTS %" GST_TIME_FORMAT
-      ", dist %d", GST_TIME_ARGS (frame->pts), GST_TIME_ARGS (frame->dts),
-      frame->distance_from_sync);
+  if (frame->abidata.ABI.num_subframes == 1) {
+    frame->abidata.ABI.ts = frame->dts;
+    frame->abidata.ABI.ts2 = frame->pts;
+  }
 
-  g_queue_push_tail (&priv->frames, gst_video_codec_frame_ref (frame));
+  GST_LOG_OBJECT (decoder,
+      "frame %p PTS %" GST_TIME_FORMAT ", DTS %" GST_TIME_FORMAT ", dist %d",
+      frame, GST_TIME_ARGS (frame->pts), GST_TIME_ARGS (frame->dts),
+      frame->distance_from_sync);
+  /* FIXME: suboptimal way to add a unique frame to the list, in case of subframe mode. */
+  if (!g_queue_find (&priv->frames, frame)) {
+    g_queue_push_tail (&priv->frames, gst_video_codec_frame_ref (frame));
+  } else {
+    GST_LOG_OBJECT (decoder,
+        "Do not add an existing frame used to decode subframes");
+  }
 
   if (priv->frames.length > 10) {
     GST_DEBUG_OBJECT (decoder, "decoder frame list getting long: %d frames,"
         "possible internal leaking?", priv->frames.length);
   }
 
-  frame->deadline =
-      gst_segment_to_running_time (&decoder->input_segment, GST_FORMAT_TIME,
-      frame->pts);
-
   /* do something with frame */
   ret = decoder_class->handle_frame (decoder, frame);
   if (ret != GST_FLOW_OK)
@@ -3580,7 +4014,7 @@ gst_video_decoder_decode_frame (GstVideoDecoder * decoder,
  *
  * Get the #GstVideoCodecState currently describing the output stream.
  *
- * Returns: (transfer full): #GstVideoCodecState describing format of video data.
+ * Returns: (transfer full) (nullable): #GstVideoCodecState describing format of video data.
  */
 GstVideoCodecState *
 gst_video_decoder_get_output_state (GstVideoDecoder * decoder)
@@ -3648,7 +4082,7 @@ _set_interlaced_output_state (GstVideoDecoder * decoder,
  * @fmt: a #GstVideoFormat
  * @width: The width in pixels
  * @height: The height in pixels
- * @reference: (allow-none) (transfer none): An optional reference #GstVideoCodecState
+ * @reference: (nullable) (transfer none): An optional reference #GstVideoCodecState
  *
  * Creates a new #GstVideoCodecState with the specified @fmt, @width and @height
  * as the output state for the decoder.
@@ -3665,7 +4099,7 @@ _set_interlaced_output_state (GstVideoDecoder * decoder,
  * The new output state will only take effect (set on pads and buffers) starting
  * from the next call to #gst_video_decoder_finish_frame().
  *
- * Returns: (transfer full): the newly configured output state.
+ * Returns: (transfer full) (nullable): the newly configured output state.
  */
 GstVideoCodecState *
 gst_video_decoder_set_output_state (GstVideoDecoder * decoder,
@@ -3683,12 +4117,12 @@ gst_video_decoder_set_output_state (GstVideoDecoder * decoder,
  * @width: The width in pixels
  * @height: The height in pixels
  * @interlace_mode: A #GstVideoInterlaceMode
- * @reference: (allow-none) (transfer none): An optional reference #GstVideoCodecState
+ * @reference: (nullable) (transfer none): An optional reference #GstVideoCodecState
  *
  * Same as #gst_video_decoder_set_output_state() but also allows you to also set
  * the interlacing mode.
  *
- * Returns: (transfer full): the newly configured output state.
+ * Returns: (transfer full) (nullable): the newly configured output state.
  *
  * Since: 1.16.
  */
@@ -3708,7 +4142,7 @@ gst_video_decoder_set_interlaced_output_state (GstVideoDecoder * decoder,
  *
  * Get the oldest pending unfinished #GstVideoCodecFrame
  *
- * Returns: (transfer full): oldest pending unfinished #GstVideoCodecFrame.
+ * Returns: (transfer full) (nullable): oldest pending unfinished #GstVideoCodecFrame.
  */
 GstVideoCodecFrame *
 gst_video_decoder_get_oldest_frame (GstVideoDecoder * decoder)
@@ -3730,7 +4164,7 @@ gst_video_decoder_get_oldest_frame (GstVideoDecoder * decoder)
  *
  * Get a pending unfinished #GstVideoCodecFrame
  *
- * Returns: (transfer full): pending unfinished #GstVideoCodecFrame identified by @frame_number.
+ * Returns: (transfer full) (nullable): pending unfinished #GstVideoCodecFrame identified by @frame_number.
  */
 GstVideoCodecFrame *
 gst_video_decoder_get_frame (GstVideoDecoder * decoder, int frame_number)
@@ -4139,7 +4573,7 @@ gst_video_decoder_negotiate (GstVideoDecoder * decoder)
  * You should use gst_video_decoder_allocate_output_frame() instead of this
  * function, if possible at all.
  *
- * Returns: (transfer full): allocated buffer, or NULL if no buffer could be
+ * Returns: (transfer full) (nullable): allocated buffer, or NULL if no buffer could be
  *     allocated (e.g. when downstream is flushing or shutting down)
  */
 GstBuffer *
@@ -4483,6 +4917,123 @@ gst_video_decoder_get_packetized (GstVideoDecoder * decoder)
   return decoder->priv->packetized;
 }
 
+/**
+ * gst_video_decoder_have_last_subframe:
+ * @decoder: a #GstVideoDecoder
+ * @frame: (transfer none): the #GstVideoCodecFrame to update
+ *
+ * Indicates that the last subframe has been processed by the decoder
+ * in @frame. This will release the current frame in video decoder
+ * allowing to receive new frames from upstream elements. This method
+ * must be called in the subclass @handle_frame callback.
+ *
+ * Returns: a #GstFlowReturn, usually GST_FLOW_OK.
+ *
+ * Since: 1.20
+ */
+GstFlowReturn
+gst_video_decoder_have_last_subframe (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame)
+{
+  g_return_val_if_fail (gst_video_decoder_get_subframe_mode (decoder),
+      GST_FLOW_OK);
+  /* unref once from the list */
+  GST_VIDEO_DECODER_STREAM_LOCK (decoder);
+  if (decoder->priv->current_frame == frame) {
+    gst_video_codec_frame_unref (decoder->priv->current_frame);
+    decoder->priv->current_frame = NULL;
+  }
+  GST_VIDEO_DECODER_STREAM_UNLOCK (decoder);
+
+  return GST_FLOW_OK;
+}
+
+/**
+ * gst_video_decoder_set_subframe_mode:
+ * @decoder: a #GstVideoDecoder
+ * @subframe_mode: whether the input data should be considered as subframes.
+ *
+ * If this is set to TRUE, it informs the base class that the subclass
+ * can receive the data at a granularity lower than one frame.
+ *
+ * Note that in this mode, the subclass has two options. It can either
+ * require the presence of a GST_VIDEO_BUFFER_FLAG_MARKER to mark the
+ * end of a frame. Or it can operate in such a way that it will decode
+ * a single frame at a time. In this second case, every buffer that
+ * arrives to the element is considered part of the same frame until
+ * gst_video_decoder_finish_frame() is called.
+ *
+ * In either case, the same #GstVideoCodecFrame will be passed to the
+ * GstVideoDecoderClass:handle_frame vmethod repeatedly with a
+ * different GstVideoCodecFrame:input_buffer every time until the end of the
+ * frame has been signaled using either method.
+ * This method must be called during the decoder subclass @set_format call.
+ *
+ * Since: 1.20
+ */
+void
+gst_video_decoder_set_subframe_mode (GstVideoDecoder * decoder,
+    gboolean subframe_mode)
+{
+  decoder->priv->subframe_mode = subframe_mode;
+}
+
+/**
+ * gst_video_decoder_get_subframe_mode:
+ * @decoder: a #GstVideoDecoder
+ *
+ * Queries whether input data is considered as subframes or not by the
+ * base class. If FALSE, each input buffer will be considered as a full
+ * frame.
+ *
+ * Returns: TRUE if input data is considered as sub frames.
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_video_decoder_get_subframe_mode (GstVideoDecoder * decoder)
+{
+  return decoder->priv->subframe_mode;
+}
+
+/**
+ * gst_video_decoder_get_input_subframe_index:
+ * @decoder: a #GstVideoDecoder
+ * @frame: (transfer none): the #GstVideoCodecFrame to update
+ *
+ * Queries the number of the last subframe received by
+ * the decoder baseclass in the @frame.
+ *
+ * Returns: the current subframe index received in subframe mode, 1 otherwise.
+ *
+ * Since: 1.20
+ */
+guint
+gst_video_decoder_get_input_subframe_index (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame)
+{
+  return frame->abidata.ABI.num_subframes;
+}
+
+/**
+ * gst_video_decoder_get_processed_subframe_index:
+ * @decoder: a #GstVideoDecoder
+ * @frame: (transfer none): the #GstVideoCodecFrame to update
+ *
+ * Queries the number of subframes in the frame processed by
+ * the decoder baseclass.
+ *
+ * Returns: the current subframe processed received in subframe mode.
+ *
+ * Since: 1.20
+ */
+guint
+gst_video_decoder_get_processed_subframe_index (GstVideoDecoder * decoder,
+    GstVideoCodecFrame * frame)
+{
+  return frame->abidata.ABI.subframes_processed;
+}
+
 /**
  * gst_video_decoder_set_estimate_rate:
  * @dec: a #GstVideoDecoder
@@ -4518,32 +5069,49 @@ gst_video_decoder_get_estimate_rate (GstVideoDecoder * dec)
  * @min_latency: minimum latency
  * @max_latency: maximum latency
  *
- * Lets #GstVideoDecoder sub-classes tell the baseclass what the decoder
- * latency is. Will also post a LATENCY message on the bus so the pipeline
- * can reconfigure its global latency.
+ * Lets #GstVideoDecoder sub-classes tell the baseclass what the decoder latency
+ * is. If the provided values changed from previously provided ones, this will
+ * also post a LATENCY message on the bus so the pipeline can reconfigure its
+ * global latency.
  */
 void
 gst_video_decoder_set_latency (GstVideoDecoder * decoder,
     GstClockTime min_latency, GstClockTime max_latency)
 {
+  gboolean post_message = FALSE;
   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (min_latency));
   g_return_if_fail (max_latency >= min_latency);
 
+  GST_DEBUG_OBJECT (decoder,
+      "min_latency:%" GST_TIME_FORMAT " max_latency:%" GST_TIME_FORMAT,
+      GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
+
   GST_OBJECT_LOCK (decoder);
-  decoder->priv->min_latency = min_latency;
-  decoder->priv->max_latency = max_latency;
+  if (decoder->priv->min_latency != min_latency) {
+    decoder->priv->min_latency = min_latency;
+    post_message = TRUE;
+  }
+  if (decoder->priv->max_latency != max_latency) {
+    decoder->priv->max_latency = max_latency;
+    post_message = TRUE;
+  }
+  if (!decoder->priv->posted_latency_msg) {
+    decoder->priv->posted_latency_msg = TRUE;
+    post_message = TRUE;
+  }
   GST_OBJECT_UNLOCK (decoder);
 
-  gst_element_post_message (GST_ELEMENT_CAST (decoder),
-      gst_message_new_latency (GST_OBJECT_CAST (decoder)));
+  if (post_message)
+    gst_element_post_message (GST_ELEMENT_CAST (decoder),
+        gst_message_new_latency (GST_OBJECT_CAST (decoder)));
 }
 
 /**
  * gst_video_decoder_get_latency:
  * @decoder: a #GstVideoDecoder
- * @min_latency: (out) (allow-none): address of variable in which to store the
+ * @min_latency: (out) (optional): address of variable in which to store the
  *     configured minimum latency, or %NULL
- * @max_latency: (out) (allow-none): address of variable in which to store the
+ * @max_latency: (out) (optional): address of variable in which to store the
  *     configured mximum latency, or %NULL
  *
  * Query the configured decoder latency. Results will be returned via
@@ -4564,7 +5132,7 @@ gst_video_decoder_get_latency (GstVideoDecoder * decoder,
 /**
  * gst_video_decoder_merge_tags:
  * @decoder: a #GstVideoDecoder
- * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
+ * @tags: (nullable): a #GstTagList to merge, or NULL to unset
  *     previously-set tags
  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
  *
@@ -4607,7 +5175,7 @@ gst_video_decoder_merge_tags (GstVideoDecoder * decoder,
  * gst_video_decoder_get_buffer_pool:
  * @decoder: a #GstVideoDecoder
  *
- * Returns: (transfer full): the instance of the #GstBufferPool used
+ * Returns: (transfer full) (nullable): the instance of the #GstBufferPool used
  * by the decoder; free it after use it
  */
 GstBufferPool *
@@ -4624,9 +5192,9 @@ gst_video_decoder_get_buffer_pool (GstVideoDecoder * decoder)
 /**
  * gst_video_decoder_get_allocator:
  * @decoder: a #GstVideoDecoder
- * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
+ * @allocator: (out) (optional) (nullable) (transfer full): the #GstAllocator
  * used
- * @params: (out) (allow-none) (transfer full): the
+ * @params: (out) (optional) (transfer full): the
  * #GstAllocationParams of @allocator
  *
  * Lets #GstVideoDecoder sub-classes to know the memory @allocator
@@ -4668,3 +5236,134 @@ gst_video_decoder_set_use_default_pad_acceptcaps (GstVideoDecoder * decoder,
 {
   decoder->priv->use_default_pad_acceptcaps = use;
 }
+
+static void
+gst_video_decoder_request_sync_point_internal (GstVideoDecoder * dec,
+    GstClockTime deadline, GstVideoDecoderRequestSyncPointFlags flags)
+{
+  GstEvent *fku = NULL;
+  GstVideoDecoderPrivate *priv;
+
+  g_return_if_fail (GST_IS_VIDEO_DECODER (dec));
+
+  priv = dec->priv;
+
+  GST_OBJECT_LOCK (dec);
+
+  /* Check if we're allowed to send a new force-keyunit event.
+   * frame->deadline is set to the running time of the PTS. */
+  if (priv->min_force_key_unit_interval == 0 ||
+      deadline == GST_CLOCK_TIME_NONE ||
+      (priv->min_force_key_unit_interval != GST_CLOCK_TIME_NONE &&
+          (priv->last_force_key_unit_time == GST_CLOCK_TIME_NONE
+              || (priv->last_force_key_unit_time +
+                  priv->min_force_key_unit_interval <= deadline)))) {
+    GST_DEBUG_OBJECT (dec,
+        "Requesting a new key-unit for frame with deadline %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (deadline));
+    fku =
+        gst_video_event_new_upstream_force_key_unit (GST_CLOCK_TIME_NONE, FALSE,
+        0);
+    priv->last_force_key_unit_time = deadline;
+  } else {
+    GST_DEBUG_OBJECT (dec,
+        "Can't request a new key-unit for frame with deadline %"
+        GST_TIME_FORMAT, GST_TIME_ARGS (deadline));
+  }
+  priv->request_sync_point_flags |= flags;
+  /* We don't know yet the frame number of the sync point so set it to a
+   * frame number higher than any allowed frame number */
+  priv->request_sync_point_frame_number = REQUEST_SYNC_POINT_PENDING;
+  GST_OBJECT_UNLOCK (dec);
+
+  if (fku)
+    gst_pad_push_event (dec->sinkpad, fku);
+}
+
+/**
+ * gst_video_decoder_request_sync_point:
+ * @dec: a #GstVideoDecoder
+ * @frame: a #GstVideoCodecFrame
+ * @flags: #GstVideoDecoderRequestSyncPointFlags
+ *
+ * Allows the #GstVideoDecoder subclass to request from the base class that
+ * a new sync should be requested from upstream, and that @frame was the frame
+ * when the subclass noticed that a new sync point is required. A reason for
+ * the subclass to do this could be missing reference frames, for example.
+ *
+ * The base class will then request a new sync point from upstream as long as
+ * the time that passed since the last one is exceeding
+ * #GstVideoDecoder:min-force-key-unit-interval.
+ *
+ * The subclass can signal via @flags how the frames until the next sync point
+ * should be handled:
+ *
+ *   * If %GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT is selected then
+ *     all following input frames until the next sync point are discarded.
+ *     This can be useful if the lack of a sync point will prevent all further
+ *     decoding and the decoder implementation is not very robust in handling
+ *     missing references frames.
+ *   * If %GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT is selected
+ *     then all output frames following @frame are marked as corrupted via
+ *     %GST_BUFFER_FLAG_CORRUPTED. Corrupted frames can be automatically
+ *     dropped by the base class, see #GstVideoDecoder:discard-corrupted-frames.
+ *     Subclasses can manually mark frames as corrupted via %GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED
+ *     before calling gst_video_decoder_finish_frame().
+ *
+ * Since: 1.20
+ */
+void
+gst_video_decoder_request_sync_point (GstVideoDecoder * dec,
+    GstVideoCodecFrame * frame, GstVideoDecoderRequestSyncPointFlags flags)
+{
+  g_return_if_fail (GST_IS_VIDEO_DECODER (dec));
+  g_return_if_fail (frame != NULL);
+
+  gst_video_decoder_request_sync_point_internal (dec, frame->deadline, flags);
+}
+
+/**
+ * gst_video_decoder_set_needs_sync_point:
+ * @dec: a #GstVideoDecoder
+ * @enabled: new state
+ *
+ * Configures whether the decoder requires a sync point before it starts
+ * outputting data in the beginning. If enabled, the base class will discard
+ * all non-sync point frames in the beginning and after a flush and does not
+ * pass it to the subclass.
+ *
+ * If the first frame is not a sync point, the base class will request a sync
+ * point via the force-key-unit event.
+ *
+ * Since: 1.20
+ */
+void
+gst_video_decoder_set_needs_sync_point (GstVideoDecoder * dec, gboolean enabled)
+{
+  g_return_if_fail (GST_IS_VIDEO_DECODER (dec));
+
+  dec->priv->needs_sync_point = enabled;
+}
+
+/**
+ * gst_video_decoder_get_needs_sync_point:
+ * @dec: a #GstVideoDecoder
+ *
+ * Queries if the decoder requires a sync point before it starts outputting
+ * data in the beginning.
+ *
+ * Returns: %TRUE if a sync point is required in the beginning.
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_video_decoder_get_needs_sync_point (GstVideoDecoder * dec)
+{
+  gboolean result;
+
+  g_return_val_if_fail (GST_IS_VIDEO_DECODER (dec), FALSE);
+
+  result = dec->priv->needs_sync_point;
+
+  return result;
+}
diff --git a/gst-libs/gst/video/gstvideodecoder.h b/gst-libs/gst/video/gstvideodecoder.h
index 0233cfa086..3556fd3c88 100644
--- a/gst-libs/gst/video/gstvideodecoder.h
+++ b/gst-libs/gst/video/gstvideodecoder.h
@@ -161,7 +161,7 @@ G_STMT_START {                                                              \
  *
  * Default maximum number of errors tolerated before signaling error.
  */
-#define GST_VIDEO_DECODER_MAX_ERRORS     10
+#define GST_VIDEO_DECODER_MAX_ERRORS     -1
 
 
 /**
@@ -214,7 +214,9 @@ struct _GstVideoDecoder
  * @reset:          Optional.
  *                  Allows subclass (decoder) to perform post-seek semantics reset.
  *                  Deprecated.
- * @handle_frame:   Provides input data frame to subclass.
+ * @handle_frame:   Provides input data frame to subclass. In subframe mode, the subclass needs
+ *                  to take ownership of @GstVideoCodecFrame.input_buffer as it will be modified
+ *                  by the base class on the next subframe buffer receiving.
  * @finish:         Optional.
  *                  Called to request subclass to dispatch any pending remaining
  *                  data at EOS. Sub-classes can refuse to decode new data after.
@@ -305,6 +307,11 @@ struct _GstVideoDecoderClass
 
   GstFlowReturn (*finish)         (GstVideoDecoder *decoder);
 
+  /**
+   * GstVideoDecoderClass::handle_frame:
+   * @decoder: The #GstVideoDecoder
+   * @frame: (transfer full): The frame to handle
+   */
   GstFlowReturn (*handle_frame)   (GstVideoDecoder *decoder,
 				   GstVideoCodecFrame *frame);
 
@@ -337,10 +344,41 @@ struct _GstVideoDecoderClass
                                    GstVideoCodecFrame *frame,
                                    GstMeta * meta);
 
+  /**
+   * GstVideoDecoderClass::handle_missing_data:
+   * @decoder: The #GstVideoDecoder
+   * @timestamp: Timestamp of the missing data
+   * @duration: Duration of the missing data
+   *
+   * Returns: %TRUE if the decoder should be drained afterwards.
+   *
+   * Since: 1.20
+   */
+  gboolean      (*handle_missing_data) (GstVideoDecoder *decoder,
+                                        GstClockTime timestamp,
+                                        GstClockTime duration);
+
   /*< private >*/
-  gpointer padding[GST_PADDING_LARGE-6];
+  gpointer padding[GST_PADDING_LARGE-7];
 };
 
+/**
+ * GstVideoDecoderRequestSyncPointFlags:
+ * @GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT: discard all following
+ *     input until the next sync point.
+ * @GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT: discard all following
+ *     output until the next sync point.
+ *
+ * Flags to be used in combination with gst_video_decoder_request_sync_point().
+ * See the function documentation for more details.
+ *
+ * Since: 1.20
+ */
+typedef enum {
+  GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT  = (1<<0),
+  GST_VIDEO_DECODER_REQUEST_SYNC_POINT_CORRUPT_OUTPUT = (1<<1),
+} GstVideoDecoderRequestSyncPointFlags;
+
 GST_VIDEO_API
 GType    gst_video_decoder_get_type (void);
 
@@ -353,6 +391,19 @@ void     gst_video_decoder_set_packetized (GstVideoDecoder * decoder,
 GST_VIDEO_API
 gboolean gst_video_decoder_get_packetized (GstVideoDecoder * decoder);
 
+GST_VIDEO_API
+void     gst_video_decoder_set_subframe_mode (GstVideoDecoder * decoder,
+                                              gboolean subframe_mode);
+
+GST_VIDEO_API
+gboolean gst_video_decoder_get_subframe_mode (GstVideoDecoder * decoder);
+
+GST_VIDEO_API
+guint gst_video_decoder_get_input_subframe_index (GstVideoDecoder * decoder, GstVideoCodecFrame * frame);
+
+GST_VIDEO_API
+guint gst_video_decoder_get_processed_subframe_index (GstVideoDecoder * decoder, GstVideoCodecFrame * frame);
+
 GST_VIDEO_API
 void     gst_video_decoder_set_estimate_rate (GstVideoDecoder * dec,
 					      gboolean          enabled);
@@ -374,6 +425,13 @@ void     gst_video_decoder_set_needs_format (GstVideoDecoder * dec,
 GST_VIDEO_API
 gboolean gst_video_decoder_get_needs_format (GstVideoDecoder * dec);
 
+GST_VIDEO_API
+void     gst_video_decoder_set_needs_sync_point (GstVideoDecoder * dec,
+                                                 gboolean enabled);
+
+GST_VIDEO_API
+gboolean gst_video_decoder_get_needs_sync_point (GstVideoDecoder * dec);
+
 GST_VIDEO_API
 void     gst_video_decoder_set_latency (GstVideoDecoder *decoder,
 					GstClockTime min_latency,
@@ -413,6 +471,10 @@ void           gst_video_decoder_add_to_frame     (GstVideoDecoder *decoder,
 GST_VIDEO_API
 GstFlowReturn  gst_video_decoder_have_frame       (GstVideoDecoder *decoder);
 
+GST_VIDEO_API
+GstFlowReturn  gst_video_decoder_have_last_subframe (GstVideoDecoder *decoder,
+                                                     GstVideoCodecFrame * frame);
+
 GST_VIDEO_API
 gsize          gst_video_decoder_get_pending_frame_size (GstVideoDecoder *decoder);
 
@@ -454,10 +516,21 @@ gdouble          gst_video_decoder_get_qos_proportion (GstVideoDecoder * decoder
 GST_VIDEO_API
 GstFlowReturn    gst_video_decoder_finish_frame (GstVideoDecoder *decoder,
 						 GstVideoCodecFrame *frame);
+GST_VIDEO_API
+GstFlowReturn    gst_video_decoder_finish_subframe (GstVideoDecoder *decoder,
+                                                 GstVideoCodecFrame *frame);
 
 GST_VIDEO_API
 GstFlowReturn    gst_video_decoder_drop_frame (GstVideoDecoder *dec,
 					       GstVideoCodecFrame *frame);
+GST_VIDEO_API
+GstFlowReturn    gst_video_decoder_drop_subframe (GstVideoDecoder *dec,
+                                               GstVideoCodecFrame *frame);
+
+GST_VIDEO_API
+void             gst_video_decoder_request_sync_point (GstVideoDecoder *dec,
+                                                       GstVideoCodecFrame *frame,
+                                                       GstVideoDecoderRequestSyncPointFlags flags);
 
 GST_VIDEO_API
 void             gst_video_decoder_release_frame (GstVideoDecoder * dec,
diff --git a/gst-libs/gst/video/gstvideoencoder.c b/gst-libs/gst/video/gstvideoencoder.c
index ff3031503d..fcfb15bbdc 100644
--- a/gst-libs/gst/video/gstvideoencoder.c
+++ b/gst-libs/gst/video/gstvideoencoder.c
@@ -134,6 +134,9 @@ struct _GstVideoEncoderPrivate
   gint64 min_latency;
   gint64 max_latency;
 
+  /* Tracks whether the latency message was posted at least once */
+  gboolean posted_latency_msg;
+
   /* FIXME 2.0: Use a GQueue or similar, see GstVideoCodecFrame::events */
   GList *current_frame_events;
 
@@ -444,18 +447,6 @@ _flush_events (GstPad * pad, GList * events)
   return NULL;
 }
 
-#if !GLIB_CHECK_VERSION(2, 60, 0)
-#define g_queue_clear_full queue_clear_full
-static void
-queue_clear_full (GQueue * queue, GDestroyNotify free_func)
-{
-  gpointer data;
-
-  while ((data = g_queue_pop_head (queue)) != NULL)
-    free_func (data);
-}
-#endif
-
 static gboolean
 gst_video_encoder_reset (GstVideoEncoder * encoder, gboolean hard)
 {
@@ -524,6 +515,8 @@ gst_video_encoder_reset (GstVideoEncoder * encoder, gboolean hard)
 
     priv->dropped = 0;
     priv->processed = 0;
+
+    priv->posted_latency_msg = FALSE;
   } else {
     GList *l;
 
@@ -674,6 +667,15 @@ _new_output_state (GstCaps * caps, GstVideoCodecState * reference)
 
     GST_VIDEO_INFO_MULTIVIEW_MODE (tgt) = GST_VIDEO_INFO_MULTIVIEW_MODE (ref);
     GST_VIDEO_INFO_MULTIVIEW_FLAGS (tgt) = GST_VIDEO_INFO_MULTIVIEW_FLAGS (ref);
+
+    if (reference->mastering_display_info) {
+      state->mastering_display_info = g_slice_dup (GstVideoMasteringDisplayInfo,
+          reference->mastering_display_info);
+    }
+    if (reference->content_light_level) {
+      state->content_light_level = g_slice_dup (GstVideoContentLightLevel,
+          reference->content_light_level);
+    }
   }
 
   return state;
@@ -683,6 +685,8 @@ static GstVideoCodecState *
 _new_input_state (GstCaps * caps)
 {
   GstVideoCodecState *state;
+  GstStructure *c_struct;
+  const gchar *s;
 
   state = g_slice_new0 (GstVideoCodecState);
   state->ref_count = 1;
@@ -691,6 +695,18 @@ _new_input_state (GstCaps * caps)
     goto parse_fail;
   state->caps = gst_caps_ref (caps);
 
+  c_struct = gst_caps_get_structure (caps, 0);
+
+  if ((s = gst_structure_get_string (c_struct, "mastering-display-info"))) {
+    state->mastering_display_info = g_slice_new (GstVideoMasteringDisplayInfo);
+    gst_video_mastering_display_info_from_string (state->mastering_display_info,
+        s);
+  }
+  if ((s = gst_structure_get_string (c_struct, "content-light-level"))) {
+    state->content_light_level = g_slice_new (GstVideoContentLightLevel);
+    gst_video_content_light_level_from_string (state->content_light_level, s);
+  }
+
   return state;
 
 parse_fail:
@@ -775,8 +791,8 @@ parse_fail:
 /**
  * gst_video_encoder_proxy_getcaps:
  * @enc: a #GstVideoEncoder
- * @caps: (allow-none): initial caps
- * @filter: (allow-none): filter caps
+ * @caps: (nullable): initial caps
+ * @filter: (nullable): filter caps
  *
  * Returns caps that express @caps (or sink template caps if @caps == NULL)
  * restricted to resolution/format/... combinations supported by downstream
@@ -1815,7 +1831,7 @@ gst_video_encoder_negotiate_default (GstVideoEncoder * encoder)
   g_return_val_if_fail (state->caps != NULL, FALSE);
 
   if (encoder->priv->output_state_changed) {
-    GstCaps *incaps;
+    GstStructure *out_struct;
 
     state->caps = gst_caps_make_writable (state->caps);
 
@@ -1851,9 +1867,18 @@ gst_video_encoder_negotiate_default (GstVideoEncoder * encoder)
           colorimetry, NULL);
     g_free (colorimetry);
 
-    if (info->chroma_site != GST_VIDEO_CHROMA_SITE_UNKNOWN)
-      gst_caps_set_simple (state->caps, "chroma-site", G_TYPE_STRING,
-          gst_video_chroma_to_string (info->chroma_site), NULL);
+    if (info->chroma_site != GST_VIDEO_CHROMA_SITE_UNKNOWN) {
+      gchar *chroma_site = gst_video_chroma_site_to_string (info->chroma_site);
+
+      if (!chroma_site) {
+        GST_WARNING ("Couldn't convert chroma-site 0x%x to string",
+            info->chroma_site);
+      } else {
+        gst_caps_set_simple (state->caps,
+            "chroma-site", G_TYPE_STRING, chroma_site, NULL);
+        g_free (chroma_site);
+      }
+    }
 
     if (GST_VIDEO_INFO_MULTIVIEW_MODE (info) != GST_VIDEO_MULTIVIEW_MODE_NONE) {
       const gchar *caps_mview_mode =
@@ -1865,30 +1890,20 @@ gst_video_encoder_negotiate_default (GstVideoEncoder * encoder)
           GST_VIDEO_INFO_MULTIVIEW_FLAGS (info), GST_FLAG_SET_MASK_EXACT, NULL);
     }
 
-    incaps = gst_pad_get_current_caps (GST_VIDEO_ENCODER_SINK_PAD (encoder));
-    if (incaps) {
-      GstStructure *in_struct;
-      GstStructure *out_struct;
-      const gchar *s;
-
-      in_struct = gst_caps_get_structure (incaps, 0);
-      out_struct = gst_caps_get_structure (state->caps, 0);
-
-      /* forward upstream mastering display info and content light level
-       * if subclass didn't set */
-      if ((s = gst_structure_get_string (in_struct, "mastering-display-info"))
-          && !gst_structure_has_field (out_struct, "mastering-display-info")) {
-        gst_caps_set_simple (state->caps, "mastering-display-info",
-            G_TYPE_STRING, s, NULL);
-      }
+    out_struct = gst_caps_get_structure (state->caps, 0);
 
-      if ((s = gst_structure_get_string (in_struct, "content-light-level")) &&
-          !gst_structure_has_field (out_struct, "content-light-level")) {
-        gst_caps_set_simple (state->caps,
-            "content-light-level", G_TYPE_STRING, s, NULL);
-      }
+    /* forward upstream mastering display info and content light level
+     * if subclass didn't set */
+    if (state->mastering_display_info &&
+        !gst_structure_has_field (out_struct, "mastering-display-info")) {
+      gst_video_mastering_display_info_add_to_caps
+          (state->mastering_display_info, state->caps);
+    }
 
-      gst_caps_unref (incaps);
+    if (state->content_light_level &&
+        !gst_structure_has_field (out_struct, "content-light-level")) {
+      gst_video_content_light_level_add_to_caps (state->content_light_level,
+          state->caps);
     }
 
     encoder->priv->output_state_changed = FALSE;
@@ -2176,7 +2191,8 @@ foreach_metadata (GstBuffer * inbuf, GstMeta ** meta, gpointer user_data)
   const GstMetaInfo *info = (*meta)->info;
   gboolean do_copy = FALSE;
 
-  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)) {
+  if (gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory)
+      || gst_meta_api_type_has_tag (info->api, _gst_meta_tag_memory_reference)) {
     /* never call the transform_meta with memory specific metadata */
     GST_DEBUG_OBJECT (encoder, "not copying memory specific metadata %s",
         g_type_name (info->api));
@@ -2762,15 +2778,16 @@ done:
  *
  * Get the current #GstVideoCodecState
  *
- * Returns: (transfer full): #GstVideoCodecState describing format of video data.
+ * Returns: (transfer full) (nullable): #GstVideoCodecState describing format of video data.
  */
 GstVideoCodecState *
 gst_video_encoder_get_output_state (GstVideoEncoder * encoder)
 {
-  GstVideoCodecState *state;
+  GstVideoCodecState *state = NULL;
 
   GST_VIDEO_ENCODER_STREAM_LOCK (encoder);
-  state = gst_video_codec_state_ref (encoder->priv->output_state);
+  if (encoder->priv->output_state)
+    state = gst_video_codec_state_ref (encoder->priv->output_state);
   GST_VIDEO_ENCODER_STREAM_UNLOCK (encoder);
 
   return state;
@@ -2780,7 +2797,7 @@ gst_video_encoder_get_output_state (GstVideoEncoder * encoder)
  * gst_video_encoder_set_output_state:
  * @encoder: a #GstVideoEncoder
  * @caps: (transfer full): the #GstCaps to use for the output
- * @reference: (allow-none) (transfer none): An optional reference @GstVideoCodecState
+ * @reference: (nullable) (transfer none): An optional reference @GstVideoCodecState
  *
  * Creates a new #GstVideoCodecState with the specified caps as the output state
  * for the encoder.
@@ -2801,7 +2818,7 @@ gst_video_encoder_get_output_state (GstVideoEncoder * encoder)
  * The new output state will only take effect (set on pads and buffers) starting
  * from the next call to #gst_video_encoder_finish_frame().
  *
- * Returns: (transfer full): the newly configured output state.
+ * Returns: (transfer full) (nullable): the newly configured output state.
  */
 GstVideoCodecState *
 gst_video_encoder_set_output_state (GstVideoEncoder * encoder, GstCaps * caps,
@@ -2841,30 +2858,49 @@ gst_video_encoder_set_output_state (GstVideoEncoder * encoder, GstCaps * caps,
  * @min_latency: minimum latency
  * @max_latency: maximum latency
  *
- * Informs baseclass of encoding latency.
+ * Informs baseclass of encoding latency. If the provided values changed from
+ * previously provided ones, this will also post a LATENCY message on the bus
+ * so the pipeline can reconfigure its global latency.
  */
 void
 gst_video_encoder_set_latency (GstVideoEncoder * encoder,
     GstClockTime min_latency, GstClockTime max_latency)
 {
+  gboolean post_message = FALSE;
+
   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (min_latency));
   g_return_if_fail (max_latency >= min_latency);
 
+  GST_DEBUG_OBJECT (encoder,
+      "min_latency:%" GST_TIME_FORMAT " max_latency:%" GST_TIME_FORMAT,
+      GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
+
   GST_OBJECT_LOCK (encoder);
-  encoder->priv->min_latency = min_latency;
-  encoder->priv->max_latency = max_latency;
+  if (encoder->priv->min_latency != min_latency) {
+    encoder->priv->min_latency = min_latency;
+    post_message = TRUE;
+  }
+  if (encoder->priv->max_latency != max_latency) {
+    encoder->priv->max_latency = max_latency;
+    post_message = TRUE;
+  }
+  if (!encoder->priv->posted_latency_msg) {
+    encoder->priv->posted_latency_msg = TRUE;
+    post_message = TRUE;
+  }
   GST_OBJECT_UNLOCK (encoder);
 
-  gst_element_post_message (GST_ELEMENT_CAST (encoder),
-      gst_message_new_latency (GST_OBJECT_CAST (encoder)));
+  if (post_message)
+    gst_element_post_message (GST_ELEMENT_CAST (encoder),
+        gst_message_new_latency (GST_OBJECT_CAST (encoder)));
 }
 
 /**
  * gst_video_encoder_get_latency:
  * @encoder: a #GstVideoEncoder
- * @min_latency: (out) (allow-none): address of variable in which to store the
+ * @min_latency: (out) (optional): address of variable in which to store the
  *     configured minimum latency, or %NULL
- * @max_latency: (out) (allow-none): address of variable in which to store the
+ * @max_latency: (out) (optional): address of variable in which to store the
  *     configured maximum latency, or %NULL
  *
  * Query the configured encoding latency. Results will be returned via
@@ -2888,7 +2924,7 @@ gst_video_encoder_get_latency (GstVideoEncoder * encoder,
  *
  * Get the oldest unfinished pending #GstVideoCodecFrame
  *
- * Returns: (transfer full): oldest unfinished pending #GstVideoCodecFrame
+ * Returns: (transfer full) (nullable): oldest unfinished pending #GstVideoCodecFrame
  */
 GstVideoCodecFrame *
 gst_video_encoder_get_oldest_frame (GstVideoEncoder * encoder)
@@ -2910,7 +2946,7 @@ gst_video_encoder_get_oldest_frame (GstVideoEncoder * encoder)
  *
  * Get a pending unfinished #GstVideoCodecFrame
  *
- * Returns: (transfer full): pending unfinished #GstVideoCodecFrame identified by @frame_number.
+ * Returns: (transfer full) (nullable): pending unfinished #GstVideoCodecFrame identified by @frame_number.
  */
 GstVideoCodecFrame *
 gst_video_encoder_get_frame (GstVideoEncoder * encoder, int frame_number)
@@ -2959,7 +2995,7 @@ gst_video_encoder_get_frames (GstVideoEncoder * encoder)
 /**
  * gst_video_encoder_merge_tags:
  * @encoder: a #GstVideoEncoder
- * @tags: (allow-none): a #GstTagList to merge, or NULL to unset
+ * @tags: (nullable): a #GstTagList to merge, or NULL to unset
  *     previously-set tags
  * @mode: the #GstTagMergeMode to use, usually #GST_TAG_MERGE_REPLACE
  *
@@ -3002,9 +3038,9 @@ gst_video_encoder_merge_tags (GstVideoEncoder * encoder,
 /**
  * gst_video_encoder_get_allocator:
  * @encoder: a #GstVideoEncoder
- * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
+ * @allocator: (out) (optional) (nullable) (transfer full): the #GstAllocator
  * used
- * @params: (out) (allow-none) (transfer full): the
+ * @params: (out) (optional) (transfer full): the
  * #GstAllocationParams of @allocator
  *
  * Lets #GstVideoEncoder sub-classes to know the memory @allocator
diff --git a/gst-libs/gst/video/gstvideometa.c b/gst-libs/gst/video/gstvideometa.c
index bfd91465cb..50113fad9e 100644
--- a/gst-libs/gst/video/gstvideometa.c
+++ b/gst-libs/gst/video/gstvideometa.c
@@ -160,7 +160,7 @@ gst_video_meta_get_info (void)
  * Buffers can contain multiple #GstVideoMeta metadata items when dealing with
  * multiview buffers.
  *
- * Returns: (transfer none): the #GstVideoMeta with lowest id (usually 0) or %NULL when there
+ * Returns: (transfer none) (nullable): the #GstVideoMeta with lowest id (usually 0) or %NULL when there
  * is no such metadata on @buffer.
  */
 GstVideoMeta *
@@ -193,7 +193,7 @@ gst_buffer_get_video_meta (GstBuffer * buffer)
  * Buffers can contain multiple #GstVideoMeta metadata items when dealing with
  * multiview buffers.
  *
- * Returns: (transfer none): the #GstVideoMeta with @id or %NULL when there is no such metadata
+ * Returns: (transfer none) (nullable): the #GstVideoMeta with @id or %NULL when there is no such metadata
  * on @buffer.
  */
 GstVideoMeta *
@@ -924,7 +924,7 @@ gst_video_region_of_interest_meta_get_info (void)
  * Buffers can contain multiple #GstVideoRegionOfInterestMeta metadata items if
  * multiple regions of interests are marked on a frame.
  *
- * Returns: (transfer none): the #GstVideoRegionOfInterestMeta with @id or %NULL when there is
+ * Returns: (transfer none) (nullable): the #GstVideoRegionOfInterestMeta with @id or %NULL when there is
  * no such metadata on @buffer.
  */
 GstVideoRegionOfInterestMeta *
@@ -1178,7 +1178,7 @@ gst_buffer_add_video_time_code_meta (GstBuffer * buffer,
  * Attaches #GstVideoTimeCodeMeta metadata to @buffer with the given
  * parameters.
  *
- * Returns: (transfer none): the #GstVideoTimeCodeMeta on @buffer, or
+ * Returns: (transfer none) (nullable): the #GstVideoTimeCodeMeta on @buffer, or
  * (since 1.16) %NULL if the timecode was invalid.
  *
  * Since: 1.10
diff --git a/gst-libs/gst/video/gstvideopool.c b/gst-libs/gst/video/gstvideopool.c
index 7cfd367e35..fd4198d79f 100644
--- a/gst-libs/gst/video/gstvideopool.c
+++ b/gst-libs/gst/video/gstvideopool.c
@@ -50,7 +50,7 @@ GST_DEBUG_CATEGORY_STATIC (gst_video_pool_debug);
  */
 void
 gst_buffer_pool_config_set_video_alignment (GstStructure * config,
-    GstVideoAlignment * align)
+    const GstVideoAlignment * align)
 {
   g_return_if_fail (config != NULL);
   g_return_if_fail (align != NULL);
diff --git a/gst-libs/gst/video/gstvideopool.h b/gst-libs/gst/video/gstvideopool.h
index 01e9abd0f7..6fd0db1bcd 100644
--- a/gst-libs/gst/video/gstvideopool.h
+++ b/gst-libs/gst/video/gstvideopool.h
@@ -48,7 +48,7 @@ G_BEGIN_DECLS
 /* setting a bufferpool config */
 
 GST_VIDEO_API
-void             gst_buffer_pool_config_set_video_alignment  (GstStructure *config, GstVideoAlignment *align);
+void             gst_buffer_pool_config_set_video_alignment  (GstStructure *config, const GstVideoAlignment *align);
 
 GST_VIDEO_API
 gboolean         gst_buffer_pool_config_get_video_alignment  (GstStructure *config, GstVideoAlignment *align);
diff --git a/gst-libs/gst/video/gstvideosink.c b/gst-libs/gst/video/gstvideosink.c
index 32f5ee7131..8450a429c6 100644
--- a/gst-libs/gst/video/gstvideosink.c
+++ b/gst-libs/gst/video/gstvideosink.c
@@ -46,6 +46,7 @@ enum
 
 struct _GstVideoSinkPrivate
 {
+  GstVideoInfo info;
   gboolean show_preroll_frame;  /* ATOMIC */
 };
 
@@ -78,59 +79,88 @@ static void gst_video_sink_set_property (GObject * object, guint prop_id,
 static void gst_video_sink_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
 
+static GstStateChangeReturn gst_video_sink_change_state (GstElement * element,
+    GstStateChange transition);
 static GstFlowReturn gst_video_sink_show_preroll_frame (GstBaseSink * bsink,
     GstBuffer * buf);
 static GstFlowReturn gst_video_sink_show_frame (GstBaseSink * bsink,
     GstBuffer * buf);
+static gboolean gst_video_sink_set_caps (GstBaseSink * bsink, GstCaps * caps);
+static void gst_video_sink_get_times (GstBaseSink * bsink, GstBuffer * buffer,
+    GstClockTime * start, GstClockTime * end);
 
 /**
  * gst_video_sink_center_rect:
  * @src: the #GstVideoRectangle describing the source area
  * @dst: the #GstVideoRectangle describing the destination area
- * @result: a pointer to a #GstVideoRectangle which will receive the result area
+ * @result: (out caller-allocates): a pointer to a #GstVideoRectangle which will receive the result area
+ * @scaling: a #gboolean indicating if scaling should be applied or not
+ *
+ * Deprecated: 1.20: Use gst_video_center_rect() instead.
+ */
+void
+gst_video_sink_center_rect (GstVideoRectangle src, GstVideoRectangle dst,
+    GstVideoRectangle * result, gboolean scaling)
+{
+  gst_video_center_rect (&src, &dst, result, scaling);
+}
+
+/**
+ * gst_video_center_rect:
+ * @src: a pointer to #GstVideoRectangle describing the source area
+ * @dst: a pointer to #GstVideoRectangle describing the destination area
+ * @result: (out caller-allocates): a pointer to a #GstVideoRectangle which will receive the result area
  * @scaling: a #gboolean indicating if scaling should be applied or not
  *
  * Takes @src rectangle and position it at the center of @dst rectangle with or
  * without @scaling. It handles clipping if the @src rectangle is bigger than
  * the @dst one and @scaling is set to FALSE.
+ *
+ * Since: 1.20
  */
 void
-gst_video_sink_center_rect (GstVideoRectangle src, GstVideoRectangle dst,
-    GstVideoRectangle * result, gboolean scaling)
+gst_video_center_rect (const GstVideoRectangle * src,
+    const GstVideoRectangle * dst, GstVideoRectangle * result, gboolean scaling)
 {
+  g_return_if_fail (src != NULL);
+  g_return_if_fail (dst != NULL);
   g_return_if_fail (result != NULL);
 
   if (!scaling) {
-    result->w = MIN (src.w, dst.w);
-    result->h = MIN (src.h, dst.h);
-    result->x = dst.x + (dst.w - result->w) / 2;
-    result->y = dst.y + (dst.h - result->h) / 2;
+    result->w = MIN (src->w, dst->w);
+    result->h = MIN (src->h, dst->h);
+    result->x = dst->x + (dst->w - result->w) / 2;
+    result->y = dst->y + (dst->h - result->h) / 2;
   } else {
     gdouble src_ratio, dst_ratio;
 
-    src_ratio = (gdouble) src.w / src.h;
-    dst_ratio = (gdouble) dst.w / dst.h;
+    g_return_if_fail (src->h != 0);
+    g_return_if_fail (dst->h != 0);
+
+    src_ratio = (gdouble) src->w / src->h;
+    dst_ratio = (gdouble) dst->w / dst->h;
 
     if (src_ratio > dst_ratio) {
-      result->w = dst.w;
-      result->h = dst.w / src_ratio;
-      result->x = dst.x;
-      result->y = dst.y + (dst.h - result->h) / 2;
+      result->w = dst->w;
+      result->h = dst->w / src_ratio;
+      result->x = dst->x;
+      result->y = dst->y + (dst->h - result->h) / 2;
     } else if (src_ratio < dst_ratio) {
-      result->w = dst.h * src_ratio;
-      result->h = dst.h;
-      result->x = dst.x + (dst.w - result->w) / 2;
-      result->y = dst.y;
+      result->w = dst->h * src_ratio;
+      result->h = dst->h;
+      result->x = dst->x + (dst->w - result->w) / 2;
+      result->y = dst->y;
     } else {
-      result->x = dst.x;
-      result->y = dst.y;
-      result->w = dst.w;
-      result->h = dst.h;
+      result->x = dst->x;
+      result->y = dst->y;
+      result->w = dst->w;
+      result->h = dst->h;
     }
   }
 
   GST_DEBUG ("source is %dx%d dest is %dx%d, result is %dx%d with x,y %dx%d",
-      src.w, src.h, dst.w, dst.h, result->w, result->h, result->x, result->y);
+      src->w, src->h, dst->w, dst->h,
+      result->w, result->h, result->x, result->y);
 }
 
 /* Initing stuff */
@@ -153,6 +183,7 @@ gst_video_sink_init (GstVideoSink * videosink)
 static void
 gst_video_sink_class_init (GstVideoSinkClass * klass)
 {
+  GstElementClass *element_class = (GstElementClass *) klass;
   GstBaseSinkClass *basesink_class = (GstBaseSinkClass *) klass;
   GObjectClass *gobject_class = (GObjectClass *) klass;
 
@@ -173,9 +204,83 @@ gst_video_sink_class_init (GstVideoSinkClass * klass)
           DEFAULT_SHOW_PREROLL_FRAME,
           G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
 
+  element_class->change_state = GST_DEBUG_FUNCPTR (gst_video_sink_change_state);
+
   basesink_class->render = GST_DEBUG_FUNCPTR (gst_video_sink_show_frame);
   basesink_class->preroll =
       GST_DEBUG_FUNCPTR (gst_video_sink_show_preroll_frame);
+  basesink_class->set_caps = GST_DEBUG_FUNCPTR (gst_video_sink_set_caps);
+  basesink_class->get_times = GST_DEBUG_FUNCPTR (gst_video_sink_get_times);
+}
+
+static GstStateChangeReturn
+gst_video_sink_change_state (GstElement * element, GstStateChange transition)
+{
+  GstVideoSink *vsink;
+
+  vsink = GST_VIDEO_SINK_CAST (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_video_info_init (&vsink->priv->info);
+      break;
+    default:
+      break;
+  }
+
+  return GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+}
+
+static gboolean
+gst_video_sink_set_caps (GstBaseSink * bsink, GstCaps * caps)
+{
+  GstVideoSink *vsink;
+  GstVideoSinkClass *klass;
+  GstVideoInfo info;
+
+  vsink = GST_VIDEO_SINK_CAST (bsink);
+  klass = GST_VIDEO_SINK_GET_CLASS (vsink);
+
+  if (!gst_video_info_from_caps (&info, caps)) {
+    GST_ERROR_OBJECT (bsink, "Failed to parse caps %" GST_PTR_FORMAT, caps);
+    return FALSE;
+  }
+
+  GST_DEBUG_OBJECT (bsink, "Setting caps %" GST_PTR_FORMAT, caps);
+  vsink->priv->info = info;
+
+  if (klass->set_info)
+    return klass->set_info (vsink, caps, &vsink->priv->info);
+
+  return TRUE;
+}
+
+static void
+gst_video_sink_get_times (GstBaseSink * bsink, GstBuffer * buffer,
+    GstClockTime * start, GstClockTime * end)
+{
+  GstVideoSink *vsink;
+  GstClockTime timestamp;
+
+  vsink = GST_VIDEO_SINK_CAST (bsink);
+
+  timestamp = GST_BUFFER_DTS_OR_PTS (buffer);
+  if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
+    *start = timestamp;
+    if (GST_BUFFER_DURATION_IS_VALID (buffer)) {
+      *end = timestamp + GST_BUFFER_DURATION (buffer);
+    } else if (vsink->priv->info.fps_n > 0) {
+      *end = timestamp +
+          gst_util_uint64_scale_int (GST_SECOND, vsink->priv->info.fps_d,
+          vsink->priv->info.fps_n);
+    } else if (bsink->segment.rate < 0) {
+      /* The end time will be used for clock waiting time position
+       * in case of revese playback, and unknown end time will result in
+       * never waiting for clock (as if sync=false).
+       * Returning timestamp here would be the best effort we can do */
+      *end = timestamp;
+    }
+  }
 }
 
 static GstFlowReturn
diff --git a/gst-libs/gst/video/gstvideosink.h b/gst-libs/gst/video/gstvideosink.h
index d28ef042ad..a7a226dde2 100644
--- a/gst-libs/gst/video/gstvideosink.h
+++ b/gst-libs/gst/video/gstvideosink.h
@@ -26,6 +26,7 @@
 #include <gst/gst.h>
 #include <gst/base/gstbasesink.h>
 #include <gst/video/video-prelude.h>
+#include <gst/video/video-info.h>
 
 G_BEGIN_DECLS
 
@@ -117,17 +118,34 @@ struct _GstVideoSinkClass {
 
   GstFlowReturn  (*show_frame) (GstVideoSink *video_sink, GstBuffer *buf);
 
+  /**
+   * GstVideoSinkClass::set_info:
+   * @caps: A #GstCaps.
+   * @info: A #GstVideoInfo corresponding to @caps.
+   *
+   * Notifies the subclass of changed #GstVideoInfo.
+   *
+   * Since: 1.20
+   */
+  gboolean       (*set_info)   (GstVideoSink *video_sink, GstCaps *caps, const GstVideoInfo *info);
+
   /*< private >*/
-  gpointer _gst_reserved[GST_PADDING];
+  gpointer _gst_reserved[GST_PADDING-1];
 };
 
 GST_VIDEO_API
 GType gst_video_sink_get_type (void);
 
-GST_VIDEO_API
+GST_VIDEO_DEPRECATED_FOR(gst_video_center_rect)
 void gst_video_sink_center_rect (GstVideoRectangle src, GstVideoRectangle dst,
                                  GstVideoRectangle *result, gboolean scaling);
 
+GST_VIDEO_API
+void gst_video_center_rect      (const GstVideoRectangle * src,
+                                 const GstVideoRectangle * dst,
+                                 GstVideoRectangle * result,
+                                 gboolean scaling);
+
 G_DEFINE_AUTOPTR_CLEANUP_FUNC(GstVideoSink, gst_object_unref)
 
 G_END_DECLS
diff --git a/gst-libs/gst/video/gstvideotimecode.c b/gst-libs/gst/video/gstvideotimecode.c
index f3ab4d82b4..15f06c6e05 100644
--- a/gst-libs/gst/video/gstvideotimecode.c
+++ b/gst-libs/gst/video/gstvideotimecode.c
@@ -759,7 +759,7 @@ gst_video_time_code_new_from_date_time (guint fps_n, guint fps_d,
  * The resulting config->latest_daily_jam is set to
  * midnight, and timecode is set to the given time.
  *
- * Returns: the #GstVideoTimeCode representation of @dt, or %NULL if
+ * Returns: (nullable): the #GstVideoTimeCode representation of @dt, or %NULL if
  *   no valid timecode could be created.
  *
  * Since: 1.16
diff --git a/gst-libs/gst/video/gstvideoutils.c b/gst-libs/gst/video/gstvideoutils.c
index 7e543db35c..03dffcd8fc 100644
--- a/gst-libs/gst/video/gstvideoutils.c
+++ b/gst-libs/gst/video/gstvideoutils.c
@@ -171,6 +171,10 @@ _gst_video_codec_state_free (GstVideoCodecState * state)
     gst_caps_unref (state->allocation_caps);
   if (state->codec_data)
     gst_buffer_unref (state->codec_data);
+  if (state->mastering_display_info)
+    g_slice_free (GstVideoMasteringDisplayInfo, state->mastering_display_info);
+  if (state->content_light_level)
+    g_slice_free (GstVideoContentLightLevel, state->content_light_level);
   g_slice_free (GstVideoCodecState, state);
 }
 
diff --git a/gst-libs/gst/video/gstvideoutils.h b/gst-libs/gst/video/gstvideoutils.h
index f49a089748..cbe19f0e61 100644
--- a/gst-libs/gst/video/gstvideoutils.h
+++ b/gst-libs/gst/video/gstvideoutils.h
@@ -28,6 +28,7 @@
 
 #include <gst/gst.h>
 #include <gst/video/video-prelude.h>
+#include <gst/video/video-hdr.h>
 
 G_BEGIN_DECLS
 #define GST_TYPE_VIDEO_CODEC_STATE \
@@ -47,6 +48,10 @@ typedef struct _GstVideoCodecFrame GstVideoCodecFrame;
  *     'codec_data' field of a stream, or NULL.
  * @allocation_caps: The #GstCaps for allocation query and pool
  *     negotiation. Since: 1.10
+ * @mastering_display_info: Mastering display color volume information
+ *     (HDR metadata) for the stream. Since: 1.20
+ * @content_light_level: Content light level information for the stream.
+ *     Since: 1.20
  *
  * Structure representing the state of an incoming or outgoing video
  * stream for encoders and decoders.
@@ -55,8 +60,22 @@ typedef struct _GstVideoCodecFrame GstVideoCodecFrame;
  * respective @set_format vmethods.
  *
  * Decoders and encoders can set the downstream state, by using the
- * @gst_video_decoder_set_output_state() or
- * @gst_video_encoder_set_output_state() methods.
+ * gst_video_decoder_set_output_state() or
+ * gst_video_encoder_set_output_state() methods.
+ */
+/**
+ * GstVideoCodecState.mastering_display_info:
+ *
+ * Mastering display color volume information (HDR metadata) for the stream.
+ *
+ * Since: 1.20
+ */
+/**
+ * GstVideoCodecState.content_light_level:
+ *
+ * Content light level information for the stream.
+ *
+ * Since: 1.20
  */
 struct _GstVideoCodecState
 {
@@ -72,8 +91,11 @@ struct _GstVideoCodecState
 
   GstCaps *allocation_caps;
 
+  GstVideoMasteringDisplayInfo *mastering_display_info;
+  GstVideoContentLightLevel *content_light_level;
+
   /*< private >*/
-  gpointer padding[GST_PADDING_LARGE - 1];
+  gpointer padding[GST_PADDING_LARGE - 3];
 };
 
 /**
@@ -82,6 +104,7 @@ struct _GstVideoCodecState
  * @GST_VIDEO_CODEC_FRAME_FLAG_SYNC_POINT: is the frame a synchronization point (keyframe)
  * @GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME: should the output frame be made a keyframe
  * @GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME_HEADERS: should the encoder output stream headers
+ * @GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED: the buffer data is corrupted (Since: 1.20)
  *
  * Flags for #GstVideoCodecFrame
  */
@@ -90,7 +113,15 @@ typedef enum
   GST_VIDEO_CODEC_FRAME_FLAG_DECODE_ONLY            = (1<<0),
   GST_VIDEO_CODEC_FRAME_FLAG_SYNC_POINT             = (1<<1),
   GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME         = (1<<2),
-  GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME_HEADERS = (1<<3)
+  GST_VIDEO_CODEC_FRAME_FLAG_FORCE_KEYFRAME_HEADERS = (1<<3),
+  /**
+   * GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED:
+   *
+   * The buffer data is corrupted.
+   *
+   * Since: 1.20
+   */
+  GST_VIDEO_CODEC_FRAME_FLAG_CORRUPTED = (1<<4),
 } GstVideoCodecFrameFlags;
 
 /**
@@ -214,8 +245,8 @@ typedef enum
  *           be kept.
  * @output_buffer: the output #GstBuffer. Implementations should set this either
  *           directly, or by using the
- *           @gst_video_decoder_allocate_output_frame() or
- *           @gst_video_decoder_allocate_output_buffer() methods. The buffer is
+ *           gst_video_decoder_allocate_output_frame() or
+ *           gst_video_decoder_allocate_output_buffer() methods. The buffer is
  *           owned by the frame and references to the frame instead of the
  *           buffer should be kept.
  * @deadline: Running time when the frame will be used.
@@ -260,9 +291,11 @@ struct _GstVideoCodecFrame
 
   union {
     struct {
+      /*< private >*/
       GstClockTime ts;
       GstClockTime ts2;
       guint num_subframes;
+      guint subframes_processed;
     } ABI;
     gpointer padding[GST_PADDING_LARGE];
   } abidata;
diff --git a/gst-libs/gst/video/meson.build b/gst-libs/gst/video/meson.build
index d1d0492099..132926501f 100644
--- a/gst-libs/gst/video/meson.build
+++ b/gst-libs/gst/video/meson.build
@@ -3,6 +3,7 @@ video_sources = [
   'colorbalancechannel.c',
   'convertframe.c',
   'gstvideoaffinetransformationmeta.c',
+  'gstvideocodecalphameta.c',
   'gstvideoaggregator.c',
   'gstvideodecoder.c',
   'gstvideoencoder.c',
@@ -29,6 +30,7 @@ video_sources = [
   'video-multiview.c',
   'video-resampler.c',
   'video-scaler.c',
+  'video-sei.c',
   'video-tile.c',
   'video-overlay-composition.c',
   'videodirection.c',
@@ -40,6 +42,7 @@ video_headers = [
   'colorbalance.h',
   'colorbalancechannel.h',
   'gstvideoaffinetransformationmeta.h',
+  'gstvideocodecalphameta.h',
   'gstvideoaggregator.h',
   'gstvideodecoder.h',
   'gstvideoencoder.h',
@@ -71,7 +74,9 @@ video_headers = [
   'video-blend.h',
   'video-overlay-composition.h',
   'video-multiview.h',
+  'video-sei.h',
 ]
+
 install_headers(video_headers, subdir : 'gstreamer-1.0/gst/video/')
 
 video_mkenum_headers = [
@@ -88,7 +93,11 @@ video_mkenum_headers = [
   'video-resampler.h',
   'video-scaler.h',
   'video-tile.h',
+  'gstvideometa.h',
   'gstvideotimecode.h',
+  'gstvideoutils.h',
+  'gstvideoencoder.h',
+  'gstvideodecoder.h',
   'colorbalance.h',
   'navigation.h',
 ]
diff --git a/gst-libs/gst/video/navigation.c b/gst-libs/gst/video/navigation.c
index 95481686c9..09411ce0d2 100644
--- a/gst-libs/gst/video/navigation.c
+++ b/gst-libs/gst/video/navigation.c
@@ -26,27 +26,29 @@
  * @short_description: Interface for creating, sending and parsing navigation
  * events.
  *
- * The Navigation interface is used for creating and injecting navigation related
- * events such as mouse button presses, cursor motion and key presses. The associated
- * library also provides methods for parsing received events, and for sending and
- * receiving navigation related bus events. One main usecase is DVD menu navigation.
+ * The Navigation interface is used for creating and injecting navigation
+ * related events such as mouse button presses, cursor motion and key presses.
+ * The associated library also provides methods for parsing received events, and
+ * for sending and receiving navigation related bus events. One main usecase is
+ * DVD menu navigation.
  *
  * The main parts of the API are:
  *
- * * The GstNavigation interface, implemented by elements which provide an application
- *   with the ability to create and inject navigation events into the pipeline.
- * * GstNavigation event handling API. GstNavigation events are created in response to
- *   calls on a GstNavigation interface implementation, and sent in the pipeline. Upstream
- *   elements can use the navigation event API functions to parse the contents of received
- *   messages.
+ * * The GstNavigation interface, implemented by elements which provide an
+ *   application with the ability to create and inject navigation events into
+ *   the pipeline.
+ * * GstNavigation event handling API. GstNavigation events are created in
+ *   response to calls on a GstNavigation interface implementation, and sent in
+ *   the pipeline. Upstream elements can use the navigation event API functions
+ *   to parse the contents of received messages.
  *
- * * GstNavigation message handling API. GstNavigation messages may be sent on the message
- *   bus to inform applications of navigation related changes in the pipeline, such as the
- *   mouse moving over a clickable region, or the set of available angles changing.
- *
- * The GstNavigation message functions provide functions for creating and parsing
- * custom bus messages for signaling GstNavigation changes.
+ * * GstNavigation message handling API. GstNavigation messages may be sent on
+ *   the message bus to inform applications of navigation related changes in the
+ *   pipeline, such as the mouse moving over a clickable region, or the set of
+ *   available angles changing.
  *
+ * The GstNavigation message functions provide functions for creating and
+ * parsing custom bus messages for signaling GstNavigation changes.
  */
 
 #ifdef HAVE_CONFIG_H
@@ -64,11 +66,26 @@
 
 G_DEFINE_INTERFACE (GstNavigation, gst_navigation, 0);
 
+static void
+gst_navigation_default_send_event_simple (GstNavigation * navigation,
+    GstEvent * event)
+{
+  GstNavigationInterface *iface = GST_NAVIGATION_GET_INTERFACE (navigation);
+
+  if (iface->send_event) {
+    iface->send_event (navigation,
+        gst_structure_copy (gst_event_get_structure (event)));
+  } else {
+    gst_event_unref (event);
+  }
+}
+
 static void
 gst_navigation_default_init (GstNavigationInterface * iface)
 {
   /* default virtual functions */
   iface->send_event = NULL;
+  iface->send_event_simple = gst_navigation_default_send_event_simple;
 }
 
 /* The interface implementer should make sure that the object can handle
@@ -80,6 +97,8 @@ gst_navigation_send_event (GstNavigation * navigation, GstStructure * structure)
 
   if (iface->send_event) {
     iface->send_event (navigation, structure);
+  } else if (iface->send_event_simple) {
+    iface->send_event_simple (navigation, gst_event_new_navigation (structure));
   } else {
     gst_structure_free (structure);
   }
@@ -179,6 +198,32 @@ gst_navigation_send_command (GstNavigation * navigation,
           "command", "command-code", G_TYPE_UINT, (guint) command, NULL));
 }
 
+/**
+ * gst_navigation_send_event_simple:
+ * @navigation: The navigation interface instance
+ * @event: (transfer full): The event to send
+ *
+ * Sends an event to the navigation interface.
+ * Since: 1.22
+ */
+void
+gst_navigation_send_event_simple (GstNavigation * navigation, GstEvent * event)
+{
+  GstNavigationInterface *iface = GST_NAVIGATION_GET_INTERFACE (navigation);
+
+  g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_NAVIGATION);
+
+  if (iface->send_event_simple) {
+    iface->send_event_simple (navigation, event);
+  } else if (iface->send_event) {
+    iface->send_event (navigation,
+        gst_structure_copy (gst_event_get_structure (event)));
+    gst_event_unref (event);
+  } else {
+    gst_event_unref (event);
+  }
+}
+
 /* Navigation Queries */
 
 #define GST_NAVIGATION_QUERY_HAS_TYPE(query,query_type) \
@@ -741,16 +786,324 @@ gst_navigation_event_get_type (GstEvent * event)
     return GST_NAVIGATION_EVENT_KEY_RELEASE;
   else if (g_str_equal (e_type, "command"))
     return GST_NAVIGATION_EVENT_COMMAND;
+  else if (g_str_equal (e_type, "touch-down"))
+    return GST_NAVIGATION_EVENT_TOUCH_DOWN;
+  else if (g_str_equal (e_type, "touch-up"))
+    return GST_NAVIGATION_EVENT_TOUCH_UP;
+  else if (g_str_equal (e_type, "touch-cancel"))
+    return GST_NAVIGATION_EVENT_TOUCH_CANCEL;
+  else if (g_str_equal (e_type, "touch-motion"))
+    return GST_NAVIGATION_EVENT_TOUCH_MOTION;
+  else if (g_str_equal (e_type, "touch-frame"))
+    return GST_NAVIGATION_EVENT_TOUCH_FRAME;
 
   return GST_NAVIGATION_EVENT_INVALID;
 }
 
+/**
+ * gst_navigation_event_new_key_press:
+ * @key: A string identifying the key press.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for the given key press.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_key_press (const gchar * key,
+    GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "key-press", "key", G_TYPE_STRING, key,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_key_release:
+ * @key: A string identifying the released key.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for the given key release.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_key_release (const gchar * key,
+    GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "key-release", "key", G_TYPE_STRING, key,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_mouse_button_press:
+ * @button: The number of the pressed mouse button.
+ * @x: The x coordinate of the mouse cursor.
+ * @y: The y coordinate of the mouse cursor.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for the given key mouse button press.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_mouse_button_press (gint button, gdouble x, gdouble y,
+    GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "mouse-button-press",
+          "button", G_TYPE_INT, button, "pointer_x", G_TYPE_DOUBLE, x,
+          "pointer_y", G_TYPE_DOUBLE, y,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_mouse_button_release:
+ * @button: The number of the released mouse button.
+ * @x: The x coordinate of the mouse cursor.
+ * @y: The y coordinate of the mouse cursor.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for the given key mouse button release.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_mouse_button_release (gint button, gdouble x,
+    gdouble y, GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "mouse-button-release",
+          "button", G_TYPE_INT, button, "pointer_x", G_TYPE_DOUBLE, x,
+          "pointer_y", G_TYPE_DOUBLE, y,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_mouse_move:
+ * @x: The x coordinate of the mouse cursor.
+ * @y: The y coordinate of the mouse cursor.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for the new mouse location.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_mouse_move (gdouble x, gdouble y,
+    GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "mouse-move",
+          "pointer_x", G_TYPE_DOUBLE, x,
+          "pointer_y", G_TYPE_DOUBLE, y,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_mouse_scroll:
+ * @x: The x coordinate of the mouse cursor.
+ * @y: The y coordinate of the mouse cursor.
+ * @delta_x: The x component of the scroll movement.
+ * @delta_y: The y component of the scroll movement.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for the mouse scroll.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_mouse_scroll (gdouble x, gdouble y, gdouble delta_x,
+    gdouble delta_y, GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "mouse-scroll",
+          "pointer_x", G_TYPE_DOUBLE, x, "pointer_y", G_TYPE_DOUBLE, y,
+          "delta_pointer_x", G_TYPE_DOUBLE, delta_x,
+          "delta_pointer_y", G_TYPE_DOUBLE, delta_y,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_command:
+ * @command: The navigation command to use.
+ *
+ * Create a new navigation event given navigation command..
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_command (GstNavigationCommand command)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "command",
+          "command-code", G_TYPE_UINT, (guint) command, NULL));
+}
+
+/**
+ * gst_navigation_event_new_touch_down:
+ * @identifier: A number uniquely identifying this touch point. It must stay
+ *    unique to this touch point at least until an up event is sent for
+ *    the same identifier, or all touch points are cancelled.
+ * @x: The x coordinate of the new touch point.
+ * @y: The y coordinate of the new touch point.
+ * @pressure: Pressure data of the touch point, from 0.0 to 1.0, or NaN if no
+ *    data is available.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for an added touch point.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_touch_down (guint identifier, gdouble x, gdouble y,
+    gdouble pressure, GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "touch-down",
+          "identifier", G_TYPE_UINT, identifier,
+          "pointer_x", G_TYPE_DOUBLE, x,
+          "pointer_y", G_TYPE_DOUBLE, y,
+          "pressure", G_TYPE_DOUBLE, pressure,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_touch_motion:
+ * @identifier: A number uniquely identifying this touch point. It must
+ *    correlate to exactly one previous touch_start event.
+ * @x: The x coordinate of the touch point.
+ * @y: The y coordinate of the touch point.
+ * @pressure: Pressure data of the touch point, from 0.0 to 1.0, or NaN if no
+ *    data is available.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for a moved touch point.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_touch_motion (guint identifier, gdouble x, gdouble y,
+    gdouble pressure, GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "touch-motion",
+          "identifier", G_TYPE_UINT, identifier,
+          "pointer_x", G_TYPE_DOUBLE, x,
+          "pointer_y", G_TYPE_DOUBLE, y,
+          "pressure", G_TYPE_DOUBLE, pressure,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_touch_up:
+ * @identifier: A number uniquely identifying this touch point. It must
+ *    correlate to exactly one previous down event, but can be reused
+ *    after sending this event.
+ * @x: The x coordinate of the touch point.
+ * @y: The y coordinate of the touch point.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event for a removed touch point.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_touch_up (guint identifier, gdouble x, gdouble y,
+    GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "touch-up",
+          "identifier", G_TYPE_UINT, identifier,
+          "pointer_x", G_TYPE_DOUBLE, x, "pointer_y", G_TYPE_DOUBLE, y,
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+/**
+ * gst_navigation_event_new_touch_frame:
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event signalling the end of a touch frame. Touch
+ * frames signal that all previous down, motion and up events not followed by
+ * another touch frame event already should be considered simultaneous.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_touch_frame (GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "touch-frame",
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
+
+/**
+ * gst_navigation_event_new_touch_cancel:
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Create a new navigation event signalling that all currently active touch
+ * points are cancelled and should be discarded. For example, under Wayland
+ * this event might be sent when a swipe passes the threshold to be recognized
+ * as a gesture by the compositor.
+ *
+ * Returns: (transfer full): a new #GstEvent
+ *
+ * Since: 1.22
+ */
+GstEvent *
+gst_navigation_event_new_touch_cancel (GstNavigationModifierType state)
+{
+  return gst_event_new_navigation (gst_structure_new (GST_NAVIGATION_EVENT_NAME,
+          "event", G_TYPE_STRING, "touch-cancel",
+          "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state, NULL));
+}
+
 /**
  * gst_navigation_event_parse_key_event:
  * @event: A #GstEvent to inspect.
  * @key: (out) (optional) (transfer none): A pointer to a location to receive
  *     the string identifying the key press. The returned string is owned by the
  *     event, and valid only until the event is unreffed.
+ *
+ * Note: Modifier keys (as defined in #GstNavigationModifierType)
+ * [press](GST_NAVIGATION_EVENT_KEY_PRESS) and
+ * [release](GST_NAVIGATION_KEY_PRESS) events are generated even if those states are
+ * present on all other related events
  */
 gboolean
 gst_navigation_event_parse_key_event (GstEvent * event, const gchar ** key)
@@ -920,3 +1273,204 @@ gst_navigation_event_parse_command (GstEvent * event,
 
   return ret;
 }
+
+/**
+ * gst_navigation_event_parse_touch_event:
+ * @event: A #GstEvent to inspect.
+ * @identifier: (out) (optional): Pointer to a guint that will receive the
+ *     identifier unique to this touch point.
+ * @x: (out) (optional): Pointer to a gdouble that will receive the x
+ *     coordinate of the touch event.
+ * @y: (out) (optional): Pointer to a gdouble that will receive the y
+ *     coordinate of the touch event.
+ * @pressure: (out) (optional): Pointer to a gdouble that will receive the
+ *     force of the touch event, in the range from 0.0 to 1.0. If pressure
+ *     data is not available, NaN will be set instead.
+ *
+ * Retrieve the details of a #GstNavigation touch-down or touch-motion event.
+ * Determine which type the event is using gst_navigation_event_get_type()
+ * to retrieve the #GstNavigationEventType.
+ *
+ * Returns: TRUE if all details could be extracted, otherwise FALSE.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_navigation_event_parse_touch_event (GstEvent * event, guint * identifier,
+    gdouble * x, gdouble * y, gdouble * pressure)
+{
+  GstNavigationEventType e_type;
+  const GstStructure *s;
+  gboolean ret = TRUE;
+
+  e_type = gst_navigation_event_get_type (event);
+  g_return_val_if_fail (e_type == GST_NAVIGATION_EVENT_TOUCH_DOWN ||
+      e_type == GST_NAVIGATION_EVENT_TOUCH_MOTION, FALSE);
+
+  s = gst_event_get_structure (event);
+  if (identifier)
+    ret &= gst_structure_get_uint (s, "identifier", identifier);
+  if (x)
+    ret &= gst_structure_get_double (s, "pointer_x", x);
+  if (y)
+    ret &= gst_structure_get_double (s, "pointer_y", y);
+  if (pressure)
+    ret &= gst_structure_get_double (s, "pressure", pressure);
+
+  WARN_IF_FAIL (ret, "Couldn't extract details from touch event");
+
+  return ret;
+}
+
+/**
+ * gst_navigation_event_parse_touch_up_event:
+ * @event: A #GstEvent to inspect.
+ * @identifier: (out) (optional): Pointer to a guint that will receive the
+ *     identifier unique to this touch point.
+ * @x: (out) (optional): Pointer to a gdouble that will receive the x
+ *     coordinate of the touch event.
+ * @y: (out) (optional): Pointer to a gdouble that will receive the y
+ *     coordinate of the touch event.
+ *
+ * Retrieve the details of a #GstNavigation touch-up event.
+ *
+ * Returns: TRUE if all details could be extracted, otherwise FALSE.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_navigation_event_parse_touch_up_event (GstEvent * event,
+    guint * identifier, gdouble * x, gdouble * y)
+{
+  const GstStructure *s;
+  gboolean ret = TRUE;
+
+  g_return_val_if_fail (GST_NAVIGATION_EVENT_HAS_TYPE (event, TOUCH_UP), FALSE);
+
+  s = gst_event_get_structure (event);
+  if (identifier)
+    ret &= gst_structure_get_uint (s, "identifier", identifier);
+  if (x)
+    ret &= gst_structure_get_double (s, "pointer_x", x);
+  if (y)
+    ret &= gst_structure_get_double (s, "pointer_y", y);
+
+  WARN_IF_FAIL (ret, "Couldn't extract details from touch-up event");
+
+  return ret;
+}
+
+/**
+ * gst_navigation_event_get_coordinates:
+ * @event: The #GstEvent to inspect.
+ * @x: (out) (optional): Pointer to a gdouble to receive the x coordinate of the
+ *     navigation event.
+ * @y: (out) (optional): Pointer to a gdouble to receive the y coordinate of the
+ *     navigation event.
+ *
+ * Try to retrieve x and y coordinates of a #GstNavigation event.
+ *
+ * Returns: A boolean indicating success.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_navigation_event_get_coordinates (GstEvent * event,
+    gdouble * x, gdouble * y)
+{
+  GstNavigationEventType e_type;
+  const GstStructure *s;
+  gboolean ret = TRUE;
+
+  e_type = gst_navigation_event_get_type (event);
+  if (e_type != GST_NAVIGATION_EVENT_MOUSE_MOVE
+      && e_type != GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS
+      && e_type != GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE
+      && e_type != GST_NAVIGATION_EVENT_TOUCH_DOWN
+      && e_type != GST_NAVIGATION_EVENT_TOUCH_MOTION
+      && e_type != GST_NAVIGATION_EVENT_TOUCH_UP) {
+    return FALSE;
+  }
+
+  s = gst_event_get_structure (event);
+  if (x)
+    ret &= gst_structure_get_double (s, "pointer_x", x);
+  if (y)
+    ret &= gst_structure_get_double (s, "pointer_y", y);
+
+  WARN_IF_FAIL (ret, "Couldn't extract coordinates from the event");
+
+  return ret;
+}
+
+/**
+ * gst_navigation_event_set_coordinates:
+ * @event: The #GstEvent to modify.
+ * @x: The x coordinate to set.
+ * @y: The y coordinate to set.
+ *
+ * Try to set x and y coordinates on a #GstNavigation event. The event must
+ * be writable.
+ *
+ * Returns: A boolean indicating success.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_navigation_event_set_coordinates (GstEvent * event, gdouble x, gdouble y)
+{
+  GstNavigationEventType e_type;
+  GstStructure *s;
+
+  g_return_val_if_fail (gst_event_is_writable (event), FALSE);
+
+  e_type = gst_navigation_event_get_type (event);
+  if (e_type != GST_NAVIGATION_EVENT_MOUSE_MOVE
+      && e_type != GST_NAVIGATION_EVENT_MOUSE_BUTTON_PRESS
+      && e_type != GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE
+      && e_type != GST_NAVIGATION_EVENT_TOUCH_DOWN
+      && e_type != GST_NAVIGATION_EVENT_TOUCH_MOTION
+      && e_type != GST_NAVIGATION_EVENT_TOUCH_UP) {
+    return FALSE;
+  }
+
+  s = gst_event_writable_structure (event);
+  gst_structure_set (s, "pointer_x", G_TYPE_DOUBLE, x,
+      "pointer_y", G_TYPE_DOUBLE, y, NULL);
+
+  return TRUE;
+}
+
+
+/**
+ * gst_navigation_event_parse_modifier_state:
+ * @event: The #GstEvent to modify.
+ * @state: a bit-mask representing the state of the modifier keys (e.g. Control,
+ * Shift and Alt).
+ *
+ * Returns: TRUE if the event is a #GstNavigation event with associated
+ * modifiers state, otherwise FALSE.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_navigation_event_parse_modifier_state (GstEvent * event,
+    GstNavigationModifierType * state)
+{
+  GstNavigationEventType e_type;
+  const GstStructure *s;
+
+  g_return_val_if_fail (GST_IS_EVENT (event), FALSE);
+
+  e_type = gst_navigation_event_get_type (event);
+  if (e_type == GST_NAVIGATION_EVENT_COMMAND) {
+    return FALSE;
+  }
+
+  s = gst_event_get_structure (event);
+  if (!gst_structure_get (s, "state", GST_TYPE_NAVIGATION_MODIFIER_TYPE, state,
+          NULL))
+    *state = GST_NAVIGATION_MODIFIER_NONE;
+
+  return TRUE;
+}
diff --git a/gst-libs/gst/video/navigation.h b/gst-libs/gst/video/navigation.h
index ced2892f10..650f58241a 100644
--- a/gst-libs/gst/video/navigation.h
+++ b/gst-libs/gst/video/navigation.h
@@ -40,10 +40,83 @@ G_BEGIN_DECLS
 typedef struct _GstNavigation GstNavigation;
 typedef struct _GstNavigationInterface GstNavigationInterface;
 
+/**
+ * GstNavigationModifierType:
+ * @GST_NAVIGATION_MODIFIER_SHIFT_MASK: the Shift key.
+ * @GST_NAVIGATION_MODIFIER_CONTROL_MASK: the Control key.
+ * @GST_NAVIGATION_MODIFIER_MOD1_MASK: the third modifier key
+ * @GST_NAVIGATION_MODIFIER_MOD2_MASK: the fourth modifier key
+ * @GST_NAVIGATION_MODIFIER_MOD3_MASK: the fifth modifier key
+ * @GST_NAVIGATION_MODIFIER_MOD4_MASK: the sixth modifier key
+ * @GST_NAVIGATION_MODIFIER_MOD5_MASK: the seventh modifier key
+ * @GST_NAVIGATION_MODIFIER_BUTTON1_MASK: the first mouse button (usually the left button).
+ * @GST_NAVIGATION_MODIFIER_BUTTON2_MASK: the second mouse button (usually the right button).
+ * @GST_NAVIGATION_MODIFIER_BUTTON3_MASK: the third mouse button (usually the mouse wheel button or middle button).
+ * @GST_NAVIGATION_MODIFIER_BUTTON4_MASK: the fourth mouse button (typically the "Back" button).
+ * @GST_NAVIGATION_MODIFIER_BUTTON5_MASK: the fifth mouse button (typically the "forward" button).
+ * @GST_NAVIGATION_MODIFIER_SUPER_MASK: the Super modifier
+ * @GST_NAVIGATION_MODIFIER_HYPER_MASK: the Hyper modifier
+ * @GST_NAVIGATION_MODIFIER_META_MASK: the Meta modifier
+ * @GST_NAVIGATION_MODIFIER_MASK: A mask covering all entries in #GdkModifierType.
+ *
+ * Flags to indicate the state of modifier keys and mouse buttons
+ * in events.
+ *
+ * Typical modifier keys are Shift, Control, Meta, Super, Hyper, Alt, Compose,
+ * Apple, CapsLock or ShiftLock.
+ *
+ * Since: 1.22
+ */
+typedef enum
+{
+  GST_NAVIGATION_MODIFIER_NONE          = 0,
+  GST_NAVIGATION_MODIFIER_SHIFT_MASK    = 1 << 0,
+  GST_NAVIGATION_MODIFIER_LOCK_MASK     = 1 << 1,
+  GST_NAVIGATION_MODIFIER_CONTROL_MASK  = 1 << 2,
+
+  GST_NAVIGATION_MODIFIER_MOD1_MASK  = 1 << 3,
+  GST_NAVIGATION_MODIFIER_MOD2_MASK  = 1 << 4,
+  GST_NAVIGATION_MODIFIER_MOD3_MASK  = 1 << 5,
+  GST_NAVIGATION_MODIFIER_MOD4_MASK  = 1 << 6,
+  GST_NAVIGATION_MODIFIER_MOD5_MASK  = 1 << 7,
+
+  GST_NAVIGATION_MODIFIER_BUTTON1_MASK  = 1 << 8,
+  GST_NAVIGATION_MODIFIER_BUTTON2_MASK  = 1 << 9,
+  GST_NAVIGATION_MODIFIER_BUTTON3_MASK  = 1 << 10,
+  GST_NAVIGATION_MODIFIER_BUTTON4_MASK  = 1 << 11,
+  GST_NAVIGATION_MODIFIER_BUTTON5_MASK  = 1 << 12,
+
+  GST_NAVIGATION_MODIFIER_SUPER_MASK    = 1 << 26,
+  GST_NAVIGATION_MODIFIER_HYPER_MASK    = 1 << 27,
+  GST_NAVIGATION_MODIFIER_META_MASK     = 1 << 28,
+
+  GST_NAVIGATION_MODIFIER_MASK = (
+    GST_NAVIGATION_MODIFIER_NONE          |
+    GST_NAVIGATION_MODIFIER_SHIFT_MASK    |
+    GST_NAVIGATION_MODIFIER_LOCK_MASK     |
+    GST_NAVIGATION_MODIFIER_CONTROL_MASK  |
+    GST_NAVIGATION_MODIFIER_MOD1_MASK      |
+    GST_NAVIGATION_MODIFIER_MOD2_MASK      |
+    GST_NAVIGATION_MODIFIER_MOD3_MASK      |
+    GST_NAVIGATION_MODIFIER_MOD4_MASK      |
+    GST_NAVIGATION_MODIFIER_MOD5_MASK      |
+    GST_NAVIGATION_MODIFIER_BUTTON1_MASK  |
+    GST_NAVIGATION_MODIFIER_BUTTON2_MASK  |
+    GST_NAVIGATION_MODIFIER_BUTTON3_MASK  |
+    GST_NAVIGATION_MODIFIER_BUTTON4_MASK  |
+    GST_NAVIGATION_MODIFIER_BUTTON5_MASK  |
+    GST_NAVIGATION_MODIFIER_SUPER_MASK    |
+    GST_NAVIGATION_MODIFIER_HYPER_MASK    |
+    GST_NAVIGATION_MODIFIER_META_MASK
+  )
+
+} GstNavigationModifierType;
+
 /**
  * GstNavigationInterface:
  * @iface: the parent interface
  * @send_event: sending a navigation event
+ * @send_event_simple: sending a navigation event (Since: 1.22)
  *
  * Navigation interface.
  */
@@ -51,7 +124,26 @@ struct _GstNavigationInterface {
   GTypeInterface iface;
 
   /* virtual functions */
+
+  /**
+   * GstNavigationInterface::send_event:
+   *
+   * sending a navigation event.
+   *
+   * Deprecated: 1.22: Use #GstNavigationInterface.send_event_simple() instead.
+   */
   void (*send_event) (GstNavigation *navigation, GstStructure *structure);
+
+  /**
+   * GstNavigationInterface::send_event_simple:
+   * @navigation: The navigation interface instance
+   * @event: (transfer full): The event to send
+   *
+   * sending a navigation event.
+   *
+   * Since: 1.22
+   */
+  void (*send_event_simple) (GstNavigation *navigation, GstEvent *event);
 };
 
 GST_VIDEO_API
@@ -263,9 +355,26 @@ gboolean        gst_navigation_message_parse_event          (GstMessage *message
  * @GST_NAVIGATION_EVENT_MOUSE_SCROLL: A mouse scroll event. Use
  * gst_navigation_event_parse_mouse_scroll_event() to extract the details from
  * the event. (Since: 1.18)
+ * @GST_NAVIGATION_EVENT_TOUCH_DOWN: An event describing a new touch point,
+ * which will be assigned an identifier that is unique to it for the duration
+ * of its movement on the screen. Use gst_navigation_event_parse_touch_event()
+ * to extract the details from the event. (Since: 1.22)
+ * @GST_NAVIGATION_EVENT_TOUCH_MOTION: An event describing the movement of an
+ * active touch point across the screen. Use
+ * gst_navigation_event_parse_touch_event() to extract the details from the
+ * event. (Since: 1.22)
+ * @GST_NAVIGATION_EVENT_TOUCH_UP: An event describing a removed touch point.
+ * After this event, its identifier may be reused for any new touch points. Use
+ * gst_navigation_event_parse_touch_up_event() to extract the details from the
+ * event. (Since: 1.22)
+ * @GST_NAVIGATION_EVENT_TOUCH_FRAME: An event signaling the end of a sequence
+ * of simultaneous touch events. (Since: 1.22)
+ * @GST_NAVIGATION_EVENT_TOUCH_CANCEL: An event cancelling all currently active
+ * touch points. (Since: 1.22)
  *
  * Enum values for the various events that an element implementing the
- * GstNavigation interface might send up the pipeline.
+ * GstNavigation interface might send up the pipeline. Touch events have been
+ * inspired by the libinput API, and have the same meaning here.
  */
 typedef enum {
   GST_NAVIGATION_EVENT_INVALID                    = 0,
@@ -275,12 +384,128 @@ typedef enum {
   GST_NAVIGATION_EVENT_MOUSE_BUTTON_RELEASE       = 4,
   GST_NAVIGATION_EVENT_MOUSE_MOVE                 = 5,
   GST_NAVIGATION_EVENT_COMMAND                    = 6,
-  GST_NAVIGATION_EVENT_MOUSE_SCROLL               = 7
+
+  /**
+   * GST_NAVIGATION_EVENT_MOUSE_SCROLL:
+   *
+   * A mouse scroll event. Use gst_navigation_event_parse_mouse_scroll_event()
+   * to extract the details from the event.
+   *
+   * Since: 1.18
+   */
+  GST_NAVIGATION_EVENT_MOUSE_SCROLL               = 7,
+
+  /**
+   * GST_NAVIGATION_EVENT_TOUCH_DOWN:
+   *
+   * An event describing a new touch point, which will be assigned an identifier
+   * that is unique to it for the duration of its movement on the screen.
+   * Use gst_navigation_event_parse_touch_event() to extract the details
+   * from the event.
+   *
+   * Since: 1.22
+   */
+  GST_NAVIGATION_EVENT_TOUCH_DOWN                 = 8,
+
+  /**
+   * GST_NAVIGATION_EVENT_TOUCH_MOTION:
+   *
+   * An event describing the movement of an active touch point across
+   * the screen. Use gst_navigation_event_parse_touch_event() to extract
+   * the details from the event.
+   *
+   * Since: 1.22
+   */
+  GST_NAVIGATION_EVENT_TOUCH_MOTION               = 9,
+
+  /**
+   * GST_NAVIGATION_EVENT_TOUCH_UP:
+   *
+   * An event describing a removed touch point. After this event,
+   * its identifier may be reused for any new touch points.
+   * Use gst_navigation_event_parse_touch_up_event() to extract the details
+   * from the event.
+   *
+   * Since: 1.22
+   */
+  GST_NAVIGATION_EVENT_TOUCH_UP                   = 10,
+
+  /**
+   * GST_NAVIGATION_EVENT_TOUCH_FRAME:
+   *
+   * An event signaling the end of a sequence of simultaneous touch events.
+   *
+   * Since: 1.22
+   */
+  GST_NAVIGATION_EVENT_TOUCH_FRAME                = 11,
+
+  /**
+   * GST_NAVIGATION_EVENT_TOUCH_CANCEL:
+   *
+   * An event cancelling all currently active touch points.
+   *
+   * Since: 1.22
+   */
+  GST_NAVIGATION_EVENT_TOUCH_CANCEL               = 12,
 } GstNavigationEventType;
 
 GST_VIDEO_API
 GstNavigationEventType gst_navigation_event_get_type          (GstEvent *event);
 
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_key_press            (const gchar * key,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_key_release          (const gchar * key,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_mouse_button_press   (gint button, gdouble x,
+                                                               gdouble y,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_mouse_button_release (gint button, gdouble x,
+                                                               gdouble y,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_mouse_move           (gdouble x,
+                                                               gdouble y,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_mouse_scroll         (gdouble x, gdouble y,
+                                                               gdouble delta_x, gdouble delta_y,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_command              (GstNavigationCommand command) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_touch_down           (guint identifier,
+                                                               gdouble x, gdouble y,
+                                                               gdouble pressure,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_touch_motion         (guint identifier,
+                                                               gdouble x, gdouble y,
+                                                               gdouble pressure,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_touch_up             (guint identifier,
+                                                               gdouble x, gdouble y,
+                                                               GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_touch_frame          (GstNavigationModifierType state) G_GNUC_MALLOC;
+
+GST_VIDEO_API
+GstEvent*       gst_navigation_event_new_touch_cancel         (GstNavigationModifierType state) G_GNUC_MALLOC;
+
 GST_VIDEO_API
 gboolean        gst_navigation_event_parse_key_event          (GstEvent *event,
                                                                const gchar **key);
@@ -302,27 +527,54 @@ GST_VIDEO_API
 gboolean        gst_navigation_event_parse_command            (GstEvent *event,
                                                                GstNavigationCommand *command);
 
-/* interface virtual function wrappers */
-
 GST_VIDEO_API
-void    gst_navigation_send_event       (GstNavigation *navigation,
-                                         GstStructure *structure);
+gboolean        gst_navigation_event_parse_touch_event        (GstEvent * event,
+                                                               guint * identifier,
+                                                               gdouble * x, gdouble * y,
+                                                               gdouble * pressure);
 
 GST_VIDEO_API
-void    gst_navigation_send_key_event   (GstNavigation *navigation,
-                                         const char *event, const char *key);
+gboolean        gst_navigation_event_parse_touch_up_event     (GstEvent * event,
+                                                               guint * identifier,
+                                                               gdouble * x, gdouble * y);
 
 GST_VIDEO_API
-void    gst_navigation_send_mouse_event (GstNavigation *navigation,
-                                         const char *event, int button, double x, double y);
+gboolean  gst_navigation_event_get_coordinates (GstEvent * event,
+                                                gdouble * x, gdouble * y);
 
 GST_VIDEO_API
+gboolean  gst_navigation_event_set_coordinates (GstEvent * event,
+                                                gdouble x, gdouble y);
+
+/* interface virtual function wrappers */
+
+GST_VIDEO_DEPRECATED_FOR(gst_navigation_send_event_simple)
+void    gst_navigation_send_event        (GstNavigation *navigation,
+                                          GstStructure *structure);
+
+GST_VIDEO_DEPRECATED_FOR(gst_navigation_send_event_simple)
+void    gst_navigation_send_key_event    (GstNavigation *navigation,
+                                          const char *event, const char *key);
+
+GST_VIDEO_DEPRECATED_FOR(gst_navigation_send_event_simple)
+void    gst_navigation_send_mouse_event  (GstNavigation *navigation,
+                                          const char *event, int button, double x, double y);
+
+GST_VIDEO_DEPRECATED_FOR(gst_navigation_send_event_simple)
 void    gst_navigation_send_mouse_scroll_event (GstNavigation *navigation,
                                                 double x, double y, double delta_x, double delta_y);
 
+GST_VIDEO_DEPRECATED_FOR(gst_navigation_send_event_simple)
+void    gst_navigation_send_command      (GstNavigation *navigation,
+                                          GstNavigationCommand command);
+
+GST_VIDEO_API
+void    gst_navigation_send_event_simple (GstNavigation *navigation,
+                                          GstEvent *event);
+
 GST_VIDEO_API
-void    gst_navigation_send_command     (GstNavigation *navigation,
-                                         GstNavigationCommand command);
+gboolean        gst_navigation_event_parse_modifier_state (GstEvent *event,
+                                                           GstNavigationModifierType *state);
 
 G_END_DECLS
 
diff --git a/gst-libs/gst/video/video-chroma.c b/gst-libs/gst/video/video-chroma.c
index f761b4435b..2a634073df 100644
--- a/gst-libs/gst/video/video-chroma.c
+++ b/gst-libs/gst/video/video-chroma.c
@@ -26,7 +26,7 @@
 
 #include "video-orc.h"
 #include "video-format.h"
-
+#include <gst/video/video-enumtypes.h>
 
 /**
  * SECTION:gstvideochroma
@@ -72,7 +72,9 @@ typedef struct
 static const ChromaSiteInfo chromasite[] = {
   {"jpeg", GST_VIDEO_CHROMA_SITE_JPEG},
   {"mpeg2", GST_VIDEO_CHROMA_SITE_MPEG2},
-  {"dv", GST_VIDEO_CHROMA_SITE_DV}
+  {"dv", GST_VIDEO_CHROMA_SITE_DV},
+  {"alt-line", GST_VIDEO_CHROMA_SITE_ALT_LINE},
+  {"cosited", GST_VIDEO_CHROMA_SITE_COSITED},
 };
 
 /**
@@ -81,18 +83,66 @@ static const ChromaSiteInfo chromasite[] = {
  *
  * Convert @s to a #GstVideoChromaSite
  *
+ * Deprecated: 1.20: Use gst_video_chroma_site_from_string() instead.
+ *
  * Returns: a #GstVideoChromaSite or %GST_VIDEO_CHROMA_SITE_UNKNOWN when @s does
  * not contain a valid chroma description.
  */
 GstVideoChromaSite
 gst_video_chroma_from_string (const gchar * s)
+{
+  return gst_video_chroma_site_from_string (s);
+}
+
+/**
+ * gst_video_chroma_site_from_string:
+ * @s: a chromasite string
+ *
+ * Convert @s to a #GstVideoChromaSite
+ *
+ * Returns: a #GstVideoChromaSite or %GST_VIDEO_CHROMA_SITE_UNKNOWN when @s does
+ * not contain a valid chroma-site description.
+ *
+ * Since: 1.20
+ */
+GstVideoChromaSite
+gst_video_chroma_site_from_string (const gchar * s)
 {
   gint i;
+  gchar **split;
+  gchar **iter;
+  GstVideoChromaSite ret = GST_VIDEO_CHROMA_SITE_UNKNOWN;
+  GFlagsClass *klass;
+
   for (i = 0; i < G_N_ELEMENTS (chromasite); i++) {
     if (g_str_equal (chromasite[i].name, s))
       return chromasite[i].site;
   }
-  return GST_VIDEO_CHROMA_SITE_UNKNOWN;
+
+  klass = (GFlagsClass *) g_type_class_ref (GST_TYPE_VIDEO_CHROMA_SITE);
+  split = g_strsplit (s, "+", 0);
+  for (iter = split; *iter; iter++) {
+    GFlagsValue *value;
+
+    value = g_flags_get_value_by_nick (klass, *iter);
+    if (!value) {
+      ret = GST_VIDEO_CHROMA_SITE_UNKNOWN;
+      goto out;
+    }
+
+    ret |= value->value;
+  }
+
+out:
+  g_type_class_unref (klass);
+  g_strfreev (split);
+
+  /* Doesn't make sense */
+  if ((ret & GST_VIDEO_CHROMA_SITE_NONE) != 0 &&
+      ret != GST_VIDEO_CHROMA_SITE_NONE)
+    return GST_VIDEO_CHROMA_SITE_UNKNOWN;
+
+  return ret;
 }
 
 /**
@@ -101,6 +151,8 @@ gst_video_chroma_from_string (const gchar * s)
  *
  * Converts @site to its string representation.
  *
+ * Deprecated: 1.20: Use gst_video_chroma_site_to_string() instead.
+ *
  * Returns: a string describing @site.
  */
 const gchar *
@@ -114,6 +166,60 @@ gst_video_chroma_to_string (GstVideoChromaSite site)
   return NULL;
 }
 
+/**
+ * gst_video_chroma_site_to_string:
+ * @site: a #GstVideoChromaSite
+ *
+ * Converts @site to its string representation.
+ *
+ * Returns: (transfer full) (nullable): a string representation of @site
+ *          or %NULL if @site contains undefined value or
+ *          is equal to %GST_VIDEO_CHROMA_SITE_UNKNOWN
+ *
+ * Since: 1.20
+ */
+gchar *
+gst_video_chroma_site_to_string (GstVideoChromaSite site)
+{
+  gint i;
+  GString *str;
+  GFlagsValue *value;
+  GFlagsClass *klass;
+
+  /* return null string for GST_VIDEO_CHROMA_SITE_UNKNOWN */
+  if (site == 0)
+    return NULL;
+
+  for (i = 0; i < G_N_ELEMENTS (chromasite); i++) {
+    if (chromasite[i].site == site)
+      return g_strdup (chromasite[i].name);
+  }
+
+  /* Doesn't make sense */
+  if ((site & GST_VIDEO_CHROMA_SITE_NONE) != 0 &&
+      site != GST_VIDEO_CHROMA_SITE_NONE)
+    return NULL;
+
+  /* Construct new string */
+  klass = (GFlagsClass *) g_type_class_ref (GST_TYPE_VIDEO_CHROMA_SITE);
+  str = g_string_new (NULL);
+  while (site != GST_VIDEO_CHROMA_SITE_UNKNOWN &&
+      (value = g_flags_get_first_value (klass, site))) {
+    if (str->len > 0)
+      g_string_append (str, "+");
+
+    g_string_append (str, value->value_nick);
+    site &= ~value->value;
+  }
+  g_type_class_unref (klass);
+
+  /* This means given chroma-site has unknown value */
+  if (site != 0)
+    return g_string_free (str, TRUE);
+
+  return g_string_free (str, FALSE);
+}
+
 struct _GstVideoChromaResample
 {
   GstVideoChromaMethod method;
@@ -154,9 +260,9 @@ struct _GstVideoChromaResample
 #define FILT_5_3(a,b)          (5*(a) + 3*(b) + 4) >> 3
 #define FILT_3_5(a,b)          (3*(a) + 5*(b) + 4) >> 3
 
-#define FILT_10_3_2_1(a,b,c,d)      (10*(a) + 3*(b) + 2*(c) + (d) + 8) >> 16
-#define FILT_1_2_3_10(a,b,c,d)      ((a) + 2*(b) + 3*(c) + 10*(d) + 8) >> 16
-#define FILT_1_2_3_4_3_2_1(a,b,c,d,e,f,g) ((a) + 2*((b)+(f)) + 3*((c)+(e)) + 4*(d) + (g) + 8) >> 16
+#define FILT_10_3_2_1(a,b,c,d)      (10*(a) + 3*(b) + 2*(c) + (d) + 8) >> 4
+#define FILT_1_2_3_10(a,b,c,d)      ((a) + 2*(b) + 3*(c) + 10*(d) + 8) >> 4
+#define FILT_1_2_3_4_3_2_1(a,b,c,d,e,f,g) ((a) + 2*((b)+(f)) + 3*((c)+(e)) + 4*(d) + (g) + 8) >> 4
 
 /* 2x horizontal upsampling without cositing
  *
@@ -1005,8 +1111,8 @@ gst_video_chroma_resample_new (GstVideoChromaMethod method,
 /**
  * gst_video_chroma_resample_get_info:
  * @resample: a #GstVideoChromaResample
- * @n_lines: the number of input lines
- * @offset: the first line
+ * @n_lines: (out) (optional): the number of input lines
+ * @offset: (out) (optional): the first line
  *
  * The resampler must be fed @n_lines at a time. The first line should be
  * at @offset.
diff --git a/gst-libs/gst/video/video-chroma.h b/gst-libs/gst/video/video-chroma.h
index 5240078c04..16720b4b52 100644
--- a/gst-libs/gst/video/video-chroma.h
+++ b/gst-libs/gst/video/video-chroma.h
@@ -52,12 +52,18 @@ typedef enum {
   GST_VIDEO_CHROMA_SITE_DV        = (GST_VIDEO_CHROMA_SITE_COSITED | GST_VIDEO_CHROMA_SITE_ALT_LINE),
 } GstVideoChromaSite;
 
-GST_VIDEO_API
+GST_VIDEO_DEPRECATED_FOR(gst_video_chroma_site_from_string)
 GstVideoChromaSite    gst_video_chroma_from_string   (const gchar * s);
 
-GST_VIDEO_API
+GST_VIDEO_DEPRECATED_FOR(gst_video_chroma_site_to_string)
 const gchar *         gst_video_chroma_to_string     (GstVideoChromaSite site);
 
+GST_VIDEO_API
+GstVideoChromaSite    gst_video_chroma_site_from_string (const gchar * s);
+
+GST_VIDEO_API
+gchar *               gst_video_chroma_site_to_string   (GstVideoChromaSite site);
+
 /**
  * GstVideoChromaMethod:
  * @GST_VIDEO_CHROMA_METHOD_NEAREST: Duplicates the chroma samples when
diff --git a/gst-libs/gst/video/video-color.c b/gst-libs/gst/video/video-color.c
index 01f8d1773c..90fa380b18 100644
--- a/gst-libs/gst/video/video-color.c
+++ b/gst-libs/gst/video/video-color.c
@@ -269,6 +269,38 @@ gst_video_colorimetry_is_equal (const GstVideoColorimetry * cinfo,
   return CI_IS_EQUAL (cinfo, other);
 }
 
+/**
+ * gst_video_colorimetry_is_equivalent:
+ * @cinfo: a #GstVideoColorimetry
+ * @bitdepth: bitdepth of a format associated with @cinfo
+ * @other: another #GstVideoColorimetry
+ * @other_bitdepth: bitdepth of a format associated with @other
+ *
+ * Compare the 2 colorimetry sets for functionally equality
+ *
+ * Returns: %TRUE if @cinfo and @other are equivalent.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_video_colorimetry_is_equivalent (const GstVideoColorimetry * cinfo,
+    guint bitdepth, const GstVideoColorimetry * other, guint other_bitdepth)
+{
+  g_return_val_if_fail (cinfo != NULL, FALSE);
+  g_return_val_if_fail (other != NULL, FALSE);
+
+  if (cinfo->range != other->range || cinfo->matrix != other->matrix)
+    return FALSE;
+
+  if (!gst_video_color_primaries_is_equivalent (cinfo->primaries,
+          other->primaries)) {
+    return FALSE;
+  }
+
+  return gst_video_transfer_function_is_equivalent (cinfo->transfer, bitdepth,
+      other->transfer, other_bitdepth);
+}
+
 #define WP_C    0.31006, 0.31616
 #define WP_D65  0.31271, 0.32902
 #define WP_CENTRE (1/3), (1/3)
@@ -319,6 +351,35 @@ gst_video_color_primaries_get_info (GstVideoColorPrimaries primaries)
   return &color_primaries[primaries];
 }
 
+/**
+ * gst_video_color_primaries_is_equivalent:
+ * @primaries: a #GstVideoColorPrimaries
+ * @other: another #GstVideoColorPrimaries
+ *
+ * Checks whether @primaries and @other are functionally equivalent
+ *
+ * Returns: TRUE if @primaries and @other can be considered equivalent.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_video_color_primaries_is_equivalent (GstVideoColorPrimaries primaries,
+    GstVideoColorPrimaries other)
+{
+  if (primaries == other)
+    return TRUE;
+
+  /* smpte-170m and 240m use the same reference RGB primaries and white point */
+  if ((primaries == GST_VIDEO_COLOR_PRIMARIES_SMPTE170M ||
+          primaries == GST_VIDEO_COLOR_PRIMARIES_SMPTE240M) &&
+      (other == GST_VIDEO_COLOR_PRIMARIES_SMPTE170M ||
+          other == GST_VIDEO_COLOR_PRIMARIES_SMPTE240M)) {
+    return TRUE;
+  }
+
+  return FALSE;
+}
+
 /**
  * gst_video_color_matrix_get_Kr_Kb:
  * @matrix: a #GstVideoColorMatrix
@@ -399,6 +460,21 @@ gst_video_color_matrix_get_Kr_Kb (GstVideoColorMatrix matrix, gdouble * Kr,
  * @func: a #GstVideoTransferFunction
  * @val: a value
  *
+ * Deprecated: 1.20: Use gst_video_transfer_function_encode() instead.
+ *
+ * Since: 1.6
+ */
+gdouble
+gst_video_color_transfer_encode (GstVideoTransferFunction func, gdouble val)
+{
+  return gst_video_transfer_function_encode (func, val);
+}
+
+/**
+ * gst_video_transfer_function_encode:
+ * @func: a #GstVideoTransferFunction
+ * @val: a value
+ *
  * Convert @val to its gamma encoded value.
  *
  * For a linear value L in the range [0..1], conversion to the non-linear
@@ -413,10 +489,10 @@ gst_video_color_matrix_get_Kr_Kb (GstVideoColorMatrix matrix, gdouble * Kr,
  *
  * Returns: the gamma encoded value of @val
  *
- * Since: 1.6
+ * Since: 1.20
  */
 gdouble
-gst_video_color_transfer_encode (GstVideoTransferFunction func, gdouble val)
+gst_video_transfer_function_encode (GstVideoTransferFunction func, gdouble val)
 {
   gdouble res;
 
@@ -481,16 +557,16 @@ gst_video_color_transfer_encode (GstVideoTransferFunction func, gdouble val)
       break;
     case GST_VIDEO_TRANSFER_SMPTE2084:
     {
-      gdouble c1 = 3424.0 / 4096.0;     /* c3 - c2 + 1 */
-      gdouble c2 = 32 * 2413 / 4096.0;
-      gdouble c3 = 32 * 2392 / 4096.0;
-      gdouble m = 128 * 2523 / 4096.0;
-      gdouble n = 0.25 * 2610 / 4096.0;
-      gdouble Ln = pow (val, n);
+      gdouble c1 = 0.8359375;
+      gdouble c2 = 18.8515625;
+      gdouble c3 = 18.6875;
+      gdouble m1 = 0.1593017578125;
+      gdouble m2 = 78.84375;
+      gdouble Ln = pow (val, m1);
 
       /* val equal to 1 for peak white is ordinarily intended to
        * correspond to a reference output luminance level of 10000 cd/m^2  */
-      res = pow ((c1 + c2 * Ln) / (1.0 + c3 * Ln), m);
+      res = pow ((c1 + c2 * Ln) / (1.0 + c3 * Ln), m2);
       break;
     }
     case GST_VIDEO_TRANSFER_ARIB_STD_B67:
@@ -516,8 +592,23 @@ gst_video_color_transfer_encode (GstVideoTransferFunction func, gdouble val)
  * @func: a #GstVideoTransferFunction
  * @val: a value
  *
+ * Deprecated: 1.20: Use gst_video_transfer_function_decode() instead.
+ *
+ * Since: 1.6
+ */
+gdouble
+gst_video_color_transfer_decode (GstVideoTransferFunction func, gdouble val)
+{
+  return gst_video_transfer_function_decode (func, val);
+}
+
+/**
+ * gst_video_transfer_function_decode:
+ * @func: a #GstVideoTransferFunction
+ * @val: a value
+ *
  * Convert @val to its gamma decoded value. This is the inverse operation of
- * @gst_video_color_transfer_encode().
+ * gst_video_color_transfer_encode().
  *
  * For a non-linear value L' in the range [0..1], conversion to the linear
  * L is in general performed with a power function like:
@@ -531,10 +622,10 @@ gst_video_color_transfer_encode (GstVideoTransferFunction func, gdouble val)
  *
  * Returns: the gamma decoded value of @val
  *
- * Since: 1.6
+ * Since: 1.20
  */
 gdouble
-gst_video_color_transfer_decode (GstVideoTransferFunction func, gdouble val)
+gst_video_transfer_function_decode (GstVideoTransferFunction func, gdouble val)
 {
   gdouble res;
 
@@ -599,14 +690,15 @@ gst_video_color_transfer_decode (GstVideoTransferFunction func, gdouble val)
       break;
     case GST_VIDEO_TRANSFER_SMPTE2084:
     {
-      gdouble c1 = 3424.0 / 4096.0;     /* c3 - c2 + 1 */
-      gdouble c2 = 32 * 2413 / 4096.0;
-      gdouble c3 = 32 * 2392 / 4096.0;
-      gdouble mi = 1 / (128 * 2523 / 4096.0);
-      gdouble ni = 1 / (0.25 * 2610 / 4096.0);
-      gdouble nm = pow (val, mi);
-
-      res = pow ((nm - c1) / (c2 - c3 * nm), ni);
+      gdouble c1 = 0.8359375;
+      gdouble c2 = 18.8515625;
+      gdouble c3 = 18.6875;
+      gdouble m1 = 0.1593017578125;
+      gdouble m2 = 78.84375;
+      gdouble tmp = pow (val, 1 / m2);
+      gdouble tmp2 = MAX (tmp - c1, 0.0f);
+
+      res = pow (tmp2 / (c2 - c3 * tmp), 1 / m1);
       break;
     }
     case GST_VIDEO_TRANSFER_ARIB_STD_B67:
diff --git a/gst-libs/gst/video/video-color.h b/gst-libs/gst/video/video-color.h
index ba99e079a2..ccdf64cf90 100644
--- a/gst-libs/gst/video/video-color.h
+++ b/gst-libs/gst/video/video-color.h
@@ -138,11 +138,15 @@ typedef enum {
   GST_VIDEO_TRANSFER_BT601
 } GstVideoTransferFunction;
 
+GST_VIDEO_DEPRECATED_FOR(gst_video_transfer_function_encode)
+gdouble      gst_video_color_transfer_encode    (GstVideoTransferFunction func, gdouble val);
 GST_VIDEO_API
-gdouble      gst_video_color_transfer_encode (GstVideoTransferFunction func, gdouble val);
+gdouble      gst_video_transfer_function_encode (GstVideoTransferFunction func, gdouble val);
 
+GST_VIDEO_DEPRECATED_FOR(gst_video_transfer_function_decode)
+gdouble      gst_video_color_transfer_decode    (GstVideoTransferFunction func, gdouble val);
 GST_VIDEO_API
-gdouble      gst_video_color_transfer_decode (GstVideoTransferFunction func, gdouble val);
+gdouble      gst_video_transfer_function_decode (GstVideoTransferFunction func, gdouble val);
 
 /**
  * GstVideoColorPrimaries:
@@ -218,6 +222,10 @@ GST_VIDEO_API
 const GstVideoColorPrimariesInfo *
                 gst_video_color_primaries_get_info     (GstVideoColorPrimaries primaries);
 
+GST_VIDEO_API
+gboolean gst_video_color_primaries_is_equivalent       (GstVideoColorPrimaries primaries,
+                                                        GstVideoColorPrimaries other);
+
 /**
  * GstVideoColorimetry:
  * @range: the color range. This is the valid range for the samples.
@@ -258,6 +266,12 @@ gchar *      gst_video_colorimetry_to_string   (const GstVideoColorimetry *cinfo
 GST_VIDEO_API
 gboolean     gst_video_colorimetry_is_equal    (const GstVideoColorimetry *cinfo, const GstVideoColorimetry *other);
 
+GST_VIDEO_API
+gboolean     gst_video_colorimetry_is_equivalent (const GstVideoColorimetry *cinfo,
+                                                  guint bitdepth,
+                                                  const GstVideoColorimetry *other,
+                                                  guint other_bitdepth);
+
 /* compute offset and scale */
 
 GST_VIDEO_API
diff --git a/gst-libs/gst/video/video-hdr.c b/gst-libs/gst/video/video-hdr.c
index 41c3131d1f..280d8e83b2 100644
--- a/gst-libs/gst/video/video-hdr.c
+++ b/gst-libs/gst/video/video-hdr.c
@@ -41,24 +41,6 @@
   (m)->max_display_mastering_luminance, \
   (m)->min_display_mastering_luminance
 
-/* g_ascii_string_to_unsigned is available since 2.54. Get rid of this wrapper
- * when we bump the version in 1.18 */
-#if !GLIB_CHECK_VERSION(2,54,0)
-#define g_ascii_string_to_unsigned video_hdr_ascii_string_to_unsigned
-static gboolean
-video_hdr_ascii_string_to_unsigned (const gchar * str, guint base, guint64 min,
-    guint64 max, guint64 * out_num, GError ** error)
-{
-  gchar *endptr = NULL;
-  *out_num = g_ascii_strtoull (str, &endptr, base);
-  if (errno)
-    return FALSE;
-  if (endptr == str)
-    return FALSE;
-  return TRUE;
-}
-#endif
-
 /**
  * gst_video_mastering_display_info_init:
  * @minfo: a #GstVideoMasteringDisplayInfo
@@ -352,6 +334,29 @@ gst_video_content_light_level_to_string (const GstVideoContentLightLevel *
       linfo->max_content_light_level, linfo->max_frame_average_light_level);
 }
 
+/**
+ * gst_video_content_light_level_is_equal:
+ * @linfo: a #GstVideoContentLightLevel
+ * @other: a #GstVideoContentLightLevel
+ *
+ * Checks equality between @linfo and @other.
+ *
+ * Returns: %TRUE if @linfo and @other are equal.
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_video_content_light_level_is_equal (const GstVideoContentLightLevel * linfo,
+    const GstVideoContentLightLevel * other)
+{
+  g_return_val_if_fail (linfo != NULL, FALSE);
+  g_return_val_if_fail (other != NULL, FALSE);
+
+  return (linfo->max_content_light_level == other->max_content_light_level &&
+      linfo->max_frame_average_light_level ==
+      other->max_frame_average_light_level);
+}
+
 /**
  * gst_video_content_light_level_from_caps:
  * @linfo: a #GstVideoContentLightLevel
diff --git a/gst-libs/gst/video/video-hdr.h b/gst-libs/gst/video/video-hdr.h
index 35765cb809..b6ce360233 100644
--- a/gst-libs/gst/video/video-hdr.h
+++ b/gst-libs/gst/video/video-hdr.h
@@ -125,6 +125,10 @@ gboolean  gst_video_content_light_level_from_string  (GstVideoContentLightLevel
 GST_VIDEO_API
 gchar *   gst_video_content_light_level_to_string    (const GstVideoContentLightLevel * linfo);
 
+GST_VIDEO_API
+gboolean  gst_video_content_light_level_is_equal     (const GstVideoContentLightLevel * linfo,
+                                                      const GstVideoContentLightLevel * other);
+
 GST_VIDEO_API
 gboolean  gst_video_content_light_level_from_caps    (GstVideoContentLightLevel * linfo,
                                                       const GstCaps * caps);
diff --git a/gst-libs/gst/video/video-sei.c b/gst-libs/gst/video/video-sei.c
new file mode 100644
index 0000000000..0b981c4076
--- /dev/null
+++ b/gst-libs/gst/video/video-sei.c
@@ -0,0 +1,236 @@
+/* GStreamer
+ * Copyright (C) 2021 Fluendo S.A. <support@fluendo.com>
+ *   Authors: Andoni Morales Alastruey <amorales@fluendo.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <string.h>
+#include <gst/base/gstbytereader.h>
+#include "video-sei.h"
+
+/**
+ * SECTION:gstvideosei
+ * @title: GstVideo SEI Unregistered User Data
+ * @short_description: Utilities for SEI User Data Unregistered
+ *
+ * A collection of objects and methods to assist with SEI User Data Unregistered
+ * metadata in H.264 and H.265 streams.
+ *
+ * Since: 1.22
+ */
+
+#ifndef GST_DISABLE_GST_DEBUG
+#define GST_CAT_DEFAULT ensure_debug_category()
+static GstDebugCategory *
+ensure_debug_category (void)
+{
+  static gsize cat_gonce = 0;
+
+  if (g_once_init_enter (&cat_gonce)) {
+    gsize cat_done;
+
+    cat_done = (gsize) _gst_debug_category_new ("video-sei", 0,
+        "H.264 / H.265 SEI messages utilities");
+
+    g_once_init_leave (&cat_gonce, cat_done);
+  }
+
+  return (GstDebugCategory *) cat_gonce;
+}
+#else
+#define ensure_debug_category() /* NOOP */
+#endif /* GST_DISABLE_GST_DEBUG */
+
+/* SEI User Data Unregistered implementation */
+
+/**
+ * gst_video_sei_user_data_unregistered_meta_api_get_type:
+ *
+ * Returns: #GType for the #GstVideoSEIUserDataUnregisteredMeta structure.
+ *
+ * Since: 1.22
+ */
+GType
+gst_video_sei_user_data_unregistered_meta_api_get_type (void)
+{
+  static GType type = 0;
+
+  if (g_once_init_enter (&type)) {
+    static const gchar *tags[] = {
+      GST_META_TAG_VIDEO_STR,
+      NULL
+    };
+    GType _type =
+        gst_meta_api_type_register ("GstVideoSEIUserDataUnregisteredMetaAPI",
+        tags);
+    g_once_init_leave (&type, _type);
+  }
+  return type;
+}
+
+static gboolean
+gst_video_sei_user_data_unregistered_meta_init (GstMeta * meta, gpointer params,
+    GstBuffer * buffer)
+{
+  GstVideoSEIUserDataUnregisteredMeta *emeta =
+      (GstVideoSEIUserDataUnregisteredMeta *) meta;
+
+  emeta->data = NULL;
+  emeta->size = 0;
+
+  return TRUE;
+}
+
+static gboolean
+gst_video_sei_user_data_unregistered_meta_transform (GstBuffer * dest,
+    GstMeta * meta, GstBuffer * buffer, GQuark type, gpointer data)
+{
+  GstVideoSEIUserDataUnregisteredMeta *smeta =
+      (GstVideoSEIUserDataUnregisteredMeta *) meta;
+
+  if (GST_META_TRANSFORM_IS_COPY (type)) {
+    GST_DEBUG ("copy SEI User Data Unregistered metadata");
+    gst_buffer_add_video_sei_user_data_unregistered_meta (dest,
+        smeta->uuid, smeta->data, smeta->size);
+    return TRUE;
+  } else {
+    /* return FALSE, if transform type is not supported */
+    return FALSE;
+  }
+}
+
+static void
+gst_video_sei_user_data_unregistered_meta_free (GstMeta * meta, GstBuffer * buf)
+{
+  GstVideoSEIUserDataUnregisteredMeta *smeta =
+      (GstVideoSEIUserDataUnregisteredMeta *) meta;
+
+  g_free (smeta->data);
+  smeta->data = NULL;
+}
+
+/**
+ * gst_video_sei_user_data_unregistered_meta_get_info:
+ *
+ * Returns: #GstMetaInfo pointer that describes #GstVideoSEIUserDataUnregisteredMeta.
+ *
+ * Since: 1.22
+ */
+const GstMetaInfo *
+gst_video_sei_user_data_unregistered_meta_get_info (void)
+{
+  static const GstMetaInfo *meta_info = NULL;
+
+  if (g_once_init_enter ((GstMetaInfo **) & meta_info)) {
+    const GstMetaInfo *mi =
+        gst_meta_register (GST_VIDEO_SEI_USER_DATA_UNREGISTERED_META_API_TYPE,
+        "GstVideoSEIUserDataUnregisteredMeta",
+        sizeof (GstVideoSEIUserDataUnregisteredMeta),
+        gst_video_sei_user_data_unregistered_meta_init,
+        gst_video_sei_user_data_unregistered_meta_free,
+        gst_video_sei_user_data_unregistered_meta_transform);
+    g_once_init_leave ((GstMetaInfo **) & meta_info, (GstMetaInfo *) mi);
+  }
+  return meta_info;
+}
+
+/**
+ * gst_buffer_add_video_sei_user_data_unregistered_meta:
+ * @buffer: a #GstBuffer
+ * @uuid: User Data Unregistered UUID
+ * @data: (transfer none): SEI User Data Unregistered buffer
+ * @size: size of the data buffer
+ *
+ * Attaches #GstVideoSEIUserDataUnregisteredMeta metadata to @buffer with the given
+ * parameters.
+ *
+ * Returns: (transfer none): the #GstVideoSEIUserDataUnregisteredMeta on @buffer.
+ *
+ * Since: 1.22
+ */
+GstVideoSEIUserDataUnregisteredMeta *
+gst_buffer_add_video_sei_user_data_unregistered_meta (GstBuffer * buffer,
+    guint8 uuid[16], guint8 * data, gsize size)
+{
+  GstVideoSEIUserDataUnregisteredMeta *meta;
+  g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
+  g_return_val_if_fail (data != NULL, NULL);
+
+  meta = (GstVideoSEIUserDataUnregisteredMeta *) gst_buffer_add_meta (buffer,
+      GST_VIDEO_SEI_USER_DATA_UNREGISTERED_META_INFO, NULL);
+  g_assert (meta != NULL);
+  memcpy (meta->uuid, uuid, 16);
+  meta->data = g_malloc (size);
+  memcpy (meta->data, data, size);
+  meta->size = size;
+
+  return meta;
+}
+
+/**
+ * gst_video_sei_user_data_unregistered_parse_precision_time_stamp:
+ * @user_data: (transfer none): a #GstVideoSEIUserDataUnregisteredMeta
+ * @status: (out): User Data Unregistered UUID
+ * @precision_time_stamp: (out): The parsed Precision Time Stamp SEI
+ *
+ * Parses and returns the Precision Time Stamp (ST 0604) from the SEI User Data Unregistered buffer
+ *
+ * Returns: True if data is a Precision Time Stamp and it was parsed correctly
+ *
+ * Since: 1.22
+ */
+gboolean
+    gst_video_sei_user_data_unregistered_parse_precision_time_stamp
+    (GstVideoSEIUserDataUnregisteredMeta * user_data, guint8 * status,
+    guint64 * precision_time_stamp) {
+  guint8 *data = user_data->data;
+
+  if (memcmp (user_data->uuid, &H264_MISP_MICROSECTIME, 16) != 0 &&
+      memcmp (user_data->uuid, &H265_MISP_MICROSECONDS, 16) != 0 &&
+      memcmp (user_data->uuid, &H265_MISP_NANOSECONDS, 16) != 0) {
+    GST_WARNING
+        ("User Data Unregistered UUID is not a known MISP Timestamp UUID");
+    return FALSE;
+  }
+
+  if (user_data->size < 12) {
+    GST_WARNING ("MISP Precision Time Stamp data size is too short, ignoring");
+    return FALSE;
+  }
+
+  /* Status */
+  *status = data[0];
+
+  *precision_time_stamp =
+      /* Two MS bytes of Time Stamp (microseconds) */
+      _GST_GET (data, 1, 64, 56) | _GST_GET (data, 2, 64, 48) |
+      /* Start Code Emulation Prevention Byte (0xFF) */
+      /* Two next MS bytes of Time Stamp (microseconds) */
+      _GST_GET (data, 4, 64, 40) | _GST_GET (data, 5, 64, 32) |
+      /* Start Code Emulation Prevention Byte (0xFF) */
+      /* Two LS bytes of Time Stamp (microseconds) */
+      _GST_GET (data, 7, 64, 24) | _GST_GET (data, 8, 64, 16) |
+      /* Start Code Emulation Prevention Byte (0xFF) */
+      /* Two next LS bytes of Time Stamp (microseconds) */
+      _GST_GET (data, 10, 64, 8) | _GST_GET (data, 11, 64, 0);
+
+  return TRUE;
+}
diff --git a/gst-libs/gst/video/video-sei.h b/gst-libs/gst/video/video-sei.h
new file mode 100644
index 0000000000..cb5d7bea43
--- /dev/null
+++ b/gst-libs/gst/video/video-sei.h
@@ -0,0 +1,110 @@
+/* GStreamer
+ * Copyright (C) <2021> Fluendo S.A. <contact@fluendo.com>
+ *   Authors: Andoni Morales Alastruey <amorales@fluendo.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_VIDEO_SEI_USER_DATA_UNREGISTERED_H__
+#define __GST_VIDEO_SEI_USER_DATA_UNREGISTERED_H__
+
+#include <gst/gst.h>
+#include <gst/video/video.h>
+
+G_BEGIN_DECLS
+
+static const guint8 H264_MISP_MICROSECTIME[] = {
+  0x4D, 0x49, 0x53, 0x50, 0x6D, 0x69, 0x63, 0x72,
+  0x6F, 0x73, 0x65, 0x63, 0x74, 0x69, 0x6D, 0x65
+};
+
+static const guint8 H265_MISP_MICROSECONDS[] = {
+  0xA8, 0x68, 0x7D, 0xD4, 0xD7, 0x59, 0x37, 0x58,
+  0xA5, 0xCE, 0xF0, 0x33, 0x8B, 0x65, 0x45, 0xF1
+};
+
+static const guint8 H265_MISP_NANOSECONDS[] = {
+  0xCF, 0x84, 0x82, 0x78, 0xEE, 0x23, 0x30, 0x6C,
+  0x92, 0x65, 0xE8, 0xFE, 0xF2, 0x2F, 0xB8, 0xB8
+};
+
+/**
+ * GstVideoSEIUserDataUnregisteredMeta:
+ * @meta: parent #GstMeta
+ * @uuid: User Data Unregistered UUID
+ * @data: Unparsed data buffer
+ * @size: Size of the data buffer
+ *
+ * H.264 H.265 metadata from SEI User Data Unregistered messages
+ *
+ * Since: 1.22
+ */
+typedef struct {
+  GstMeta meta;
+
+  guint8 uuid[16];
+  guint8 *data;
+  gsize size;
+} GstVideoSEIUserDataUnregisteredMeta;
+
+GST_VIDEO_API
+GType gst_video_sei_user_data_unregistered_meta_api_get_type (void);
+/**
+ * GST_VIDEO_SEI_USER_DATA_UNREGISTERED_META_API_TYPE:
+ *
+ * Since: 1.22
+ */
+#define GST_VIDEO_SEI_USER_DATA_UNREGISTERED_META_API_TYPE (\
+    gst_video_sei_user_data_unregistered_meta_api_get_type())
+
+GST_VIDEO_API
+const GstMetaInfo *gst_video_sei_user_data_unregistered_meta_get_info (void);
+/**
+ * GST_VIDEO_SEI_USER_DATA_UNREGISTERED_META_INFO:
+ *
+ * Since: 1.22
+ */
+#define GST_VIDEO_SEI_USER_DATA_UNREGISTERED_META_INFO (\
+    gst_video_sei_user_data_unregistered_meta_get_info())
+
+/**
+ * gst_buffer_get_video_sei_user_data_unregistered_meta:
+ * @b: A #GstBuffer
+ *
+ * Gets the GstVideoSEIUserDataUnregisteredMeta that might be present on @b.
+ *
+ * Returns: (nullable): The first #GstVideoSEIUserDataUnregisteredMeta present on @b, or %NULL if
+ * no #GstVideoSEIUserDataUnregisteredMeta are present
+ *
+ * Since: 1.22
+ */
+#define gst_buffer_get_video_sei_user_data_unregistered_meta(b) \
+        ((GstVideoSEIUserDataUnregisteredMeta*)gst_buffer_get_meta((b),GST_VIDEO_SEI_USER_DATA_UNREGISTERED_META_API_TYPE))
+
+GST_VIDEO_API
+GstVideoSEIUserDataUnregisteredMeta *gst_buffer_add_video_sei_user_data_unregistered_meta (GstBuffer * buffer,
+                                                                                           guint8 uuid[16],
+                                                                                           guint8 * data,
+                                                                                           gsize size);
+
+GST_VIDEO_API
+gboolean gst_video_sei_user_data_unregistered_parse_precision_time_stamp (GstVideoSEIUserDataUnregisteredMeta * user_data,
+                                                                          guint8 * status,
+                                                                          guint64 * precision_time_stamp);
+
+G_END_DECLS
+
+#endif /* __GST_VIDEO_SEI_USER_DATA_UNREGISTERED_H__ */
diff --git a/gst-libs/gst/video/video.c b/gst-libs/gst/video/video.c
index 0743044576..6c3e913bcf 100644
--- a/gst-libs/gst/video/video.c
+++ b/gst-libs/gst/video/video.c
@@ -183,6 +183,44 @@ gst_video_guess_framerate (GstClockTime duration, gint * dest_n, gint * dest_d)
   return (best_error != G_MAXUINT64);
 }
 
+/**
+ * gst_video_is_common_aspect_ratio:
+ * @width: Width of the video frame
+ * @height: Height of the video frame
+ * @par_n: Pixel aspect ratio numerator
+ * @par_d: Pixel aspect ratio denominator
+ *
+ * Given a frame's dimensions and pixel aspect ratio, this function will
+ * calculate the frame's aspect ratio and compare it against a set of
+ * common well-known "standard" aspect ratios.
+ *
+ * Returns: %TRUE if a known "standard" aspect ratio was
+ * recognised, and %FALSE otherwise.
+ *
+ * Since: 1.22
+ */
+gboolean
+gst_video_is_common_aspect_ratio (gint width, gint height, gint par_n,
+    gint par_d)
+{
+  gint dar_n, dar_d;
+
+  gst_util_fraction_multiply (width, height, par_n, par_d, &dar_n, &dar_d);
+
+  if (dar_n == 16 && dar_d == 9)
+    return TRUE;
+  if (dar_n == 4 && dar_d == 3)
+    return TRUE;
+  if (dar_n == 14 && dar_d == 9)
+    return TRUE;
+  if (dar_n == 8 && dar_d == 5)
+    return TRUE;
+  if (dar_n == 21 && dar_d == 11)
+    return TRUE;
+
+  return FALSE;
+}
+
 
 /**
  * gst_video_alignment_reset:
@@ -204,3 +242,52 @@ gst_video_alignment_reset (GstVideoAlignment * align)
   for (i = 0; i < GST_VIDEO_MAX_PLANES; i++)
     align->stride_align[i] = 0;
 }
+
+/**
+ * gst_video_orientation_from_tag:
+ * @taglist: A #GstTagList
+ * @method: (out): The location where to return the orientation.
+ *
+ * Parses the "image-orientation" tag and transforms it into the
+ * #GstVideoOrientationMethod enum.
+ *
+ * Returns: TRUE if there was a valid "image-orientation" tag in the taglist.
+ *
+ * Since: 1.20
+ */
+gboolean
+gst_video_orientation_from_tag (GstTagList * taglist,
+    GstVideoOrientationMethod * method)
+{
+  gchar *orientation;
+  gboolean ret = TRUE;
+
+  g_return_val_if_fail (GST_IS_TAG_LIST (taglist), FALSE);
+  g_return_val_if_fail (method != NULL, FALSE);
+
+  if (!gst_tag_list_get_string (taglist, "image-orientation", &orientation))
+    return FALSE;
+
+  if (!g_strcmp0 ("rotate-0", orientation))
+    *method = GST_VIDEO_ORIENTATION_IDENTITY;
+  else if (!g_strcmp0 ("rotate-90", orientation))
+    *method = GST_VIDEO_ORIENTATION_90R;
+  else if (!g_strcmp0 ("rotate-180", orientation))
+    *method = GST_VIDEO_ORIENTATION_180;
+  else if (!g_strcmp0 ("rotate-270", orientation))
+    *method = GST_VIDEO_ORIENTATION_90L;
+  else if (!g_strcmp0 ("flip-rotate-0", orientation))
+    *method = GST_VIDEO_ORIENTATION_HORIZ;
+  else if (!g_strcmp0 ("flip-rotate-90", orientation))
+    *method = GST_VIDEO_ORIENTATION_UR_LL;
+  else if (!g_strcmp0 ("flip-rotate-180", orientation))
+    *method = GST_VIDEO_ORIENTATION_VERT;
+  else if (!g_strcmp0 ("flip-rotate-270", orientation))
+    *method = GST_VIDEO_ORIENTATION_UL_LR;
+  else
+    ret = FALSE;
+
+  g_free (orientation);
+
+  return ret;
+}
diff --git a/gst-libs/gst/video/video.h b/gst-libs/gst/video/video.h
index c6ca091e93..a43e45a4af 100644
--- a/gst-libs/gst/video/video.h
+++ b/gst-libs/gst/video/video.h
@@ -89,6 +89,12 @@ typedef enum {
   GST_VIDEO_ORIENTATION_CUSTOM,
 } GstVideoOrientationMethod;
 
+/**
+ * GST_TYPE_VIDEO_ORIENTATION_METHOD:
+ *
+ * Since: 1.20
+ */
+
 /* metadata macros */
 /**
  * GST_META_TAG_VIDEO_STR:
@@ -143,6 +149,9 @@ GST_VIDEO_API
 gboolean       gst_video_guess_framerate (GstClockTime duration,
                                           gint * dest_n, gint * dest_d);
 
+GST_VIDEO_API
+gboolean       gst_video_is_common_aspect_ratio (gint width, gint height, gint par_n, gint par_d);
+
 /* convert/encode video sample from one format to another */
 
 typedef void (*GstVideoConvertSampleCallback) (GstSample * sample, GError *error, gpointer user_data);
@@ -161,28 +170,35 @@ GstSample *   gst_video_convert_sample       (GstSample     * sample,
                                               GstClockTime    timeout,
                                               GError       ** error);
 
+
+GST_VIDEO_API
+gboolean gst_video_orientation_from_tag (GstTagList * taglist,
+                                         GstVideoOrientationMethod * method);
+
 G_END_DECLS
 
 #include <gst/video/colorbalancechannel.h>
 #include <gst/video/colorbalance.h>
+#include <gst/video/gstvideoaffinetransformationmeta.h>
 #include <gst/video/gstvideoaggregator.h>
+#include <gst/video/gstvideocodecalphameta.h>
 #include <gst/video/gstvideodecoder.h>
 #include <gst/video/gstvideoencoder.h>
 #include <gst/video/gstvideofilter.h>
 #include <gst/video/gstvideometa.h>
 #include <gst/video/gstvideopool.h>
 #include <gst/video/gstvideosink.h>
+#include <gst/video/gstvideotimecode.h>
 #include <gst/video/gstvideoutils.h>
 #include <gst/video/navigation.h>
+#include <gst/video/video-anc.h>
 #include <gst/video/video-blend.h>
-#include <gst/video/video-event.h>
 #include <gst/video/videodirection.h>
+#include <gst/video/video-event.h>
+#include <gst/video/video-hdr.h>
 #include <gst/video/videoorientation.h>
 #include <gst/video/video-overlay-composition.h>
 #include <gst/video/videooverlay.h>
-#include <gst/video/gstvideotimecode.h>
-#include <gst/video/gstvideoaffinetransformationmeta.h>
-#include <gst/video/video-anc.h>
-#include <gst/video/video-hdr.h>
+#include <gst/video/video-sei.h>
 
 #endif /* __GST_VIDEO_H__ */
-- 
2.39.1

