From 29df22c7e23cff707800c5878fc8d1fc9d653dc3 Mon Sep 17 00:00:00 2001
From: Philippe Normand <philn@igalia.com>
Date: Thu, 19 Jan 2023 14:52:07 +0000
Subject: [PATCH] Backports from GStreamer 1.21.

---
 ext/vpx/gstvp8dec.c                           |   12 +
 ext/vpx/gstvp8enc.c                           |   81 ++
 ext/vpx/gstvp9dec.c                           |  117 +-
 ext/vpx/gstvp9enc.c                           |  432 ++++++-
 ext/vpx/gstvp9enc.h                           |   10 +-
 ext/vpx/gstvpxcompat.h                        |   47 +
 ext/vpx/gstvpxdec.c                           |   39 +-
 ext/vpx/gstvpxdec.h                           |    7 +
 ext/vpx/gstvpxelement.c                       |   39 +
 ext/vpx/gstvpxelements.h                      |   36 +
 ext/vpx/gstvpxenc.c                           |  384 +++++-
 ext/vpx/gstvpxenc.h                           |   32 +-
 ext/vpx/gstvpxenums.h                         |   49 +
 ext/vpx/meson.build                           |   16 +-
 ext/vpx/plugin.c                              |   21 +-
 gst/rtp/gstasteriskh263.c                     |   10 +-
 gst/rtp/gstasteriskh263.h                     |    2 -
 gst/rtp/gstrtp.c                              |  488 ++------
 gst/rtp/gstrtpL16depay.c                      |   10 +-
 gst/rtp/gstrtpL16depay.h                      |    2 -
 gst/rtp/gstrtpL16pay.c                        |   10 +-
 gst/rtp/gstrtpL16pay.h                        |    2 -
 gst/rtp/gstrtpL24depay.c                      |   10 +-
 gst/rtp/gstrtpL24depay.h                      |    2 -
 gst/rtp/gstrtpL24pay.c                        |   10 +-
 gst/rtp/gstrtpL24pay.h                        |    2 -
 gst/rtp/gstrtpL8depay.c                       |   12 +-
 gst/rtp/gstrtpL8depay.h                       |    2 -
 gst/rtp/gstrtpL8pay.c                         |   12 +-
 gst/rtp/gstrtpL8pay.h                         |    2 -
 gst/rtp/gstrtpac3depay.c                      |   10 +-
 gst/rtp/gstrtpac3depay.h                      |    2 -
 gst/rtp/gstrtpac3pay.c                        |   14 +-
 gst/rtp/gstrtpac3pay.h                        |    2 -
 gst/rtp/gstrtpamrdepay.c                      |   10 +-
 gst/rtp/gstrtpamrdepay.h                      |    2 -
 gst/rtp/gstrtpamrpay.c                        |   11 +-
 gst/rtp/gstrtpamrpay.h                        |    2 -
 gst/rtp/gstrtpbvdepay.c                       |   10 +-
 gst/rtp/gstrtpbvdepay.h                       |    2 -
 gst/rtp/gstrtpbvpay.c                         |   10 +-
 gst/rtp/gstrtpbvpay.h                         |    2 -
 gst/rtp/gstrtpceltdepay.c                     |   11 +-
 gst/rtp/gstrtpceltdepay.h                     |    2 -
 gst/rtp/gstrtpceltpay.c                       |   10 +-
 gst/rtp/gstrtpceltpay.h                       |    2 -
 gst/rtp/gstrtpdvdepay.c                       |   12 +-
 gst/rtp/gstrtpdvdepay.h                       |    2 -
 gst/rtp/gstrtpdvpay.c                         |   15 +-
 gst/rtp/gstrtpdvpay.h                         |    2 -
 gst/rtp/gstrtpelement.c                       |   46 +
 gst/rtp/gstrtpelements.h                      |  134 +++
 gst/rtp/gstrtpg722depay.c                     |   10 +-
 gst/rtp/gstrtpg722depay.h                     |    2 -
 gst/rtp/gstrtpg722pay.c                       |   10 +-
 gst/rtp/gstrtpg722pay.h                       |    2 -
 gst/rtp/gstrtpg723depay.c                     |   10 +-
 gst/rtp/gstrtpg723depay.h                     |    2 -
 gst/rtp/gstrtpg723pay.c                       |   12 +-
 gst/rtp/gstrtpg723pay.h                       |    2 -
 gst/rtp/gstrtpg726depay.c                     |   12 +-
 gst/rtp/gstrtpg726depay.h                     |    2 -
 gst/rtp/gstrtpg726pay.c                       |   10 +-
 gst/rtp/gstrtpg726pay.h                       |    2 -
 gst/rtp/gstrtpg729depay.c                     |   10 +-
 gst/rtp/gstrtpg729depay.h                     |    2 -
 gst/rtp/gstrtpg729pay.c                       |   11 +-
 gst/rtp/gstrtpg729pay.h                       |    2 -
 gst/rtp/gstrtpgsmdepay.c                      |   10 +-
 gst/rtp/gstrtpgsmdepay.h                      |    2 -
 gst/rtp/gstrtpgsmpay.c                        |   10 +-
 gst/rtp/gstrtpgsmpay.h                        |    1 -
 gst/rtp/gstrtpgstdepay.c                      |   11 +-
 gst/rtp/gstrtpgstdepay.h                      |    2 -
 gst/rtp/gstrtpgstpay.c                        |   46 +-
 gst/rtp/gstrtpgstpay.h                        |    6 +-
 gst/rtp/gstrtph261depay.c                     |   13 +-
 gst/rtp/gstrtph261depay.h                     |    2 -
 gst/rtp/gstrtph261pay.c                       |   19 +-
 gst/rtp/gstrtph261pay.h                       |    2 -
 gst/rtp/gstrtph263depay.c                     |   10 +-
 gst/rtp/gstrtph263depay.h                     |    2 -
 gst/rtp/gstrtph263pay.c                       |   25 +-
 gst/rtp/gstrtph263pay.h                       |    2 -
 gst/rtp/gstrtph263pdepay.c                    |  104 +-
 gst/rtp/gstrtph263pdepay.h                    |    2 -
 gst/rtp/gstrtph263ppay.c                      |   16 +-
 gst/rtp/gstrtph263ppay.h                      |    2 -
 gst/rtp/gstrtph264depay.c                     |  218 +++-
 gst/rtp/gstrtph264depay.h                     |    6 +-
 gst/rtp/gstrtph264pay.c                       |   71 +-
 gst/rtp/gstrtph264pay.h                       |    4 +-
 gst/rtp/gstrtph265depay.c                     |   19 +-
 gst/rtp/gstrtph265depay.h                     |    2 -
 gst/rtp/gstrtph265pay.c                       |  106 +-
 gst/rtp/gstrtph265pay.h                       |    5 +-
 gst/rtp/gstrtphdrext-colorspace.c             |  483 ++++++++
 gst/rtp/gstrtphdrext-colorspace.h             |   41 +
 gst/rtp/gstrtpilbcdepay.c                     |   10 +-
 gst/rtp/gstrtpilbcdepay.h                     |    2 -
 gst/rtp/gstrtpilbcpay.c                       |   10 +-
 gst/rtp/gstrtpilbcpay.h                       |    2 -
 gst/rtp/gstrtpisacdepay.c                     |  147 +++
 gst/rtp/gstrtpisacdepay.h                     |   31 +
 gst/rtp/gstrtpisacpay.c                       |  183 +++
 gst/rtp/gstrtpisacpay.h                       |   31 +
 gst/rtp/gstrtpj2kdepay.c                      |   10 +-
 gst/rtp/gstrtpj2kdepay.h                      |    1 -
 gst/rtp/gstrtpj2kpay.c                        |   15 +-
 gst/rtp/gstrtpj2kpay.h                        |    2 -
 gst/rtp/gstrtpjpegdepay.c                     |   11 +-
 gst/rtp/gstrtpjpegdepay.h                     |    1 -
 gst/rtp/gstrtpjpegpay.c                       |   15 +-
 gst/rtp/gstrtpjpegpay.h                       |    2 -
 gst/rtp/gstrtpklvdepay.c                      |   10 +-
 gst/rtp/gstrtpklvdepay.h                      |    2 -
 gst/rtp/gstrtpklvpay.c                        |   13 +-
 gst/rtp/gstrtpklvpay.h                        |    2 -
 gst/rtp/gstrtpldacpay.c                       |  228 ++++
 gst/rtp/gstrtpldacpay.h                       |   56 +
 gst/rtp/gstrtpmp1sdepay.c                     |   10 +-
 gst/rtp/gstrtpmp1sdepay.h                     |    2 -
 gst/rtp/gstrtpmp2tdepay.c                     |   10 +-
 gst/rtp/gstrtpmp2tdepay.h                     |    2 -
 gst/rtp/gstrtpmp2tpay.c                       |   10 +-
 gst/rtp/gstrtpmp2tpay.h                       |    2 -
 gst/rtp/gstrtpmp4adepay.c                     |   10 +-
 gst/rtp/gstrtpmp4adepay.h                     |    2 -
 gst/rtp/gstrtpmp4apay.c                       |   12 +-
 gst/rtp/gstrtpmp4apay.h                       |    2 -
 gst/rtp/gstrtpmp4gdepay.c                     |   10 +-
 gst/rtp/gstrtpmp4gdepay.h                     |    2 -
 gst/rtp/gstrtpmp4gpay.c                       |   12 +-
 gst/rtp/gstrtpmp4gpay.h                       |    2 -
 gst/rtp/gstrtpmp4vdepay.c                     |   10 +-
 gst/rtp/gstrtpmp4vdepay.h                     |    2 -
 gst/rtp/gstrtpmp4vpay.c                       |   24 +-
 gst/rtp/gstrtpmp4vpay.h                       |    2 -
 gst/rtp/gstrtpmpadepay.c                      |   10 +-
 gst/rtp/gstrtpmpadepay.h                      |    2 -
 gst/rtp/gstrtpmpapay.c                        |   14 +-
 gst/rtp/gstrtpmpapay.h                        |    2 -
 gst/rtp/gstrtpmparobustdepay.c                |   11 +-
 gst/rtp/gstrtpmparobustdepay.h                |    2 -
 gst/rtp/gstrtpmpvdepay.c                      |   10 +-
 gst/rtp/gstrtpmpvdepay.h                      |    2 -
 gst/rtp/gstrtpmpvpay.c                        |   17 +-
 gst/rtp/gstrtpmpvpay.h                        |    2 -
 gst/rtp/gstrtpopusdepay.c                     |  138 ++-
 gst/rtp/gstrtpopusdepay.h                     |    2 -
 gst/rtp/gstrtpopuspay.c                       |  316 ++++-
 gst/rtp/gstrtpopuspay.h                       |    7 +-
 gst/rtp/gstrtppcmadepay.c                     |   10 +-
 gst/rtp/gstrtppcmadepay.h                     |    2 -
 gst/rtp/gstrtppcmapay.c                       |   10 +-
 gst/rtp/gstrtppcmapay.h                       |    2 -
 gst/rtp/gstrtppcmudepay.c                     |   10 +-
 gst/rtp/gstrtppcmudepay.h                     |    2 -
 gst/rtp/gstrtppcmupay.c                       |   10 +-
 gst/rtp/gstrtppcmupay.h                       |    2 -
 gst/rtp/gstrtpqcelpdepay.c                    |   10 +-
 gst/rtp/gstrtpqcelpdepay.h                    |    2 -
 gst/rtp/gstrtpqdmdepay.c                      |   17 +-
 gst/rtp/gstrtpqdmdepay.h                      |    2 -
 gst/rtp/gstrtpreddec.c                        |  193 ++-
 gst/rtp/gstrtpreddec.h                        |    9 +-
 gst/rtp/gstrtpredenc.c                        |   68 +-
 gst/rtp/gstrtpredenc.h                        |    3 +
 gst/rtp/gstrtpsbcdepay.c                      |   10 +-
 gst/rtp/gstrtpsbcdepay.h                      |    2 -
 gst/rtp/gstrtpsbcpay.c                        |   89 +-
 gst/rtp/gstrtpsbcpay.h                        |    2 -
 gst/rtp/gstrtpsirendepay.c                    |   10 +-
 gst/rtp/gstrtpsirendepay.h                    |    2 -
 gst/rtp/gstrtpsirenpay.c                      |   10 +-
 gst/rtp/gstrtpsirenpay.h                      |    2 -
 gst/rtp/gstrtpspeexdepay.c                    |   10 +-
 gst/rtp/gstrtpspeexdepay.h                    |    2 -
 gst/rtp/gstrtpspeexpay.c                      |   10 +-
 gst/rtp/gstrtpspeexpay.h                      |    2 -
 gst/rtp/gstrtpstorage.c                       |    3 +
 gst/rtp/gstrtpstreamdepay.c                   |   10 +-
 gst/rtp/gstrtpstreamdepay.h                   |    1 -
 gst/rtp/gstrtpstreampay.c                     |   10 +-
 gst/rtp/gstrtpstreampay.h                     |    2 -
 gst/rtp/gstrtpsv3vdepay.c                     |   18 +-
 gst/rtp/gstrtpsv3vdepay.h                     |    2 -
 gst/rtp/gstrtptheoradepay.c                   |   10 +-
 gst/rtp/gstrtptheoradepay.h                   |    2 -
 gst/rtp/gstrtptheorapay.c                     |   14 +-
 gst/rtp/gstrtptheorapay.h                     |    2 -
 gst/rtp/gstrtpulpfecdec.c                     |   71 +-
 gst/rtp/gstrtpulpfecdec.h                     |    2 +
 gst/rtp/gstrtpulpfecenc.c                     |  133 ++-
 gst/rtp/gstrtpulpfecenc.h                     |    1 +
 gst/rtp/gstrtpvorbisdepay.c                   |   10 +-
 gst/rtp/gstrtpvorbisdepay.h                   |    2 -
 gst/rtp/gstrtpvorbispay.c                     |   10 +-
 gst/rtp/gstrtpvorbispay.h                     |    2 -
 gst/rtp/gstrtpvp8depay.c                      |  277 ++++-
 gst/rtp/gstrtpvp8depay.h                      |   14 +-
 gst/rtp/gstrtpvp8pay.c                        |  263 +++-
 gst/rtp/gstrtpvp8pay.h                        |    5 +-
 gst/rtp/gstrtpvp9depay.c                      |  298 ++++-
 gst/rtp/gstrtpvp9depay.h                      |   19 +-
 gst/rtp/gstrtpvp9pay.c                        |   16 +-
 gst/rtp/gstrtpvp9pay.h                        |    2 -
 gst/rtp/gstrtpvrawdepay.c                     |   10 +-
 gst/rtp/gstrtpvrawdepay.h                     |    2 -
 gst/rtp/gstrtpvrawpay.c                       |   13 +-
 gst/rtp/gstrtpvrawpay.h                       |    2 -
 gst/rtp/meson.build                           |    6 +-
 gst/rtp/rtpulpfeccommon.c                     |   10 +-
 gst/rtpmanager/gstrtpbin.c                    | 1062 +++++++++++++++--
 gst/rtpmanager/gstrtpbin.h                    |   15 +
 gst/rtpmanager/gstrtpdtmfmux.c                |   16 +-
 gst/rtpmanager/gstrtpdtmfmux.h                |    3 +-
 gst/rtpmanager/gstrtpfunnel.c                 |  129 +-
 gst/rtpmanager/gstrtpfunnel.h                 |    2 +
 .../gstrtphdrext-clientaudiolevel.c           |  268 +++++
 .../gstrtphdrext-clientaudiolevel.h           |   32 +
 gst/rtpmanager/gstrtphdrext-mid.c             |  318 +++++
 gst/rtpmanager/gstrtphdrext-mid.h             |   36 +
 gst/rtpmanager/gstrtphdrext-ntp.c             |  269 +++++
 gst/rtpmanager/gstrtphdrext-ntp.h             |   36 +
 .../gstrtphdrext-repairedstreamid.c           |  307 +++++
 .../gstrtphdrext-repairedstreamid.h           |   36 +
 gst/rtpmanager/gstrtphdrext-streamid.c        |  297 +++++
 gst/rtpmanager/gstrtphdrext-streamid.h        |   36 +
 gst/rtpmanager/gstrtphdrext-twcc.c            |  230 ++++
 gst/rtpmanager/gstrtphdrext-twcc.h            |   83 ++
 gst/rtpmanager/gstrtpjitterbuffer.c           |  879 +++++++++++---
 gst/rtpmanager/gstrtpjitterbuffer.h           |    2 +
 gst/rtpmanager/gstrtpmanager.c                |   74 +-
 gst/rtpmanager/gstrtpmux.c                    |   14 +-
 gst/rtpmanager/gstrtpmux.h                    |    4 +-
 gst/rtpmanager/gstrtpptdemux.c                |   10 +-
 gst/rtpmanager/gstrtpptdemux.h                |    2 +
 gst/rtpmanager/gstrtprtxqueue.c               |   16 +-
 gst/rtpmanager/gstrtprtxqueue.h               |    4 +-
 gst/rtpmanager/gstrtprtxreceive.c             |  454 +++++--
 gst/rtpmanager/gstrtprtxreceive.h             |   18 +-
 gst/rtpmanager/gstrtprtxsend.c                |  409 ++++++-
 gst/rtpmanager/gstrtprtxsend.h                |   19 +-
 gst/rtpmanager/gstrtpsession.c                |  179 ++-
 gst/rtpmanager/gstrtpsession.h                |    2 +
 gst/rtpmanager/gstrtpssrcdemux.c              |  141 +--
 gst/rtpmanager/gstrtpssrcdemux.h              |    3 +-
 gst/rtpmanager/gstrtpst2022-1-fecdec.c        | 1013 ++++++++++++++++
 gst/rtpmanager/gstrtpst2022-1-fecdec.h        |   39 +
 gst/rtpmanager/gstrtpst2022-1-fecenc.c        |  803 +++++++++++++
 gst/rtpmanager/gstrtpst2022-1-fecenc.h        |   39 +
 gst/rtpmanager/gstrtputils.c                  |   44 +
 gst/rtpmanager/gstrtputils.h                  |   34 +
 gst/rtpmanager/meson.build                    |   12 +-
 gst/rtpmanager/rtpjitterbuffer.c              |  134 ++-
 gst/rtpmanager/rtpjitterbuffer.h              |    2 +-
 gst/rtpmanager/rtpsession.c                   |  633 ++++++----
 gst/rtpmanager/rtpsession.h                   |   27 +-
 gst/rtpmanager/rtpsource.c                    |  112 +-
 gst/rtpmanager/rtpsource.h                    |   21 +-
 gst/rtpmanager/rtpstats.c                     |    1 +
 gst/rtpmanager/rtpstats.h                     |   16 +-
 gst/rtpmanager/rtptimerqueue.c                |   10 +-
 gst/rtpmanager/rtptimerqueue.h                |    2 -
 gst/rtpmanager/rtptwcc.c                      |  355 ++++--
 gst/rtpmanager/rtptwcc.h                      |   16 +-
 267 files changed, 12759 insertions(+), 2703 deletions(-)
 create mode 100644 ext/vpx/gstvpxcompat.h
 create mode 100644 ext/vpx/gstvpxelement.c
 create mode 100644 ext/vpx/gstvpxelements.h
 create mode 100644 ext/vpx/gstvpxenums.h
 create mode 100644 gst/rtp/gstrtpelement.c
 create mode 100644 gst/rtp/gstrtpelements.h
 create mode 100644 gst/rtp/gstrtphdrext-colorspace.c
 create mode 100644 gst/rtp/gstrtphdrext-colorspace.h
 create mode 100644 gst/rtp/gstrtpisacdepay.c
 create mode 100644 gst/rtp/gstrtpisacdepay.h
 create mode 100644 gst/rtp/gstrtpisacpay.c
 create mode 100644 gst/rtp/gstrtpisacpay.h
 create mode 100644 gst/rtp/gstrtpldacpay.c
 create mode 100644 gst/rtp/gstrtpldacpay.h
 create mode 100644 gst/rtpmanager/gstrtphdrext-clientaudiolevel.c
 create mode 100644 gst/rtpmanager/gstrtphdrext-clientaudiolevel.h
 create mode 100644 gst/rtpmanager/gstrtphdrext-mid.c
 create mode 100644 gst/rtpmanager/gstrtphdrext-mid.h
 create mode 100644 gst/rtpmanager/gstrtphdrext-ntp.c
 create mode 100644 gst/rtpmanager/gstrtphdrext-ntp.h
 create mode 100644 gst/rtpmanager/gstrtphdrext-repairedstreamid.c
 create mode 100644 gst/rtpmanager/gstrtphdrext-repairedstreamid.h
 create mode 100644 gst/rtpmanager/gstrtphdrext-streamid.c
 create mode 100644 gst/rtpmanager/gstrtphdrext-streamid.h
 create mode 100644 gst/rtpmanager/gstrtphdrext-twcc.c
 create mode 100644 gst/rtpmanager/gstrtphdrext-twcc.h
 create mode 100644 gst/rtpmanager/gstrtpst2022-1-fecdec.c
 create mode 100644 gst/rtpmanager/gstrtpst2022-1-fecdec.h
 create mode 100644 gst/rtpmanager/gstrtpst2022-1-fecenc.c
 create mode 100644 gst/rtpmanager/gstrtpst2022-1-fecenc.h
 create mode 100644 gst/rtpmanager/gstrtputils.c
 create mode 100644 gst/rtpmanager/gstrtputils.h

diff --git a/ext/vpx/gstvp8dec.c b/ext/vpx/gstvp8dec.c
index 8aea6aced..16a1b5ae2 100644
--- a/ext/vpx/gstvp8dec.c
+++ b/ext/vpx/gstvp8dec.c
@@ -44,6 +44,7 @@
 
 #include <string.h>
 
+#include "gstvpxelements.h"
 #include "gstvp8dec.h"
 #include "gstvp8utils.h"
 
@@ -59,6 +60,7 @@ static void gst_vp8_dec_set_default_format (GstVPXDec * dec, GstVideoFormat fmt,
     int width, int height);
 static void gst_vp8_dec_handle_resolution_change (GstVPXDec * dec,
     vpx_image_t * img, GstVideoFormat fmt);
+static gboolean gst_vp8_dec_get_needs_sync_point (GstVPXDec * dec);
 
 static GstStaticPadTemplate gst_vp8_dec_sink_template =
 GST_STATIC_PAD_TEMPLATE ("sink",
@@ -76,6 +78,8 @@ GST_STATIC_PAD_TEMPLATE ("src",
 
 #define parent_class gst_vp8_dec_parent_class
 G_DEFINE_TYPE (GstVP8Dec, gst_vp8_dec, GST_TYPE_VPX_DEC);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (vp8dec, "vp8dec", GST_RANK_PRIMARY,
+    gst_vp8_dec_get_type (), vpx_element_init (plugin));
 
 static void
 gst_vp8_dec_class_init (GstVP8DecClass * klass)
@@ -103,6 +107,8 @@ gst_vp8_dec_class_init (GstVP8DecClass * klass)
       GST_DEBUG_FUNCPTR (gst_vp8_dec_set_default_format);
   vpx_class->handle_resolution_change =
       GST_DEBUG_FUNCPTR (gst_vp8_dec_handle_resolution_change);
+  vpx_class->get_needs_sync_point =
+      GST_DEBUG_FUNCPTR (gst_vp8_dec_get_needs_sync_point);
 
   GST_DEBUG_CATEGORY_INIT (gst_vp8dec_debug, "vp8dec", 0, "VP8 Decoder");
 }
@@ -153,4 +159,10 @@ gst_vp8_dec_handle_resolution_change (GstVPXDec * dec, vpx_image_t * img,
   }
 }
 
+static gboolean
+gst_vp8_dec_get_needs_sync_point (GstVPXDec * dec)
+{
+  return FALSE;
+}
+
 #endif /* HAVE_VP8_DECODER */
diff --git a/ext/vpx/gstvp8enc.c b/ext/vpx/gstvp8enc.c
index 8bc56f980..93ef43e83 100644
--- a/ext/vpx/gstvp8enc.c
+++ b/ext/vpx/gstvp8enc.c
@@ -62,6 +62,7 @@
 #include <gst/video/video.h>
 #include <string.h>
 
+#include "gstvpxelements.h"
 #include "gstvp8utils.h"
 #include "gstvp8enc.h"
 
@@ -72,6 +73,9 @@ typedef struct
 {
   vpx_image_t *image;
   GList *invisible;
+  guint layer_id;
+  guint8 tl0picidx;
+  gboolean layer_sync;
 } GstVP8EncUserData;
 
 static void
@@ -104,6 +108,15 @@ static GstFlowReturn gst_vp8_enc_handle_invisible_frame_buffer (GstVPXEnc * enc,
     void *user_data, GstBuffer * buffer);
 static void gst_vp8_enc_set_frame_user_data (GstVPXEnc * enc,
     GstVideoCodecFrame * frame, vpx_image_t * image);
+static void gst_vp8_enc_apply_frame_temporal_settings (GstVPXEnc * enc,
+    GstVideoCodecFrame * frame, guint layer_id, guint8 tl0picidx,
+    gboolean layer_sync);
+static void gst_vp8_enc_get_frame_temporal_settings (GstVPXEnc * enc,
+    GstVideoCodecFrame * frame, guint * layer_id, guint8 * tl0picidx,
+    gboolean * layer_sync);
+static void gst_vp8_enc_preflight_buffer (GstVPXEnc * enc,
+    GstVideoCodecFrame * frame, GstBuffer * buffer,
+    gboolean layer_sync, guint layer_id, guint8 tl0picidx);
 
 static GstFlowReturn gst_vp8_enc_pre_push (GstVideoEncoder * encoder,
     GstVideoCodecFrame * frame);
@@ -127,6 +140,8 @@ GST_STATIC_PAD_TEMPLATE ("src",
 
 #define parent_class gst_vp8_enc_parent_class
 G_DEFINE_TYPE (GstVP8Enc, gst_vp8_enc, GST_TYPE_VPX_ENC);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (vp8enc, "vp8enc", GST_RANK_PRIMARY,
+    gst_vp8_enc_get_type (), vpx_element_init (plugin));
 
 static void
 gst_vp8_enc_class_init (GstVP8EncClass * klass)
@@ -163,6 +178,11 @@ gst_vp8_enc_class_init (GstVP8EncClass * klass)
   vpx_encoder_class->handle_invisible_frame_buffer =
       gst_vp8_enc_handle_invisible_frame_buffer;
   vpx_encoder_class->set_frame_user_data = gst_vp8_enc_set_frame_user_data;
+  vpx_encoder_class->apply_frame_temporal_settings =
+      gst_vp8_enc_apply_frame_temporal_settings;
+  vpx_encoder_class->get_frame_temporal_settings =
+      gst_vp8_enc_get_frame_temporal_settings;
+  vpx_encoder_class->preflight_buffer = gst_vp8_enc_preflight_buffer;
 
   GST_DEBUG_CATEGORY_INIT (gst_vp8enc_debug, "vp8enc", 0, "VP8 Encoder");
 }
@@ -330,6 +350,67 @@ gst_vp8_enc_set_frame_user_data (GstVPXEnc * enc, GstVideoCodecFrame * frame,
   return;
 }
 
+static void
+gst_vp8_enc_apply_frame_temporal_settings (GstVPXEnc * enc,
+    GstVideoCodecFrame * frame, guint layer_id, guint8 tl0picidx,
+    gboolean layer_sync)
+{
+  GstVP8EncUserData *user_data;
+
+  user_data = gst_video_codec_frame_get_user_data (frame);
+
+  if (!user_data) {
+    GST_ERROR_OBJECT (enc, "Have no frame user data");
+    return;
+  }
+
+  vpx_codec_control (&enc->encoder, VP8E_SET_TEMPORAL_LAYER_ID, layer_id);
+  user_data->layer_id = layer_id;
+  user_data->tl0picidx = tl0picidx;
+  user_data->layer_sync = layer_sync;
+
+  return;
+}
+
+static void
+gst_vp8_enc_get_frame_temporal_settings (GstVPXEnc * enc,
+    GstVideoCodecFrame * frame, guint * layer_id, guint8 * tl0picidx,
+    gboolean * layer_sync)
+{
+  GstVP8EncUserData *user_data;
+
+  user_data = gst_video_codec_frame_get_user_data (frame);
+
+  if (!user_data) {
+    GST_ERROR_OBJECT (enc, "Have no frame user data");
+    *layer_id = 0;
+    *tl0picidx = 0;
+    *layer_sync = FALSE;
+    return;
+  }
+
+  *layer_id = user_data->layer_id;
+  *tl0picidx = user_data->tl0picidx;
+  *layer_sync = user_data->layer_sync;
+
+  return;
+}
+
+static void
+gst_vp8_enc_preflight_buffer (GstVPXEnc * enc,
+    GstVideoCodecFrame * frame, GstBuffer * buffer,
+    gboolean layer_sync, guint layer_id, guint8 tl0picidx)
+{
+  GstCustomMeta *meta = gst_buffer_add_custom_meta (buffer, "GstVP8Meta");
+  GstStructure *s = gst_custom_meta_get_structure (meta);
+
+  gst_structure_set (s,
+      "use-temporal-scaling", G_TYPE_BOOLEAN, (enc->cfg.ts_periodicity != 0),
+      "layer-sync", G_TYPE_BOOLEAN, layer_sync,
+      "layer-id", G_TYPE_UINT, layer_id,
+      "tl0picidx", G_TYPE_UINT, tl0picidx, NULL);
+}
+
 static guint64
 _to_granulepos (guint64 frame_end_number, guint inv_count, guint keyframe_dist)
 {
diff --git a/ext/vpx/gstvp9dec.c b/ext/vpx/gstvp9dec.c
index 43a0dda47..3819e602a 100644
--- a/ext/vpx/gstvp9dec.c
+++ b/ext/vpx/gstvp9dec.c
@@ -44,6 +44,7 @@
 
 #include <string.h>
 
+#include "gstvpxelements.h"
 #include "gstvp8utils.h"
 #include "gstvp9dec.h"
 
@@ -61,6 +62,7 @@ static gboolean gst_vp9_dec_get_valid_format (GstVPXDec * dec,
     vpx_image_t * img, GstVideoFormat * fmt);
 static void gst_vp9_dec_handle_resolution_change (GstVPXDec * dec,
     vpx_image_t * img, GstVideoFormat fmt);
+static gboolean gst_vp9_dec_get_needs_sync_point (GstVPXDec * dec);
 
 static GstStaticPadTemplate gst_vp9_dec_sink_template =
 GST_STATIC_PAD_TEMPLATE ("sink",
@@ -69,27 +71,41 @@ GST_STATIC_PAD_TEMPLATE ("sink",
     GST_STATIC_CAPS ("video/x-vp9")
     );
 
-static GstStaticPadTemplate gst_vp9_dec_src_template =
-GST_STATIC_PAD_TEMPLATE ("src",
-    GST_PAD_SRC,
-    GST_PAD_ALWAYS,
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE ("{ I420, YV12, Y42B, Y444, GBR }"))
-    );
+#define GST_VP9_DEC_VIDEO_FORMATS_8BIT "I420, YV12, Y42B, Y444, GBR"
+#define GST_VP9_DEC_VIDEO_FORMATS_HIGHBIT \
+    "I420_10LE, I420_12LE, I422_10LE, I422_12LE, Y444_10LE, Y444_12LE, GBR_10LE, GBR_12LE"
 
 #define parent_class gst_vp9_dec_parent_class
 G_DEFINE_TYPE (GstVP9Dec, gst_vp9_dec, GST_TYPE_VPX_DEC);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (vp9dec, "vp9dec", GST_RANK_PRIMARY,
+    gst_vp9_dec_get_type (), vpx_element_init (plugin));
+
+static GstCaps *
+gst_vp9_dec_get_src_caps (void)
+{
+#define CAPS_8BIT GST_VIDEO_CAPS_MAKE ("{ " GST_VP9_DEC_VIDEO_FORMATS_8BIT " }")
+#define CAPS_HIGHBIT GST_VIDEO_CAPS_MAKE ( "{ " GST_VP9_DEC_VIDEO_FORMATS_8BIT ", " \
+    GST_VP9_DEC_VIDEO_FORMATS_HIGHBIT "}")
+
+  return gst_caps_from_string ((vpx_codec_get_caps (&vpx_codec_vp9_dx_algo)
+          & VPX_CODEC_CAP_HIGHBITDEPTH) ? CAPS_HIGHBIT : CAPS_8BIT);
+}
 
 static void
 gst_vp9_dec_class_init (GstVP9DecClass * klass)
 {
   GstElementClass *element_class;
   GstVPXDecClass *vpx_class;
+  GstCaps *caps;
 
   element_class = GST_ELEMENT_CLASS (klass);
   vpx_class = GST_VPX_DEC_CLASS (klass);
 
-  gst_element_class_add_static_pad_template (element_class,
-      &gst_vp9_dec_src_template);
+  caps = gst_vp9_dec_get_src_caps ();
+  gst_element_class_add_pad_template (element_class,
+      gst_pad_template_new ("src", GST_PAD_SRC, GST_PAD_ALWAYS, caps));
+  gst_clear_caps (&caps);
+
   gst_element_class_add_static_pad_template (element_class,
       &gst_vp9_dec_sink_template);
 
@@ -106,6 +122,8 @@ gst_vp9_dec_class_init (GstVP9DecClass * klass)
       GST_DEBUG_FUNCPTR (gst_vp9_dec_get_valid_format);
   vpx_class->handle_resolution_change =
       GST_DEBUG_FUNCPTR (gst_vp9_dec_handle_resolution_change);
+  vpx_class->get_needs_sync_point =
+      GST_DEBUG_FUNCPTR (gst_vp9_dec_get_needs_sync_point);
 
   GST_DEBUG_CATEGORY_INIT (gst_vp9dec_debug, "vp9dec", 0, "VP9 Decoder");
 }
@@ -130,65 +148,82 @@ static gboolean
 gst_vp9_dec_get_valid_format (GstVPXDec * dec, vpx_image_t * img,
     GstVideoFormat * fmt)
 {
-  switch (img->fmt) {
-    case VPX_IMG_FMT_I420:
+  switch ((gst_vpx_img_fmt_t) img->fmt) {
+    case GST_VPX_IMG_FMT_I420:
       *fmt = GST_VIDEO_FORMAT_I420;
       return TRUE;
 
-    case VPX_IMG_FMT_YV12:
+    case GST_VPX_IMG_FMT_YV12:
       *fmt = GST_VIDEO_FORMAT_YV12;
       return TRUE;
 
-    case VPX_IMG_FMT_I422:
+    case GST_VPX_IMG_FMT_I422:
       *fmt = GST_VIDEO_FORMAT_Y42B;
       return TRUE;
 
-    case VPX_IMG_FMT_I444:
+    case GST_VPX_IMG_FMT_I444:
       if (img->cs == VPX_CS_SRGB)
         *fmt = GST_VIDEO_FORMAT_GBR;
       else
         *fmt = GST_VIDEO_FORMAT_Y444;
       return TRUE;
-#ifdef VPX_IMG_FMT_I440
-    case VPX_IMG_FMT_I440:
+    case GST_VPX_IMG_FMT_I440:
       /* Planar, half height, full width U/V */
       GST_FIXME_OBJECT (dec, "Please add a 4:4:0 planar frame format");
       GST_ELEMENT_WARNING (dec, STREAM, NOT_IMPLEMENTED,
           (NULL), ("Unsupported frame format - 4:4:0 planar"));
       return FALSE;
-#endif
-#ifdef VPX_IMG_FMT_I42016
-    case VPX_IMG_FMT_I42016:
-      /* VPX_IMG_FMT_I420 | VPX_IMG_FMT_HIGHBITDEPTH */
-      GST_FIXME_OBJECT (dec, "Please add 16-bit I420 format");
+    case GST_VPX_IMG_FMT_I42016:
+      if (img->bit_depth == 10) {
+        *fmt = GST_VIDEO_FORMAT_I420_10LE;
+        return TRUE;
+      } else if (img->bit_depth == 12) {
+        *fmt = GST_VIDEO_FORMAT_I420_12LE;
+        return TRUE;
+      }
       GST_ELEMENT_WARNING (dec, STREAM, NOT_IMPLEMENTED,
-          (NULL), ("Unsupported frame format - 16-bit 4:2:0 planar"));
+          (NULL), ("Unsupported frame format - %d-bit 4:2:0 planar",
+              img->bit_depth));
       return FALSE;
-#endif
-#ifdef VPX_IMG_FMT_I42216
-    case VPX_IMG_FMT_I42216:
-      /* VPX_IMG_FMT_I422 | VPX_IMG_FMT_HIGHBITDEPTH */
-      GST_FIXME_OBJECT (dec, "Please add 16-bit Y42B format");
+    case GST_VPX_IMG_FMT_I42216:
+      if (img->bit_depth == 10) {
+        *fmt = GST_VIDEO_FORMAT_I422_10LE;
+        return TRUE;
+      } else if (img->bit_depth == 12) {
+        *fmt = GST_VIDEO_FORMAT_I422_12LE;
+        return TRUE;
+      }
       GST_ELEMENT_WARNING (dec, STREAM, NOT_IMPLEMENTED,
-          (NULL), ("Unsupported frame format - 16-bit 4:2:2 planar"));
+          (NULL), ("Unsupported frame format - %d-bit 4:2:2 planar",
+              img->bit_depth));
       return FALSE;
-#endif
-#ifdef VPX_IMG_FMT_I44416
-    case VPX_IMG_FMT_I44416:
-      /* VPX_IMG_FMT_I444 | VPX_IMG_FMT_HIGHBITDEPTH */
-      GST_FIXME_OBJECT (dec, "Please add 16-bit Y444 format");
+    case GST_VPX_IMG_FMT_I44416:
+      if (img->cs == VPX_CS_SRGB) {
+        if (img->bit_depth == 10) {
+          *fmt = GST_VIDEO_FORMAT_GBR_10LE;
+          return TRUE;
+        } else if (img->bit_depth == 12) {
+          *fmt = GST_VIDEO_FORMAT_GBR_12LE;
+          return TRUE;
+        }
+      } else {
+        if (img->bit_depth == 10) {
+          *fmt = GST_VIDEO_FORMAT_Y444_10LE;
+          return TRUE;
+        } else if (img->bit_depth == 12) {
+          *fmt = GST_VIDEO_FORMAT_Y444_12LE;
+          return TRUE;
+        }
+      }
       GST_ELEMENT_WARNING (dec, STREAM, NOT_IMPLEMENTED,
-          (NULL), ("Unsupported frame format - 16-bit 4:4:4 planar"));
+          (NULL), ("Unsupported frame format - %d-bit 4:4:4 planar",
+              img->bit_depth));
       return FALSE;
-#endif
-#ifdef VPX_IMG_FMT_I44016
-    case VPX_IMG_FMT_I44016:
-      /* VPX_IMG_FMT_I440 | VPX_IMG_FMT_HIGHBITDEPTH */
+    case GST_VPX_IMG_FMT_I44016:
       GST_FIXME_OBJECT (dec, "Please add 16-bit 4:4:0 planar frame format");
       GST_ELEMENT_WARNING (dec, STREAM, NOT_IMPLEMENTED,
           (NULL), ("Unsupported frame format - 16-bit 4:4:0 planar"));
       return FALSE;
-#endif
     default:
       return FALSE;
   }
@@ -218,4 +253,10 @@ gst_vp9_dec_handle_resolution_change (GstVPXDec * dec, vpx_image_t * img,
   }
 }
 
+static gboolean
+gst_vp9_dec_get_needs_sync_point (GstVPXDec * dec)
+{
+  return TRUE;
+}
+
 #endif /* HAVE_VP9_DECODER */
diff --git a/ext/vpx/gstvp9enc.c b/ext/vpx/gstvp9enc.c
index 1705b0602..eb75fa1d0 100644
--- a/ext/vpx/gstvp9enc.c
+++ b/ext/vpx/gstvp9enc.c
@@ -62,21 +62,34 @@
 #include <gst/video/video.h>
 #include <string.h>
 
+#include "gstvpxelements.h"
+#include "gstvpxenums.h"
+#include "gstvpx-enumtypes.h"
 #include "gstvp8utils.h"
 #include "gstvp9enc.h"
 
 GST_DEBUG_CATEGORY_STATIC (gst_vp9enc_debug);
 #define GST_CAT_DEFAULT gst_vp9enc_debug
 
+#define DEFAULT_TILE_COLUMNS 6
+#define DEFAULT_TILE_ROWS 0
+#define DEFAULT_ROW_MT 0
+#define DEFAULT_AQ_MODE GST_VPX_AQ_OFF
+#define DEFAULT_FRAME_PARALLEL_DECODING TRUE
 
-/* FIXME: Y42B and Y444 do not work yet it seems */
-static GstStaticPadTemplate gst_vp9_enc_sink_template =
-GST_STATIC_PAD_TEMPLATE ("sink",
-    GST_PAD_SINK,
-    GST_PAD_ALWAYS,
-    /*GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE ("{ I420, YV12, Y42B, Y444 }")) */
-    GST_STATIC_CAPS (GST_VIDEO_CAPS_MAKE ("{ I420, YV12 }"))
-    );
+enum
+{
+  PROP_0,
+  PROP_TILE_COLUMNS,
+  PROP_TILE_ROWS,
+  PROP_ROW_MT,
+  PROP_AQ_MODE,
+  PROP_FRAME_PARALLEL_DECODING,
+};
+
+#define GST_VP9_ENC_VIDEO_FORMATS_8BIT "I420, YV12, Y444"
+#define GST_VP9_ENC_VIDEO_FORMATS_HIGHBIT \
+    "I420_10LE, I420_12LE, I422_10LE, I422_12LE, Y444_10LE, Y444_12LE"
 
 static GstStaticPadTemplate gst_vp9_enc_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -87,6 +100,8 @@ GST_STATIC_PAD_TEMPLATE ("src",
 
 #define parent_class gst_vp9_enc_parent_class
 G_DEFINE_TYPE (GstVP9Enc, gst_vp9_enc, GST_TYPE_VPX_ENC);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (vp9enc, "vp9enc", GST_RANK_PRIMARY,
+    gst_vp9_enc_get_type (), vpx_element_init (plugin));
 
 static vpx_codec_iface_t *gst_vp9_enc_get_algo (GstVPXEnc * enc);
 static gboolean gst_vp9_enc_enable_scaling (GstVPXEnc * enc);
@@ -100,22 +115,115 @@ static GstFlowReturn gst_vp9_enc_handle_invisible_frame_buffer (GstVPXEnc * enc,
     void *user_data, GstBuffer * buffer);
 static void gst_vp9_enc_set_frame_user_data (GstVPXEnc * enc,
     GstVideoCodecFrame * frame, vpx_image_t * image);
+static void gst_vp9_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
+static void gst_vp9_enc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+static gboolean gst_vp9_enc_configure_encoder (GstVPXEnc * encoder,
+    GstVideoCodecState * state);
 
 #define DEFAULT_BITS_PER_PIXEL 0.0289
 
+static GstCaps *
+gst_vp9_enc_get_sink_caps (void)
+{
+#define CAPS_8BIT GST_VIDEO_CAPS_MAKE ("{ " GST_VP9_ENC_VIDEO_FORMATS_8BIT " }")
+#define CAPS_HIGHBIT GST_VIDEO_CAPS_MAKE ( "{ " GST_VP9_ENC_VIDEO_FORMATS_8BIT ", " \
+    GST_VP9_ENC_VIDEO_FORMATS_HIGHBIT "}")
+
+  return gst_caps_from_string ((vpx_codec_get_caps (gst_vp9_enc_get_algo (NULL))
+          & VPX_CODEC_CAP_HIGHBITDEPTH) ? CAPS_HIGHBIT : CAPS_8BIT);
+}
+
 static void
 gst_vp9_enc_class_init (GstVP9EncClass * klass)
 {
+  GObjectClass *gobject_class;
   GstElementClass *element_class;
   GstVPXEncClass *vpx_encoder_class;
+  GstCaps *caps;
 
+  gobject_class = G_OBJECT_CLASS (klass);
   element_class = GST_ELEMENT_CLASS (klass);
   vpx_encoder_class = GST_VPX_ENC_CLASS (klass);
 
+  gobject_class->set_property = gst_vp9_enc_set_property;
+  gobject_class->get_property = gst_vp9_enc_get_property;
+
+  /**
+   * GstVP9Enc:tile-columns:
+   *
+   * Number of tile columns, log2
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_TILE_COLUMNS,
+      g_param_spec_int ("tile-columns", "Tile Columns",
+          "Number of tile columns, log2",
+          0, 6, DEFAULT_TILE_COLUMNS,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  /**
+   * GstVP9Enc:tile-rows:
+   *
+   * Number of tile rows, log2
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_TILE_ROWS,
+      g_param_spec_int ("tile-rows", "Tile Rows",
+          "Number of tile rows, log2",
+          0, 2, DEFAULT_TILE_ROWS,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  /**
+   * GstVP9Enc:row-mt:
+   *
+   * Whether each row should be encoded using multiple threads
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_ROW_MT,
+      g_param_spec_boolean ("row-mt", "Row Multithreading",
+          "Whether each row should be encoded using multiple threads",
+          DEFAULT_ROW_MT,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
+  /**
+   * GstVP9Enc:aq-mode:
+   *
+   * Adaptive Quantization Mode
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_AQ_MODE,
+      g_param_spec_enum ("aq-mode", "Adaptive Quantization Mode",
+          "Which adaptive quantization mode should be used",
+          GST_TYPE_VPXAQ, DEFAULT_AQ_MODE,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+  gst_type_mark_as_plugin_api (GST_TYPE_VPXAQ, 0);
+
+  /**
+   * GstVP9Enc:frame-parallel-decoding:
+   *
+   * Whether encoded bitstream should allow parallel processing of video frames in the decoder
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_FRAME_PARALLEL_DECODING,
+      g_param_spec_boolean ("frame-parallel-decoding",
+          "Frame Parallel Decoding",
+          "Whether encoded bitstream should allow parallel processing of video frames in the decoder "
+          "(default is on)", DEFAULT_FRAME_PARALLEL_DECODING,
+          (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)));
+
   gst_element_class_add_static_pad_template (element_class,
       &gst_vp9_enc_src_template);
-  gst_element_class_add_static_pad_template (element_class,
-      &gst_vp9_enc_sink_template);
+
+  caps = gst_vp9_enc_get_sink_caps ();
+  gst_element_class_add_pad_template (element_class,
+      gst_pad_template_new ("sink", GST_PAD_SINK, GST_PAD_ALWAYS, caps));
+  gst_clear_caps (&caps);
 
   gst_element_class_set_static_metadata (element_class,
       "On2 VP9 Encoder",
@@ -133,6 +241,7 @@ gst_vp9_enc_class_init (GstVP9EncClass * klass)
   vpx_encoder_class->handle_invisible_frame_buffer =
       gst_vp9_enc_handle_invisible_frame_buffer;
   vpx_encoder_class->set_frame_user_data = gst_vp9_enc_set_frame_user_data;
+  vpx_encoder_class->configure_encoder = gst_vp9_enc_configure_encoder;
 
   GST_DEBUG_CATEGORY_INIT (gst_vp9enc_debug, "vp9enc", 0, "VP9 Encoder");
 }
@@ -155,6 +264,259 @@ gst_vp9_enc_init (GstVP9Enc * gst_vp9_enc)
     gst_vpx_enc->have_default_config = TRUE;
   }
   gst_vpx_enc->bits_per_pixel = DEFAULT_BITS_PER_PIXEL;
+
+  gst_vp9_enc->tile_columns = DEFAULT_TILE_COLUMNS;
+  gst_vp9_enc->tile_rows = DEFAULT_TILE_ROWS;
+  gst_vp9_enc->row_mt = DEFAULT_ROW_MT;
+  gst_vp9_enc->aq_mode = DEFAULT_AQ_MODE;
+  gst_vp9_enc->frame_parallel_decoding = DEFAULT_FRAME_PARALLEL_DECODING;
+}
+
+static void
+gst_vp9_enc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstVPXEnc *gst_vpx_enc = GST_VPX_ENC (object);
+  GstVP9Enc *gst_vp9_enc = GST_VP9_ENC (object);
+  vpx_codec_err_t status;
+
+  g_mutex_lock (&gst_vpx_enc->encoder_lock);
+
+  switch (prop_id) {
+    case PROP_TILE_COLUMNS:
+      gst_vp9_enc->tile_columns = g_value_get_int (value);
+      if (gst_vpx_enc->inited) {
+        status =
+            vpx_codec_control (&gst_vpx_enc->encoder, VP9E_SET_TILE_COLUMNS,
+            gst_vp9_enc->tile_columns);
+        if (status != VPX_CODEC_OK) {
+          GST_WARNING_OBJECT (gst_vpx_enc,
+              "Failed to set VP9E_SET_TILE_COLUMNS: %s",
+              gst_vpx_error_name (status));
+        }
+      }
+      break;
+    case PROP_TILE_ROWS:
+      gst_vp9_enc->tile_rows = g_value_get_int (value);
+      if (gst_vpx_enc->inited) {
+        status =
+            vpx_codec_control (&gst_vpx_enc->encoder, VP9E_SET_TILE_ROWS,
+            gst_vp9_enc->tile_rows);
+        if (status != VPX_CODEC_OK) {
+          GST_WARNING_OBJECT (gst_vpx_enc,
+              "Failed to set VP9E_SET_TILE_ROWS: %s",
+              gst_vpx_error_name (status));
+        }
+      }
+      break;
+    case PROP_ROW_MT:
+      gst_vp9_enc->row_mt = g_value_get_boolean (value);
+      if (gst_vpx_enc->inited) {
+        status =
+            vpx_codec_control (&gst_vpx_enc->encoder, VP9E_SET_ROW_MT,
+            gst_vp9_enc->row_mt ? 1 : 0);
+        if (status != VPX_CODEC_OK) {
+          GST_WARNING_OBJECT (gst_vpx_enc,
+              "Failed to set VP9E_SET_ROW_MT: %s", gst_vpx_error_name (status));
+        }
+      }
+      break;
+    case PROP_AQ_MODE:
+      gst_vp9_enc->aq_mode = g_value_get_enum (value);
+      if (gst_vpx_enc->inited) {
+        status = vpx_codec_control (&gst_vpx_enc->encoder, VP9E_SET_AQ_MODE,
+            gst_vp9_enc->aq_mode);
+        if (status != VPX_CODEC_OK) {
+          GST_WARNING_OBJECT (gst_vpx_enc,
+              "Failed to set VP9E_SET_AQ_MODE: %s",
+              gst_vpx_error_name (status));
+        }
+      }
+      break;
+    case PROP_FRAME_PARALLEL_DECODING:
+      gst_vp9_enc->frame_parallel_decoding = g_value_get_boolean (value);
+      if (gst_vpx_enc->inited) {
+        status = vpx_codec_control (&gst_vpx_enc->encoder,
+            VP9E_SET_FRAME_PARALLEL_DECODING,
+            gst_vp9_enc->frame_parallel_decoding ? 1 : 0);
+        if (status != VPX_CODEC_OK) {
+          GST_WARNING_OBJECT (gst_vpx_enc,
+              "Failed to set VP9E_SET_FRAME_PARALLEL_DECODING: %s",
+              gst_vpx_error_name (status));
+        }
+      }
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+
+  g_mutex_unlock (&gst_vpx_enc->encoder_lock);
+}
+
+static void
+gst_vp9_enc_get_property (GObject * object, guint prop_id, GValue * value,
+    GParamSpec * pspec)
+{
+  GstVPXEnc *gst_vpx_enc = GST_VPX_ENC (object);
+  GstVP9Enc *gst_vp9_enc = GST_VP9_ENC (object);
+
+  g_mutex_lock (&gst_vpx_enc->encoder_lock);
+
+  switch (prop_id) {
+    case PROP_TILE_COLUMNS:
+      g_value_set_int (value, gst_vp9_enc->tile_columns);
+      break;
+    case PROP_TILE_ROWS:
+      g_value_set_int (value, gst_vp9_enc->tile_rows);
+      break;
+    case PROP_ROW_MT:
+      g_value_set_boolean (value, gst_vp9_enc->row_mt);
+      break;
+    case PROP_AQ_MODE:
+      g_value_set_enum (value, gst_vp9_enc->aq_mode);
+      break;
+    case PROP_FRAME_PARALLEL_DECODING:
+      g_value_set_boolean (value, gst_vp9_enc->frame_parallel_decoding);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+
+  g_mutex_unlock (&gst_vpx_enc->encoder_lock);
+}
+
+static vpx_color_space_t
+gst_vp9_get_vpx_colorspace (GstVPXEnc * encoder, GstVideoColorimetry * in_cinfo,
+    GstVideoFormat format)
+{
+  vpx_color_space_t colorspace = VPX_CS_UNKNOWN;
+  GstVideoColorimetry cinfo = *in_cinfo;
+  gchar *colorimetry_str;
+  guint i;
+
+  /* *INDENT-OFF* */
+  static const struct
+  {
+    const gchar *str;
+    vpx_color_space_t vpx_color_space;
+  } colorimetry_map[] = {
+    {
+    GST_VIDEO_COLORIMETRY_BT601, VPX_CS_BT_601}, {
+    GST_VIDEO_COLORIMETRY_BT709, VPX_CS_BT_709}, {
+    GST_VIDEO_COLORIMETRY_SMPTE240M, VPX_CS_SMPTE_240}, {
+    GST_VIDEO_COLORIMETRY_BT2020, VPX_CS_BT_2020}
+  };
+  /* *INDENT-ON* */
+
+  /* We support any range, all mapped CSC are by default reduced range. */
+  cinfo.range = GST_VIDEO_COLOR_RANGE_16_235;
+  colorimetry_str = gst_video_colorimetry_to_string (&cinfo);
+
+  if (colorimetry_str != NULL) {
+    for (i = 0; i < G_N_ELEMENTS (colorimetry_map); ++i) {
+      if (g_strcmp0 (colorimetry_map[i].str, colorimetry_str) == 0) {
+        colorspace = colorimetry_map[i].vpx_color_space;
+        break;
+      }
+    }
+  }
+
+  if (colorspace == VPX_CS_UNKNOWN) {
+    if (format == GST_VIDEO_FORMAT_GBR
+        || format == GST_VIDEO_FORMAT_GBR_10BE
+        || format == GST_VIDEO_FORMAT_GBR_10LE
+        || format == GST_VIDEO_FORMAT_GBR_12BE
+        || format == GST_VIDEO_FORMAT_GBR_12LE) {
+      /* Currently has no effect because vp*enc elements only accept YUV video
+       * formats.
+       *
+       * FIXME: Support encoding GST_VIDEO_FORMAT_GBR and its high bits variants.
+       */
+      colorspace = VPX_CS_SRGB;
+    } else {
+      GST_WARNING_OBJECT (encoder, "Unsupported colorspace \"%s\"",
+          GST_STR_NULL (colorimetry_str));
+    }
+  }
+
+  g_free (colorimetry_str);
+
+  return colorspace;
+}
+
+static gint
+gst_vp9_get_vpx_color_range (GstVideoColorimetry * colorimetry)
+{
+  if (colorimetry->range == GST_VIDEO_COLOR_RANGE_0_255)
+    /* Full range (0..255 or HBD equivalent) */
+    return 1;
+
+  /* Limited range (16..235 or HBD equivalent) */
+  return 0;
+}
+
+static gboolean
+gst_vp9_enc_configure_encoder (GstVPXEnc * encoder, GstVideoCodecState * state)
+{
+  GstVP9Enc *vp9enc = GST_VP9_ENC (encoder);
+  GstVideoInfo *info = &state->info;
+  vpx_codec_err_t status;
+
+  status = vpx_codec_control (&encoder->encoder, VP9E_SET_COLOR_SPACE,
+      gst_vp9_get_vpx_colorspace (encoder, &GST_VIDEO_INFO_COLORIMETRY (info),
+          GST_VIDEO_INFO_FORMAT (info)));
+  if (status != VPX_CODEC_OK) {
+    GST_WARNING_OBJECT (encoder,
+        "Failed to set VP9E_SET_COLOR_SPACE: %s", gst_vpx_error_name (status));
+  }
+
+  status = vpx_codec_control (&encoder->encoder, VP9E_SET_COLOR_RANGE,
+      gst_vp9_get_vpx_color_range (&GST_VIDEO_INFO_COLORIMETRY (info)));
+  if (status != VPX_CODEC_OK) {
+    GST_WARNING_OBJECT (encoder,
+        "Failed to set VP9E_SET_COLOR_RANGE: %s", gst_vpx_error_name (status));
+  }
+
+  status =
+      vpx_codec_control (&encoder->encoder, VP9E_SET_TILE_COLUMNS,
+      vp9enc->tile_columns);
+  if (status != VPX_CODEC_OK) {
+    GST_DEBUG_OBJECT (encoder, "Failed to set VP9E_SET_TILE_COLUMNS: %s",
+        gst_vpx_error_name (status));
+  }
+
+  status =
+      vpx_codec_control (&encoder->encoder, VP9E_SET_TILE_ROWS,
+      vp9enc->tile_rows);
+  if (status != VPX_CODEC_OK) {
+    GST_DEBUG_OBJECT (encoder, "Failed to set VP9E_SET_TILE_ROWS: %s",
+        gst_vpx_error_name (status));
+  }
+  status =
+      vpx_codec_control (&encoder->encoder, VP9E_SET_ROW_MT,
+      vp9enc->row_mt ? 1 : 0);
+  if (status != VPX_CODEC_OK) {
+    GST_DEBUG_OBJECT (encoder,
+        "Failed to set VP9E_SET_ROW_MT: %s", gst_vpx_error_name (status));
+  }
+  status =
+      vpx_codec_control (&encoder->encoder, VP9E_SET_AQ_MODE, vp9enc->aq_mode);
+  if (status != VPX_CODEC_OK) {
+    GST_WARNING_OBJECT (encoder,
+        "Failed to set VP9E_SET_AQ_MODE: %s", gst_vpx_error_name (status));
+  }
+  status =
+      vpx_codec_control (&encoder->encoder, VP9E_SET_FRAME_PARALLEL_DECODING,
+      vp9enc->frame_parallel_decoding ? 1 : 0);
+  if (status != VPX_CODEC_OK) {
+    GST_WARNING_OBJECT (encoder,
+        "Failed to set VP9E_SET_FRAME_PARALLEL_DECODING: %s",
+        gst_vpx_error_name (status));
+  }
+
+  return TRUE;
 }
 
 static vpx_codec_iface_t *
@@ -174,24 +536,66 @@ gst_vp9_enc_set_image_format (GstVPXEnc * enc, vpx_image_t * image)
 {
   switch (enc->input_state->info.finfo->format) {
     case GST_VIDEO_FORMAT_I420:
-      image->fmt = VPX_IMG_FMT_I420;
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I420;
       image->bps = 12;
+      image->bit_depth = 8;
       image->x_chroma_shift = image->y_chroma_shift = 1;
       break;
     case GST_VIDEO_FORMAT_YV12:
-      image->fmt = VPX_IMG_FMT_YV12;
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_YV12;
       image->bps = 12;
+      image->bit_depth = 8;
       image->x_chroma_shift = image->y_chroma_shift = 1;
       break;
     case GST_VIDEO_FORMAT_Y42B:
-      image->fmt = VPX_IMG_FMT_I422;
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I422;
       image->bps = 16;
+      image->bit_depth = 8;
       image->x_chroma_shift = 1;
       image->y_chroma_shift = 0;
       break;
     case GST_VIDEO_FORMAT_Y444:
-      image->fmt = VPX_IMG_FMT_I444;
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I444;
+      image->bps = 24;
+      image->bit_depth = 8;
+      image->x_chroma_shift = image->y_chroma_shift = 0;
+      break;
+    case GST_VIDEO_FORMAT_I420_10LE:
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I42016;
+      image->bps = 15;
+      image->bit_depth = 10;
+      image->x_chroma_shift = image->y_chroma_shift = 1;
+      break;
+    case GST_VIDEO_FORMAT_I420_12LE:
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I42016;
+      image->bps = 18;
+      image->bit_depth = 12;
+      image->x_chroma_shift = image->y_chroma_shift = 1;
+      break;
+    case GST_VIDEO_FORMAT_I422_10LE:
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I42216;
+      image->bps = 20;
+      image->bit_depth = 10;
+      image->x_chroma_shift = 1;
+      image->y_chroma_shift = 0;
+      break;
+    case GST_VIDEO_FORMAT_I422_12LE:
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I42216;
       image->bps = 24;
+      image->bit_depth = 12;
+      image->x_chroma_shift = 1;
+      image->y_chroma_shift = 0;
+      break;
+    case GST_VIDEO_FORMAT_Y444_10LE:
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I44416;
+      image->bps = 30;
+      image->bit_depth = 10;
+      image->x_chroma_shift = image->y_chroma_shift = 0;
+      break;
+    case GST_VIDEO_FORMAT_Y444_12LE:
+      image->fmt = (vpx_img_fmt_t) GST_VPX_IMG_FMT_I44416;
+      image->bps = 36;
+      image->bit_depth = 12;
       image->x_chroma_shift = image->y_chroma_shift = 0;
       break;
     default:
diff --git a/ext/vpx/gstvp9enc.h b/ext/vpx/gstvp9enc.h
index a61a2f91a..03d31d1bd 100644
--- a/ext/vpx/gstvp9enc.h
+++ b/ext/vpx/gstvp9enc.h
@@ -43,7 +43,15 @@ G_DECLARE_FINAL_TYPE (GstVP9Enc, gst_vp9_enc, GST, VP9_ENC, GstVPXEnc)
 
 struct _GstVP9Enc
 {
-	GstVPXEnc base_vpx_encoder;
+  GstVPXEnc base_vpx_encoder;
+
+  guint tile_columns;
+  guint tile_rows;
+#ifdef VPX_CTRL_VP9E_SET_ROW_MT
+  gboolean row_mt;
+#endif
+  GstVPXAQ aq_mode;
+  gboolean frame_parallel_decoding;
 };
 
 G_END_DECLS
diff --git a/ext/vpx/gstvpxcompat.h b/ext/vpx/gstvpxcompat.h
new file mode 100644
index 000000000..1919791a1
--- /dev/null
+++ b/ext/vpx/gstvpxcompat.h
@@ -0,0 +1,47 @@
+/*
+ * GStreamer
+ * Copyright (C) 2022 Seungha Yang <seungha@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#pragma once
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_VPX_IMG_FMT_PLANAR 0x100
+#define GST_VPX_IMG_FMT_UV_FLIP 0x200
+#define GST_VPX_IMG_FMT_HIGHBITDEPTH 0x800
+
+/* vpx_img_fmt with GST_ prefix */
+typedef enum gst_vpx_img_fmt
+{
+  GST_VPX_IMG_FMT_NONE,
+  GST_VPX_IMG_FMT_YV12 = GST_VPX_IMG_FMT_PLANAR | GST_VPX_IMG_FMT_UV_FLIP | 1,
+  GST_VPX_IMG_FMT_I420 = GST_VPX_IMG_FMT_PLANAR | 2,
+  GST_VPX_IMG_FMT_I422 = GST_VPX_IMG_FMT_PLANAR | 5,
+  GST_VPX_IMG_FMT_I444 = GST_VPX_IMG_FMT_PLANAR | 6,
+  GST_VPX_IMG_FMT_I440 = GST_VPX_IMG_FMT_PLANAR | 7,
+  GST_VPX_IMG_FMT_NV12 = GST_VPX_IMG_FMT_PLANAR | 9,
+  GST_VPX_IMG_FMT_I42016 = GST_VPX_IMG_FMT_I420 | GST_VPX_IMG_FMT_HIGHBITDEPTH,
+  GST_VPX_IMG_FMT_I42216 = GST_VPX_IMG_FMT_I422 | GST_VPX_IMG_FMT_HIGHBITDEPTH,
+  GST_VPX_IMG_FMT_I44416 = GST_VPX_IMG_FMT_I444 | GST_VPX_IMG_FMT_HIGHBITDEPTH,
+  GST_VPX_IMG_FMT_I44016 = GST_VPX_IMG_FMT_I440 | GST_VPX_IMG_FMT_HIGHBITDEPTH
+} gst_vpx_img_fmt_t;
+
+G_END_DECLS
diff --git a/ext/vpx/gstvpxdec.c b/ext/vpx/gstvpxdec.c
index 74cc3c970..d5351b839 100644
--- a/ext/vpx/gstvpxdec.c
+++ b/ext/vpx/gstvpxdec.c
@@ -197,6 +197,7 @@ static void
 gst_vpx_dec_init (GstVPXDec * gst_vpx_dec)
 {
   GstVideoDecoder *decoder = (GstVideoDecoder *) gst_vpx_dec;
+  GstVPXDecClass *vpxclass = GST_VPX_DEC_GET_CLASS (gst_vpx_dec);
 
   GST_DEBUG_OBJECT (gst_vpx_dec, "gst_vpx_dec_init");
   gst_video_decoder_set_packetized (decoder, TRUE);
@@ -205,6 +206,11 @@ gst_vpx_dec_init (GstVPXDec * gst_vpx_dec)
   gst_vpx_dec->deblocking_level = DEFAULT_DEBLOCKING_LEVEL;
   gst_vpx_dec->noise_level = DEFAULT_NOISE_LEVEL;
 
+  if (vpxclass->get_needs_sync_point) {
+    gst_video_decoder_set_needs_sync_point (GST_VIDEO_DECODER (gst_vpx_dec),
+        vpxclass->get_needs_sync_point (gst_vpx_dec));
+  }
+
   gst_video_decoder_set_needs_format (decoder, TRUE);
   gst_video_decoder_set_use_default_pad_acceptcaps (decoder, TRUE);
   GST_PAD_SET_ACCEPT_TEMPLATE (GST_VIDEO_DECODER_SINK_PAD (decoder));
@@ -280,6 +286,7 @@ gst_vpx_dec_start (GstVideoDecoder * decoder)
 
   GST_DEBUG_OBJECT (gst_vpx_dec, "start");
   gst_vpx_dec->decoder_inited = FALSE;
+  gst_vpx_dec->safe_remap = FALSE;
 
   return TRUE;
 }
@@ -395,6 +402,15 @@ gst_vpx_dec_prepare_image (GstVPXDec * dec, const vpx_image_t * img)
 
   buffer = gst_buffer_ref (frame->buffer);
 
+  /* FIXME: an atomic remap would be preferable, for now we simply
+   * remap the buffer from RW to RO when using a sysmem allocator,
+   * in order to avoid a useless memcpy in GstVideoDecoder.
+   */
+  if (dec->safe_remap) {
+    gst_buffer_unmap (buffer, &frame->info);
+    gst_buffer_map (buffer, &frame->info, GST_MAP_READ);
+  }
+
   vmeta = gst_buffer_get_video_meta (buffer);
   vmeta->format = GST_VIDEO_INFO_FORMAT (info);
   vmeta->width = GST_VIDEO_INFO_WIDTH (info);
@@ -444,6 +460,9 @@ gst_vpx_dec_get_buffer_cb (gpointer priv, gsize min_size,
       allocator = NULL;
     }
 
+    dec->safe_remap = (allocator == NULL
+        || !g_strcmp0 (allocator->mem_type, GST_ALLOCATOR_SYSMEM));
+
     pool = gst_buffer_pool_new ();
     config = gst_buffer_pool_get_config (pool);
     gst_buffer_pool_config_set_allocator (config, allocator, &params);
@@ -581,14 +600,11 @@ gst_vpx_dec_open_codec (GstVPXDec * dec, GstVideoCodecFrame * frame)
   gst_buffer_unmap (frame->input_buffer, &minfo);
 
   if (status != VPX_CODEC_OK) {
-    GST_WARNING_OBJECT (dec, "VPX preprocessing error: %s",
+    GST_INFO_OBJECT (dec, "VPX preprocessing error: %s",
         gst_vpx_error_name (status));
     return GST_FLOW_CUSTOM_SUCCESS_1;
   }
-  if (!stream_info.is_kf) {
-    GST_WARNING_OBJECT (dec, "No keyframe, skipping");
-    return GST_FLOW_CUSTOM_SUCCESS_1;
-  }
+
   if (stream_info.w == 0 || stream_info.h == 0) {
     /* For VP8 it's possible to signal width or height to be 0, but it does
      * not make sense to do so. For VP9 it's impossible. Hence, we most likely
@@ -672,6 +688,12 @@ gst_vpx_dec_handle_frame (GstVideoDecoder * decoder, GstVideoCodecFrame * frame)
   if (!dec->decoder_inited) {
     ret = vpxclass->open_codec (dec, frame);
     if (ret == GST_FLOW_CUSTOM_SUCCESS_1) {
+      GstVideoDecoderRequestSyncPointFlags flags = 0;
+
+      if (gst_video_decoder_get_needs_sync_point (decoder))
+        flags |= GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT;
+
+      gst_video_decoder_request_sync_point (decoder, frame, flags);
       gst_video_decoder_drop_frame (decoder, frame);
       return GST_FLOW_OK;
     } else if (ret != GST_FLOW_OK) {
@@ -701,8 +723,15 @@ gst_vpx_dec_handle_frame (GstVideoDecoder * decoder, GstVideoCodecFrame * frame)
   gst_buffer_unmap (frame->input_buffer, &minfo);
 
   if (status) {
+    GstVideoDecoderRequestSyncPointFlags flags = 0;
+
     GST_VIDEO_DECODER_ERROR (decoder, 1, LIBRARY, ENCODE,
         ("Failed to decode frame"), ("%s", gst_vpx_error_name (status)), ret);
+
+    if (gst_video_decoder_get_needs_sync_point (decoder))
+      flags |= GST_VIDEO_DECODER_REQUEST_SYNC_POINT_DISCARD_INPUT;
+
+    gst_video_decoder_request_sync_point (decoder, frame, flags);
     gst_video_codec_frame_unref (frame);
     return ret;
   }
diff --git a/ext/vpx/gstvpxdec.h b/ext/vpx/gstvpxdec.h
index 36b3c272e..e48f4e714 100644
--- a/ext/vpx/gstvpxdec.h
+++ b/ext/vpx/gstvpxdec.h
@@ -31,6 +31,7 @@
 
 #include <gst/gst.h>
 #include <gst/video/gstvideodecoder.h>
+#include "gstvpxcompat.h"
 
 /* FIXME: Undef HAVE_CONFIG_H because vpx_codec.h uses it,
  * which causes compilation failures */
@@ -82,6 +83,7 @@ struct _GstVPXDec
   gboolean have_video_meta;
   GstBufferPool *pool;
   gsize buf_size;
+  gboolean safe_remap;
 };
 
 struct _GstVPXDecClass
@@ -102,6 +104,11 @@ struct _GstVPXDecClass
   void (*handle_resolution_change) (GstVPXDec *dec, vpx_image_t *img, GstVideoFormat fmt);
   /*virtual function to check valid format*/
   gboolean (*get_frame_format)(GstVPXDec *dec, vpx_image_t *img, GstVideoFormat* fmt);
+  /* virtual function to check whether the decoder can handle data
+   * before receiving a sync_point, either at the start of after a
+   * decoding error
+   */
+  gboolean (*get_needs_sync_point)(GstVPXDec *dec);
 };
 
 GType gst_vpx_dec_get_type (void);
diff --git a/ext/vpx/gstvpxelement.c b/ext/vpx/gstvpxelement.c
new file mode 100644
index 000000000..2550283bf
--- /dev/null
+++ b/ext/vpx/gstvpxelement.c
@@ -0,0 +1,39 @@
+/* VPX
+ * Copyright (C) 2006 David Schleef <ds@schleef.org>
+ * Copyright (C) 2010 Entropy Wave Inc
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "gstvpxelements.h"
+
+#include <gst/tag/tag.h>
+
+void
+vpx_element_init (GstPlugin * plugin)
+{
+  static gsize res = FALSE;
+  static const gchar *tags[] = { NULL };
+  if (g_once_init_enter (&res)) {
+    gst_meta_register_custom ("GstVP8Meta", tags, NULL, NULL, NULL);
+    g_once_init_leave (&res, TRUE);
+  }
+}
diff --git a/ext/vpx/gstvpxelements.h b/ext/vpx/gstvpxelements.h
new file mode 100644
index 000000000..b2c1f88f3
--- /dev/null
+++ b/ext/vpx/gstvpxelements.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2020 Huawei Technologies Co., Ltd.
+ *   @Author: Julian Bouzas <julian.bouzas@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_VPX_ELEMENTS_H__
+#define __GST_VPX_ELEMENTS_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+void vpx_element_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (vp8dec);
+GST_ELEMENT_REGISTER_DECLARE (vp8enc);
+GST_ELEMENT_REGISTER_DECLARE (vp9dec);
+GST_ELEMENT_REGISTER_DECLARE (vp9enc);
+
+G_END_DECLS
+
+#endif /* __GST_VPX_ELEMENTS_H__ */
diff --git a/ext/vpx/gstvpxenc.c b/ext/vpx/gstvpxenc.c
index 4b3b4f770..612a7a59f 100644
--- a/ext/vpx/gstvpxenc.c
+++ b/ext/vpx/gstvpxenc.c
@@ -75,6 +75,8 @@ GST_DEBUG_CATEGORY_STATIC (gst_vpxenc_debug);
 #define DEFAULT_TS_RATE_DECIMATOR NULL
 #define DEFAULT_TS_PERIODICITY 0
 #define DEFAULT_TS_LAYER_ID NULL
+#define DEFAULT_TS_LAYER_FLAGS NULL
+#define DEFAULT_TS_LAYER_SYNC_FLAGS NULL
 
 #define DEFAULT_ERROR_RESILIENT 0
 #define DEFAULT_LAG_IN_FRAMES 0
@@ -85,7 +87,7 @@ GST_DEBUG_CATEGORY_STATIC (gst_vpxenc_debug);
 #define DEFAULT_V_SCALING_MODE VP8E_NORMAL
 #define DEFAULT_CPU_USED 0
 #define DEFAULT_ENABLE_AUTO_ALT_REF FALSE
-#define DEFAULT_DEADLINE VPX_DL_BEST_QUALITY
+#define DEFAULT_DEADLINE VPX_DL_GOOD_QUALITY
 #define DEFAULT_NOISE_SENSITIVITY 0
 #define DEFAULT_SHARPNESS 0
 
@@ -130,6 +132,8 @@ enum
   PROP_TS_RATE_DECIMATOR,
   PROP_TS_PERIODICITY,
   PROP_TS_LAYER_ID,
+  PROP_TS_LAYER_FLAGS,
+  PROP_TS_LAYER_SYNC_FLAGS,
   PROP_MULTIPASS_MODE,
   PROP_MULTIPASS_CACHE_FILE,
   PROP_ERROR_RESILIENT,
@@ -316,6 +320,35 @@ gst_vpx_enc_er_flags_get_type (void)
   return id;
 }
 
+#define GST_VPX_ENC_TS_LAYER_FLAGS_TYPE (gst_vpx_enc_ts_layer_flags_get_type())
+static GType
+gst_vpx_enc_ts_layer_flags_get_type (void)
+{
+  static const GFlagsValue values[] = {
+    {VP8_EFLAG_NO_REF_LAST, "Don't reference the last frame", "no-ref-last"},
+    {VP8_EFLAG_NO_REF_GF, "Don't reference the golden frame", "no-ref-golden"},
+    {VP8_EFLAG_NO_REF_ARF, "Don't reference the alternate reference frame",
+        "no-ref-alt"},
+    {VP8_EFLAG_NO_UPD_LAST, "Don't update the last frame", "no-upd-last"},
+    {VP8_EFLAG_NO_UPD_GF, "Don't update the golden frame", "no-upd-golden"},
+    {VP8_EFLAG_NO_UPD_ARF, "Don't update the alternate reference frame",
+        "no-upd-alt"},
+    {VP8_EFLAG_NO_UPD_ENTROPY, "Disable entropy update", "no-upd-entropy"},
+    {0, NULL, NULL}
+  };
+  static GType id = 0;
+
+  if (g_once_init_enter ((gsize *) & id)) {
+    GType _id;
+
+    _id = g_flags_register_static ("GstVPXEncTsLayerFlags", values);
+
+    g_once_init_leave ((gsize *) & id, _id);
+  }
+
+  return id;
+}
+
 static void gst_vpx_enc_finalize (GObject * object);
 static void gst_vpx_enc_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
@@ -335,12 +368,13 @@ static gboolean gst_vpx_enc_sink_event (GstVideoEncoder *
     video_encoder, GstEvent * event);
 static gboolean gst_vpx_enc_propose_allocation (GstVideoEncoder * encoder,
     GstQuery * query);
+static gboolean gst_vpx_enc_transform_meta (GstVideoEncoder * encoder,
+    GstVideoCodecFrame * frame, GstMeta * meta);
 
 #define parent_class gst_vpx_enc_parent_class
 G_DEFINE_TYPE_WITH_CODE (GstVPXEnc, gst_vpx_enc, GST_TYPE_VIDEO_ENCODER,
     G_IMPLEMENT_INTERFACE (GST_TYPE_TAG_SETTER, NULL);
-    G_IMPLEMENT_INTERFACE (GST_TYPE_PRESET, NULL);
-    );
+    G_IMPLEMENT_INTERFACE (GST_TYPE_PRESET, NULL););
 
 static void
 gst_vpx_enc_class_init (GstVPXEncClass * klass)
@@ -363,6 +397,7 @@ gst_vpx_enc_class_init (GstVPXEncClass * klass)
   video_encoder_class->finish = gst_vpx_enc_finish;
   video_encoder_class->sink_event = gst_vpx_enc_sink_event;
   video_encoder_class->propose_allocation = gst_vpx_enc_propose_allocation;
+  video_encoder_class->transform_meta = gst_vpx_enc_transform_meta;
 
   g_object_class_install_property (gobject_class, PROP_RC_END_USAGE,
       g_param_spec_enum ("end-usage", "Rate control mode",
@@ -518,7 +553,7 @@ gst_vpx_enc_class_init (GstVPXEncClass * klass)
   g_object_class_install_property (gobject_class, PROP_TS_TARGET_BITRATE,
       g_param_spec_value_array ("temporal-scalability-target-bitrate",
           "Coding layer target bitrates",
-          "Target bitrates for coding layers (one per layer, decreasing)",
+          "Target bitrates (bits/sec) for coding layers (one per layer)",
           g_param_spec_int ("target-bitrate", "Target bitrate",
               "Target bitrate", 0, G_MAXINT, DEFAULT_RC_TARGET_BITRATE,
               G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
@@ -555,6 +590,36 @@ gst_vpx_enc_class_init (GstVPXEncClass * klass)
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
           GST_PARAM_DOC_SHOW_DEFAULT));
 
+  /**
+   * GstVPXEnc:temporal-scalability-layer-flags:
+   *
+   * Sequence defining coding layer flags
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_TS_LAYER_FLAGS,
+      gst_param_spec_array ("temporal-scalability-layer-flags",
+          "Coding layer flags", "Sequence defining coding layer flags",
+          g_param_spec_flags ("flags", "Flags", "Flags",
+              GST_VPX_ENC_TS_LAYER_FLAGS_TYPE, 0,
+              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS),
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstVPXEnc:temporal-scalability-layer-sync-flags:
+   *
+   * Sequence defining coding layer sync flags
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_TS_LAYER_SYNC_FLAGS,
+      gst_param_spec_array ("temporal-scalability-layer-sync-flags",
+          "Coding layer sync flags",
+          "Sequence defining coding layer sync flags",
+          g_param_spec_boolean ("flags", "Flags", "Flags", FALSE,
+              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS),
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   g_object_class_install_property (gobject_class, PROP_LAG_IN_FRAMES,
       g_param_spec_int ("lag-in-frames", "Lag in frames",
           "Maximum number of frames to lag",
@@ -578,7 +643,7 @@ gst_vpx_enc_class_init (GstVPXEncClass * klass)
 
   g_object_class_install_property (gobject_class, PROP_DEADLINE,
       g_param_spec_int64 ("deadline", "Deadline",
-          "Deadline per frame (usec, 0=disabled)",
+          "Deadline per frame (usec, 0=best, 1=realtime)",
           0, G_MAXINT64, DEFAULT_DEADLINE,
           (GParamFlags) (G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
               GST_PARAM_DOC_SHOW_DEFAULT)));
@@ -744,6 +809,10 @@ gst_vpx_enc_init (GstVPXEnc * gst_vpx_enc)
   gst_vpx_enc->n_ts_rate_decimator = 0;
   gst_vpx_enc->cfg.ts_periodicity = DEFAULT_TS_PERIODICITY;
   gst_vpx_enc->n_ts_layer_id = 0;
+  gst_vpx_enc->n_ts_layer_flags = 0;
+  gst_vpx_enc->ts_layer_flags = NULL;
+  gst_vpx_enc->n_ts_layer_sync_flags = 0;
+  gst_vpx_enc->ts_layer_sync_flags = NULL;
   gst_vpx_enc->cfg.g_error_resilient = DEFAULT_ERROR_RESILIENT;
   gst_vpx_enc->cfg.g_lag_in_frames = DEFAULT_LAG_IN_FRAMES;
   gst_vpx_enc->cfg.g_threads = DEFAULT_THREADS;
@@ -765,6 +834,8 @@ gst_vpx_enc_init (GstVPXEnc * gst_vpx_enc)
   gst_vpx_enc->timebase_n = DEFAULT_TIMEBASE_N;
   gst_vpx_enc->timebase_d = DEFAULT_TIMEBASE_D;
   gst_vpx_enc->bits_per_pixel = DEFAULT_BITS_PER_PIXEL;
+  gst_vpx_enc->tl0picidx = 0;
+  gst_vpx_enc->prev_was_keyframe = FALSE;
 
   gst_vpx_enc->cfg.g_profile = DEFAULT_PROFILE;
 
@@ -781,6 +852,9 @@ gst_vpx_enc_finalize (GObject * object)
   g_return_if_fail (GST_IS_VPX_ENC (object));
   gst_vpx_enc = GST_VPX_ENC (object);
 
+  g_free (gst_vpx_enc->ts_layer_flags);
+  g_free (gst_vpx_enc->ts_layer_sync_flags);
+
   g_free (gst_vpx_enc->multipass_cache_prefix);
   g_free (gst_vpx_enc->multipass_cache_file);
   gst_vpx_enc->multipass_cache_idx = 0;
@@ -950,7 +1024,7 @@ gst_vpx_enc_set_property (GObject * object, guint prop_id,
 
         for (i = 0; i < va->n_values; i++)
           gst_vpx_enc->cfg.ts_target_bitrate[i] =
-              g_value_get_int (g_value_array_get_nth (va, i));
+              g_value_get_int (g_value_array_get_nth (va, i)) / 1000;
         gst_vpx_enc->n_ts_target_bitrate = va->n_values;
       }
       global = TRUE;
@@ -1002,6 +1076,45 @@ gst_vpx_enc_set_property (GObject * object, guint prop_id,
       global = TRUE;
       break;
     }
+    case PROP_TS_LAYER_FLAGS:{
+      gint l = gst_value_array_get_size (value);
+
+      g_free (gst_vpx_enc->ts_layer_flags);
+      gst_vpx_enc->n_ts_layer_flags = 0;
+
+      if (l > 0) {
+        gint i;
+
+        gst_vpx_enc->ts_layer_flags = g_new (gint, l);
+
+        for (i = 0; i < l; i++)
+          gst_vpx_enc->ts_layer_flags[i] =
+              g_value_get_flags (gst_value_array_get_value (value, i));
+        gst_vpx_enc->n_ts_layer_flags = l;
+      } else {
+        gst_vpx_enc->ts_layer_flags = NULL;
+      }
+      break;
+    }
+    case PROP_TS_LAYER_SYNC_FLAGS:{
+      gint l = gst_value_array_get_size (value);
+
+      g_free (gst_vpx_enc->ts_layer_sync_flags);
+      gst_vpx_enc->n_ts_layer_sync_flags = 0;
+
+      if (l > 0) {
+        gint i;
+
+        gst_vpx_enc->ts_layer_sync_flags = g_new (gboolean, l);
+        for (i = 0; i < l; i++)
+          gst_vpx_enc->ts_layer_sync_flags[i] =
+              g_value_get_boolean (gst_value_array_get_value (value, i));
+        gst_vpx_enc->n_ts_layer_sync_flags = l;
+      } else {
+        gst_vpx_enc->ts_layer_sync_flags = NULL;
+      }
+      break;
+    }
     case PROP_ERROR_RESILIENT:
       gst_vpx_enc->cfg.g_error_resilient = g_value_get_flags (value);
       global = TRUE;
@@ -1312,7 +1425,7 @@ gst_vpx_enc_get_property (GObject * object, guint prop_id, GValue * value,
           GValue v = { 0, };
 
           g_value_init (&v, G_TYPE_INT);
-          g_value_set_int (&v, gst_vpx_enc->cfg.ts_target_bitrate[i]);
+          g_value_set_int (&v, gst_vpx_enc->cfg.ts_target_bitrate[i] * 1000);
           g_value_array_append (va, &v);
           g_value_unset (&v);
         }
@@ -1368,6 +1481,32 @@ gst_vpx_enc_get_property (GObject * object, guint prop_id, GValue * value,
       }
       break;
     }
+    case PROP_TS_LAYER_FLAGS:{
+      gint i;
+
+      for (i = 0; i < gst_vpx_enc->n_ts_layer_flags; i++) {
+        GValue v = { 0, };
+
+        g_value_init (&v, GST_VPX_ENC_TS_LAYER_FLAGS_TYPE);
+        g_value_set_flags (&v, gst_vpx_enc->ts_layer_flags[i]);
+        gst_value_array_append_value (value, &v);
+        g_value_unset (&v);
+      }
+      break;
+    }
+    case PROP_TS_LAYER_SYNC_FLAGS:{
+      gint i;
+
+      for (i = 0; i < gst_vpx_enc->n_ts_layer_sync_flags; i++) {
+        GValue v = { 0, };
+
+        g_value_init (&v, G_TYPE_BOOLEAN);
+        g_value_set_boolean (&v, gst_vpx_enc->ts_layer_sync_flags[i]);
+        gst_value_array_append_value (value, &v);
+        g_value_unset (&v);
+      }
+      break;
+    }
     case PROP_ERROR_RESILIENT:
       g_value_set_flags (value, gst_vpx_enc->cfg.g_error_resilient);
       break;
@@ -1472,6 +1611,10 @@ gst_vpx_enc_destroy_encoder (GstVPXEnc * encoder)
     encoder->cfg.rc_twopass_stats_in.buf = NULL;
     encoder->cfg.rc_twopass_stats_in.sz = 0;
   }
+
+  encoder->last_pts = GST_CLOCK_TIME_NONE;
+  encoder->last_input_duration = GST_CLOCK_TIME_NONE;
+
   g_mutex_unlock (&encoder->encoder_lock);
 }
 
@@ -1495,12 +1638,46 @@ gst_vpx_enc_stop (GstVideoEncoder * video_encoder)
   return TRUE;
 }
 
+#define INVALID_PROFILE -1
+
 static gint
-gst_vpx_enc_get_downstream_profile (GstVPXEnc * encoder)
+gst_vpx_gvalue_to_profile (const GValue * v)
+{
+  gchar *endptr = NULL;
+  gint profile = g_ascii_strtoull (g_value_get_string (v), &endptr, 10);
+
+  if (*endptr != '\0') {
+    profile = INVALID_PROFILE;
+  }
+
+  return profile;
+}
+
+static gint
+gst_vpx_enc_get_downstream_profile (GstVPXEnc * encoder, GstVideoInfo * info)
 {
   GstCaps *allowed;
   GstStructure *s;
-  gint profile = DEFAULT_PROFILE;
+  gint min_profile;
+  gint profile = INVALID_PROFILE;
+
+  switch (GST_VIDEO_INFO_FORMAT (info)) {
+    case GST_VIDEO_FORMAT_Y444:
+      min_profile = 1;
+      break;
+    case GST_VIDEO_FORMAT_I420_10LE:
+    case GST_VIDEO_FORMAT_I420_12LE:
+      min_profile = 2;
+      break;
+    case GST_VIDEO_FORMAT_I422_10LE:
+    case GST_VIDEO_FORMAT_I422_12LE:
+    case GST_VIDEO_FORMAT_Y444_10LE:
+    case GST_VIDEO_FORMAT_Y444_12LE:
+      min_profile = 3;
+      break;
+    default:
+      min_profile = 0;
+  }
 
   allowed = gst_pad_get_allowed_caps (GST_VIDEO_ENCODER_SRC_PAD (encoder));
   if (allowed) {
@@ -1508,22 +1685,29 @@ gst_vpx_enc_get_downstream_profile (GstVPXEnc * encoder)
     s = gst_caps_get_structure (allowed, 0);
     if (gst_structure_has_field (s, "profile")) {
       const GValue *v = gst_structure_get_value (s, "profile");
-      const gchar *profile_str = NULL;
 
-      if (GST_VALUE_HOLDS_LIST (v) && gst_value_list_get_size (v) > 0) {
-        profile_str = g_value_get_string (gst_value_list_get_value (v, 0));
+      if (GST_VALUE_HOLDS_LIST (v)) {
+        gint i;
+
+        for (i = 0; i != gst_value_list_get_size (v); ++i) {
+          gint p = gst_vpx_gvalue_to_profile (gst_value_list_get_value (v, i));
+          if (p >= min_profile) {
+            profile = p;
+            break;
+          }
+        }
       } else if (G_VALUE_HOLDS_STRING (v)) {
-        profile_str = g_value_get_string (v);
+        profile = gst_vpx_gvalue_to_profile (v);
       }
 
-      if (profile_str) {
-        gchar *endptr = NULL;
+      if (profile < min_profile || profile > 3) {
+        profile = INVALID_PROFILE;
+      }
 
-        profile = g_ascii_strtoull (profile_str, &endptr, 10);
-        if (*endptr != '\0' || profile < 0 || profile > 3) {
-          GST_ERROR_OBJECT (encoder, "Invalid profile '%s'", profile_str);
-          profile = DEFAULT_PROFILE;
-        }
+      if (profile > 1 && info->finfo->bits == 8) {
+        GST_DEBUG_OBJECT (encoder,
+            "Codec bit-depth 8 not supported in profile > 1");
+        profile = INVALID_PROFILE;
       }
     }
     gst_caps_unref (allowed);
@@ -1541,6 +1725,7 @@ gst_vpx_enc_set_format (GstVideoEncoder * video_encoder,
   GstVPXEnc *encoder;
   vpx_codec_err_t status;
   vpx_image_t *image;
+  vpx_codec_flags_t flags = 0;
   GstCaps *caps;
   gboolean ret = TRUE;
   GstVideoInfo *info = &state->info;
@@ -1558,11 +1743,25 @@ gst_vpx_enc_set_format (GstVideoEncoder * video_encoder,
     vpx_codec_destroy (&encoder->encoder);
     encoder->inited = FALSE;
     encoder->multipass_cache_idx++;
+    encoder->last_pts = GST_CLOCK_TIME_NONE;
+    encoder->last_input_duration = GST_CLOCK_TIME_NONE;
   } else {
     g_mutex_lock (&encoder->encoder_lock);
   }
 
-  encoder->cfg.g_profile = gst_vpx_enc_get_downstream_profile (encoder);
+  encoder->cfg.g_bit_depth = encoder->cfg.g_input_bit_depth = info->finfo->bits;
+  if (encoder->cfg.g_bit_depth > 8) {
+    flags |= VPX_CODEC_USE_HIGHBITDEPTH;
+  }
+
+  encoder->cfg.g_profile = gst_vpx_enc_get_downstream_profile (encoder, info);
+  if (encoder->cfg.g_profile == INVALID_PROFILE) {
+    GST_ELEMENT_ERROR (encoder, RESOURCE, OPEN_READ,
+        ("Invalid vpx profile"), (NULL));
+    g_mutex_unlock (&encoder->encoder_lock);
+    return FALSE;
+  }
+
   encoder->cfg.g_w = GST_VIDEO_INFO_WIDTH (info);
   encoder->cfg.g_h = GST_VIDEO_INFO_HEIGHT (info);
 
@@ -1628,7 +1827,7 @@ gst_vpx_enc_set_format (GstVideoEncoder * video_encoder,
 
   status =
       vpx_codec_enc_init (&encoder->encoder, vpx_enc_class->get_algo (encoder),
-      &encoder->cfg, 0);
+      &encoder->cfg, flags);
   if (status != VPX_CODEC_OK) {
     GST_ELEMENT_ERROR (encoder, LIBRARY, INIT,
         ("Failed to initialize encoder"), ("%s", gst_vpx_error_name (status)));
@@ -1726,6 +1925,13 @@ gst_vpx_enc_set_format (GstVideoEncoder * video_encoder,
         gst_vpx_error_name (status));
   }
 
+  if (vpx_enc_class->configure_encoder
+      && !vpx_enc_class->configure_encoder (encoder, state)) {
+    ret = FALSE;
+    g_mutex_unlock (&encoder->encoder_lock);
+    goto done;
+  }
+
   if (GST_VIDEO_INFO_FPS_D (info) == 0 || GST_VIDEO_INFO_FPS_N (info) == 0) {
     /* FIXME: Assume 25fps for unknown framerates. Better than reporting
      * that we introduce no latency while we actually do
@@ -1773,6 +1979,7 @@ gst_vpx_enc_set_format (GstVideoEncoder * video_encoder,
 
   gst_video_encoder_negotiate (GST_VIDEO_ENCODER (encoder));
 
+done:
   return ret;
 }
 
@@ -1787,6 +1994,9 @@ gst_vpx_enc_process (GstVPXEnc * encoder)
   GstFlowReturn ret = GST_FLOW_OK;
   GstVPXEncClass *vpx_enc_class;
   vpx_codec_pts_t pts;
+  guint layer_id = 0;
+  guint8 tl0picidx = 0;
+  gboolean layer_sync = FALSE;
 
   video_encoder = GST_VIDEO_ENCODER (encoder);
   vpx_enc_class = GST_VPX_ENC_GET_CLASS (encoder);
@@ -1830,11 +2040,24 @@ gst_vpx_enc_process (GstVPXEnc * encoder)
     /* discard older frames that were dropped by libvpx */
     frame = NULL;
     do {
+      GstClockTime pts_rt;
+
       if (frame)
         gst_video_encoder_finish_frame (video_encoder, frame);
       frame = gst_video_encoder_get_oldest_frame (video_encoder);
+      if (!frame) {
+        GST_WARNING_OBJECT (encoder,
+            "vpx pts %" G_GINT64_FORMAT
+            " does not match input frames, discarding", pkt->data.frame.pts);
+        goto out;
+      }
+
+      pts_rt =
+          gst_segment_to_running_time (&video_encoder->input_segment,
+          GST_FORMAT_TIME, frame->pts);
+
       pts =
-          gst_util_uint64_scale (frame->pts,
+          gst_util_uint64_scale (pts_rt,
           encoder->cfg.g_timebase.den,
           encoder->cfg.g_timebase.num * (GstClockTime) GST_SECOND);
       GST_TRACE_OBJECT (encoder, "vpx pts: %" G_GINT64_FORMAT
@@ -1843,17 +2066,47 @@ gst_vpx_enc_process (GstVPXEnc * encoder)
     } while (pkt->data.frame.pts > pts);
 
     g_assert (frame != NULL);
-    if ((pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0)
-      GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (frame);
-    else
-      GST_VIDEO_CODEC_FRAME_UNSET_SYNC_POINT (frame);
 
     /* FIXME : It would be nice to avoid the memory copy ... */
-    buffer =
-        gst_buffer_new_wrapped (g_memdup (pkt->data.frame.buf,
-            pkt->data.frame.sz), pkt->data.frame.sz);
+    buffer = gst_buffer_new_memdup (pkt->data.frame.buf, pkt->data.frame.sz);
 
     user_data = vpx_enc_class->process_frame_user_data (encoder, frame);
+    if (vpx_enc_class->get_frame_temporal_settings &&
+        encoder->cfg.ts_periodicity != 0) {
+      vpx_enc_class->get_frame_temporal_settings (encoder, frame,
+          &layer_id, &tl0picidx, &layer_sync);
+    }
+
+    if (layer_id != 0 && encoder->prev_was_keyframe) {
+      /* Non-base layer frame immediately after a keyframe is a layer sync */
+      layer_sync = TRUE;
+    }
+
+    if ((pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0) {
+      GST_VIDEO_CODEC_FRAME_SET_SYNC_POINT (frame);
+      /* Key frames always live on layer 0 */
+      layer_id = 0;
+      layer_sync = TRUE;
+      encoder->prev_was_keyframe = TRUE;
+    } else {
+      GST_VIDEO_CODEC_FRAME_UNSET_SYNC_POINT (frame);
+      encoder->prev_was_keyframe = FALSE;
+    }
+
+    if ((pkt->data.frame.flags & VPX_FRAME_IS_DROPPABLE) != 0)
+      GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DROPPABLE);
+    else
+      GST_BUFFER_FLAG_UNSET (buffer, GST_BUFFER_FLAG_DROPPABLE);
+
+    if (layer_id == 0) {
+      /* Allocate a new tl0picidx if this is layer 0 */
+      tl0picidx = ++encoder->tl0picidx;
+    }
+
+    if (vpx_enc_class->preflight_buffer) {
+      vpx_enc_class->preflight_buffer (encoder, frame, buffer,
+          layer_sync, layer_id, tl0picidx);
+    }
 
     if (invisible) {
       ret =
@@ -1869,6 +2122,8 @@ gst_vpx_enc_process (GstVPXEnc * encoder)
 
     pkt = vpx_codec_get_cx_data (&encoder->encoder, &iter);
   }
+
+out:
   g_mutex_unlock (&encoder->encoder_lock);
 
   return ret;
@@ -1883,14 +2138,20 @@ gst_vpx_enc_drain (GstVideoEncoder * video_encoder)
   vpx_codec_err_t status;
   gint64 deadline;
   vpx_codec_pts_t pts;
+  GstClockTime gst_pts = 0;
 
   encoder = GST_VPX_ENC (video_encoder);
 
   g_mutex_lock (&encoder->encoder_lock);
   deadline = encoder->deadline;
 
+  if (GST_CLOCK_TIME_IS_VALID (encoder->last_pts))
+    gst_pts = encoder->last_pts;
+  if (GST_CLOCK_TIME_IS_VALID (encoder->last_input_duration))
+    gst_pts += encoder->last_input_duration;
+
   pts =
-      gst_util_uint64_scale (encoder->last_pts,
+      gst_util_uint64_scale (gst_pts,
       encoder->cfg.g_timebase.den,
       encoder->cfg.g_timebase.num * (GstClockTime) GST_SECOND);
 
@@ -1988,6 +2249,7 @@ gst_vpx_enc_handle_frame (GstVideoEncoder * video_encoder,
   int flags = 0;
   vpx_image_t *image;
   GstVideoFrame vframe;
+  GstClockTime pts_rt;
   vpx_codec_pts_t pts;
   unsigned long duration;
   GstVPXEncClass *vpx_enc_class;
@@ -2012,11 +2274,28 @@ gst_vpx_enc_handle_frame (GstVideoEncoder * video_encoder,
   }
 
   g_mutex_lock (&encoder->encoder_lock);
+
+  /* the input pts needs to be strictly increasing, see vpx_codec_encode() doc, so convert it to
+   * running time as we don't want to reset the encoder for each segment. */
+  pts_rt =
+      gst_segment_to_running_time (&video_encoder->input_segment,
+      GST_FORMAT_TIME, frame->pts);
+
+  /* vpx_codec_encode() enforces us to pass strictly increasing pts */
+  if (GST_CLOCK_TIME_IS_VALID (encoder->last_pts)
+      && pts_rt <= encoder->last_pts) {
+    GST_WARNING_OBJECT (encoder,
+        "decreasing pts %" GST_TIME_FORMAT " previous buffer was %"
+        GST_TIME_FORMAT " enforce increasing pts", GST_TIME_ARGS (pts_rt),
+        GST_TIME_ARGS (encoder->last_pts));
+    pts_rt = encoder->last_pts + 1;
+  }
+
   pts =
-      gst_util_uint64_scale (frame->pts,
+      gst_util_uint64_scale (pts_rt,
       encoder->cfg.g_timebase.den,
       encoder->cfg.g_timebase.num * (GstClockTime) GST_SECOND);
-  encoder->last_pts = frame->pts;
+  encoder->last_pts = pts_rt;
 
   if (frame->duration != GST_CLOCK_TIME_NONE) {
     duration =
@@ -2024,7 +2303,7 @@ gst_vpx_enc_handle_frame (GstVideoEncoder * video_encoder,
         encoder->cfg.g_timebase.num * (GstClockTime) GST_SECOND);
 
     if (duration > 0) {
-      encoder->last_pts += frame->duration;
+      encoder->last_input_duration = frame->duration;
     } else {
       /* We force the path ignoring the duration if we end up with a zero
        * value for duration after scaling (e.g. duration value too small) */
@@ -2037,6 +2316,25 @@ gst_vpx_enc_handle_frame (GstVideoEncoder * video_encoder,
     duration = 1;
   }
 
+  if (encoder->n_ts_layer_flags != 0) {
+    /* If we need a keyframe, then the pattern is irrelevant */
+    if ((flags & VPX_EFLAG_FORCE_KF) == 0) {
+      flags |=
+          encoder->ts_layer_flags[frame->system_frame_number %
+          encoder->n_ts_layer_flags];
+    }
+  }
+
+  if (vpx_enc_class->apply_frame_temporal_settings &&
+      encoder->cfg.ts_periodicity != 0 &&
+      encoder->n_ts_layer_id >= encoder->cfg.ts_periodicity) {
+    vpx_enc_class->apply_frame_temporal_settings (encoder, frame,
+        encoder->cfg.ts_layer_id[frame->system_frame_number %
+            encoder->cfg.ts_periodicity], encoder->tl0picidx,
+        encoder->ts_layer_sync_flags[frame->system_frame_number %
+            encoder->n_ts_layer_sync_flags]);
+  }
+
   status = vpx_codec_encode (&encoder->encoder, image,
       pts, duration, flags, encoder->deadline);
 
@@ -2084,4 +2382,22 @@ gst_vpx_enc_propose_allocation (GstVideoEncoder * encoder, GstQuery * query)
       query);
 }
 
+static gboolean
+gst_vpx_enc_transform_meta (GstVideoEncoder * encoder,
+    GstVideoCodecFrame * frame, GstMeta * meta)
+{
+  const GstMetaInfo *info = meta->info;
+  gboolean ret = FALSE;
+
+  /* Do not copy GstVP8Meta from input to output buffer */
+  if (gst_meta_info_is_custom (info)
+      && gst_custom_meta_has_name ((GstCustomMeta *) meta, "GstVP8Meta"))
+    goto done;
+
+  ret = TRUE;
+
+done:
+  return ret;
+}
+
 #endif /* HAVE_VP8_ENCODER || HAVE_VP9_ENCODER */
diff --git a/ext/vpx/gstvpxenc.h b/ext/vpx/gstvpxenc.h
index fbf5476ba..d9c40e544 100644
--- a/ext/vpx/gstvpxenc.h
+++ b/ext/vpx/gstvpxenc.h
@@ -30,6 +30,7 @@
 
 #include <gst/gst.h>
 #include <gst/video/gstvideoencoder.h>
+#include "gstvpxcompat.h"
 
 /* FIXME: Undef HAVE_CONFIG_H because vpx_codec.h uses it,
  * which causes compilation failures */
@@ -61,7 +62,7 @@ struct _GstVPXEnc
 {
   GstVideoEncoder base_video_encoder;
 
-  /* < private > */
+  /* < protected > */
   vpx_codec_ctx_t encoder;
   GMutex encoder_lock;
 
@@ -72,6 +73,10 @@ struct _GstVPXEnc
   gint n_ts_target_bitrate;
   gint n_ts_rate_decimator;
   gint n_ts_layer_id;
+  gint n_ts_layer_flags;
+  gint *ts_layer_flags;
+  gint n_ts_layer_sync_flags;
+  gboolean *ts_layer_sync_flags;
   /* Global two-pass options */
   gchar *multipass_cache_file;
   gchar *multipass_cache_prefix;
@@ -105,10 +110,15 @@ struct _GstVPXEnc
 
   /* state */
   gboolean inited;
+  guint8 tl0picidx;
+  gboolean prev_was_keyframe;
 
   vpx_image_t image;
 
+  /* last input pts, in running time */
   GstClockTime last_pts;
+  /* duration of the last input buffer */
+  GstClockTime last_input_duration;
 
   GstVideoCodecState *input_state;
 };
@@ -120,6 +130,8 @@ struct _GstVPXEncClass
   vpx_codec_iface_t* (*get_algo) (GstVPXEnc *enc);
   /*enabled scaling*/
   gboolean (*enable_scaling) (GstVPXEnc *enc);
+  /*called from set_format with lock taken*/
+  gboolean (*configure_encoder) (GstVPXEnc *enc, GstVideoCodecState *state);
   /*set image format info*/
   void (*set_image_format) (GstVPXEnc *enc, vpx_image_t *image);
   /*get new simple caps*/
@@ -129,9 +141,23 @@ struct _GstVPXEncClass
   /*process user data*/
   void* (*process_frame_user_data) (GstVPXEnc *enc, GstVideoCodecFrame* frame);
   /*set frame user data*/
-  void (*set_frame_user_data) (GstVPXEnc *enc, GstVideoCodecFrame* frame, vpx_image_t *image);
+  void (*set_frame_user_data) (GstVPXEnc *enc, GstVideoCodecFrame* frame,
+      vpx_image_t *image);
   /*Handle invisible frame*/
-  GstFlowReturn (*handle_invisible_frame_buffer) (GstVPXEnc *enc, void* user_data, GstBuffer* buffer);
+  GstFlowReturn (*handle_invisible_frame_buffer) (GstVPXEnc *enc,
+      void* user_data, GstBuffer* buffer);
+  /*apply temporal settings -- called with encoder lock*/
+  void (*apply_frame_temporal_settings) (GstVPXEnc *enc,
+      GstVideoCodecFrame* frame, guint layer_id, guint8 tl0picidx,
+      gboolean layer_sync);
+  /*get temporal settings*/
+  void (*get_frame_temporal_settings) (GstVPXEnc *enc,
+      GstVideoCodecFrame *frame, guint * layer_id, guint8 *tl0picidx,
+      gboolean *layer_sync);
+  /* preflight buffer */
+  void (*preflight_buffer) (GstVPXEnc *enc,
+      GstVideoCodecFrame *frame, GstBuffer *buffer,
+      gboolean layer_sync, guint layer_id, guint8 tl0picidx);
 };
 
 GType gst_vpx_enc_get_type (void);
diff --git a/ext/vpx/gstvpxenums.h b/ext/vpx/gstvpxenums.h
new file mode 100644
index 000000000..a3bf1c640
--- /dev/null
+++ b/ext/vpx/gstvpxenums.h
@@ -0,0 +1,49 @@
+/* GStreamer
+ * Copyright (C) 2021, Collabora Ltd.
+ *   @author: Jakub Adam <jakub.adam@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_VPX_ENUM_H__
+#define __GST_VPX_ENUM_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+/**
+ * GstVPXAQ:
+ *
+ * VPX Adaptive Quantization modes.
+ *
+ * Since: 1.20
+ */
+typedef enum
+{
+  GST_VPX_AQ_OFF = 0,
+  GST_VPX_AQ_VARIANCE = 1,
+  GST_VPX_AQ_COMPLEXITY = 2,
+  GST_VPX_AQ_CYCLIC_REFRESH = 3,
+  GST_VPX_AQ_EQUATOR360 = 4,
+  GST_VPX_AQ_PERCEPTUAL = 5,
+  GST_VPX_AQ_PSNR = 6,
+  GST_VPX_AQ_LOOKAHEAD = 7,
+} GstVPXAQ;
+
+G_END_DECLS
+
+#endif // __GST_VPX_ENUM_H__
diff --git a/ext/vpx/meson.build b/ext/vpx/meson.build
index 349915cdc..e007cafc0 100644
--- a/ext/vpx/meson.build
+++ b/ext/vpx/meson.build
@@ -6,6 +6,7 @@ vpx_sources = [
   'gstvp9enc.c',
   'gstvpxdec.c',
   'gstvpxenc.c',
+  'gstvpxelement.c',
   'plugin.c',
 ]
 
@@ -17,7 +18,7 @@ vpx_features = [
 ]
 
 vpx_option = get_option('vpx')
-vpx_dep = dependency('vpx', version : '>=1.5.0', required : vpx_option)
+vpx_dep = dependency('vpx', version : '>=1.7.0', required : vpx_option)
 
 if vpx_dep.found()
   vpx_args = []
@@ -56,16 +57,25 @@ if vpx_dep.found()
     vpx_args += '-DHAVE_VPX_1_8'
   endif
 
+  gnome = import('gnome')
+
+  gstvpx_enums = gnome.mkenums_simple('gstvpx-enumtypes',
+    sources : ['gstvpxenums.h'],
+    decorator : 'G_GNUC_INTERNAL',
+    install_header: false)
+
   gstvpx = library('gstvpx',
-    vpx_sources,
+    vpx_sources, gstvpx_enums,
     c_args : gst_plugins_good_args + vpx_args,
     include_directories : [configinc],
     dependencies : [gstbase_dep, gsttag_dep, gstvideo_dep, vpx_dep],
     install : true,
     install_dir : plugins_install_dir,
   )
-  pkgconfig.generate(gstvpx, install_dir : plugins_pkgconfig_install_dir)
   plugins += [gstvpx]
 
   install_data(sources: ['GstVP8Enc.prs'], install_dir: presetdir)
+  env = environment()
+  env.prepend('GST_PRESET_PATH', meson.current_source_dir())
+  meson.add_devenv(env)
 endif
diff --git a/ext/vpx/plugin.c b/ext/vpx/plugin.c
index 4f04efaff..1887aee70 100644
--- a/ext/vpx/plugin.c
+++ b/ext/vpx/plugin.c
@@ -25,35 +25,30 @@
 
 #include <gst/gst.h>
 
-#include "gstvp8dec.h"
-#include "gstvp8enc.h"
-#include "gstvp9dec.h"
-#include "gstvp9enc.h"
+#include "gstvpxelements.h"
 
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
+  gboolean ret = FALSE;
+
 #ifdef HAVE_VP8_DECODER
-  gst_element_register (plugin, "vp8dec", GST_RANK_PRIMARY,
-      gst_vp8_dec_get_type ());
+  ret |= GST_ELEMENT_REGISTER (vp8dec, plugin);
 #endif
 
 #ifdef HAVE_VP8_ENCODER
-  gst_element_register (plugin, "vp8enc", GST_RANK_PRIMARY,
-      gst_vp8_enc_get_type ());
+  ret |= GST_ELEMENT_REGISTER (vp8enc, plugin);
 #endif
 
 #ifdef HAVE_VP9_DECODER
-  gst_element_register (plugin, "vp9dec", GST_RANK_PRIMARY,
-      gst_vp9_dec_get_type ());
+  ret |= GST_ELEMENT_REGISTER (vp9dec, plugin);
 #endif
 
 #ifdef HAVE_VP9_ENCODER
-  gst_element_register (plugin, "vp9enc", GST_RANK_PRIMARY,
-      gst_vp9_enc_get_type ());
+  ret |= GST_ELEMENT_REGISTER (vp9enc, plugin);
 #endif
 
-  return TRUE;
+  return ret;
 }
 
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
diff --git a/gst/rtp/gstasteriskh263.c b/gst/rtp/gstasteriskh263.c
index 8aa7fd451..f22c33f31 100644
--- a/gst/rtp/gstasteriskh263.c
+++ b/gst/rtp/gstasteriskh263.c
@@ -24,6 +24,7 @@
 #include <string.h>
 
 #include <gst/rtp/gstrtpbuffer.h>
+#include "gstrtpelements.h"
 #include "gstasteriskh263.h"
 
 #define GST_ASTERISKH263_HEADER_LEN 6
@@ -64,6 +65,8 @@ static GstStateChangeReturn gst_asteriskh263_change_state (GstElement *
 
 #define gst_asteriskh263_parent_class parent_class
 G_DEFINE_TYPE (GstAsteriskh263, gst_asteriskh263, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (asteriskh263, "asteriskh263",
+    GST_RANK_NONE, GST_TYPE_ASTERISK_H263, rtp_element_init (plugin));
 
 static void
 gst_asteriskh263_class_init (GstAsteriskh263Class * klass)
@@ -221,10 +224,3 @@ gst_asteriskh263_change_state (GstElement * element, GstStateChange transition)
    */
   return ret;
 }
-
-gboolean
-gst_asteriskh263_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "asteriskh263",
-      GST_RANK_NONE, GST_TYPE_ASTERISK_H263);
-}
diff --git a/gst/rtp/gstasteriskh263.h b/gst/rtp/gstasteriskh263.h
index 1c9523d4c..f0416b561 100644
--- a/gst/rtp/gstasteriskh263.h
+++ b/gst/rtp/gstasteriskh263.h
@@ -58,8 +58,6 @@ struct _GstAsteriskh263Class
 
 GType gst_asteriskh263_get_type (void);
 
-gboolean gst_asteriskh263_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_ASTERISK_H263_H__ */
diff --git a/gst/rtp/gstrtp.c b/gst/rtp/gstrtp.c
index b2a6706e1..9528ffb10 100644
--- a/gst/rtp/gstrtp.c
+++ b/gst/rtp/gstrtp.c
@@ -23,397 +23,113 @@
 
 #include <gst/tag/tag.h>
 
-#include "gstrtputils.h"
+#include "gstrtpelements.h"
 
-#include "gstrtpac3depay.h"
-#include "gstrtpac3pay.h"
-#include "gstrtpbvdepay.h"
-#include "gstrtpbvpay.h"
-#include "gstrtpceltdepay.h"
-#include "gstrtpceltpay.h"
-#include "gstrtpdvdepay.h"
-#include "gstrtpdvpay.h"
-#include "gstrtpgstdepay.h"
-#include "gstrtpgstpay.h"
-#include "gstrtpilbcdepay.h"
-#include "gstrtpilbcpay.h"
-#include "gstrtppcmupay.h"
-#include "gstrtppcmapay.h"
-#include "gstrtppcmadepay.h"
-#include "gstrtppcmudepay.h"
-#include "gstrtpg722depay.h"
-#include "gstrtpg722pay.h"
-#include "gstrtpg723depay.h"
-#include "gstrtpg723pay.h"
-#include "gstrtpg726depay.h"
-#include "gstrtpg726pay.h"
-#include "gstrtpg729depay.h"
-#include "gstrtpg729pay.h"
-#include "gstrtpgsmpay.h"
-#include "gstrtpgsmdepay.h"
-#include "gstrtpamrpay.h"
-#include "gstrtpamrdepay.h"
-#include "gstrtpmpapay.h"
-#include "gstrtpmpadepay.h"
-#include "gstrtpmparobustdepay.h"
-#include "gstrtpmpvdepay.h"
-#include "gstrtpmpvpay.h"
-#include "gstrtpopusdepay.h"
-#include "gstrtpopuspay.h"
-#include "gstrtph261pay.h"
-#include "gstrtph261depay.h"
-#include "gstrtph263pdepay.h"
-#include "gstrtph263ppay.h"
-#include "gstrtph263depay.h"
-#include "gstrtph263pay.h"
-#include "gstrtph264depay.h"
-#include "gstrtph264pay.h"
-#include "gstrtph265depay.h"
-#include "gstrtph265pay.h"
-#include "gstrtpj2kdepay.h"
-#include "gstrtpj2kpay.h"
-#include "gstrtpjpegdepay.h"
-#include "gstrtpjpegpay.h"
-#include "gstrtpklvdepay.h"
-#include "gstrtpklvpay.h"
-#include "gstrtpL8depay.h"
-#include "gstrtpL8pay.h"
-#include "gstrtpL16depay.h"
-#include "gstrtpL16pay.h"
-#include "gstrtpL24depay.h"
-#include "gstrtpL24pay.h"
-#include "gstasteriskh263.h"
-#include "gstrtpmp1sdepay.h"
-#include "gstrtpmp2tdepay.h"
-#include "gstrtpmp2tpay.h"
-#include "gstrtpmp4vdepay.h"
-#include "gstrtpmp4vpay.h"
-#include "gstrtpmp4adepay.h"
-#include "gstrtpmp4apay.h"
-#include "gstrtpmp4gdepay.h"
-#include "gstrtpmp4gpay.h"
-#include "gstrtpqcelpdepay.h"
-#include "gstrtpqdmdepay.h"
-#include "gstrtpsbcdepay.h"
-#include "gstrtpsbcpay.h"
-#include "gstrtpsirenpay.h"
-#include "gstrtpsirendepay.h"
-#include "gstrtpspeexpay.h"
-#include "gstrtpspeexdepay.h"
-#include "gstrtpsv3vdepay.h"
-#include "gstrtptheoradepay.h"
-#include "gstrtptheorapay.h"
-#include "gstrtpvorbisdepay.h"
-#include "gstrtpvorbispay.h"
-#include "gstrtpvp8depay.h"
-#include "gstrtpvp8pay.h"
-#include "gstrtpvp9depay.h"
-#include "gstrtpvp9pay.h"
-#include "gstrtpvrawdepay.h"
-#include "gstrtpvrawpay.h"
-#include "gstrtpstreampay.h"
-#include "gstrtpstreamdepay.h"
-#include "gstrtpredenc.h"
-#include "gstrtpreddec.h"
-#include "gstrtpulpfecdec.h"
-#include "gstrtpulpfecenc.h"
-#include "gstrtpstorage.h"
 
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
-  gst_tag_image_type_get_type ();
-
-  rtp_quark_meta_tag_video =
-      g_quark_from_static_string (GST_META_TAG_VIDEO_STR);
-  rtp_quark_meta_tag_audio =
-      g_quark_from_static_string (GST_META_TAG_AUDIO_STR);
-
-  if (!gst_rtp_ac3_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_ac3_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_bv_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_bv_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_celt_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_celt_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_dv_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_dv_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_gst_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_gst_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_ilbc_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_ilbc_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g722_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g722_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g723_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g723_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g726_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g726_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g729_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_g729_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_gsm_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_gsm_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_amr_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_amr_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_pcma_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_pcmu_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_pcmu_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_pcma_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mpa_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mpa_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mpa_robust_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mpv_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mpv_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_opus_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_opus_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h261_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h261_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h263p_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h263p_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h263_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h263_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h264_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h264_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h265_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_h265_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_j2k_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_j2k_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_jpeg_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_jpeg_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_klv_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_klv_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_L8_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_L8_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_L16_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_L16_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_L24_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_L24_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_asteriskh263_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp1s_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp2t_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp2t_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp4v_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp4v_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp4a_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp4a_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp4g_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_mp4g_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_qcelp_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_qdm2_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_sbc_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_sbc_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_siren_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_siren_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_speex_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_speex_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_sv3v_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_theora_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_theora_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vorbis_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vorbis_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vp8_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vp8_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vp9_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vp9_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vraw_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_vraw_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_stream_pay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_stream_depay_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpredenc", GST_RANK_NONE,
-          GST_TYPE_RTP_RED_ENC))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpreddec", GST_RANK_NONE,
-          GST_TYPE_RTP_RED_DEC))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpulpfecdec", GST_RANK_NONE,
-          GST_TYPE_RTP_ULPFEC_DEC))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpulpfecenc", GST_RANK_NONE,
-          GST_TYPE_RTP_ULPFEC_ENC))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpstorage", GST_RANK_NONE,
-          GST_TYPE_RTP_STORAGE))
-    return FALSE;
-
-  return TRUE;
+  gboolean ret = FALSE;
+
+  ret |= GST_ELEMENT_REGISTER (rtpac3depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpac3pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpbvdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpbvpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpceltdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpceltpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpdvdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpdvpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpgstdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpgstpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpilbcpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpilbcdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg722depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg722pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg723depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg723pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg726depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg726pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg729depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpg729pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpgsmdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpgsmpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpamrdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpamrpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtppcmadepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtppcmudepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtppcmupay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtppcmapay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmpadepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmpapay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmparobustdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmpvdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmpvpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpopusdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpopuspay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph261pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph261depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph263ppay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph263pdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph263depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph263pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph264depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph264pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph265depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtph265pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpj2kdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpj2kpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpjpegdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpjpegpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpklvdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpklvpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpL8pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpL8depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpL16pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpL16depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpL24pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpL24depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpldacpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (asteriskh263, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp1sdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp2tdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp2tpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp4vpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp4vdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp4apay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp4adepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp4gdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmp4gpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpqcelpdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpqdm2depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpsbcdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpsbcpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpsirenpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpsirendepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpspeexpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpspeexdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpsv3vdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtptheoradepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtptheorapay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvorbisdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvorbispay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvp8depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvp8pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvp9depay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvp9pay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvrawdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpvrawpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpstreampay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpstreamdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpisacpay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpisacdepay, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpredenc, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpreddec, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpulpfecdec, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpulpfecenc, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpstorage, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtphdrextcolorspace, plugin);
+
+  return ret;
 }
 
 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
diff --git a/gst/rtp/gstrtpL16depay.c b/gst/rtp/gstrtpL16depay.c
index f054a2480..aa7e5d03d 100644
--- a/gst/rtp/gstrtpL16depay.c
+++ b/gst/rtp/gstrtpL16depay.c
@@ -42,6 +42,7 @@
 
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpL16depay.h"
 #include "gstrtpchannels.h"
 #include "gstrtputils.h"
@@ -81,6 +82,8 @@ static GstStaticPadTemplate gst_rtp_L16_depay_sink_template =
 
 #define gst_rtp_L16_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpL16Depay, gst_rtp_L16_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpL16depay, "rtpL16depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_L16_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_L16_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -291,10 +294,3 @@ reorder_failed:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_L16_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpL16depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_L16_DEPAY);
-}
diff --git a/gst/rtp/gstrtpL16depay.h b/gst/rtp/gstrtpL16depay.h
index 125d4cd53..fac933bb1 100644
--- a/gst/rtp/gstrtpL16depay.h
+++ b/gst/rtp/gstrtpL16depay.h
@@ -60,8 +60,6 @@ struct _GstRtpL16DepayClass
 
 GType gst_rtp_L16_depay_get_type (void);
 
-gboolean gst_rtp_L16_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_L16_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpL16pay.c b/gst/rtp/gstrtpL16pay.c
index 7e358d3d0..41a7c0544 100644
--- a/gst/rtp/gstrtpL16pay.c
+++ b/gst/rtp/gstrtpL16pay.c
@@ -42,6 +42,7 @@
 #include <gst/audio/audio.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpL16pay.h"
 #include "gstrtpchannels.h"
 
@@ -90,6 +91,8 @@ gst_rtp_L16_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
 #define gst_rtp_L16_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpL16Pay, gst_rtp_L16_pay, GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpL16pay, "rtpL16pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_L16_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_L16_pay_class_init (GstRtpL16PayClass * klass)
@@ -254,10 +257,3 @@ gst_rtp_L16_pay_handle_buffer (GstRTPBasePayload * basepayload,
   return GST_RTP_BASE_PAYLOAD_CLASS (parent_class)->handle_buffer (basepayload,
       buffer);
 }
-
-gboolean
-gst_rtp_L16_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpL16pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_L16_PAY);
-}
diff --git a/gst/rtp/gstrtpL16pay.h b/gst/rtp/gstrtpL16pay.h
index f4f3702e1..b3078db05 100644
--- a/gst/rtp/gstrtpL16pay.h
+++ b/gst/rtp/gstrtpL16pay.h
@@ -56,8 +56,6 @@ struct _GstRtpL16PayClass
 
 GType gst_rtp_L16_pay_get_type (void);
 
-gboolean gst_rtp_L16_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_L16_PAY_H__ */
diff --git a/gst/rtp/gstrtpL24depay.c b/gst/rtp/gstrtpL24depay.c
index 448dac022..e39fe7c2f 100644
--- a/gst/rtp/gstrtpL24depay.c
+++ b/gst/rtp/gstrtpL24depay.c
@@ -42,6 +42,7 @@
 
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpL24depay.h"
 #include "gstrtpchannels.h"
 #include "gstrtputils.h"
@@ -70,6 +71,8 @@ GST_STATIC_PAD_TEMPLATE ("sink",
 
 #define gst_rtp_L24_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpL24Depay, gst_rtp_L24_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpL24depay, "rtpL24depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_L24_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_L24_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -256,10 +259,3 @@ reorder_failed:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_L24_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpL24depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_L24_DEPAY);
-}
diff --git a/gst/rtp/gstrtpL24depay.h b/gst/rtp/gstrtpL24depay.h
index c4e00e6f2..411adf910 100644
--- a/gst/rtp/gstrtpL24depay.h
+++ b/gst/rtp/gstrtpL24depay.h
@@ -60,8 +60,6 @@ struct _GstRtpL24DepayClass
 
 GType gst_rtp_L24_depay_get_type (void);
 
-gboolean gst_rtp_L24_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_L24_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpL24pay.c b/gst/rtp/gstrtpL24pay.c
index d2ad72535..aa8fc2273 100644
--- a/gst/rtp/gstrtpL24pay.c
+++ b/gst/rtp/gstrtpL24pay.c
@@ -42,6 +42,7 @@
 #include <gst/audio/audio.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpL24pay.h"
 #include "gstrtpchannels.h"
 
@@ -79,6 +80,8 @@ gst_rtp_L24_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
 #define gst_rtp_L24_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpL24Pay, gst_rtp_L24_pay, GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpL24pay, "rtpL24pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_L24_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_L24_pay_class_init (GstRtpL24PayClass * klass)
@@ -235,10 +238,3 @@ gst_rtp_L24_pay_handle_buffer (GstRTPBasePayload * basepayload,
   return GST_RTP_BASE_PAYLOAD_CLASS (parent_class)->handle_buffer (basepayload,
       buffer);
 }
-
-gboolean
-gst_rtp_L24_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpL24pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_L24_PAY);
-}
diff --git a/gst/rtp/gstrtpL24pay.h b/gst/rtp/gstrtpL24pay.h
index 47395ad16..4dd64dbef 100644
--- a/gst/rtp/gstrtpL24pay.h
+++ b/gst/rtp/gstrtpL24pay.h
@@ -56,8 +56,6 @@ struct _GstRtpL24PayClass
 
 GType gst_rtp_L24_pay_get_type (void);
 
-gboolean gst_rtp_L24_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_L24_PAY_H__ */
diff --git a/gst/rtp/gstrtpL8depay.c b/gst/rtp/gstrtpL8depay.c
index 121a749af..f1c0fe302 100644
--- a/gst/rtp/gstrtpL8depay.c
+++ b/gst/rtp/gstrtpL8depay.c
@@ -42,6 +42,7 @@
 
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpL8depay.h"
 #include "gstrtpchannels.h"
 
@@ -73,6 +74,10 @@ static GstStaticPadTemplate gst_rtp_L8_depay_sink_template =
 #define gst_rtp_L8_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpL8Depay, gst_rtp_L8_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
 
+
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpL8depay, "rtpL8depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_L8_DEPAY, rtp_element_init (plugin));
+
 static gboolean gst_rtp_L8_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
 static GstBuffer *gst_rtp_L8_depay_process (GstRTPBaseDepayload * depayload,
@@ -258,10 +263,3 @@ reorder_failed:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_L8_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpL8depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_L8_DEPAY);
-}
diff --git a/gst/rtp/gstrtpL8depay.h b/gst/rtp/gstrtpL8depay.h
index a2d9bec59..589e9fb27 100644
--- a/gst/rtp/gstrtpL8depay.h
+++ b/gst/rtp/gstrtpL8depay.h
@@ -58,8 +58,6 @@ struct _GstRtpL8DepayClass
 
 GType gst_rtp_L8_depay_get_type (void);
 
-gboolean gst_rtp_L8_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_L8_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpL8pay.c b/gst/rtp/gstrtpL8pay.c
index 6662cda91..b7a39e89f 100644
--- a/gst/rtp/gstrtpL8pay.c
+++ b/gst/rtp/gstrtpL8pay.c
@@ -42,6 +42,7 @@
 #include <gst/audio/audio.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpL8pay.h"
 #include "gstrtpchannels.h"
 
@@ -80,6 +81,10 @@ gst_rtp_L8_pay_handle_buffer (GstRTPBasePayload * basepayload,
 #define gst_rtp_L8_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpL8Pay, gst_rtp_L8_pay, GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
 
+
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpL8pay, "rtpL8pay", GST_RANK_SECONDARY,
+    GST_TYPE_RTP_L8_PAY, rtp_element_init (plugin));
+
 static void
 gst_rtp_L8_pay_class_init (GstRtpL8PayClass * klass)
 {
@@ -234,10 +239,3 @@ gst_rtp_L8_pay_handle_buffer (GstRTPBasePayload * basepayload,
   return GST_RTP_BASE_PAYLOAD_CLASS (parent_class)->handle_buffer (basepayload,
       buffer);
 }
-
-gboolean
-gst_rtp_L8_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpL8pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_L8_PAY);
-}
diff --git a/gst/rtp/gstrtpL8pay.h b/gst/rtp/gstrtpL8pay.h
index 183eb2fcf..bebd724f7 100644
--- a/gst/rtp/gstrtpL8pay.h
+++ b/gst/rtp/gstrtpL8pay.h
@@ -57,8 +57,6 @@ struct _GstRtpL8PayClass
 
 GType gst_rtp_L8_pay_get_type (void);
 
-gboolean gst_rtp_L8_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_L8_PAY_H__ */
diff --git a/gst/rtp/gstrtpac3depay.c b/gst/rtp/gstrtpac3depay.c
index 54339f343..68c23e276 100644
--- a/gst/rtp/gstrtpac3depay.c
+++ b/gst/rtp/gstrtpac3depay.c
@@ -41,6 +41,7 @@
 #include <gst/audio/audio.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpac3depay.h"
 #include "gstrtputils.h"
 
@@ -65,6 +66,8 @@ GST_STATIC_PAD_TEMPLATE ("sink",
     );
 
 G_DEFINE_TYPE (GstRtpAC3Depay, gst_rtp_ac3_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpac3depay, "rtpac3depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_AC3_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_ac3_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -171,10 +174,3 @@ empty_packet:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_ac3_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpac3depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_AC3_DEPAY);
-}
diff --git a/gst/rtp/gstrtpac3depay.h b/gst/rtp/gstrtpac3depay.h
index 294bb12c4..62478f9c8 100644
--- a/gst/rtp/gstrtpac3depay.h
+++ b/gst/rtp/gstrtpac3depay.h
@@ -51,8 +51,6 @@ struct _GstRtpAC3DepayClass
 
 GType gst_rtp_ac3_depay_get_type (void);
 
-gboolean gst_rtp_ac3_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_AC3_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpac3pay.c b/gst/rtp/gstrtpac3pay.c
index 1feccedf4..478c4a378 100644
--- a/gst/rtp/gstrtpac3pay.c
+++ b/gst/rtp/gstrtpac3pay.c
@@ -42,6 +42,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpac3pay.h"
 #include "gstrtputils.h"
 
@@ -81,6 +82,8 @@ static GstFlowReturn gst_rtp_ac3_pay_handle_buffer (GstRTPBasePayload * payload,
 
 #define gst_rtp_ac3_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpAC3Pay, gst_rtp_ac3_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpac3pay, "rtpac3pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_AC3_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_ac3_pay_class_init (GstRtpAC3PayClass * klass)
@@ -319,8 +322,10 @@ gst_rtp_ac3_pay_flush (GstRtpAC3Pay * rtpac3pay)
     payload[1] = NF;
     payload_len -= 2;
 
-    if (avail == payload_len)
+    if (avail == payload_len) {
       gst_rtp_buffer_set_marker (&rtp, TRUE);
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
+    }
     gst_rtp_buffer_unmap (&rtp);
 
     payload_buffer =
@@ -470,10 +475,3 @@ gst_rtp_ac3_pay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-gboolean
-gst_rtp_ac3_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpac3pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_AC3_PAY);
-}
diff --git a/gst/rtp/gstrtpac3pay.h b/gst/rtp/gstrtpac3pay.h
index c131eac13..918a250e4 100644
--- a/gst/rtp/gstrtpac3pay.h
+++ b/gst/rtp/gstrtpac3pay.h
@@ -57,8 +57,6 @@ struct _GstRtpAC3PayClass
 
 GType gst_rtp_ac3_pay_get_type (void);
 
-gboolean gst_rtp_ac3_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_AC3_PAY_H__ */
diff --git a/gst/rtp/gstrtpamrdepay.c b/gst/rtp/gstrtpamrdepay.c
index de0275801..08e64e518 100644
--- a/gst/rtp/gstrtpamrdepay.c
+++ b/gst/rtp/gstrtpamrdepay.c
@@ -48,6 +48,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpamrdepay.h"
 #include "gstrtputils.h"
 
@@ -130,6 +131,8 @@ static GstBuffer *gst_rtp_amr_depay_process (GstRTPBaseDepayload * depayload,
 
 #define gst_rtp_amr_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpAMRDepay, gst_rtp_amr_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpamrdepay, "rtpamrdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_AMR_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_amr_depay_class_init (GstRtpAMRDepayClass * klass)
@@ -469,10 +472,3 @@ bad_packet:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_amr_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpamrdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_AMR_DEPAY);
-}
diff --git a/gst/rtp/gstrtpamrdepay.h b/gst/rtp/gstrtpamrdepay.h
index 0b806345d..b1ebe4f8f 100644
--- a/gst/rtp/gstrtpamrdepay.h
+++ b/gst/rtp/gstrtpamrdepay.h
@@ -70,8 +70,6 @@ struct _GstRtpAMRDepayClass
 
 GType gst_rtp_amr_depay_get_type (void);
 
-gboolean gst_rtp_amr_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_AMR_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpamrpay.c b/gst/rtp/gstrtpamrpay.c
index 828a7189f..147348555 100644
--- a/gst/rtp/gstrtpamrpay.c
+++ b/gst/rtp/gstrtpamrpay.c
@@ -55,6 +55,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpamrpay.h"
 #include "gstrtputils.h"
 
@@ -113,6 +114,8 @@ gst_rtp_amr_pay_change_state (GstElement * element, GstStateChange transition);
 
 #define gst_rtp_amr_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpAMRPay, gst_rtp_amr_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpamrpay, "rtpamrpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_AMR_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_amr_pay_class_init (GstRtpAMRPayClass * klass)
@@ -330,6 +333,7 @@ gst_rtp_amr_pay_handle_buffer (GstRTPBasePayload * basepayload,
   if (GST_BUFFER_IS_DISCONT (buffer)) {
     GST_DEBUG_OBJECT (basepayload, "discont, setting marker bit");
     GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DISCONT);
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
     gst_rtp_buffer_set_marker (&rtp, TRUE);
     gst_rtp_amr_pay_recalc_rtp_time (rtpamrpay, timestamp);
   }
@@ -456,10 +460,3 @@ gst_rtp_amr_pay_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-gboolean
-gst_rtp_amr_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpamrpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_AMR_PAY);
-}
diff --git a/gst/rtp/gstrtpamrpay.h b/gst/rtp/gstrtpamrpay.h
index a3df1ce63..b6e21483e 100644
--- a/gst/rtp/gstrtpamrpay.h
+++ b/gst/rtp/gstrtpamrpay.h
@@ -63,8 +63,6 @@ struct _GstRtpAMRPayClass
 
 GType gst_rtp_amr_pay_get_type (void);
 
-gboolean gst_rtp_amr_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_AMR_PAY_H__ */
diff --git a/gst/rtp/gstrtpbvdepay.c b/gst/rtp/gstrtpbvdepay.c
index 625bb3731..98cff92fd 100644
--- a/gst/rtp/gstrtpbvdepay.c
+++ b/gst/rtp/gstrtpbvdepay.c
@@ -35,6 +35,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpbvdepay.h"
 #include "gstrtputils.h"
 
@@ -65,6 +66,8 @@ static gboolean gst_rtp_bv_depay_setcaps (GstRTPBaseDepayload * depayload,
 
 #define gst_rtp_bv_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPBVDepay, gst_rtp_bv_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpbvdepay, "rtpbvdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_BV_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_bv_depay_class_init (GstRTPBVDepayClass * klass)
@@ -182,10 +185,3 @@ gst_rtp_bv_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_bv_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpbvdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_BV_DEPAY);
-}
diff --git a/gst/rtp/gstrtpbvdepay.h b/gst/rtp/gstrtpbvdepay.h
index f130682c0..9a9ea7c40 100644
--- a/gst/rtp/gstrtpbvdepay.h
+++ b/gst/rtp/gstrtpbvdepay.h
@@ -53,8 +53,6 @@ struct _GstRTPBVDepayClass
 
 GType gst_rtp_bv_depay_get_type (void);
 
-gboolean gst_rtp_bv_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_BV_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpbvpay.c b/gst/rtp/gstrtpbvpay.c
index a396d2642..a70f3c237 100644
--- a/gst/rtp/gstrtpbvpay.c
+++ b/gst/rtp/gstrtpbvpay.c
@@ -34,6 +34,7 @@
 #include <string.h>
 
 #include <gst/rtp/gstrtpbuffer.h>
+#include "gstrtpelements.h"
 #include "gstrtpbvpay.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpbvpay_debug);
@@ -69,6 +70,8 @@ static gboolean gst_rtp_bv_pay_sink_setcaps (GstRTPBasePayload * payload,
 
 #define gst_rtp_bv_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPBVPay, gst_rtp_bv_pay, GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpbvpay, "rtpbvpay", GST_RANK_SECONDARY,
+    GST_TYPE_RTP_BV_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_bv_pay_class_init (GstRTPBVPayClass * klass)
@@ -231,10 +234,3 @@ gst_rtp_bv_pay_sink_getcaps (GstRTPBasePayload * rtppayload, GstPad * pad,
 
   return caps;
 }
-
-gboolean
-gst_rtp_bv_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpbvpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_BV_PAY);
-}
diff --git a/gst/rtp/gstrtpbvpay.h b/gst/rtp/gstrtpbvpay.h
index 09766ccaa..afb3485b9 100644
--- a/gst/rtp/gstrtpbvpay.h
+++ b/gst/rtp/gstrtpbvpay.h
@@ -53,8 +53,6 @@ struct _GstRTPBVPayClass
 
 GType gst_rtp_bv_pay_get_type (void);
 
-gboolean gst_rtp_bv_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_BV_PAY_H__ */
diff --git a/gst/rtp/gstrtpceltdepay.c b/gst/rtp/gstrtpceltdepay.c
index 97c17f013..9054af7c6 100644
--- a/gst/rtp/gstrtpceltdepay.c
+++ b/gst/rtp/gstrtpceltdepay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpceltdepay.h"
 #include "gstrtputils.h"
 
@@ -74,7 +75,8 @@ static gboolean gst_rtp_celt_depay_setcaps (GstRTPBaseDepayload * depayload,
 #define gst_rtp_celt_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpCELTDepay, gst_rtp_celt_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
-
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpceltdepay, "rtpceltdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_CELT_DEPAY, rtp_element_init (plugin));
 static void
 gst_rtp_celt_depay_class_init (GstRtpCELTDepayClass * klass)
 {
@@ -267,10 +269,3 @@ gst_rtp_celt_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
 
   return NULL;
 }
-
-gboolean
-gst_rtp_celt_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpceltdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_CELT_DEPAY);
-}
diff --git a/gst/rtp/gstrtpceltdepay.h b/gst/rtp/gstrtpceltdepay.h
index 0905c681d..eb4bc3099 100644
--- a/gst/rtp/gstrtpceltdepay.h
+++ b/gst/rtp/gstrtpceltdepay.h
@@ -47,8 +47,6 @@ struct _GstRtpCELTDepayClass
 
 GType gst_rtp_celt_depay_get_type (void);
 
-gboolean gst_rtp_celt_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_CELT_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpceltpay.c b/gst/rtp/gstrtpceltpay.c
index a29d23b17..18ef55640 100644
--- a/gst/rtp/gstrtpceltpay.c
+++ b/gst/rtp/gstrtpceltpay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpceltpay.h"
 #include "gstrtputils.h"
 
@@ -66,6 +67,8 @@ static GstFlowReturn gst_rtp_celt_pay_handle_buffer (GstRTPBasePayload *
 
 #define gst_rtp_celt_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpCELTPay, gst_rtp_celt_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpceltpay, "rtpceltpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_CELT_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_celt_pay_class_init (GstRtpCELTPayClass * klass)
@@ -495,10 +498,3 @@ gst_rtp_celt_pay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-gboolean
-gst_rtp_celt_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpceltpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_CELT_PAY);
-}
diff --git a/gst/rtp/gstrtpceltpay.h b/gst/rtp/gstrtpceltpay.h
index dcdd0ecc5..452c12452 100644
--- a/gst/rtp/gstrtpceltpay.h
+++ b/gst/rtp/gstrtpceltpay.h
@@ -55,8 +55,6 @@ struct _GstRtpCELTPayClass
 
 GType gst_rtp_celt_pay_get_type (void);
 
-gboolean gst_rtp_celt_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_CELT_PAY_H__ */
diff --git a/gst/rtp/gstrtpdvdepay.c b/gst/rtp/gstrtpdvdepay.c
index 12297f004..6558dddd1 100644
--- a/gst/rtp/gstrtpdvdepay.c
+++ b/gst/rtp/gstrtpdvdepay.c
@@ -33,6 +33,8 @@
 #include <gst/gst.h>
 
 #include "gstrtpdvdepay.h"
+
+#include "gstrtpelements.h"
 #include "gstrtputils.h"
 
 GST_DEBUG_CATEGORY (rtpdvdepay_debug);
@@ -82,7 +84,8 @@ static gboolean gst_rtp_dv_depay_setcaps (GstRTPBaseDepayload * depayload,
 
 #define gst_rtp_dv_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPDVDepay, gst_rtp_dv_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
-
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpdvdepay, "rtpdvdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_DV_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_dv_depay_class_init (GstRTPDVDepayClass * klass)
@@ -416,10 +419,3 @@ gst_rtp_dv_depay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-gboolean
-gst_rtp_dv_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpdvdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_DV_DEPAY);
-}
diff --git a/gst/rtp/gstrtpdvdepay.h b/gst/rtp/gstrtpdvdepay.h
index 1ce5b9715..3cd921460 100644
--- a/gst/rtp/gstrtpdvdepay.h
+++ b/gst/rtp/gstrtpdvdepay.h
@@ -59,8 +59,6 @@ struct _GstRTPDVDepayClass
 
 GType gst_rtp_dv_depay_get_type (void);
 
-gboolean gst_rtp_dv_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GSTRTPDVDEPAY_H__ */
diff --git a/gst/rtp/gstrtpdvpay.c b/gst/rtp/gstrtpdvpay.c
index 540d68566..24bb9b41c 100644
--- a/gst/rtp/gstrtpdvpay.c
+++ b/gst/rtp/gstrtpdvpay.c
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpdvpay.h"
 #include "gstrtputils.h"
 
@@ -97,6 +98,8 @@ static void gst_dv_pay_get_property (GObject * object,
 
 #define gst_rtp_dv_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPDVPay, gst_rtp_dv_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpdvpay, "rtpdvpay", GST_RANK_SECONDARY,
+    GST_TYPE_RTP_DV_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_dv_pay_class_init (GstRTPDVPayClass * klass)
@@ -332,7 +335,9 @@ gst_rtp_dv_pay_handle_buffer (GstRTPBasePayload * basepayload,
   while (size >= 80) {
     /* Allocate a new buffer, set the timestamp */
     if (outbuf == NULL) {
-      outbuf = gst_rtp_buffer_new_allocate (max_payload_size, 0, 0);
+      outbuf =
+          gst_rtp_base_payload_allocate_output_buffer (basepayload,
+          max_payload_size, 0, 0);
       GST_BUFFER_PTS (outbuf) = GST_BUFFER_PTS (buffer);
 
       if (!gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp)) {
@@ -367,6 +372,7 @@ gst_rtp_dv_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
         /* set marker */
         gst_rtp_buffer_set_marker (&rtp, TRUE);
+        GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
 
         /* shrink buffer to last packet */
         hlen = gst_rtp_buffer_get_header_len (&rtp);
@@ -390,10 +396,3 @@ beach:
 
   return ret;
 }
-
-gboolean
-gst_rtp_dv_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpdvpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_DV_PAY);
-}
diff --git a/gst/rtp/gstrtpdvpay.h b/gst/rtp/gstrtpdvpay.h
index 4c250a840..def525b2c 100644
--- a/gst/rtp/gstrtpdvpay.h
+++ b/gst/rtp/gstrtpdvpay.h
@@ -62,8 +62,6 @@ struct _GstRTPDVPayClass
 
 GType gst_rtp_dv_pay_get_type (void);
 
-gboolean gst_rtp_dv_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GSTRTPDVPAY_H__ */
diff --git a/gst/rtp/gstrtpelement.c b/gst/rtp/gstrtpelement.c
new file mode 100644
index 000000000..cd6d883b0
--- /dev/null
+++ b/gst/rtp/gstrtpelement.c
@@ -0,0 +1,46 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ * Copyright (C) 2020 Huawei Technologies Co., Ltd.
+ *   @Author: Julian Bouzas <julian.bouzas@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/tag/tag.h>
+#include <gst/video/video.h>
+#include <gst/audio/audio.h>
+
+#include "gstrtpelements.h"
+#include "gstrtputils.h"
+
+
+void
+rtp_element_init (GstPlugin * plugin)
+{
+  static gsize res = FALSE;
+  if (g_once_init_enter (&res)) {
+    gst_tag_image_type_get_type ();
+    rtp_quark_meta_tag_video =
+        g_quark_from_static_string (GST_META_TAG_VIDEO_STR);
+    rtp_quark_meta_tag_audio =
+        g_quark_from_static_string (GST_META_TAG_AUDIO_STR);
+    g_once_init_leave (&res, TRUE);
+  }
+}
diff --git a/gst/rtp/gstrtpelements.h b/gst/rtp/gstrtpelements.h
new file mode 100644
index 000000000..9321d3530
--- /dev/null
+++ b/gst/rtp/gstrtpelements.h
@@ -0,0 +1,134 @@
+/* GStreamer
+ * Copyright (C) <1999> Erik Walthinsen <omega@cse.ogi.edu>
+ * Copyright (C) 2020 Huawei Technologies Co., Ltd.
+ *   @Author: Julian Bouzas <julian.bouzas@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the Free
+ * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_RTP_ELEMENTS_H__
+#define __GST_RTP_ELEMENTS_H__
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+void rtp_element_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (rtpac3depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpac3pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpbvdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpbvpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpceltdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpceltpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpdvdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpdvpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpgstdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpgstpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpilbcpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpilbcdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg722depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg722pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg723depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg723pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg726depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg726pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg729depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpg729pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpgsmdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpgsmpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpamrdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpamrpay);
+GST_ELEMENT_REGISTER_DECLARE (rtppcmadepay);
+GST_ELEMENT_REGISTER_DECLARE (rtppcmudepay);
+GST_ELEMENT_REGISTER_DECLARE (rtppcmupay);
+GST_ELEMENT_REGISTER_DECLARE (rtppcmapay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmpadepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmpapay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmparobustdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmpvdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmpvpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpopusdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpopuspay);
+GST_ELEMENT_REGISTER_DECLARE (rtph261pay);
+GST_ELEMENT_REGISTER_DECLARE (rtph261depay);
+GST_ELEMENT_REGISTER_DECLARE (rtph263ppay);
+GST_ELEMENT_REGISTER_DECLARE (rtph263pdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtph263depay);
+GST_ELEMENT_REGISTER_DECLARE (rtph263pay);
+GST_ELEMENT_REGISTER_DECLARE (rtph264depay);
+GST_ELEMENT_REGISTER_DECLARE (rtph264pay);
+GST_ELEMENT_REGISTER_DECLARE (rtph265depay);
+GST_ELEMENT_REGISTER_DECLARE (rtph265pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpj2kdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpj2kpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpjpegdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpjpegpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpklvdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpklvpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpL8pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpL8depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpL16pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpL16depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpL24pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpL24depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpldacpay);
+GST_ELEMENT_REGISTER_DECLARE (asteriskh263);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp1sdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp2tdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp2tpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp4vpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp4vdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp4apay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp4adepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp4gdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpmp4gpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpqcelpdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpqdm2depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpsbcdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpsbcpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpsirenpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpsirendepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpspeexpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpspeexdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpsv3vdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtptheoradepay);
+GST_ELEMENT_REGISTER_DECLARE (rtptheorapay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvorbisdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvorbispay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvp8depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvp8pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvp9depay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvp9pay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvrawdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpvrawpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpstreampay);
+GST_ELEMENT_REGISTER_DECLARE (rtpstreamdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpisacpay);
+GST_ELEMENT_REGISTER_DECLARE (rtpisacdepay);
+GST_ELEMENT_REGISTER_DECLARE (rtpredenc);
+GST_ELEMENT_REGISTER_DECLARE (rtpreddec);
+GST_ELEMENT_REGISTER_DECLARE (rtpulpfecdec);
+GST_ELEMENT_REGISTER_DECLARE (rtpulpfecenc);
+GST_ELEMENT_REGISTER_DECLARE (rtpstorage);
+GST_ELEMENT_REGISTER_DECLARE (rtphdrextcolorspace);
+
+G_END_DECLS
+
+#endif /* __GST_RTP_ELEMENTS_H__ */
diff --git a/gst/rtp/gstrtpg722depay.c b/gst/rtp/gstrtpg722depay.c
index 5a25eef52..060c7e1c8 100644
--- a/gst/rtp/gstrtpg722depay.c
+++ b/gst/rtp/gstrtpg722depay.c
@@ -26,6 +26,7 @@
 
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpg722depay.h"
 #include "gstrtpchannels.h"
 #include "gstrtputils.h"
@@ -63,6 +64,8 @@ static GstStaticPadTemplate gst_rtp_g722_depay_sink_template =
 #define gst_rtp_g722_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpG722Depay, gst_rtp_g722_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg722depay, "rtpg722depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G722_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_g722_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -253,10 +256,3 @@ empty_packet:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_g722_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg722depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_G722_DEPAY);
-}
diff --git a/gst/rtp/gstrtpg722depay.h b/gst/rtp/gstrtpg722depay.h
index 8b6ffa046..2acdf28b2 100644
--- a/gst/rtp/gstrtpg722depay.h
+++ b/gst/rtp/gstrtpg722depay.h
@@ -57,8 +57,6 @@ struct _GstRtpG722DepayClass
 
 GType gst_rtp_g722_depay_get_type (void);
 
-gboolean gst_rtp_g722_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_G722_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpg722pay.c b/gst/rtp/gstrtpg722pay.c
index a383e0120..8afc2ebe0 100644
--- a/gst/rtp/gstrtpg722pay.c
+++ b/gst/rtp/gstrtpg722pay.c
@@ -26,6 +26,7 @@
 #include <gst/audio/audio.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpg722pay.h"
 #include "gstrtpchannels.h"
 
@@ -64,6 +65,8 @@ static GstCaps *gst_rtp_g722_pay_getcaps (GstRTPBasePayload * rtppayload,
 #define gst_rtp_g722_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpG722Pay, gst_rtp_g722_pay,
     GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg722pay, "rtpg722pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G722_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_g722_pay_class_init (GstRtpG722PayClass * klass)
@@ -227,10 +230,3 @@ gst_rtp_g722_pay_getcaps (GstRTPBasePayload * rtppayload, GstPad * pad,
 
   return caps;
 }
-
-gboolean
-gst_rtp_g722_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg722pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_G722_PAY);
-}
diff --git a/gst/rtp/gstrtpg722pay.h b/gst/rtp/gstrtpg722pay.h
index f238286ea..1211ca0a0 100644
--- a/gst/rtp/gstrtpg722pay.h
+++ b/gst/rtp/gstrtpg722pay.h
@@ -54,8 +54,6 @@ struct _GstRtpG722PayClass
 
 GType gst_rtp_g722_pay_get_type (void);
 
-gboolean gst_rtp_g722_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_G722_PAY_H__ */
diff --git a/gst/rtp/gstrtpg723depay.c b/gst/rtp/gstrtpg723depay.c
index 901d9ae06..e4f416ea2 100644
--- a/gst/rtp/gstrtpg723depay.c
+++ b/gst/rtp/gstrtpg723depay.c
@@ -26,6 +26,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpg723depay.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpg723depay_debug);
@@ -80,6 +81,8 @@ static GstBuffer *gst_rtp_g723_depay_process (GstRTPBaseDepayload * depayload,
 #define gst_rtp_g723_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpG723Depay, gst_rtp_g723_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg723depay, "rtpg723depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G723_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_g723_depay_class_init (GstRtpG723DepayClass * klass)
@@ -214,10 +217,3 @@ bad_packet:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_g723_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg723depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_G723_DEPAY);
-}
diff --git a/gst/rtp/gstrtpg723depay.h b/gst/rtp/gstrtpg723depay.h
index dd942b3b6..673a13766 100644
--- a/gst/rtp/gstrtpg723depay.h
+++ b/gst/rtp/gstrtpg723depay.h
@@ -52,8 +52,6 @@ struct _GstRtpG723DepayClass
 
 GType gst_rtp_g723_depay_get_type (void);
 
-gboolean gst_rtp_g723_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_G723_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpg723pay.c b/gst/rtp/gstrtpg723pay.c
index 18e294a3f..0c5fd1bdd 100644
--- a/gst/rtp/gstrtpg723pay.c
+++ b/gst/rtp/gstrtpg723pay.c
@@ -28,6 +28,7 @@
 #include <gst/base/gstadapter.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpg723pay.h"
 #include "gstrtputils.h"
 
@@ -68,6 +69,8 @@ static GstStateChangeReturn gst_rtp_g723_pay_change_state (GstElement * element,
 
 #define gst_rtp_g723_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPG723Pay, gst_rtp_g723_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg723pay, "rtpg723pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G723_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_g723_pay_class_init (GstRTPG723PayClass * klass)
@@ -161,6 +164,7 @@ gst_rtp_g723_pay_flush (GstRTPG723Pay * pay)
   /* set discont and marker */
   if (pay->discont) {
     GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DISCONT);
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
     gst_rtp_buffer_set_marker (&rtp, TRUE);
     pay->discont = FALSE;
   }
@@ -298,11 +302,3 @@ gst_rtp_g723_pay_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-/*Plugin init functions*/
-gboolean
-gst_rtp_g723_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg723pay", GST_RANK_SECONDARY,
-      gst_rtp_g723_pay_get_type ());
-}
diff --git a/gst/rtp/gstrtpg723pay.h b/gst/rtp/gstrtpg723pay.h
index 37807412a..03bff5002 100644
--- a/gst/rtp/gstrtpg723pay.h
+++ b/gst/rtp/gstrtpg723pay.h
@@ -57,8 +57,6 @@ struct _GstRTPG723PayClass
 
 GType gst_rtp_g723_pay_get_type (void);
 
-gboolean gst_rtp_g723_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_G723_PAY_H__ */
diff --git a/gst/rtp/gstrtpg726depay.c b/gst/rtp/gstrtpg726depay.c
index 7af1928aa..d4bdc4f27 100644
--- a/gst/rtp/gstrtpg726depay.c
+++ b/gst/rtp/gstrtpg726depay.c
@@ -30,6 +30,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpg726depay.h"
 #include "gstrtputils.h"
 
@@ -91,6 +92,8 @@ static gboolean gst_rtp_g726_depay_setcaps (GstRTPBaseDepayload * depayload,
 #define gst_rtp_g726_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpG726Depay, gst_rtp_g726_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg726depay, "rtpg726depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G726_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_g726_depay_class_init (GstRtpG726DepayClass * klass)
@@ -282,7 +285,7 @@ gst_rtp_g726_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
               ((tmp & 0x1c) << 1) | ((tmp & 0x03) << 6);
           tmp = *in++;
           *out++ = ((tmp & 0x80) >> 7) |
-              ((tmp & 0x70) >> 3) | ((tmp & 0x0e) << 4) | ((tmp & 0x01) << 7);
+              ((tmp & 0x70) >> 3) | ((tmp & 0x0e) << 3) | ((tmp & 0x01) << 7);
           tmp = *in++;
           *out++ = ((tmp & 0xc0) >> 6) |
               ((tmp & 0x38) >> 1) | ((tmp & 0x07) << 5);
@@ -384,10 +387,3 @@ gst_rtp_g726_depay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_g726_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg726depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_G726_DEPAY);
-}
diff --git a/gst/rtp/gstrtpg726depay.h b/gst/rtp/gstrtpg726depay.h
index 45fd2edbd..04ceec2f8 100644
--- a/gst/rtp/gstrtpg726depay.h
+++ b/gst/rtp/gstrtpg726depay.h
@@ -52,7 +52,5 @@ struct _GstRtpG726DepayClass
 
 GType gst_rtp_g726_depay_get_type (void);
 
-gboolean gst_rtp_g726_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_G726_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpg726pay.c b/gst/rtp/gstrtpg726pay.c
index d251b4995..76dad4053 100644
--- a/gst/rtp/gstrtpg726pay.c
+++ b/gst/rtp/gstrtpg726pay.c
@@ -28,6 +28,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpg726pay.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpg726pay_debug);
@@ -77,6 +78,8 @@ static GstFlowReturn gst_rtp_g726_pay_handle_buffer (GstRTPBasePayload *
 #define gst_rtp_g726_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpG726Pay, gst_rtp_g726_pay,
     GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg726pay, "rtpg726pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G726_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_g726_pay_class_init (GstRtpG726PayClass * klass)
@@ -413,10 +416,3 @@ gst_rtp_g726_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_g726_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg726pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_G726_PAY);
-}
diff --git a/gst/rtp/gstrtpg726pay.h b/gst/rtp/gstrtpg726pay.h
index d9dbfa436..fd3078c2f 100644
--- a/gst/rtp/gstrtpg726pay.h
+++ b/gst/rtp/gstrtpg726pay.h
@@ -49,7 +49,5 @@ struct _GstRtpG726PayClass
 
 GType gst_rtp_g726_pay_get_type (void);
 
-gboolean gst_rtp_g726_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_G726_PAY_H__ */
diff --git a/gst/rtp/gstrtpg729depay.c b/gst/rtp/gstrtpg729depay.c
index 69c1c4dfc..0fb0bcd13 100644
--- a/gst/rtp/gstrtpg729depay.c
+++ b/gst/rtp/gstrtpg729depay.c
@@ -25,6 +25,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpg729depay.h"
 #include "gstrtputils.h"
 
@@ -80,6 +81,8 @@ static GstBuffer *gst_rtp_g729_depay_process (GstRTPBaseDepayload * depayload,
 #define gst_rtp_g729_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpG729Depay, gst_rtp_g729_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg729depay, "rtpg729depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G729_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_g729_depay_class_init (GstRtpG729DepayClass * klass)
@@ -216,10 +219,3 @@ bad_packet:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_g729_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg729depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_G729_DEPAY);
-}
diff --git a/gst/rtp/gstrtpg729depay.h b/gst/rtp/gstrtpg729depay.h
index a23562e56..355ee5068 100644
--- a/gst/rtp/gstrtpg729depay.h
+++ b/gst/rtp/gstrtpg729depay.h
@@ -54,8 +54,6 @@ struct _GstRtpG729DepayClass
 
 GType gst_rtp_g729_depay_get_type (void);
 
-gboolean gst_rtp_g729_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_G729_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpg729pay.c b/gst/rtp/gstrtpg729pay.c
index 78097805e..bc158c1f8 100644
--- a/gst/rtp/gstrtpg729pay.c
+++ b/gst/rtp/gstrtpg729pay.c
@@ -34,6 +34,7 @@
 #include <gst/base/gstadapter.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpg729pay.h"
 #include "gstrtputils.h"
 
@@ -78,6 +79,8 @@ static GstStaticPadTemplate gst_rtp_g729_pay_src_template =
 
 #define gst_rtp_g729_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPG729Pay, gst_rtp_g729_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpg729pay, "rtpg729pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_G729_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_g729_pay_finalize (GObject * object)
@@ -186,6 +189,7 @@ gst_rtp_g729_pay_push (GstRTPG729Pay * rtpg729pay, GstBuffer * buf)
   if (G_UNLIKELY (rtpg729pay->discont)) {
     GST_DEBUG_OBJECT (basepayload, "discont, setting marker bit");
     GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DISCONT);
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
     gst_rtp_buffer_set_marker (&rtp, TRUE);
     rtpg729pay->discont = FALSE;
   }
@@ -389,10 +393,3 @@ gst_rtp_g729_pay_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-gboolean
-gst_rtp_g729_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpg729pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_G729_PAY);
-}
diff --git a/gst/rtp/gstrtpg729pay.h b/gst/rtp/gstrtpg729pay.h
index 1b9246050..c9e76c27b 100644
--- a/gst/rtp/gstrtpg729pay.h
+++ b/gst/rtp/gstrtpg729pay.h
@@ -59,8 +59,6 @@ struct _GstRTPG729PayClass
 
 GType gst_rtp_g729_pay_get_type (void);
 
-gboolean gst_rtp_g729_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_G729_PAY_H__ */
diff --git a/gst/rtp/gstrtpgsmdepay.c b/gst/rtp/gstrtpgsmdepay.c
index c87c61852..313acb545 100644
--- a/gst/rtp/gstrtpgsmdepay.c
+++ b/gst/rtp/gstrtpgsmdepay.c
@@ -25,6 +25,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpgsmdepay.h"
 #include "gstrtputils.h"
 
@@ -65,6 +66,8 @@ static gboolean gst_rtp_gsm_depay_setcaps (GstRTPBaseDepayload * _depayload,
 
 #define gst_rtp_gsm_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPGSMDepay, gst_rtp_gsm_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpgsmdepay, "rtpgsmdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_GSM_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_gsm_depay_class_init (GstRTPGSMDepayClass * klass)
@@ -143,10 +146,3 @@ gst_rtp_gsm_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_gsm_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpgsmdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_GSM_DEPAY);
-}
diff --git a/gst/rtp/gstrtpgsmdepay.h b/gst/rtp/gstrtpgsmdepay.h
index e428aa09f..166f55869 100644
--- a/gst/rtp/gstrtpgsmdepay.h
+++ b/gst/rtp/gstrtpgsmdepay.h
@@ -51,8 +51,6 @@ struct _GstRTPGSMDepayClass
 
 GType gst_rtp_gsm_depay_get_type (void);
 
-gboolean gst_rtp_gsm_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_GSM_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpgsmpay.c b/gst/rtp/gstrtpgsmpay.c
index 25fa0fa0a..b3197cb31 100644
--- a/gst/rtp/gstrtpgsmpay.c
+++ b/gst/rtp/gstrtpgsmpay.c
@@ -27,6 +27,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpgsmpay.h"
 #include "gstrtputils.h"
 
@@ -61,6 +62,8 @@ static GstFlowReturn gst_rtp_gsm_pay_handle_buffer (GstRTPBasePayload * payload,
 
 #define gst_rtp_gsm_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPGSMPay, gst_rtp_gsm_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpgsmpay, "rtpgsmpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_GSM_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_gsm_pay_class_init (GstRTPGSMPayClass * klass)
@@ -172,10 +175,3 @@ too_big:
     return GST_FLOW_ERROR;
   }
 }
-
-gboolean
-gst_rtp_gsm_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpgsmpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_GSM_PAY);
-}
diff --git a/gst/rtp/gstrtpgsmpay.h b/gst/rtp/gstrtpgsmpay.h
index b6437f516..357a7c695 100644
--- a/gst/rtp/gstrtpgsmpay.h
+++ b/gst/rtp/gstrtpgsmpay.h
@@ -52,7 +52,6 @@ struct _GstRTPGSMPayClass
 
 GType gst_rtp_gsm_pay_get_type (void);
 
-gboolean gst_rtp_gsm_pay_plugin_init (GstPlugin * plugin);
 
 G_END_DECLS
 
diff --git a/gst/rtp/gstrtpgstdepay.c b/gst/rtp/gstrtpgstdepay.c
index 0f081776e..ebf838296 100644
--- a/gst/rtp/gstrtpgstdepay.c
+++ b/gst/rtp/gstrtpgstdepay.c
@@ -24,6 +24,7 @@
 #include <string.h>
 #include <stdlib.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpgstdepay.h"
 #include "gstrtputils.h"
 
@@ -49,6 +50,8 @@ GST_STATIC_PAD_TEMPLATE ("sink",
 
 #define gst_rtp_gst_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpGSTDepay, gst_rtp_gst_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpgstdepay, "rtpgstdepay",
+    GST_RANK_MARGINAL, GST_TYPE_RTP_GST_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_gst_depay_finalize (GObject * object);
 
@@ -602,11 +605,3 @@ gst_rtp_gst_depay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-
-gboolean
-gst_rtp_gst_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpgstdepay",
-      GST_RANK_MARGINAL, GST_TYPE_RTP_GST_DEPAY);
-}
diff --git a/gst/rtp/gstrtpgstdepay.h b/gst/rtp/gstrtpgstdepay.h
index 9ea9ec6c9..41528792e 100644
--- a/gst/rtp/gstrtpgstdepay.h
+++ b/gst/rtp/gstrtpgstdepay.h
@@ -59,8 +59,6 @@ struct _GstRtpGSTDepayClass
 
 GType gst_rtp_gst_depay_get_type (void);
 
-gboolean gst_rtp_gst_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_GST_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpgstpay.c b/gst/rtp/gstrtpgstpay.c
index 15b281bd7..5dba040bf 100644
--- a/gst/rtp/gstrtpgstpay.c
+++ b/gst/rtp/gstrtpgstpay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpgstpay.h"
 #include "gstrtputils.h"
 
@@ -102,6 +103,8 @@ static gboolean gst_rtp_gst_pay_src_event (GstRTPBasePayload * payload,
 
 #define gst_rtp_gst_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpGSTPay, gst_rtp_gst_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpgstpay, "rtpgstpay", GST_RANK_NONE,
+    GST_TYPE_RTP_GST_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_gst_pay_class_init (GstRtpGSTPayClass * klass)
@@ -168,8 +171,7 @@ gst_rtp_gst_pay_reset (GstRtpGSTPay * rtpgstpay, gboolean full)
   rtpgstpay->flags &= 0x70;
   rtpgstpay->etype = 0;
   if (rtpgstpay->pending_buffers)
-    g_list_free_full (rtpgstpay->pending_buffers,
-        (GDestroyNotify) gst_buffer_list_unref);
+    gst_buffer_list_unref (rtpgstpay->pending_buffers);
   rtpgstpay->pending_buffers = NULL;
   if (full) {
     if (rtpgstpay->taglist)
@@ -180,6 +182,7 @@ gst_rtp_gst_pay_reset (GstRtpGSTPay * rtpgstpay, gboolean full)
     rtpgstpay->current_CV = 0;
     rtpgstpay->next_CV = 0;
   }
+  rtpgstpay->received_buffer = FALSE;
 }
 
 static void
@@ -268,7 +271,6 @@ gst_rtp_gst_pay_create_from_adapter (GstRtpGSTPay * rtpgstpay,
 {
   guint avail, mtu;
   guint frag_offset;
-  GstBufferList *list;
 
   avail = gst_adapter_available (rtpgstpay->adapter);
   if (avail == 0)
@@ -276,7 +278,9 @@ gst_rtp_gst_pay_create_from_adapter (GstRtpGSTPay * rtpgstpay,
 
   mtu = GST_RTP_BASE_PAYLOAD_MTU (rtpgstpay);
 
-  list = gst_buffer_list_new_sized ((avail / (mtu - (RTP_HEADER_LEN + 8))) + 1);
+  if (!rtpgstpay->pending_buffers)
+    rtpgstpay->pending_buffers =
+        gst_buffer_list_new_sized ((avail / (mtu - (RTP_HEADER_LEN + 8))) + 1);
   frag_offset = 0;
 
   while (avail) {
@@ -332,8 +336,10 @@ gst_rtp_gst_pay_create_from_adapter (GstRtpGSTPay * rtpgstpay,
     frag_offset += payload_len;
     avail -= payload_len;
 
-    if (avail == 0)
+    if (avail == 0) {
       gst_rtp_buffer_set_marker (&rtp, TRUE);
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
+    }
 
     gst_rtp_buffer_unmap (&rtp);
 
@@ -351,12 +357,11 @@ gst_rtp_gst_pay_create_from_adapter (GstRtpGSTPay * rtpgstpay,
     GST_BUFFER_PTS (outbuf) = timestamp;
 
     /* and add to list */
-    gst_buffer_list_insert (list, -1, outbuf);
+    gst_buffer_list_insert (rtpgstpay->pending_buffers, -1, outbuf);
   }
 
   rtpgstpay->flags &= 0x70;
   rtpgstpay->etype = 0;
-  rtpgstpay->pending_buffers = g_list_append (rtpgstpay->pending_buffers, list);
 
   return TRUE;
 }
@@ -365,22 +370,20 @@ static GstFlowReturn
 gst_rtp_gst_pay_flush (GstRtpGSTPay * rtpgstpay, GstClockTime timestamp)
 {
   GstFlowReturn ret = GST_FLOW_OK;
-  GList *iter;
 
   gst_rtp_gst_pay_create_from_adapter (rtpgstpay, timestamp);
 
-  iter = rtpgstpay->pending_buffers;
-  while (iter) {
-    GstBufferList *list = iter->data;
-
-    rtpgstpay->pending_buffers = iter =
-        g_list_delete_link (rtpgstpay->pending_buffers, iter);
+  if (!rtpgstpay->received_buffer) {
+    GST_DEBUG_OBJECT (rtpgstpay,
+        "Can't flush without having received a buffer yet");
+    return GST_FLOW_OK;
+  }
 
+  if (rtpgstpay->pending_buffers) {
     /* push the whole buffer list at once */
     ret = gst_rtp_base_payload_push_list (GST_RTP_BASE_PAYLOAD (rtpgstpay),
-        list);
-    if (ret != GST_FLOW_OK)
-      break;
+        rtpgstpay->pending_buffers);
+    rtpgstpay->pending_buffers = NULL;
   }
 
   return ret;
@@ -651,6 +654,8 @@ gst_rtp_gst_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
   rtpgstpay = GST_RTP_GST_PAY (basepayload);
 
+  rtpgstpay->received_buffer = TRUE;
+
   timestamp = GST_BUFFER_PTS (buffer);
   running_time =
       gst_segment_to_running_time (&basepayload->segment, GST_FORMAT_TIME,
@@ -694,10 +699,3 @@ gst_rtp_gst_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
   return ret;
 }
-
-gboolean
-gst_rtp_gst_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpgstpay",
-      GST_RANK_NONE, GST_TYPE_RTP_GST_PAY);
-}
diff --git a/gst/rtp/gstrtpgstpay.h b/gst/rtp/gstrtpgstpay.h
index 6625a4dbc..671186bf7 100644
--- a/gst/rtp/gstrtpgstpay.h
+++ b/gst/rtp/gstrtpgstpay.h
@@ -44,7 +44,7 @@ struct _GstRtpGSTPay
 {
   GstRTPBasePayload payload;
 
-  GList *pending_buffers; /* GstBufferList */
+  GstBufferList *pending_buffers;
   GstAdapter *adapter;
   guint8 flags;
   guint8 etype;
@@ -57,6 +57,8 @@ struct _GstRtpGSTPay
   guint config_interval;
   GstClockTime last_config;
   gboolean force_config;
+
+  gboolean received_buffer;
 };
 
 struct _GstRtpGSTPayClass
@@ -66,8 +68,6 @@ struct _GstRtpGSTPayClass
 
 GType gst_rtp_gst_pay_get_type (void);
 
-gboolean gst_rtp_gst_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_GST_PAY_H__ */
diff --git a/gst/rtp/gstrtph261depay.c b/gst/rtp/gstrtph261depay.c
index 164d2f04d..23a888a4e 100644
--- a/gst/rtp/gstrtph261depay.c
+++ b/gst/rtp/gstrtph261depay.c
@@ -46,6 +46,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "gstrtph261depay.h"
 #include "gstrtph261pay.h"      /* GstRtpH261PayHeader */
 #include "gstrtputils.h"
@@ -75,10 +76,11 @@ static GstStaticPadTemplate gst_rtp_h261_depay_sink_template =
         "payload = (int) " GST_RTP_PAYLOAD_DYNAMIC_STRING ", "
         "clock-rate = (int) 90000, " "encoding-name = (string) \"H261\"")
     );
-
+#define parent_class gst_rtp_h261_depay_parent_class
 G_DEFINE_TYPE (GstRtpH261Depay, gst_rtp_h261_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
-#define parent_class gst_rtp_h261_depay_parent_class
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph261depay, "rtph261depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H261_DEPAY, rtp_element_init (plugin));
 
 static GstBuffer *
 gst_rtp_h261_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
@@ -285,10 +287,3 @@ gst_rtp_h261_depay_init (GstRtpH261Depay * depay)
   depay->adapter = gst_adapter_new ();
   depay->leftover = NO_LEFTOVER;
 }
-
-gboolean
-gst_rtp_h261_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph261depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H261_DEPAY);
-}
diff --git a/gst/rtp/gstrtph261depay.h b/gst/rtp/gstrtph261depay.h
index f87f81773..821eff993 100644
--- a/gst/rtp/gstrtph261depay.h
+++ b/gst/rtp/gstrtph261depay.h
@@ -54,7 +54,5 @@ struct _GstRtpH261DepayClass
 
 GType gst_rtp_h261_depay_get_type (void);
 
-gboolean gst_rtp_h261_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_H261_DEPAY_H__ */
diff --git a/gst/rtp/gstrtph261pay.c b/gst/rtp/gstrtph261pay.c
index 9b8c0d922..a7c9033bb 100644
--- a/gst/rtp/gstrtph261pay.c
+++ b/gst/rtp/gstrtph261pay.c
@@ -48,6 +48,7 @@
 #  include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtph261pay.h"
 #include "gstrtputils.h"
 #include <gst/rtp/gstrtpbuffer.h>
@@ -82,8 +83,10 @@ static GstStaticPadTemplate gst_rtp_h261_pay_src_template =
         "clock-rate = (int) 90000, " "encoding-name = (string) \"H261\"")
     );
 
-G_DEFINE_TYPE (GstRtpH261Pay, gst_rtp_h261_pay, GST_TYPE_RTP_BASE_PAYLOAD);
 #define parent_class gst_rtp_h261_pay_parent_class
+G_DEFINE_TYPE (GstRtpH261Pay, gst_rtp_h261_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph261pay, "rtph261pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H261_PAY, rtp_element_init (plugin));
 
 typedef struct
 {
@@ -813,8 +816,9 @@ gst_rtp_h261_pay_fragment_push (GstRtpH261Pay * pay, GstBuffer * buffer,
 
   nbytes = bitrange_to_bytes (start, end);
 
-  outbuf = gst_rtp_buffer_new_allocate (nbytes +
-      GST_RTP_H261_PAYLOAD_HEADER_LEN, 0, 0);
+  outbuf =
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD (pay),
+      nbytes + GST_RTP_H261_PAYLOAD_HEADER_LEN, 0, 0);
   gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
   payload = gst_rtp_buffer_get_payload (&rtp);
   header = (GstRtpH261PayHeader *) payload;
@@ -840,6 +844,8 @@ gst_rtp_h261_pay_fragment_push (GstRtpH261Pay * pay, GstBuffer * buffer,
       bits + GST_ROUND_DOWN_8 (start) / 8, nbytes);
 
   GST_BUFFER_TIMESTAMP (outbuf) = pay->timestamp;
+  if (marker)
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
   gst_rtp_buffer_set_marker (&rtp, marker);
   pay->offset = end & 7;
 
@@ -1062,10 +1068,3 @@ gst_rtp_h261_pay_class_init (GstRtpH261PayClass * klass)
   GST_DEBUG_CATEGORY_INIT (rtph261pay_debug, "rtph261pay", 0,
       "H261 RTP Payloader");
 }
-
-gboolean
-gst_rtp_h261_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph261pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H261_PAY);
-}
diff --git a/gst/rtp/gstrtph261pay.h b/gst/rtp/gstrtph261pay.h
index eae4bf2db..1052d01be 100644
--- a/gst/rtp/gstrtph261pay.h
+++ b/gst/rtp/gstrtph261pay.h
@@ -94,7 +94,5 @@ typedef struct _GstRtpH261PayHeader
 
 GType gst_rtp_h261_pay_get_type (void);
 
-gboolean gst_rtp_h261_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_H261_PAY_H__ */
diff --git a/gst/rtp/gstrtph263depay.c b/gst/rtp/gstrtph263depay.c
index 296f91787..f6b41a5bc 100644
--- a/gst/rtp/gstrtph263depay.c
+++ b/gst/rtp/gstrtph263depay.c
@@ -31,6 +31,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "gstrtph263depay.h"
 #include "gstrtputils.h"
 
@@ -72,6 +73,8 @@ static GstStaticPadTemplate gst_rtp_h263_depay_sink_template =
 #define gst_rtp_h263_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpH263Depay, gst_rtp_h263_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph263depay, "rtph263depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H263_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_h263_depay_finalize (GObject * object);
 
@@ -438,10 +441,3 @@ gst_rtp_h263_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_h263_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph263depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H263_DEPAY);
-}
diff --git a/gst/rtp/gstrtph263depay.h b/gst/rtp/gstrtph263depay.h
index 2d9ca55c7..485fc9dfa 100644
--- a/gst/rtp/gstrtph263depay.h
+++ b/gst/rtp/gstrtph263depay.h
@@ -58,8 +58,6 @@ struct _GstRtpH263DepayClass
 
 GType gst_rtp_h263_depay_get_type (void);
 
-gboolean gst_rtp_h263_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_H263_DEPAY_H__ */
diff --git a/gst/rtp/gstrtph263pay.c b/gst/rtp/gstrtph263pay.c
index a8def87aa..f89843a5b 100644
--- a/gst/rtp/gstrtph263pay.c
+++ b/gst/rtp/gstrtph263pay.c
@@ -29,6 +29,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "gstrtph263pay.h"
 #include "gstrtputils.h"
 
@@ -399,6 +400,8 @@ static void gst_rtp_h263_pay_package_destroy (GstRtpH263PayPackage * pack);
 
 #define gst_rtp_h263_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpH263Pay, gst_rtp_h263_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph263pay, "rtph263pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H263_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_h263_pay_class_init (GstRtpH263PayClass * klass)
@@ -1308,8 +1311,10 @@ gst_rtp_h263_pay_push (GstRtpH263Pay * rtph263pay,
   GST_BUFFER_PTS (package->outbuf) = rtph263pay->first_ts;
 
   gst_rtp_buffer_set_marker (&rtp, package->marker);
-  if (package->marker)
+  if (package->marker) {
+    GST_BUFFER_FLAG_SET (package->outbuf, GST_BUFFER_FLAG_MARKER);
     GST_DEBUG_OBJECT (rtph263pay, "Marker set!");
+  }
 
   gst_rtp_buffer_unmap (&rtp);
 
@@ -1355,7 +1360,9 @@ gst_rtp_h263_pay_A_fragment_push (GstRtpH263Pay * rtph263pay,
 
   pack->gobn = context->gobs[first]->gobn;
   pack->mode = GST_RTP_H263_PAYLOAD_HEADER_MODE_A;
-  pack->outbuf = gst_rtp_buffer_new_allocate (pack->mode, 0, 0);
+  pack->outbuf =
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+      (rtph263pay), pack->mode, 0, 0);
 
   GST_DEBUG_OBJECT (rtph263pay, "Sending len:%d data to push function",
       pack->payload_len);
@@ -1412,7 +1419,9 @@ gst_rtp_h263_pay_B_fragment_push (GstRtpH263Pay * rtph263pay,
   }
 
   pack->payload_len = pack->payload_end - pack->payload_start + 1;
-  pack->outbuf = gst_rtp_buffer_new_allocate (pack->mode, 0, 0);
+  pack->outbuf =
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+      (rtph263pay), pack->mode, 0, 0);
 
   return gst_rtp_h263_pay_push (rtph263pay, context, pack);
 }
@@ -1637,7 +1646,8 @@ gst_rtp_h263_send_entire_frame (GstRtpH263Pay * rtph263pay,
       rtph263pay->available_data);
 
   pack->outbuf =
-      gst_rtp_buffer_new_allocate (GST_RTP_H263_PAYLOAD_HEADER_MODE_A, 0, 0);
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+      (rtph263pay), GST_RTP_H263_PAYLOAD_HEADER_MODE_A, 0, 0);
 
   return gst_rtp_h263_pay_push (rtph263pay, context, pack);
 }
@@ -1860,10 +1870,3 @@ gst_rtp_h263_pay_handle_buffer (GstRTPBasePayload * payload, GstBuffer * buffer)
 
   return ret;
 }
-
-gboolean
-gst_rtp_h263_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph263pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H263_PAY);
-}
diff --git a/gst/rtp/gstrtph263pay.h b/gst/rtp/gstrtph263pay.h
index 2abfc871e..c77e6ac15 100644
--- a/gst/rtp/gstrtph263pay.h
+++ b/gst/rtp/gstrtph263pay.h
@@ -409,7 +409,5 @@ struct _GstRtpH263PayPackage
 
 GType gst_rtp_h263_pay_get_type (void);
 
-gboolean gst_rtp_h263_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_H263_PAY_H__ */
diff --git a/gst/rtp/gstrtph263pdepay.c b/gst/rtp/gstrtph263pdepay.c
index a1fc40c4a..8b371ba92 100644
--- a/gst/rtp/gstrtph263pdepay.c
+++ b/gst/rtp/gstrtph263pdepay.c
@@ -25,6 +25,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "gstrtph263pdepay.h"
 #include "gstrtputils.h"
 
@@ -84,6 +85,8 @@ static GstStaticPadTemplate gst_rtp_h263p_depay_sink_template =
 #define gst_rtp_h263p_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpH263PDepay, gst_rtp_h263p_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph263pdepay, "rtph263pdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H263P_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_h263p_depay_finalize (GObject * object);
 
@@ -231,6 +234,98 @@ no_caps:
   }
 }
 
+static void
+gst_rtp_h263p_depay_decorate_output_buffer (GstRtpH263PDepay * rtph263pdepay,
+    GstBuffer * outbuf)
+{
+  gboolean is_intra = FALSE;
+  GstBitReader bits;
+  guint8 pic_hdr[16];
+  gsize pic_hdr_len = 0;
+  guint32 psc, ptype, mpptype;
+  guint8 ufep;
+
+  pic_hdr_len = gst_buffer_extract (outbuf, 0, pic_hdr, sizeof (pic_hdr));
+
+  GST_MEMDUMP_OBJECT (rtph263pdepay, "pic_hdr", pic_hdr, pic_hdr_len);
+
+#if 0
+  if (gst_debug_category_get_threshold (GST_CAT_DEFAULT) >= GST_LEVEL_MEMDUMP) {
+    gchar bit_str[1 + sizeof (pic_hdr) * 8] = { 0, };
+    guint8 b;
+
+    gst_bit_reader_init (&bits, pic_hdr, pic_hdr_len);
+    while ((gst_bit_reader_get_bits_uint8 (&bits, &b, 1))) {
+      g_strlcat (bit_str, b ? "1" : "0", sizeof (bit_str));
+    }
+    GST_TRACE_OBJECT (rtph263pdepay, "pic_hdr bits: %s", bit_str);
+  }
+#endif
+
+  gst_bit_reader_init (&bits, pic_hdr, pic_hdr_len);
+
+  /* PSC - Picture Start Code: 22 bits: 0000 0000 0000 0000 10 0000 */
+  if (!gst_bit_reader_get_bits_uint32 (&bits, &psc, 22) || psc != 0x20) {
+    GST_WARNING_OBJECT (rtph263pdepay, "No picture start code");
+    return;
+  }
+
+  /* TR - Temporal Reference: 8 bits */
+  if (!gst_bit_reader_skip (&bits, 8)) {
+    GST_WARNING_OBJECT (rtph263pdepay, "Short picture header: no TR");
+    return;
+  }
+
+  /* PTYPE (first 8 bits) */
+  if (!gst_bit_reader_get_bits_uint32 (&bits, &ptype, 8) || (ptype >> 6) != 2) {
+    GST_WARNING_OBJECT (rtph263pdepay, "Short picture header: no PTYPE");
+    return;
+  }
+
+  /* PTYPE: check for extended PTYPE (bits 6-8 = 111) */
+  if ((ptype & 7) != 7) {
+    /* No extended PTYPE, read remaining 5 bits */
+    if (!gst_bit_reader_get_bits_uint32 (&bits, &ptype, 5)) {
+      GST_WARNING_OBJECT (rtph263pdepay, "Short picture header: no PTYPE");
+      return;
+    }
+    is_intra = (ptype & 0x10) == 0;
+    goto done;
+  }
+
+  /* UFEP - Update Full Extended PTYPE */
+  ufep = 0;
+  if (!gst_bit_reader_get_bits_uint8 (&bits, &ufep, 3) || ufep > 1) {
+    GST_WARNING_OBJECT (rtph263pdepay, "Short picture header: no PLUSPTYPE, %d",
+        ufep);
+    return;
+  }
+
+  /* Skip optional part of PLUSPTYPE (OPPTYPE) */
+  if (ufep == 1 && !gst_bit_reader_skip (&bits, 18)) {
+    GST_WARNING_OBJECT (rtph263pdepay, "Short picture header: no OPPTYPE");
+    return;
+  }
+
+  /* Mandatory part of PLUSPTYPE (MPPTYPE) */
+  if (!gst_bit_reader_get_bits_uint32 (&bits, &mpptype, 9)
+      || (mpptype & 7) != 1) {
+    GST_WARNING_OBJECT (rtph263pdepay, "Short picture header: no MPPTYPE");
+    return;
+  }
+
+  is_intra = (mpptype >> 6) == 0;
+
+done:
+
+  if (is_intra) {
+    GST_LOG_OBJECT (rtph263pdepay, "I-frame");
+    GST_BUFFER_FLAG_UNSET (outbuf, GST_BUFFER_FLAG_DELTA_UNIT);
+  } else {
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DELTA_UNIT);
+  }
+}
+
 static GstBuffer *
 gst_rtp_h263p_depay_process (GstRTPBaseDepayload * depayload,
     GstRTPBuffer * rtp)
@@ -333,6 +428,8 @@ gst_rtp_h263p_depay_process (GstRTPBaseDepayload * depayload,
 
     gst_rtp_drop_non_video_meta (rtph263pdepay, outbuf);
 
+    gst_rtp_h263p_depay_decorate_output_buffer (rtph263pdepay, outbuf);
+
     return outbuf;
   } else {
     /* frame not completed: store in adapter */
@@ -394,10 +491,3 @@ gst_rtp_h263p_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_h263p_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph263pdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H263P_DEPAY);
-}
diff --git a/gst/rtp/gstrtph263pdepay.h b/gst/rtp/gstrtph263pdepay.h
index bbdb2b0a4..bdcb826a9 100644
--- a/gst/rtp/gstrtph263pdepay.h
+++ b/gst/rtp/gstrtph263pdepay.h
@@ -55,8 +55,6 @@ struct _GstRtpH263PDepayClass
 
 GType gst_rtp_h263p_depay_get_type (void);
 
-gboolean gst_rtp_h263p_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_H263P_DEPAY_H__ */
diff --git a/gst/rtp/gstrtph263ppay.c b/gst/rtp/gstrtph263ppay.c
index 3b1ee0512..b6d8040ae 100644
--- a/gst/rtp/gstrtph263ppay.c
+++ b/gst/rtp/gstrtph263ppay.c
@@ -28,6 +28,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "gstrtph263ppay.h"
 #include "gstrtputils.h"
 
@@ -112,6 +113,8 @@ static GstFlowReturn gst_rtp_h263p_pay_handle_buffer (GstRTPBasePayload *
 
 #define gst_rtp_h263p_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpH263PPay, gst_rtp_h263p_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph263ppay, "rtph263ppay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H263P_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_h263p_pay_class_init (GstRtpH263PPayClass * klass)
@@ -732,11 +735,15 @@ gst_rtp_h263p_pay_flush (GstRtpH263PPay * rtph263ppay)
     if (next_gop > 0)
       towrite = MIN (next_gop, towrite);
 
-    outbuf = gst_rtp_buffer_new_allocate (header_len, 0, 0);
+    outbuf =
+        gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+        (rtph263ppay), header_len, 0, 0);
 
     gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
     /* last fragment gets the marker bit set */
     gst_rtp_buffer_set_marker (&rtp, avail > towrite ? 0 : 1);
+    if (avail <= towrite)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
 
     payload = gst_rtp_buffer_get_payload (&rtp);
 
@@ -807,10 +814,3 @@ gst_rtp_h263p_pay_handle_buffer (GstRTPBasePayload * payload,
 
   return ret;
 }
-
-gboolean
-gst_rtp_h263p_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph263ppay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H263P_PAY);
-}
diff --git a/gst/rtp/gstrtph263ppay.h b/gst/rtp/gstrtph263ppay.h
index 23ec8b8e9..7197b86e5 100644
--- a/gst/rtp/gstrtph263ppay.h
+++ b/gst/rtp/gstrtph263ppay.h
@@ -63,8 +63,6 @@ struct _GstRtpH263PPayClass
 
 GType gst_rtp_h263p_pay_get_type (void);
 
-gboolean gst_rtp_h263p_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_H263P_PAY_H__ */
diff --git a/gst/rtp/gstrtph264depay.c b/gst/rtp/gstrtph264depay.c
index cc92c9a14..9cef347c2 100644
--- a/gst/rtp/gstrtph264depay.c
+++ b/gst/rtp/gstrtph264depay.c
@@ -28,6 +28,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/pbutils/pbutils.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "gstrtph264depay.h"
 #include "gstrtputils.h"
 
@@ -38,6 +39,16 @@ GST_DEBUG_CATEGORY_STATIC (rtph264depay_debug);
  * expressed a restriction or preference via caps */
 #define DEFAULT_BYTE_STREAM   TRUE
 #define DEFAULT_ACCESS_UNIT   FALSE
+#define DEFAULT_WAIT_FOR_KEYFRAME FALSE
+#define DEFAULT_REQUEST_KEYFRAME FALSE
+
+enum
+{
+  PROP_0,
+  PROP_WAIT_FOR_KEYFRAME,
+  PROP_REQUEST_KEYFRAME,
+};
+
 
 /* 3 zero bytes syncword */
 static const guint8 sync_bytes[] = { 0, 0, 0, 1 };
@@ -79,8 +90,11 @@ GST_STATIC_PAD_TEMPLATE ("sink",
     );
 
 #define gst_rtp_h264_depay_parent_class parent_class
-G_DEFINE_TYPE (GstRtpH264Depay, gst_rtp_h264_depay,
-    GST_TYPE_RTP_BASE_DEPAYLOAD);
+G_DEFINE_TYPE_WITH_CODE (GstRtpH264Depay, gst_rtp_h264_depay,
+    GST_TYPE_RTP_BASE_DEPAYLOAD, GST_DEBUG_CATEGORY_INIT (rtph264depay_debug,
+        "rtph264depay", 0, "H264 Video RTP Depayloader"));
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph264depay, "rtph264depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H264_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_h264_depay_finalize (GObject * object);
 
@@ -99,6 +113,44 @@ static void gst_rtp_h264_depay_push (GstRtpH264Depay * rtph264depay,
     GstBuffer * outbuf, gboolean keyframe, GstClockTime timestamp,
     gboolean marker);
 
+static void
+gst_rtp_h264_depay_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstRtpH264Depay *self = GST_RTP_H264_DEPAY (object);
+
+  switch (prop_id) {
+    case PROP_WAIT_FOR_KEYFRAME:
+      self->wait_for_keyframe = g_value_get_boolean (value);
+      break;
+    case PROP_REQUEST_KEYFRAME:
+      self->request_keyframe = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_h264_depay_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstRtpH264Depay *self = GST_RTP_H264_DEPAY (object);
+
+  switch (prop_id) {
+    case PROP_WAIT_FOR_KEYFRAME:
+      g_value_set_boolean (value, self->wait_for_keyframe);
+      break;
+    case PROP_REQUEST_KEYFRAME:
+      g_value_set_boolean (value, self->request_keyframe);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
 static void
 gst_rtp_h264_depay_class_init (GstRtpH264DepayClass * klass)
 {
@@ -111,6 +163,36 @@ gst_rtp_h264_depay_class_init (GstRtpH264DepayClass * klass)
   gstrtpbasedepayload_class = (GstRTPBaseDepayloadClass *) klass;
 
   gobject_class->finalize = gst_rtp_h264_depay_finalize;
+  gobject_class->set_property = gst_rtp_h264_depay_set_property;
+  gobject_class->get_property = gst_rtp_h264_depay_get_property;
+
+  /**
+   * GstRtpH264Depay:wait-for-keyframe:
+   *
+   * Wait for the next keyframe after packet loss,
+   * meaningful only when outputting access units
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_WAIT_FOR_KEYFRAME,
+      g_param_spec_boolean ("wait-for-keyframe", "Wait for Keyframe",
+          "Wait for the next keyframe after packet loss, meaningful only when "
+          "outputting access units",
+          DEFAULT_WAIT_FOR_KEYFRAME,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRtpH264Depay:request-keyframe:
+   *
+   * Request new keyframe when packet loss is detected
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_REQUEST_KEYFRAME,
+      g_param_spec_boolean ("request-keyframe", "Request Keyframe",
+          "Request new keyframe when packet loss is detected",
+          DEFAULT_REQUEST_KEYFRAME,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   gst_element_class_add_static_pad_template (gstelement_class,
       &gst_rtp_h264_depay_src_template);
@@ -139,6 +221,8 @@ gst_rtp_h264_depay_init (GstRtpH264Depay * rtph264depay)
       (GDestroyNotify) gst_buffer_unref);
   rtph264depay->pps = g_ptr_array_new_with_free_func (
       (GDestroyNotify) gst_buffer_unref);
+  rtph264depay->wait_for_keyframe = DEFAULT_WAIT_FOR_KEYFRAME;
+  rtph264depay->request_keyframe = DEFAULT_REQUEST_KEYFRAME;
 }
 
 static void
@@ -146,6 +230,7 @@ gst_rtp_h264_depay_reset (GstRtpH264Depay * rtph264depay, gboolean hard)
 {
   gst_adapter_clear (rtph264depay->adapter);
   rtph264depay->wait_start = TRUE;
+  rtph264depay->waiting_for_keyframe = rtph264depay->wait_for_keyframe;
   gst_adapter_clear (rtph264depay->picture_adapter);
   rtph264depay->picture_start = FALSE;
   rtph264depay->last_keyframe = FALSE;
@@ -351,7 +436,7 @@ gst_rtp_h264_set_src_caps (GstRtpH264Depay * rtph264depay)
     guint8 *data;
     guint len;
     guint new_size;
-    guint i;
+    guint i, first_sps, num_sps, first_pps, num_pps;
     guchar level = 0;
     guchar profile_compat = G_MAXUINT8;
 
@@ -392,11 +477,22 @@ gst_rtp_h264_set_src_caps (GstRtpH264Depay * rtph264depay)
 
     /* 6 bits reserved | 2 bits lengthSizeMinusOn */
     *data++ = 0xff;
+
+    if (rtph264depay->sps->len > 31) {
+      GST_WARNING_OBJECT (rtph264depay,
+          "Too many SPS to put in codec_data. Sending the most recent 31");
+      num_sps = 31;
+      first_sps = rtph264depay->sps->len - 31;
+    } else {
+      num_sps = rtph264depay->sps->len;
+      first_sps = 0;
+    }
+
     /* 3 bits reserved | 5 bits numOfSequenceParameterSets */
-    *data++ = 0xe0 | (rtph264depay->sps->len & 0x1f);
+    *data++ = 0xe0 | (num_sps & 0x1f);
 
     /* copy all SPS */
-    for (i = 0; i < rtph264depay->sps->len; i++) {
+    for (i = first_sps; i < rtph264depay->sps->len; i++) {
       gst_buffer_map (g_ptr_array_index (rtph264depay->sps, i), &nalmap,
           GST_MAP_READ);
 
@@ -409,10 +505,21 @@ gst_rtp_h264_set_src_caps (GstRtpH264Depay * rtph264depay)
       gst_buffer_unmap (g_ptr_array_index (rtph264depay->sps, i), &nalmap);
     }
 
+    if (rtph264depay->pps->len > 255) {
+      GST_WARNING_OBJECT (rtph264depay,
+          "Too many PPS to put in codec_data. Sending the most recent 255");
+      num_pps = 255;
+      first_pps = rtph264depay->pps->len - 255;
+    } else {
+      num_pps = rtph264depay->pps->len;
+      first_pps = 0;
+    }
+
     /* 8 bits numOfPictureParameterSets */
-    *data++ = rtph264depay->pps->len;
+    *data++ = num_pps;
+
     /* copy all PPS */
-    for (i = 0; i < rtph264depay->pps->len; i++) {
+    for (i = first_pps; i < rtph264depay->pps->len; i++) {
       gst_buffer_map (g_ptr_array_index (rtph264depay->pps, i), &nalmap,
           GST_MAP_READ);
 
@@ -559,14 +666,16 @@ gst_rtp_h264_add_sps_pps (GstElement * rtph264, GPtrArray * sps_array,
       parse_sps (&spsmap, &tmp_sps_id);
 
       if (sps_id == tmp_sps_id) {
-        if (map.size == spsmap.size &&
+        /* If this is already the most recent SPS and unchanged, nothing to do */
+        if (i == (sps_array->len - 1) && map.size == spsmap.size &&
             memcmp (map.data, spsmap.data, spsmap.size) == 0) {
-          GST_LOG_OBJECT (rtph264, "Unchanged SPS %u, not updating", sps_id);
+          GST_LOG_OBJECT (rtph264,
+              "Unchanged SPS %u already most recent, not updating", sps_id);
           gst_buffer_unmap (sps, &spsmap);
           goto drop;
         } else {
           gst_buffer_unmap (sps, &spsmap);
-          g_ptr_array_remove_index_fast (sps_array, i);
+          g_ptr_array_remove_index (sps_array, i);
           g_ptr_array_add (sps_array, nal);
           GST_LOG_OBJECT (rtph264, "Modified SPS %u, replacing", sps_id);
           goto done;
@@ -597,15 +706,17 @@ gst_rtp_h264_add_sps_pps (GstElement * rtph264, GPtrArray * sps_array,
       parse_pps (&ppsmap, &tmp_sps_id, &tmp_pps_id);
 
       if (pps_id == tmp_pps_id) {
-        if (map.size == ppsmap.size &&
+        /* If this is already the most recent PPS and unchanged, nothing to do */
+        if (i == (pps_array->len - 1) && map.size == ppsmap.size &&
             memcmp (map.data, ppsmap.data, ppsmap.size) == 0) {
-          GST_LOG_OBJECT (rtph264, "Unchanged PPS %u:%u, not updating", sps_id,
+          GST_LOG_OBJECT (rtph264,
+              "Unchanged PPS %u:%u already most recent, not updating", sps_id,
               pps_id);
           gst_buffer_unmap (pps, &ppsmap);
           goto drop;
         } else {
           gst_buffer_unmap (pps, &ppsmap);
-          g_ptr_array_remove_index_fast (pps_array, i);
+          g_ptr_array_remove_index (pps_array, i);
           g_ptr_array_add (pps_array, nal);
           GST_LOG_OBJECT (rtph264, "Modified PPS %u:%u, replacing",
               sps_id, pps_id);
@@ -926,31 +1037,31 @@ gst_rtp_h264_depay_handle_nal (GstRtpH264Depay * rtph264depay, GstBuffer * nal,
   if (rtph264depay->merge) {
     gboolean start = FALSE, complete = FALSE;
 
-    /* marker bit isn't mandatory so in the following code we try to guess
-     * an AU boundary by detecting a new picture start */
-    if (!marker) {
-      /* consider a coded slices (IDR or not) to start a picture,
-       * (so ending the previous one) if first_mb_in_slice == 0
-       * (non-0 is part of previous one) */
-      /* NOTE this is not entirely according to Access Unit specs in 7.4.1.2.4,
-       * but in practice it works in sane cases, needs not much parsing,
-       * and also works with broken frame_num in NAL (where spec-wise would fail) */
-      /* FIXME: this code isn't correct for interlaced content as AUs should be
-       * constructed with pairs of fields and the guess here will just push out
-       * AUs with a single field in it */
-      if (nal_type == 1 || nal_type == 2 || nal_type == 5) {
-        /* we have a picture start */
-        start = TRUE;
-        if (map.data[5] & 0x80) {
-          /* first_mb_in_slice == 0 completes a picture */
-          complete = TRUE;
-        }
-      } else if (nal_type >= 6 && nal_type <= 9) {
-        /* SEI, SPS, PPS, AU terminate picture */
+    /* consider a coded slices (IDR or not) to start a picture,
+     * (so ending the previous one) if first_mb_in_slice == 0
+     * (non-0 is part of previous one) */
+    /* NOTE this is not entirely according to Access Unit specs in 7.4.1.2.4,
+     * but in practice it works in sane cases, needs not much parsing,
+     * and also works with broken frame_num in NAL (where spec-wise would fail) */
+    /* FIXME: this code isn't correct for interlaced content as AUs should be
+     * constructed with pairs of fields and the guess here will just push out
+     * AUs with a single field in it */
+    if (nal_type == 1 || nal_type == 2 || nal_type == 5) {
+      /* we have a picture start */
+      start = TRUE;
+      if (map.data[5] & 0x80) {
+        /* first_mb_in_slice == 0 completes a picture */
         complete = TRUE;
       }
-      GST_DEBUG_OBJECT (depayload, "start %d, complete %d", start, complete);
+    } else if (nal_type >= 6 && nal_type <= 9) {
+      /* SEI, SPS, PPS, AU terminate picture */
+      complete = TRUE;
+    }
+    GST_DEBUG_OBJECT (depayload, "start %d, complete %d", start, complete);
 
+    /* marker bit isn't mandatory so in the following code we try to guess
+     * an AU boundary by detecting a new picture start */
+    if (!marker) {
       if (complete && rtph264depay->picture_start)
         outbuf = gst_rtp_h264_complete_au (rtph264depay, &out_timestamp,
             &out_keyframe);
@@ -958,6 +1069,9 @@ gst_rtp_h264_depay_handle_nal (GstRtpH264Depay * rtph264depay, GstBuffer * nal,
     /* add to adapter */
     gst_buffer_unmap (nal, &map);
 
+    if (!rtph264depay->picture_start && start && out_keyframe)
+      rtph264depay->waiting_for_keyframe = FALSE;
+
     GST_DEBUG_OBJECT (depayload, "adding NAL to picture adapter");
     gst_adapter_push (rtph264depay->picture_adapter, nal);
     rtph264depay->last_ts = in_timestamp;
@@ -975,8 +1089,15 @@ gst_rtp_h264_depay_handle_nal (GstRtpH264Depay * rtph264depay, GstBuffer * nal,
   }
 
   if (outbuf) {
-    gst_rtp_h264_depay_push (rtph264depay, outbuf, out_keyframe, out_timestamp,
-        marker);
+    if (!rtph264depay->waiting_for_keyframe) {
+      gst_rtp_h264_depay_push (rtph264depay, outbuf, out_keyframe,
+          out_timestamp, marker);
+    } else {
+      GST_LOG_OBJECT (depayload,
+          "Dropping %" GST_PTR_FORMAT ", we are waiting for a keyframe",
+          outbuf);
+      gst_buffer_unref (outbuf);
+    }
   }
 
   return;
@@ -1030,12 +1151,25 @@ gst_rtp_h264_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
 
   rtph264depay = GST_RTP_H264_DEPAY (depayload);
 
+  if (!rtph264depay->merge)
+    rtph264depay->waiting_for_keyframe = FALSE;
+
   /* flush remaining data on discont */
   if (GST_BUFFER_IS_DISCONT (rtp->buffer)) {
     gst_adapter_clear (rtph264depay->adapter);
     rtph264depay->wait_start = TRUE;
     rtph264depay->current_fu_type = 0;
     rtph264depay->last_fu_seqnum = 0;
+
+    if (rtph264depay->merge && rtph264depay->wait_for_keyframe) {
+      rtph264depay->waiting_for_keyframe = TRUE;
+    }
+
+
+    if (rtph264depay->request_keyframe)
+      gst_pad_push_event (GST_RTP_BASE_DEPAYLOAD_SINKPAD (depayload),
+          gst_video_event_new_upstream_force_key_unit (GST_CLOCK_TIME_NONE,
+              TRUE, 0));
   }
 
   {
@@ -1376,13 +1510,3 @@ gst_rtp_h264_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_h264_depay_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (rtph264depay_debug, "rtph264depay", 0,
-      "H264 Video RTP Depayloader");
-
-  return gst_element_register (plugin, "rtph264depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H264_DEPAY);
-}
diff --git a/gst/rtp/gstrtph264depay.h b/gst/rtp/gstrtph264depay.h
index 2cb2167a4..8ca7381be 100644
--- a/gst/rtp/gstrtph264depay.h
+++ b/gst/rtp/gstrtph264depay.h
@@ -71,6 +71,10 @@ struct _GstRtpH264Depay
   /* downstream allocator */
   GstAllocator *allocator;
   GstAllocationParams params;
+
+  gboolean wait_for_keyframe;
+  gboolean request_keyframe;
+  gboolean waiting_for_keyframe;
 };
 
 struct _GstRtpH264DepayClass
@@ -80,8 +84,6 @@ struct _GstRtpH264DepayClass
 
 GType gst_rtp_h264_depay_get_type (void);
 
-gboolean gst_rtp_h264_depay_plugin_init (GstPlugin * plugin);
-
 gboolean gst_rtp_h264_add_sps_pps (GstElement * rtph264, GPtrArray * sps,
     GPtrArray * pps, GstBuffer * nal);
 
diff --git a/gst/rtp/gstrtph264pay.c b/gst/rtp/gstrtph264pay.c
index 67353283e..de476e64e 100644
--- a/gst/rtp/gstrtph264pay.c
+++ b/gst/rtp/gstrtph264pay.c
@@ -31,6 +31,7 @@
 /* Included to not duplicate gst_rtp_h264_add_sps_pps () */
 #include "gstrtph264depay.h"
 
+#include "gstrtpelements.h"
 #include "gstrtph264pay.h"
 #include "gstrtputils.h"
 #include "gstbuffermemory.h"
@@ -133,6 +134,8 @@ static void gst_rtp_h264_pay_reset_bundle (GstRtpH264Pay * rtph264pay);
 
 #define gst_rtp_h264_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpH264Pay, gst_rtp_h264_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph264pay, "rtph264pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H264_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_h264_pay_class_init (GstRtpH264PayClass * klass)
@@ -220,7 +223,7 @@ static void
 gst_rtp_h264_pay_init (GstRtpH264Pay * rtph264pay)
 {
   rtph264pay->queue = g_array_new (FALSE, FALSE, sizeof (guint));
-  rtph264pay->profile = 0;
+  rtph264pay->profile_level = 0;
   rtph264pay->sps = g_ptr_array_new_with_free_func (
       (GDestroyNotify) gst_buffer_unref);
   rtph264pay->pps = g_ptr_array_new_with_free_func (
@@ -318,7 +321,7 @@ gst_rtp_h264_pay_getcaps (GstRTPBasePayload * payload, GstPad * pad,
   for (i = 0; i < gst_caps_get_size (allowed_caps); i++) {
     GstStructure *s = gst_caps_get_structure (allowed_caps, i);
     GstStructure *new_s = gst_structure_new_empty ("video/x-h264");
-    const gchar *profile_level_id;
+    const gchar *profile_level_id, *profile;
 
     profile_level_id = gst_structure_get_string (s, "profile-level-id");
 
@@ -340,9 +343,9 @@ gst_rtp_h264_pay_getcaps (GstRTPBasePayload * payload, GstPad * pad,
         GST_LOG_OBJECT (payload, "In caps, have profile %s and level %s",
             profile, level);
 
-        if (!strcmp (profile, "constrained-baseline"))
+        if (!strcmp (profile, "constrained-baseline")) {
           gst_structure_set (new_s, "profile", G_TYPE_STRING, profile, NULL);
-        else {
+        } else {
           GValue val = { 0, };
           GValue profiles = { 0, };
 
@@ -382,6 +385,8 @@ gst_rtp_h264_pay_getcaps (GstRTPBasePayload * payload, GstPad * pad,
         gst_structure_set (new_s,
             "profile", G_TYPE_STRING, "constrained-baseline", NULL);
       }
+    } else if ((profile = gst_structure_get_string (s, "profile"))) {
+      gst_structure_set (new_s, "profile", G_TYPE_STRING, profile, NULL);
     } else {
       /* No profile-level-id means baseline or unrestricted */
 
@@ -454,14 +459,13 @@ gst_rtp_h264_pay_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
   return gst_pad_query_default (pad, parent, query);
 }
 
-
 /* take the currently configured SPS and PPS lists and set them on the caps as
  * sprop-parameter-sets */
 static gboolean
 gst_rtp_h264_pay_set_sps_pps (GstRTPBasePayload * basepayload)
 {
+  GstStructure *s = gst_structure_new_empty ("unused");
   GstRtpH264Pay *payloader = GST_RTP_H264_PAY (basepayload);
-  gchar *profile;
   gchar *set;
   GString *sprops;
   guint count;
@@ -499,24 +503,34 @@ gst_rtp_h264_pay_set_sps_pps (GstRTPBasePayload * basepayload)
   }
 
   if (G_LIKELY (count)) {
-    if (payloader->profile != 0) {
-      /* profile is 24 bit. Force it to respect the limit */
-      profile = g_strdup_printf ("%06x", payloader->profile & 0xffffff);
-      /* combine into output caps */
-      res = gst_rtp_base_payload_set_outcaps (basepayload,
-          "packetization-mode", G_TYPE_STRING, "1",
-          "profile-level-id", G_TYPE_STRING, profile,
-          "sprop-parameter-sets", G_TYPE_STRING, sprops->str, NULL);
-      g_free (profile);
-    } else {
-      res = gst_rtp_base_payload_set_outcaps (basepayload,
-          "packetization-mode", G_TYPE_STRING, "1",
-          "sprop-parameter-sets", G_TYPE_STRING, sprops->str, NULL);
+    gchar *profile_level;
+
+    gst_structure_set (s,
+        "packetization-mode", G_TYPE_STRING, "1",
+        "sprop-parameter-sets", G_TYPE_STRING, sprops->str, NULL);
+
+    if (payloader->profile_level != 0) {
+      guint8 sps[2] = {
+        payloader->profile_level >> 16,
+        payloader->profile_level >> 8,
+      };
+
+      profile_level =
+          g_strdup_printf ("%06x", payloader->profile_level & 0xffffff);
+      gst_structure_set (s,
+          "profile-level-id", G_TYPE_STRING, profile_level,
+          "profile", G_TYPE_STRING, gst_codec_utils_h264_get_profile (sps, 2),
+          NULL);
+
+      g_free (profile_level);
     }
 
+    /* combine into output caps */
+    res = gst_rtp_base_payload_set_outcaps_structure (basepayload, s);
   } else {
     res = gst_rtp_base_payload_set_outcaps (basepayload, NULL);
   }
+  gst_structure_free (s);
   g_string_free (sprops, TRUE);
 
   return res;
@@ -588,8 +602,8 @@ gst_rtp_h264_pay_setcaps (GstRTPBasePayload * basepayload, GstCaps * caps)
     /* AVCProfileIndication */
     /* profile_compat */
     /* AVCLevelIndication */
-    rtph264pay->profile = (data[1] << 16) | (data[2] << 8) | data[3];
-    GST_DEBUG_OBJECT (rtph264pay, "profile %06x", rtph264pay->profile);
+    rtph264pay->profile_level = (data[1] << 16) | (data[2] << 8) | data[3];
+    GST_DEBUG_OBJECT (rtph264pay, "profile %06x", rtph264pay->profile_level);
 
     /* 6 bits reserved | 2 bits lengthSizeMinusOne */
     /* this is the number of bytes in front of the NAL units to mark their
@@ -1060,7 +1074,7 @@ gst_rtp_h264_pay_payload_nal_fragment (GstRTPBasePayload * basepayload,
     /* use buffer lists
      * create buffer without payload containing only the RTP header
      * (memory block at index 0) */
-    outbuf = gst_rtp_buffer_new_allocate (2, 0, 0);
+    outbuf = gst_rtp_base_payload_allocate_output_buffer (basepayload, 2, 0, 0);
 
     gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
 
@@ -1071,6 +1085,8 @@ gst_rtp_h264_pay_payload_nal_fragment (GstRTPBasePayload * basepayload,
     /* If it's the last fragment and the end of this au, mark the end of
      * slice */
     gst_rtp_buffer_set_marker (&rtp, last_fragment && end_of_au);
+    if (last_fragment && end_of_au)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
 
     /* FU indicator */
     payload[0] = (nal_header & 0x60) | FU_A_TYPE_ID;
@@ -1122,12 +1138,14 @@ gst_rtp_h264_pay_payload_nal_single (GstRTPBasePayload * basepayload,
 
   /* create buffer without payload containing only the RTP header
    * (memory block at index 0) */
-  outbuf = gst_rtp_buffer_new_allocate (0, 0, 0);
+  outbuf = gst_rtp_base_payload_allocate_output_buffer (basepayload, 0, 0, 0);
 
   gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
 
   /* Mark the end of a frame */
   gst_rtp_buffer_set_marker (&rtp, end_of_au);
+  if (end_of_au)
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
 
   /* timestamp the outbuffer */
   GST_BUFFER_PTS (outbuf) = pts;
@@ -1809,10 +1827,3 @@ gst_rtp_h264_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_h264_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph264pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H264_PAY);
-}
diff --git a/gst/rtp/gstrtph264pay.h b/gst/rtp/gstrtph264pay.h
index 879394bfa..c983a9251 100644
--- a/gst/rtp/gstrtph264pay.h
+++ b/gst/rtp/gstrtph264pay.h
@@ -65,7 +65,7 @@ struct _GstRtpH264Pay
 {
   GstRTPBasePayload payload;
 
-  guint profile;
+  guint profile_level;
   GPtrArray *sps, *pps;
 
   GstH264StreamFormat stream_format;
@@ -104,8 +104,6 @@ struct _GstRtpH264PayClass
 
 GType gst_rtp_h264_pay_get_type (void);
 
-gboolean gst_rtp_h264_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_H264_PAY_H__ */
diff --git a/gst/rtp/gstrtph265depay.c b/gst/rtp/gstrtph265depay.c
index 46553f0e1..41d2762ff 100644
--- a/gst/rtp/gstrtph265depay.c
+++ b/gst/rtp/gstrtph265depay.c
@@ -28,6 +28,7 @@
 #include <gst/base/gstbitreader.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "gstrtph265depay.h"
 #include "gstrtputils.h"
 
@@ -95,8 +96,11 @@ GST_STATIC_PAD_TEMPLATE ("sink",
     );
 
 #define gst_rtp_h265_depay_parent_class parent_class
-G_DEFINE_TYPE (GstRtpH265Depay, gst_rtp_h265_depay,
-    GST_TYPE_RTP_BASE_DEPAYLOAD);
+G_DEFINE_TYPE_WITH_CODE (GstRtpH265Depay, gst_rtp_h265_depay,
+    GST_TYPE_RTP_BASE_DEPAYLOAD, GST_DEBUG_CATEGORY_INIT (rtph265depay_debug,
+        "rtph265depay", 0, "H265 Video RTP Depayloader"));
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph265depay, "rtph265depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H265_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_h265_depay_finalize (GObject * object);
 
@@ -460,7 +464,6 @@ gst_rtp_h265_set_src_caps (GstRtpH265Depay * rtph265depay)
     gst_rtp_read_golomb (&br, &chroma_format_idc);      /* chroma_format_idc */
 
     if (chroma_format_idc == 3)
-
       gst_bit_reader_get_bits_uint8 (&br, &tmp8, 1);    /* separate_colour_plane_flag */
 
     gst_rtp_read_golomb (&br, &tmp);    /* pic_width_in_luma_samples */
@@ -1634,13 +1637,3 @@ gst_rtp_h265_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_h265_depay_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (rtph265depay_debug, "rtph265depay", 0,
-      "H265 Video RTP Depayloader");
-
-  return gst_element_register (plugin, "rtph265depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H265_DEPAY);
-}
diff --git a/gst/rtp/gstrtph265depay.h b/gst/rtp/gstrtph265depay.h
index b3b55ee7b..505bdb5cd 100644
--- a/gst/rtp/gstrtph265depay.h
+++ b/gst/rtp/gstrtph265depay.h
@@ -108,8 +108,6 @@ typedef struct
 
 GType gst_rtp_h265_depay_get_type (void);
 
-gboolean gst_rtp_h265_depay_plugin_init (GstPlugin * plugin);
-
 gboolean gst_rtp_h265_add_vps_sps_pps (GstElement * rtph265, GPtrArray * vps,
     GPtrArray * sps, GPtrArray * pps, GstBuffer * nal);
 
diff --git a/gst/rtp/gstrtph265pay.c b/gst/rtp/gstrtph265pay.c
index 3793ad613..82b68cce9 100644
--- a/gst/rtp/gstrtph265pay.c
+++ b/gst/rtp/gstrtph265pay.c
@@ -32,6 +32,7 @@
 /* Included to not duplicate gst_rtp_h265_add_vps_sps_pps () */
 #include "gstrtph265depay.h"
 
+#include "gstrtpelements.h"
 #include "gstrtph265pay.h"
 #include "gstrtputils.h"
 #include "gstbuffermemory.h"
@@ -166,6 +167,8 @@ static void gst_rtp_h265_pay_reset_bundle (GstRtpH265Pay * rtph265pay);
 
 #define gst_rtp_h265_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpH265Pay, gst_rtp_h265_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtph265pay, "rtph265pay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_H265_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_h265_pay_class_init (GstRtpH265PayClass * klass)
@@ -919,21 +922,24 @@ gst_rtp_h265_pay_decode_nal (GstRtpH265Pay * payloader,
 }
 
 static GstFlowReturn gst_rtp_h265_pay_payload_nal (GstRTPBasePayload *
-    basepayload, GPtrArray * paybufs, GstClockTime dts, GstClockTime pts);
+    basepayload, GPtrArray * paybufs, GstClockTime dts, GstClockTime pts,
+    gboolean delta_unit);
 static GstFlowReturn gst_rtp_h265_pay_payload_nal_single (GstRTPBasePayload *
     basepayload, GstBuffer * paybuf, GstClockTime dts, GstClockTime pts,
-    gboolean marker);
+    gboolean marker, gboolean delta_unit);
 static GstFlowReturn gst_rtp_h265_pay_payload_nal_fragment (GstRTPBasePayload *
     basepayload, GstBuffer * paybuf, GstClockTime dts, GstClockTime pts,
-    gboolean marker, guint mtu, guint8 nal_type, const guint8 * nal_header,
-    int size);
+    gboolean marker, gboolean delta_unit, guint mtu, guint8 nal_type,
+    const guint8 * nal_header, int size);
 static GstFlowReturn gst_rtp_h265_pay_payload_nal_bundle (GstRTPBasePayload *
     basepayload, GstBuffer * paybuf, GstClockTime dts, GstClockTime pts,
-    gboolean marker, guint8 nal_type, const guint8 * nal_header, int size);
+    gboolean marker, gboolean delta_unit, guint8 nal_type,
+    const guint8 * nal_header, int size);
 
 static GstFlowReturn
 gst_rtp_h265_pay_send_vps_sps_pps (GstRTPBasePayload * basepayload,
-    GstRtpH265Pay * rtph265pay, GstClockTime dts, GstClockTime pts)
+    GstRtpH265Pay * rtph265pay, GstClockTime dts, GstClockTime pts,
+    gboolean delta_unit)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   gboolean sent_all_vps_sps_pps = TRUE;
@@ -964,7 +970,7 @@ gst_rtp_h265_pay_send_vps_sps_pps (GstRTPBasePayload * basepayload,
     g_ptr_array_add (bufs, gst_buffer_ref (pps_buf));
   }
 
-  ret = gst_rtp_h265_pay_payload_nal (basepayload, bufs, dts, pts);
+  ret = gst_rtp_h265_pay_payload_nal (basepayload, bufs, dts, pts, FALSE);
   if (ret != GST_FLOW_OK) {
     /* not critical but warn */
     GST_WARNING_OBJECT (basepayload, "failed pushing VPS/SPS/PPS");
@@ -990,7 +996,8 @@ gst_rtp_h265_pay_reset_bundle (GstRtpH265Pay * rtph265pay)
 
 static GstFlowReturn
 gst_rtp_h265_pay_payload_nal (GstRTPBasePayload * basepayload,
-    GPtrArray * paybufs, GstClockTime dts, GstClockTime pts)
+    GPtrArray * paybufs, GstClockTime dts, GstClockTime pts,
+    gboolean delta_unit)
 {
   GstRtpH265Pay *rtph265pay;
   guint mtu;
@@ -1100,7 +1107,8 @@ gst_rtp_h265_pay_payload_nal (GstRTPBasePayload * basepayload,
       sent_ps = TRUE;
       GST_DEBUG_OBJECT (rtph265pay, "sending VPS/SPS/PPS before current frame");
       ret =
-          gst_rtp_h265_pay_send_vps_sps_pps (basepayload, rtph265pay, dts, pts);
+          gst_rtp_h265_pay_send_vps_sps_pps (basepayload, rtph265pay, dts, pts,
+          delta_unit);
       if (ret != GST_FLOW_OK) {
         gst_buffer_unref (paybuf);
         continue;
@@ -1109,10 +1117,10 @@ gst_rtp_h265_pay_payload_nal (GstRTPBasePayload * basepayload,
 
     if (rtph265pay->aggregate_mode != GST_RTP_H265_AGGREGATE_NONE)
       ret = gst_rtp_h265_pay_payload_nal_bundle (basepayload, paybuf, dts, pts,
-          marker, nal_type, nal_header, size);
+          marker, delta_unit, nal_type, nal_header, size);
     else
       ret = gst_rtp_h265_pay_payload_nal_fragment (basepayload, paybuf, dts,
-          pts, marker, mtu, nal_type, nal_header, size);
+          pts, marker, delta_unit, mtu, nal_type, nal_header, size);
   }
 
   g_ptr_array_free (paybufs, TRUE);
@@ -1122,7 +1130,8 @@ gst_rtp_h265_pay_payload_nal (GstRTPBasePayload * basepayload,
 
 static GstFlowReturn
 gst_rtp_h265_pay_payload_nal_single (GstRTPBasePayload * basepayload,
-    GstBuffer * paybuf, GstClockTime dts, GstClockTime pts, gboolean marker)
+    GstBuffer * paybuf, GstClockTime dts, GstClockTime pts, gboolean marker,
+    gboolean delta_unit)
 {
   GstBufferList *outlist;
   GstBuffer *outbuf;
@@ -1131,12 +1140,16 @@ gst_rtp_h265_pay_payload_nal_single (GstRTPBasePayload * basepayload,
   /* use buffer lists
    * create buffer without payload containing only the RTP header
    * (memory block at index 0) */
-  outbuf = gst_rtp_buffer_new_allocate (0, 0, 0);
+  outbuf = gst_rtp_base_payload_allocate_output_buffer (basepayload, 0, 0, 0);
 
   gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
 
   /* Mark the end of a frame */
   gst_rtp_buffer_set_marker (&rtp, marker);
+  GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
+
+  if (delta_unit)
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DELTA_UNIT);
 
   /* timestamp the outbuffer */
   GST_BUFFER_PTS (outbuf) = pts;
@@ -1160,6 +1173,7 @@ gst_rtp_h265_pay_payload_nal_single (GstRTPBasePayload * basepayload,
 static GstFlowReturn
 gst_rtp_h265_pay_payload_nal_fragment (GstRTPBasePayload * basepayload,
     GstBuffer * paybuf, GstClockTime dts, GstClockTime pts, gboolean marker,
+    gboolean delta_unit,
     guint mtu, guint8 nal_type, const guint8 * nal_header, int size)
 {
   GstRtpH265Pay *rtph265pay = (GstRtpH265Pay *) basepayload;
@@ -1175,7 +1189,7 @@ gst_rtp_h265_pay_payload_nal_fragment (GstRTPBasePayload * basepayload,
         "NAL Unit fit in one packet datasize=%d mtu=%d", size, mtu);
     /* will fit in one packet */
     return gst_rtp_h265_pay_payload_nal_single (basepayload, paybuf, dts, pts,
-        marker);
+        marker, delta_unit);
   }
 
   GST_DEBUG_OBJECT (basepayload,
@@ -1206,7 +1220,7 @@ gst_rtp_h265_pay_payload_nal_fragment (GstRTPBasePayload * basepayload,
     /* use buffer lists
      * create buffer without payload containing only the RTP header
      * (memory block at index 0), and with space for PayloadHdr and FU header */
-    outbuf = gst_rtp_buffer_new_allocate (3, 0, 0);
+    outbuf = gst_rtp_base_payload_allocate_output_buffer (basepayload, 3, 0, 0);
 
     gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
 
@@ -1221,6 +1235,8 @@ gst_rtp_h265_pay_payload_nal_fragment (GstRTPBasePayload * basepayload,
     /* If it's the last fragment and the end of this au, mark the end of
      * slice */
     gst_rtp_buffer_set_marker (&rtp, last_fragment && marker);
+    if (last_fragment && marker)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
 
     /* FU Header */
     payload[2] = (first_fragment << 7) | (last_fragment << 6) |
@@ -1232,6 +1248,12 @@ gst_rtp_h265_pay_payload_nal_fragment (GstRTPBasePayload * basepayload,
     gst_rtp_copy_video_meta (rtph265pay, outbuf, paybuf);
     gst_buffer_copy_into (outbuf, paybuf, GST_BUFFER_COPY_MEMORY, pos,
         fragment_size);
+    if (!delta_unit)
+      /* only the first packet sent should not have the flag */
+      delta_unit = TRUE;
+    else
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_DELTA_UNIT);
+
     /* add the buffer to the buffer list */
     gst_buffer_list_add (outlist, outbuf);
   }
@@ -1250,6 +1272,7 @@ gst_rtp_h265_pay_send_bundle (GstRtpH265Pay * rtph265pay, gboolean marker)
   guint length, bundle_size;
   GstBuffer *first, *outbuf;
   GstClockTime dts, pts;
+  gboolean delta_unit;
 
   bundle_size = rtph265pay->bundle_size;
 
@@ -1265,6 +1288,7 @@ gst_rtp_h265_pay_send_bundle (GstRtpH265Pay * rtph265pay, gboolean marker)
   first = gst_buffer_list_get (bundle, 0);
   dts = GST_BUFFER_DTS (first);
   pts = GST_BUFFER_PTS (first);
+  delta_unit = GST_BUFFER_FLAG_IS_SET (first, GST_BUFFER_FLAG_DELTA_UNIT);
 
   if (length == 1) {
     /* Push unaggregated NALU */
@@ -1324,13 +1348,14 @@ gst_rtp_h265_pay_send_bundle (GstRtpH265Pay * rtph265pay, gboolean marker)
 
   gst_rtp_h265_pay_reset_bundle (rtph265pay);
   return gst_rtp_h265_pay_payload_nal_single (basepayload, outbuf, dts, pts,
-      marker);
+      marker, delta_unit);
 }
 
 static gboolean
 gst_rtp_h265_pay_payload_nal_bundle (GstRTPBasePayload * basepayload,
     GstBuffer * paybuf, GstClockTime dts, GstClockTime pts,
-    gboolean marker, guint8 nal_type, const guint8 * nal_header, int size)
+    gboolean marker, gboolean delta_unit, guint8 nal_type,
+    const guint8 * nal_header, int size)
 {
   GstRtpH265Pay *rtph265pay;
   GstFlowReturn ret;
@@ -1380,7 +1405,7 @@ gst_rtp_h265_pay_payload_nal_bundle (GstRTPBasePayload * basepayload,
       goto out;
 
     return gst_rtp_h265_pay_payload_nal_fragment (basepayload, paybuf, dts, pts,
-        marker, mtu, nal_type, nal_header, size);
+        marker, delta_unit, mtu, nal_type, nal_header, size);
   }
 
   bundle_size = rtph265pay->bundle_size + pay_size;
@@ -1412,6 +1437,11 @@ gst_rtp_h265_pay_payload_nal_bundle (GstRTPBasePayload * basepayload,
   GST_BUFFER_PTS (paybuf) = pts;
   GST_BUFFER_DTS (paybuf) = dts;
 
+  if (delta_unit)
+    GST_BUFFER_FLAG_SET (paybuf, GST_BUFFER_FLAG_DELTA_UNIT);
+  else
+    GST_BUFFER_FLAG_UNSET (paybuf, GST_BUFFER_FLAG_DELTA_UNIT);
+
   gst_buffer_list_add (bundle, gst_buffer_ref (paybuf));
   rtph265pay->bundle_size += pay_size;
   ret = GST_FLOW_OK;
@@ -1446,6 +1476,7 @@ gst_rtp_h265_pay_handle_buffer (GstRTPBasePayload * basepayload,
   gboolean hevc;
   GstBuffer *paybuf = NULL;
   gsize skip;
+  gboolean delayed_not_delta_unit = FALSE;
   gboolean marker = FALSE;
   gboolean discont = FALSE;
   gboolean draining = (buffer == NULL);
@@ -1463,8 +1494,14 @@ gst_rtp_h265_pay_handle_buffer (GstRTPBasePayload * basepayload,
       return GST_FLOW_OK;
   } else {
     if (buffer) {
-      if (gst_adapter_available (rtph265pay->adapter) == 0)
-        discont = GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT);
+      if (!GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT)) {
+        if (gst_adapter_available (rtph265pay->adapter) == 0)
+          rtph265pay->delta_unit = FALSE;
+        else
+          delayed_not_delta_unit = TRUE;
+      }
+
+      discont = GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DISCONT);
       marker = GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_MARKER);
       gst_adapter_push (rtph265pay->adapter, buffer);
       buffer = NULL;
@@ -1500,6 +1537,8 @@ gst_rtp_h265_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
     pts = GST_BUFFER_PTS (buffer);
     dts = GST_BUFFER_DTS (buffer);
+    rtph265pay->delta_unit = GST_BUFFER_FLAG_IS_SET (buffer,
+        GST_BUFFER_FLAG_DELTA_UNIT);
     marker = GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_MARKER);
     GST_DEBUG_OBJECT (basepayload, "got %" G_GSIZE_FORMAT " bytes",
         remaining_buffer_size);
@@ -1553,7 +1592,13 @@ gst_rtp_h265_pay_handle_buffer (GstRTPBasePayload * basepayload,
       offset += nal_len;
       remaining_buffer_size -= nal_len;
     }
-    ret = gst_rtp_h265_pay_payload_nal (basepayload, paybufs, dts, pts);
+    ret =
+        gst_rtp_h265_pay_payload_nal (basepayload, paybufs, dts, pts,
+        rtph265pay->delta_unit);
+
+    if (!rtph265pay->delta_unit)
+      /* only the first outgoing packet doesn't have the DELTA_UNIT flag */
+      rtph265pay->delta_unit = TRUE;
 
     gst_buffer_memory_unmap (&memory);
     gst_buffer_unref (buffer);
@@ -1668,12 +1713,22 @@ gst_rtp_h265_pay_handle_buffer (GstRTPBasePayload * basepayload,
         discont = FALSE;
       }
 
+      if (delayed_not_delta_unit) {
+        rtph265pay->delta_unit = FALSE;
+        delayed_not_delta_unit = FALSE;
+      } else {
+        /* only the first outgoing packet doesn't have the DELTA_UNIT flag */
+        rtph265pay->delta_unit = TRUE;
+      }
+
       /* move to next NAL packet */
       /* Skips the trailing zeros */
       gst_adapter_flush (rtph265pay->adapter, nal_len - size);
     }
     /* put the data in one or more RTP packets */
-    ret = gst_rtp_h265_pay_payload_nal (basepayload, paybufs, dts, pts);
+    ret =
+        gst_rtp_h265_pay_payload_nal (basepayload, paybufs, dts, pts,
+        rtph265pay->delta_unit);
     g_array_set_size (nal_queue, 0);
   }
 
@@ -1821,10 +1876,3 @@ gst_rtp_h265_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_h265_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtph265pay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_H265_PAY);
-}
diff --git a/gst/rtp/gstrtph265pay.h b/gst/rtp/gstrtph265pay.h
index 6d1409558..f2829d0a9 100644
--- a/gst/rtp/gstrtph265pay.h
+++ b/gst/rtp/gstrtph265pay.h
@@ -73,6 +73,9 @@ struct _GstRtpH265Pay
   gboolean send_vps_sps_pps;
   GstClockTime last_vps_sps_pps;
 
+  /* TRUE if the next NALU processed should have the DELTA_UNIT flag */
+  gboolean delta_unit;
+
   /* aggregate buffers with AP */
   GstBufferList *bundle;
   guint bundle_size;
@@ -87,7 +90,5 @@ struct _GstRtpH265PayClass
 
 GType gst_rtp_h265_pay_get_type (void);
 
-gboolean gst_rtp_h265_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_H265_PAY_H__ */
diff --git a/gst/rtp/gstrtphdrext-colorspace.c b/gst/rtp/gstrtphdrext-colorspace.c
new file mode 100644
index 000000000..5a77e3d8f
--- /dev/null
+++ b/gst/rtp/gstrtphdrext-colorspace.c
@@ -0,0 +1,483 @@
+/* GStreamer
+ * Copyright (C) 2020-2021 Collabora Ltd.
+ *   @author: Jakub Adam <jakub.adam@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:rtphdrextcolorspace
+ * @title: GstRtphdrext-Colorspace
+ * @short_description: Helper methods for dealing with Color Space RTP header
+ * extension as defined in  http://www.webrtc.org/experiments/rtp-hdrext/color-space
+ * @see_also: #GstRTPHeaderExtension, #GstRTPBasePayload, #GstRTPBaseDepayload
+ *
+ * Since: 1.20
+ */
+
+#include "gstrtphdrext-colorspace.h"
+
+#include "gstrtpelements.h"
+
+#include <gst/base/gstbytereader.h>
+#include <gst/video/video-color.h>
+#include <gst/video/video-hdr.h>
+
+GST_DEBUG_CATEGORY_STATIC (rtphdrext_colorspace_debug);
+#define GST_CAT_DEFAULT (rtphdrext_colorspace_debug)
+
+/**
+ * GstRTPHeaderExtensionColorspace:
+ * @parent: the parent #GstRTPHeaderExtension
+ *
+ * Instance struct for Color Space RTP header extension.
+ *
+ * http://www.webrtc.org/experiments/rtp-hdrext/color-space
+ */
+struct _GstRTPHeaderExtensionColorspace
+{
+  GstRTPHeaderExtension parent;
+
+  GstVideoColorimetry colorimetry;
+  GstVideoChromaSite chroma_site;
+  GstVideoMasteringDisplayInfo mdi;
+  GstVideoContentLightLevel cll;
+  gboolean has_hdr_meta;
+};
+
+G_DEFINE_TYPE_WITH_CODE (GstRTPHeaderExtensionColorspace,
+    gst_rtp_header_extension_colorspace, GST_TYPE_RTP_HEADER_EXTENSION,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "rtphdrextcolorspace", 0,
+        "RTP Color Space Header Extension");
+    );
+GST_ELEMENT_REGISTER_DEFINE (rtphdrextcolorspace, "rtphdrextcolorspace",
+    GST_RANK_MARGINAL, GST_TYPE_RTP_HEADER_EXTENSION_COLORSPACE);
+
+static void
+gst_rtp_header_extension_colorspace_init (GstRTPHeaderExtensionColorspace *
+    self)
+{
+}
+
+static GstRTPHeaderExtensionFlags
+gst_rtp_header_extension_colorspace_get_supported_flags (GstRTPHeaderExtension *
+    ext)
+{
+  GstRTPHeaderExtensionColorspace *self =
+      GST_RTP_HEADER_EXTENSION_COLORSPACE (ext);
+
+  return self->has_hdr_meta ?
+      GST_RTP_HEADER_EXTENSION_TWO_BYTE : GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+}
+
+static gsize
+gst_rtp_header_extension_colorspace_get_max_size (GstRTPHeaderExtension * ext,
+    const GstBuffer * buffer)
+{
+  GstRTPHeaderExtensionColorspace *self =
+      GST_RTP_HEADER_EXTENSION_COLORSPACE (ext);
+
+  return self->has_hdr_meta ?
+      GST_RTP_HDREXT_COLORSPACE_WITH_HDR_META_SIZE :
+      GST_RTP_HDREXT_COLORSPACE_SIZE;
+}
+
+static gssize
+gst_rtp_header_extension_colorspace_write (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstRTPHeaderExtensionColorspace *self =
+      GST_RTP_HEADER_EXTENSION_COLORSPACE (ext);
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  gboolean is_frame_last_buffer;
+  guint8 *ptr = data;
+  guint8 range;
+  guint8 horizontal_site;
+  guint8 vertical_site;
+
+  g_return_val_if_fail (size >=
+      gst_rtp_header_extension_colorspace_get_max_size (ext, NULL), -1);
+  g_return_val_if_fail (write_flags &
+      gst_rtp_header_extension_colorspace_get_supported_flags (ext), -1);
+
+  if (self->colorimetry.matrix == GST_VIDEO_COLOR_MATRIX_UNKNOWN &&
+      self->colorimetry.primaries == GST_VIDEO_COLOR_PRIMARIES_UNKNOWN &&
+      self->colorimetry.range == GST_VIDEO_COLOR_RANGE_UNKNOWN &&
+      self->colorimetry.transfer == GST_VIDEO_TRANSFER_UNKNOWN) {
+    /* Nothing to write. */
+    return 0;
+  }
+
+  gst_rtp_buffer_map (output, GST_MAP_READ, &rtp);
+  is_frame_last_buffer = gst_rtp_buffer_get_marker (&rtp);
+  gst_rtp_buffer_unmap (&rtp);
+
+  if (!is_frame_last_buffer) {
+    /* Only a video frame's final packet should carry color space info. */
+    return 0;
+  }
+
+  *ptr++ = gst_video_color_primaries_to_iso (self->colorimetry.primaries);
+  *ptr++ = gst_video_transfer_function_to_iso (self->colorimetry.transfer);
+  *ptr++ = gst_video_color_matrix_to_iso (self->colorimetry.matrix);
+
+  switch (self->colorimetry.range) {
+    case GST_VIDEO_COLOR_RANGE_0_255:
+      range = 2;
+      break;
+    case GST_VIDEO_COLOR_RANGE_16_235:
+      range = 1;
+      break;
+    default:
+      range = 0;
+      break;
+  }
+
+  if (self->chroma_site & GST_VIDEO_CHROMA_SITE_H_COSITED) {
+    horizontal_site = 1;
+  } else if (self->chroma_site & GST_VIDEO_CHROMA_SITE_NONE) {
+    horizontal_site = 2;
+  } else {
+    horizontal_site = 0;
+  }
+
+  if (self->chroma_site & GST_VIDEO_CHROMA_SITE_V_COSITED) {
+    vertical_site = 1;
+  } else if (self->chroma_site & GST_VIDEO_CHROMA_SITE_NONE) {
+    vertical_site = 2;
+  } else {
+    vertical_site = 0;
+  }
+
+  *ptr++ = (range << 4) + (horizontal_site << 2) + vertical_site;
+
+  if (self->has_hdr_meta) {
+    guint i;
+
+    GST_WRITE_UINT16_BE (ptr,
+        self->mdi.max_display_mastering_luminance / 10000);
+    ptr += 2;
+    GST_WRITE_UINT16_BE (ptr, self->mdi.min_display_mastering_luminance);
+    ptr += 2;
+
+    for (i = 0; i < 3; ++i) {
+      GST_WRITE_UINT16_BE (ptr, self->mdi.display_primaries[i].x);
+      ptr += 2;
+      GST_WRITE_UINT16_BE (ptr, self->mdi.display_primaries[i].y);
+      ptr += 2;
+    }
+
+    GST_WRITE_UINT16_BE (ptr, self->mdi.white_point.x);
+    ptr += 2;
+    GST_WRITE_UINT16_BE (ptr, self->mdi.white_point.y);
+    ptr += 2;
+
+    GST_WRITE_UINT16_BE (ptr, self->cll.max_content_light_level);
+    ptr += 2;
+    GST_WRITE_UINT16_BE (ptr, self->cll.max_frame_average_light_level);
+    ptr += 2;
+  }
+
+  return ptr - data;
+}
+
+static gboolean
+parse_colorspace (GstByteReader * reader, GstVideoColorimetry * colorimetry,
+    GstVideoChromaSite * chroma_site)
+{
+  guint8 val;
+
+  g_return_val_if_fail (reader != NULL, FALSE);
+  g_return_val_if_fail (colorimetry != NULL, FALSE);
+  g_return_val_if_fail (chroma_site != NULL, FALSE);
+
+  if (gst_byte_reader_get_remaining (reader) < GST_RTP_HDREXT_COLORSPACE_SIZE) {
+    return FALSE;
+  }
+
+  if (!gst_byte_reader_get_uint8 (reader, &val)) {
+    return FALSE;
+  }
+  colorimetry->primaries = gst_video_color_primaries_from_iso (val);
+
+  if (!gst_byte_reader_get_uint8 (reader, &val)) {
+    return FALSE;
+  }
+  colorimetry->transfer = gst_video_transfer_function_from_iso (val);
+
+  if (!gst_byte_reader_get_uint8 (reader, &val)) {
+    return FALSE;
+  }
+  colorimetry->matrix = gst_video_color_matrix_from_iso (val);
+
+  *chroma_site = GST_VIDEO_CHROMA_SITE_UNKNOWN;
+
+  if (!gst_byte_reader_get_uint8 (reader, &val)) {
+    return FALSE;
+  }
+  switch ((val >> 2) & 0x03) {
+    case 1:
+      *chroma_site |= GST_VIDEO_CHROMA_SITE_H_COSITED;
+      break;
+    case 2:
+      *chroma_site |= GST_VIDEO_CHROMA_SITE_NONE;
+      break;
+  }
+
+  switch (val & 0x03) {
+    case 1:
+      *chroma_site |= GST_VIDEO_CHROMA_SITE_V_COSITED;
+      break;
+    case 2:
+      *chroma_site |= GST_VIDEO_CHROMA_SITE_NONE;
+      break;
+  }
+
+  switch (val >> 4) {
+    case 1:
+      colorimetry->range = GST_VIDEO_COLOR_RANGE_16_235;
+      break;
+    case 2:
+      colorimetry->range = GST_VIDEO_COLOR_RANGE_0_255;
+      break;
+    default:
+      colorimetry->range = GST_VIDEO_COLOR_RANGE_UNKNOWN;
+      break;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+parse_colorspace_with_hdr_meta (GstByteReader * reader,
+    GstVideoColorimetry * colorimetry,
+    GstVideoChromaSite * chroma_site,
+    GstVideoMasteringDisplayInfo * mastering_display_info,
+    GstVideoContentLightLevel * content_light_level)
+{
+  guint i;
+  guint16 val16;
+
+  g_return_val_if_fail (reader != NULL, FALSE);
+  g_return_val_if_fail (mastering_display_info != NULL, FALSE);
+  g_return_val_if_fail (content_light_level != NULL, FALSE);
+
+  if (gst_byte_reader_get_remaining (reader) <
+      GST_RTP_HDREXT_COLORSPACE_WITH_HDR_META_SIZE) {
+    return FALSE;
+  }
+
+  if (!parse_colorspace (reader, colorimetry, chroma_site)) {
+    return FALSE;
+  }
+
+  if (!gst_byte_reader_get_uint16_be (reader, &val16)) {
+    return FALSE;
+  }
+  mastering_display_info->max_display_mastering_luminance = val16 * 10000;
+
+  if (!gst_byte_reader_get_uint16_be (reader, &val16)) {
+    return FALSE;
+  }
+  mastering_display_info->min_display_mastering_luminance = val16;
+
+  for (i = 0; i < 3; ++i) {
+    if (!gst_byte_reader_get_uint16_be (reader,
+            &mastering_display_info->display_primaries[i].x)) {
+      return FALSE;
+    }
+
+    if (!gst_byte_reader_get_uint16_be (reader,
+            &mastering_display_info->display_primaries[i].y)) {
+      return FALSE;
+    }
+  }
+
+  if (!gst_byte_reader_get_uint16_be (reader,
+          &mastering_display_info->white_point.x)) {
+    return FALSE;
+  }
+  if (!gst_byte_reader_get_uint16_be (reader,
+          &mastering_display_info->white_point.y)) {
+    return FALSE;
+  }
+
+  if (!gst_byte_reader_get_uint16_be (reader,
+          &content_light_level->max_content_light_level)) {
+    return FALSE;
+  }
+  if (!gst_byte_reader_get_uint16_be (reader,
+          &content_light_level->max_frame_average_light_level)) {
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+gst_rtp_header_extension_colorspace_read (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionFlags read_flags, const guint8 * data, gsize size,
+    GstBuffer * buffer)
+{
+  GstRTPHeaderExtensionColorspace *self =
+      GST_RTP_HEADER_EXTENSION_COLORSPACE (ext);
+  gboolean has_hdr_meta;
+  GstByteReader *reader;
+  GstVideoColorimetry colorimetry;
+  GstVideoChromaSite chroma_site;
+  GstVideoMasteringDisplayInfo mdi;
+  GstVideoContentLightLevel cll;
+  gboolean caps_update_needed;
+  gboolean result;
+
+  if (size != GST_RTP_HDREXT_COLORSPACE_SIZE &&
+      size != GST_RTP_HDREXT_COLORSPACE_WITH_HDR_META_SIZE) {
+    GST_WARNING_OBJECT (ext, "Invalid Color Space header extension size %"
+        G_GSIZE_FORMAT, size);
+    return FALSE;
+  }
+
+  has_hdr_meta = size == GST_RTP_HDREXT_COLORSPACE_WITH_HDR_META_SIZE;
+
+  reader = gst_byte_reader_new (data, size);
+
+  if (has_hdr_meta) {
+    result = parse_colorspace_with_hdr_meta (reader, &colorimetry, &chroma_site,
+        &mdi, &cll);
+  } else {
+    result = parse_colorspace (reader, &colorimetry, &chroma_site);
+  }
+
+  g_clear_pointer (&reader, gst_byte_reader_free);
+
+  if (!gst_video_colorimetry_is_equal (&self->colorimetry, &colorimetry)) {
+    caps_update_needed = TRUE;
+    self->colorimetry = colorimetry;
+  }
+
+  if (self->chroma_site != chroma_site) {
+    caps_update_needed = TRUE;
+    self->chroma_site = chroma_site;
+  }
+
+  if (self->has_hdr_meta != has_hdr_meta) {
+    caps_update_needed = TRUE;
+    self->has_hdr_meta = has_hdr_meta;
+  }
+
+  if (has_hdr_meta) {
+    if (!gst_video_mastering_display_info_is_equal (&self->mdi, &mdi)) {
+      caps_update_needed = TRUE;
+      self->mdi = mdi;
+    }
+    if (!gst_video_content_light_level_is_equal (&self->cll, &cll)) {
+      caps_update_needed = TRUE;
+      self->cll = cll;
+    }
+  }
+
+  if (caps_update_needed) {
+    gst_rtp_header_extension_set_wants_update_non_rtp_src_caps (ext, TRUE);
+  }
+
+  return result;
+}
+
+static gboolean
+    gst_rtp_header_extension_colorspace_set_non_rtp_sink_caps
+    (GstRTPHeaderExtension * ext, const GstCaps * caps)
+{
+  GstRTPHeaderExtensionColorspace *self =
+      GST_RTP_HEADER_EXTENSION_COLORSPACE (ext);
+  GstStructure *s;
+  const gchar *colorimetry;
+  const gchar *chroma_site;
+
+  s = gst_caps_get_structure (caps, 0);
+
+  colorimetry = gst_structure_get_string (s, "colorimetry");
+  if (colorimetry) {
+    gst_video_colorimetry_from_string (&self->colorimetry, colorimetry);
+
+    self->has_hdr_meta =
+        gst_video_mastering_display_info_from_caps (&self->mdi, caps);
+
+    gst_video_content_light_level_from_caps (&self->cll, caps);
+  }
+
+  chroma_site = gst_structure_get_string (s, "chroma-site");
+  if (chroma_site) {
+    self->chroma_site = gst_video_chroma_from_string (chroma_site);
+  }
+
+  return TRUE;
+}
+
+static gboolean
+    gst_rtp_header_extension_colorspace_update_non_rtp_src_caps
+    (GstRTPHeaderExtension * ext, GstCaps * caps)
+{
+  GstRTPHeaderExtensionColorspace *self =
+      GST_RTP_HEADER_EXTENSION_COLORSPACE (ext);
+
+  gchar *color_str;
+
+  gst_structure_remove_fields (gst_caps_get_structure (caps, 0),
+      "mastering-display-info", "content-light-level", NULL);
+
+  if ((color_str = gst_video_colorimetry_to_string (&self->colorimetry))) {
+    gst_caps_set_simple (caps, "colorimetry", G_TYPE_STRING, color_str, NULL);
+    g_free (color_str);
+  }
+  if (self->chroma_site != GST_VIDEO_CHROMA_SITE_UNKNOWN) {
+    gst_caps_set_simple (caps, "chroma-site", G_TYPE_STRING,
+        gst_video_chroma_to_string (self->chroma_site), NULL);
+  }
+  if (self->has_hdr_meta) {
+    gst_video_mastering_display_info_add_to_caps (&self->mdi, caps);
+    gst_video_content_light_level_add_to_caps (&self->cll, caps);
+  }
+
+  return TRUE;
+}
+
+static void
+    gst_rtp_header_extension_colorspace_class_init
+    (GstRTPHeaderExtensionColorspaceClass * klass)
+{
+  GstRTPHeaderExtensionClass *rtp_hdr_class =
+      GST_RTP_HEADER_EXTENSION_CLASS (klass);
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  rtp_hdr_class->get_supported_flags =
+      gst_rtp_header_extension_colorspace_get_supported_flags;
+  rtp_hdr_class->get_max_size =
+      gst_rtp_header_extension_colorspace_get_max_size;
+  rtp_hdr_class->write = gst_rtp_header_extension_colorspace_write;
+  rtp_hdr_class->read = gst_rtp_header_extension_colorspace_read;
+  rtp_hdr_class->set_non_rtp_sink_caps =
+      gst_rtp_header_extension_colorspace_set_non_rtp_sink_caps;
+  rtp_hdr_class->update_non_rtp_src_caps =
+      gst_rtp_header_extension_colorspace_update_non_rtp_src_caps;
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "Color Space", GST_RTP_HDREXT_ELEMENT_CLASS,
+      "Extends RTP packets with color space and high dynamic range (HDR) information.",
+      "Jakub Adam <jakub.adam@collabora.com>");
+  gst_rtp_header_extension_class_set_uri (rtp_hdr_class,
+      GST_RTP_HDREXT_COLORSPACE_URI);
+}
diff --git a/gst/rtp/gstrtphdrext-colorspace.h b/gst/rtp/gstrtphdrext-colorspace.h
new file mode 100644
index 000000000..c451cc63f
--- /dev/null
+++ b/gst/rtp/gstrtphdrext-colorspace.h
@@ -0,0 +1,41 @@
+/* GStreamer
+ * Copyright (C) 2020-2021 Collabora Ltd.
+ *   @author: Jakub Adam <jakub.adam@collabora.com>
+ *
+ * gstrtphdrext-colorspace.h: Color Space RTP header extension
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_RTPHDREXT_COLORSPACE_H__
+#define __GST_RTPHDREXT_COLORSPACE_H__
+
+#include <gst/rtp/gstrtphdrext.h>
+
+G_BEGIN_DECLS
+
+#define GST_RTP_HDREXT_COLORSPACE_SIZE 4
+#define GST_RTP_HDREXT_COLORSPACE_WITH_HDR_META_SIZE 28
+#define GST_RTP_HDREXT_COLORSPACE_URI "http://www.webrtc.org/experiments/rtp-hdrext/color-space"
+
+#define GST_TYPE_RTP_HEADER_EXTENSION_COLORSPACE (gst_rtp_header_extension_colorspace_get_type())
+
+G_DECLARE_FINAL_TYPE (GstRTPHeaderExtensionColorspace, gst_rtp_header_extension_colorspace,
+  GST, RTP_HEADER_EXTENSION_COLORSPACE, GstRTPHeaderExtension)
+
+G_END_DECLS
+
+#endif /* __GST_RTPHDREXT_COLORSPACE_H__ */
diff --git a/gst/rtp/gstrtpilbcdepay.c b/gst/rtp/gstrtpilbcdepay.c
index 0b020afd7..043e065d7 100644
--- a/gst/rtp/gstrtpilbcdepay.c
+++ b/gst/rtp/gstrtpilbcdepay.c
@@ -25,6 +25,7 @@
 #include <stdlib.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpilbcdepay.h"
 #include "gstrtputils.h"
 
@@ -74,6 +75,8 @@ static gboolean gst_rtp_ilbc_depay_setcaps (GstRTPBaseDepayload * depayload,
 #define gst_rtp_ilbc_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPiLBCDepay, gst_rtp_ilbc_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpilbcdepay, "rtpilbcdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_ILBC_DEPAY, rtp_element_init (plugin));
 
 #define GST_TYPE_ILBC_MODE (gst_ilbc_mode_get_type())
 static GType
@@ -230,10 +233,3 @@ gst_ilbc_depay_get_property (GObject * object,
       break;
   }
 }
-
-gboolean
-gst_rtp_ilbc_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpilbcdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_ILBC_DEPAY);
-}
diff --git a/gst/rtp/gstrtpilbcdepay.h b/gst/rtp/gstrtpilbcdepay.h
index 01fd225ea..b016004e4 100644
--- a/gst/rtp/gstrtpilbcdepay.h
+++ b/gst/rtp/gstrtpilbcdepay.h
@@ -58,8 +58,6 @@ struct _GstRTPiLBCDepayClass
 
 GType gst_rtp_ilbc_depay_get_type (void);
 
-gboolean gst_rtp_ilbc_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_ILBC_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpilbcpay.c b/gst/rtp/gstrtpilbcpay.c
index cbc7d93de..0048045ae 100644
--- a/gst/rtp/gstrtpilbcpay.c
+++ b/gst/rtp/gstrtpilbcpay.c
@@ -23,6 +23,7 @@
 
 #include <stdlib.h>
 #include <gst/rtp/gstrtpbuffer.h>
+#include "gstrtpelements.h"
 #include "gstrtpilbcpay.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpilbcpay_debug);
@@ -56,6 +57,8 @@ static gboolean gst_rtp_ilbc_pay_sink_setcaps (GstRTPBasePayload * payload,
 #define gst_rtp_ilbc_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPILBCPay, gst_rtp_ilbc_pay,
     GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpilbcpay, "rtpilbcpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_ILBC_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_ilbc_pay_class_init (GstRTPILBCPayClass * klass)
@@ -219,10 +222,3 @@ gst_rtp_ilbc_pay_sink_getcaps (GstRTPBasePayload * rtppayload, GstPad * pad,
 
   return caps;
 }
-
-gboolean
-gst_rtp_ilbc_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpilbcpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_ILBC_PAY);
-}
diff --git a/gst/rtp/gstrtpilbcpay.h b/gst/rtp/gstrtpilbcpay.h
index 14363c077..d30c11239 100644
--- a/gst/rtp/gstrtpilbcpay.h
+++ b/gst/rtp/gstrtpilbcpay.h
@@ -53,8 +53,6 @@ struct _GstRTPILBCPayClass
 
 GType gst_rtp_ilbc_pay_get_type (void);
 
-gboolean gst_rtp_ilbc_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_ILBC_PAY_H__ */
diff --git a/gst/rtp/gstrtpisacdepay.c b/gst/rtp/gstrtpisacdepay.c
new file mode 100644
index 000000000..bac1fa048
--- /dev/null
+++ b/gst/rtp/gstrtpisacdepay.c
@@ -0,0 +1,147 @@
+/* GStreamer
+ * Copyright (C) 2020 Collabora Ltd.
+ *  Author: Guillaume Desmottes <guillaume.desmottes@collabora.com>, Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-rtpisacdepay
+ * @title: rtpisacdepay
+ * @short_description: iSAC RTP Depayloader
+ *
+ * Since: 1.20
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <gst/rtp/gstrtpbuffer.h>
+#include <gst/audio/audio.h>
+
+#include "gstrtpelements.h"
+#include "gstrtpisacdepay.h"
+#include "gstrtputils.h"
+
+GST_DEBUG_CATEGORY_STATIC (rtpisacdepay_debug);
+#define GST_CAT_DEFAULT (rtpisacdepay_debug)
+
+static GstStaticPadTemplate gst_rtp_isac_depay_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("application/x-rtp, "
+        "media = (string) \"audio\", "
+        "payload = (int) " GST_RTP_PAYLOAD_DYNAMIC_STRING ", "
+        "clock-rate =  (int) { 16000, 32000 }, "
+        "encoding-name = (string) \"ISAC\"")
+    );
+
+static GstStaticPadTemplate gst_rtp_isac_depay_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/isac, "
+        "rate = (int) { 16000, 32000 }, " "channels = (int) 1")
+    );
+
+struct _GstRtpIsacDepay
+{
+  /*< private > */
+  GstRTPBaseDepayload parent;
+
+  guint64 packet;
+};
+
+#define gst_rtp_isac_depay_parent_class parent_class
+G_DEFINE_TYPE (GstRtpIsacDepay, gst_rtp_isac_depay,
+    GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpisacdepay, "rtpisacdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_ISAC_DEPAY, rtp_element_init (plugin));
+
+static gboolean
+gst_rtp_isac_depay_setcaps (GstRTPBaseDepayload * depayload, GstCaps * caps)
+{
+  GstCaps *src_caps;
+  GstStructure *s;
+  gint rate;
+  gboolean ret;
+
+  GST_DEBUG_OBJECT (depayload, "sink caps: %" GST_PTR_FORMAT, caps);
+
+  s = gst_caps_get_structure (caps, 0);
+  if (!gst_structure_get_int (s, "clock-rate", &rate)) {
+    GST_ERROR_OBJECT (depayload, "Missing 'clock-rate' in caps");
+    return FALSE;
+  }
+
+  src_caps = gst_caps_new_simple ("audio/isac",
+      "channels", G_TYPE_INT, 1, "rate", G_TYPE_INT, rate, NULL);
+
+  ret = gst_pad_set_caps (GST_RTP_BASE_DEPAYLOAD_SRCPAD (depayload), src_caps);
+
+  GST_DEBUG_OBJECT (depayload,
+      "set caps on source: %" GST_PTR_FORMAT " (ret=%d)", src_caps, ret);
+  gst_caps_unref (src_caps);
+
+  return ret;
+}
+
+static GstBuffer *
+gst_rtp_isac_depay_process (GstRTPBaseDepayload * depayload,
+    GstRTPBuffer * rtp_buffer)
+{
+  GstBuffer *outbuf;
+
+  outbuf = gst_rtp_buffer_get_payload_buffer (rtp_buffer);
+
+  gst_rtp_drop_non_audio_meta (depayload, outbuf);
+
+  return outbuf;
+}
+
+static void
+gst_rtp_isac_depay_class_init (GstRtpIsacDepayClass * klass)
+{
+  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstRTPBaseDepayloadClass *depayload_class =
+      (GstRTPBaseDepayloadClass *) klass;
+
+  depayload_class->set_caps = gst_rtp_isac_depay_setcaps;
+  depayload_class->process_rtp_packet = gst_rtp_isac_depay_process;
+
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_rtp_isac_depay_sink_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_rtp_isac_depay_src_template);
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "RTP iSAC depayloader", "Codec/Depayloader/Network/RTP",
+      "Extracts iSAC audio from RTP packets",
+      "Guillaume Desmottes <guillaume.desmottes@collabora.com>");
+
+  GST_DEBUG_CATEGORY_INIT (rtpisacdepay_debug, "rtpisacdepay", 0,
+      "iSAC RTP Depayloader");
+}
+
+static void
+gst_rtp_isac_depay_init (GstRtpIsacDepay * rtpisacdepay)
+{
+}
diff --git a/gst/rtp/gstrtpisacdepay.h b/gst/rtp/gstrtpisacdepay.h
new file mode 100644
index 000000000..f5ab28954
--- /dev/null
+++ b/gst/rtp/gstrtpisacdepay.h
@@ -0,0 +1,31 @@
+/* GStreamer
+ * Copyright (C) 2020 Collabora Ltd.
+ *  Author: Guillaume Desmottes <guillaume.desmottes@collabora.com>, Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+
+#ifndef __GST_RTP_ISAC_DEPAY_H__
+#define __GST_RTP_ISAC_DEPAY_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtpbasedepayload.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_ISAC_DEPAY gst_rtp_isac_depay_get_type ()
+
+G_DECLARE_FINAL_TYPE (GstRtpIsacDepay, gst_rtp_isac_depay, GST, RTP_ISAC_DEPAY,
+    GstRTPBaseDepayload);
+
+G_END_DECLS
+#endif /* __GST_RTP_ISAC_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpisacpay.c b/gst/rtp/gstrtpisacpay.c
new file mode 100644
index 000000000..ad03a190f
--- /dev/null
+++ b/gst/rtp/gstrtpisacpay.c
@@ -0,0 +1,183 @@
+/* GStreamer
+ * Copyright (C) 2020 Collabora Ltd.
+ *  Author: Guillaume Desmottes <guillaume.desmottes@collabora.com>, Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-rtpisacpay
+ * @title: rtpisacpay
+ * @short_description: iSAC RTP Payloader
+ *
+ * Since: 1.20
+ *
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtpelements.h"
+#include "gstrtpisacpay.h"
+#include "gstrtputils.h"
+
+GST_DEBUG_CATEGORY_STATIC (rtpisacpay_debug);
+#define GST_CAT_DEFAULT (rtpisacpay_debug)
+
+static GstStaticPadTemplate gst_rtp_isac_pay_sink_template =
+GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/isac, "
+        "rate = (int) { 16000, 32000 }, " "channels = (int) 1")
+    );
+
+static GstStaticPadTemplate gst_rtp_isac_pay_src_template =
+GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("application/x-rtp, "
+        "media = (string) \"audio\", "
+        "payload = (int) " GST_RTP_PAYLOAD_DYNAMIC_STRING ", "
+        "clock-rate =  (int) { 16000, 32000 }, "
+        "encoding-name = (string) \"ISAC\", "
+        "encoding-params = (string) \"1\"")
+    );
+
+struct _GstRtpIsacPay
+{
+  /*< private > */
+  GstRTPBasePayload parent;
+};
+
+#define gst_rtp_isac_pay_parent_class parent_class
+G_DEFINE_TYPE (GstRtpIsacPay, gst_rtp_isac_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpisacpay, "rtpisacpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_ISAC_PAY, rtp_element_init (plugin));
+
+static GstCaps *
+gst_rtp_isac_pay_getcaps (GstRTPBasePayload * payload, GstPad * pad,
+    GstCaps * filter)
+{
+  GstCaps *otherpadcaps;
+  GstCaps *caps;
+
+  otherpadcaps = gst_pad_get_allowed_caps (payload->srcpad);
+  caps = gst_pad_get_pad_template_caps (pad);
+
+  if (otherpadcaps) {
+    if (!gst_caps_is_empty (otherpadcaps)) {
+      GstStructure *ps;
+      GstStructure *s;
+      const GValue *v;
+
+      ps = gst_caps_get_structure (otherpadcaps, 0);
+      caps = gst_caps_make_writable (caps);
+      s = gst_caps_get_structure (caps, 0);
+
+      v = gst_structure_get_value (ps, "clock-rate");
+      if (v)
+        gst_structure_set_value (s, "rate", v);
+    }
+    gst_caps_unref (otherpadcaps);
+  }
+
+  if (filter) {
+    GstCaps *tcaps = caps;
+
+    caps = gst_caps_intersect_full (filter, tcaps, GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (tcaps);
+  }
+
+  GST_DEBUG_OBJECT (payload, "%" GST_PTR_FORMAT, caps);
+
+  return caps;
+}
+
+static gboolean
+gst_rtp_isac_pay_setcaps (GstRTPBasePayload * payload, GstCaps * caps)
+{
+  GstStructure *s;
+  gint rate;
+
+  GST_DEBUG_OBJECT (payload, "%" GST_PTR_FORMAT, caps);
+
+  s = gst_caps_get_structure (caps, 0);
+  if (!gst_structure_get_int (s, "rate", &rate)) {
+    GST_ERROR_OBJECT (payload, "Missing 'rate' in caps");
+    return FALSE;
+  }
+
+  gst_rtp_base_payload_set_options (payload, "audio", TRUE, "ISAC", rate);
+
+  return gst_rtp_base_payload_set_outcaps (payload, NULL);
+}
+
+static GstFlowReturn
+gst_rtp_isac_pay_handle_buffer (GstRTPBasePayload * basepayload,
+    GstBuffer * buffer)
+{
+  GstBuffer *outbuf;
+  GstClockTime pts, dts, duration;
+
+  pts = GST_BUFFER_PTS (buffer);
+  dts = GST_BUFFER_DTS (buffer);
+  duration = GST_BUFFER_DURATION (buffer);
+
+  outbuf = gst_rtp_base_payload_allocate_output_buffer (basepayload, 0, 0, 0);
+
+  gst_rtp_copy_audio_meta (basepayload, outbuf, buffer);
+
+  outbuf = gst_buffer_append (outbuf, buffer);
+
+  GST_BUFFER_PTS (outbuf) = pts;
+  GST_BUFFER_DTS (outbuf) = dts;
+  GST_BUFFER_DURATION (outbuf) = duration;
+
+  return gst_rtp_base_payload_push (basepayload, outbuf);
+}
+
+static void
+gst_rtp_isac_pay_class_init (GstRtpIsacPayClass * klass)
+{
+  GstElementClass *gstelement_class = (GstElementClass *) klass;
+  GstRTPBasePayloadClass *payload_class = (GstRTPBasePayloadClass *) klass;
+
+  payload_class->get_caps = gst_rtp_isac_pay_getcaps;
+  payload_class->set_caps = gst_rtp_isac_pay_setcaps;
+  payload_class->handle_buffer = gst_rtp_isac_pay_handle_buffer;
+
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_rtp_isac_pay_sink_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &gst_rtp_isac_pay_src_template);
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "RTP iSAC payloader", "Codec/Payloader/Network/RTP",
+      "Payload-encodes iSAC audio into a RTP packet",
+      "Guillaume Desmottes <guillaume.desmottes@collabora.com>");
+
+  GST_DEBUG_CATEGORY_INIT (rtpisacpay_debug, "rtpisacpay", 0,
+      "iSAC RTP Payloader");
+}
+
+static void
+gst_rtp_isac_pay_init (GstRtpIsacPay * rtpisacpay)
+{
+}
diff --git a/gst/rtp/gstrtpisacpay.h b/gst/rtp/gstrtpisacpay.h
new file mode 100644
index 000000000..82c072bdd
--- /dev/null
+++ b/gst/rtp/gstrtpisacpay.h
@@ -0,0 +1,31 @@
+/* GStreamer
+ * Copyright (C) 2020 Collabora Ltd.
+ *  Author: Guillaume Desmottes <guillaume.desmottes@collabora.com>, Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+
+#ifndef __GST_RTP_ISAC_PAY_H__
+#define __GST_RTP_ISAC_PAY_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtpbasepayload.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_ISAC_PAY gst_rtp_isac_pay_get_type ()
+
+G_DECLARE_FINAL_TYPE(GstRtpIsacPay, gst_rtp_isac_pay, GST, RTP_ISAC_PAY, GstRTPBasePayload);
+
+G_END_DECLS
+
+#endif /* __GST_RTP_ISAC_PAY_H__ */
diff --git a/gst/rtp/gstrtpj2kdepay.c b/gst/rtp/gstrtpj2kdepay.c
index 132bcf5df..4456b3dd8 100644
--- a/gst/rtp/gstrtpj2kdepay.c
+++ b/gst/rtp/gstrtpj2kdepay.c
@@ -37,6 +37,7 @@
 #include <gst/video/video.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpj2kcommon.h"
 #include "gstrtpj2kdepay.h"
 #include "gstrtputils.h"
@@ -74,6 +75,8 @@ enum
 
 #define gst_rtp_j2k_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpJ2KDepay, gst_rtp_j2k_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpj2kdepay, "rtpj2kdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_J2K_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_j2k_depay_finalize (GObject * object);
 
@@ -659,10 +662,3 @@ gst_rtp_j2k_depay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-gboolean
-gst_rtp_j2k_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpj2kdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_J2K_DEPAY);
-}
diff --git a/gst/rtp/gstrtpj2kdepay.h b/gst/rtp/gstrtpj2kdepay.h
index ebc743397..5f499393d 100644
--- a/gst/rtp/gstrtpj2kdepay.h
+++ b/gst/rtp/gstrtpj2kdepay.h
@@ -66,7 +66,6 @@ struct _GstRtpJ2KDepayClass
 
 GType gst_rtp_j2k_depay_get_type (void);
 
-gboolean gst_rtp_j2k_depay_plugin_init (GstPlugin * plugin);
 
 G_END_DECLS
 #endif /* __GST_RTP_J2K_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpj2kpay.c b/gst/rtp/gstrtpj2kpay.c
index 9ead8a21a..90075d06c 100644
--- a/gst/rtp/gstrtpj2kpay.c
+++ b/gst/rtp/gstrtpj2kpay.c
@@ -40,6 +40,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "gstrtpj2kcommon.h"
 #include "gstrtpj2kpay.h"
 #include "gstrtputils.h"
@@ -97,6 +98,8 @@ static GstFlowReturn gst_rtp_j2k_pay_handle_buffer (GstRTPBasePayload * pad,
 
 #define gst_rtp_j2k_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpJ2KPay, gst_rtp_j2k_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpj2kpay, "rtpj2kpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_J2K_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_j2k_pay_class_init (GstRtpJ2KPayClass * klass)
@@ -440,7 +443,9 @@ gst_rtp_j2k_pay_handle_buffer (GstRTPBasePayload * basepayload,
       data_size = payload_size - GST_RTP_J2K_HEADER_SIZE;
 
       /* make buffer for header */
-      outbuf = gst_rtp_buffer_new_allocate (GST_RTP_J2K_HEADER_SIZE, 0, 0);
+      outbuf =
+          gst_rtp_base_payload_allocate_output_buffer (basepayload,
+          GST_RTP_J2K_HEADER_SIZE, 0, 0);
 
       GST_BUFFER_PTS (outbuf) = timestamp;
 
@@ -454,6 +459,7 @@ gst_rtp_j2k_pay_handle_buffer (GstRTPBasePayload * basepayload,
       /* reached the end of a packetization unit */
       if (pu_size == 0 && end >= map.size) {
         gst_rtp_buffer_set_marker (&rtp, TRUE);
+        GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
       }
       /* If we were processing a header, see if all fits in one RTP packet
          or if we have to fragment it */
@@ -560,10 +566,3 @@ gst_rtp_j2k_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_j2k_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpj2kpay", GST_RANK_SECONDARY,
-      GST_TYPE_RTP_J2K_PAY);
-}
diff --git a/gst/rtp/gstrtpj2kpay.h b/gst/rtp/gstrtpj2kpay.h
index 14f529595..e5474938b 100644
--- a/gst/rtp/gstrtpj2kpay.h
+++ b/gst/rtp/gstrtpj2kpay.h
@@ -52,7 +52,5 @@ struct _GstRtpJ2KPayClass
 
 GType gst_rtp_j2k_pay_get_type (void);
 
-gboolean gst_rtp_j2k_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_J2K_PAY_H__ */
diff --git a/gst/rtp/gstrtpjpegdepay.c b/gst/rtp/gstrtpjpegdepay.c
index 5cd542828..02209d53b 100644
--- a/gst/rtp/gstrtpjpegdepay.c
+++ b/gst/rtp/gstrtpjpegdepay.c
@@ -28,6 +28,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpjpegdepay.h"
 #include "gstrtputils.h"
 
@@ -70,6 +71,8 @@ static GstStaticPadTemplate gst_rtp_jpeg_depay_sink_template =
 #define gst_rtp_jpeg_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpJPEGDepay, gst_rtp_jpeg_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpjpegdepay, "rtpjpegdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_JPEG_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_jpeg_depay_finalize (GObject * object);
 
@@ -790,11 +793,3 @@ gst_rtp_jpeg_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-
-gboolean
-gst_rtp_jpeg_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpjpegdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_JPEG_DEPAY);
-}
diff --git a/gst/rtp/gstrtpjpegdepay.h b/gst/rtp/gstrtpjpegdepay.h
index cb74f12d4..3f7aea219 100644
--- a/gst/rtp/gstrtpjpegdepay.h
+++ b/gst/rtp/gstrtpjpegdepay.h
@@ -63,7 +63,6 @@ struct _GstRtpJPEGDepayClass
 
 GType gst_rtp_jpeg_depay_get_type (void);
 
-gboolean gst_rtp_jpeg_depay_plugin_init (GstPlugin * plugin);
 
 G_END_DECLS
 
diff --git a/gst/rtp/gstrtpjpegpay.c b/gst/rtp/gstrtpjpegpay.c
index 7ba1f51eb..1f7b8d8c9 100644
--- a/gst/rtp/gstrtpjpegpay.c
+++ b/gst/rtp/gstrtpjpegpay.c
@@ -41,6 +41,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpjpegpay.h"
 #include "gstrtputils.h"
 #include "gstbuffermemory.h"
@@ -248,6 +249,8 @@ static GstFlowReturn gst_rtp_jpeg_pay_handle_buffer (GstRTPBasePayload * pad,
 
 #define gst_rtp_jpeg_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpJPEGPay, gst_rtp_jpeg_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpjpegpay, "rtpjpegpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_JPEG_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_jpeg_pay_class_init (GstRtpJPEGPayClass * klass)
@@ -886,7 +889,9 @@ gst_rtp_jpeg_pay_handle_buffer (GstRTPBasePayload * basepayload,
     if (dri_found)
       header_size += sizeof (restart_marker_header);
 
-    outbuf = gst_rtp_buffer_new_allocate (header_size, 0, 0);
+    outbuf =
+        gst_rtp_base_payload_allocate_output_buffer (basepayload, header_size,
+        0, 0);
 
     gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
 
@@ -894,6 +899,7 @@ gst_rtp_jpeg_pay_handle_buffer (GstRTPBasePayload * basepayload,
       GST_LOG_OBJECT (pay, "last packet of frame");
       frame_done = TRUE;
       gst_rtp_buffer_set_marker (&rtp, 1);
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
     }
 
     payload = gst_rtp_buffer_get_payload (&rtp);
@@ -1046,10 +1052,3 @@ gst_rtp_jpeg_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_jpeg_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpjpegpay", GST_RANK_SECONDARY,
-      GST_TYPE_RTP_JPEG_PAY);
-}
diff --git a/gst/rtp/gstrtpjpegpay.h b/gst/rtp/gstrtpjpegpay.h
index 4d65ea71e..696dc39e3 100644
--- a/gst/rtp/gstrtpjpegpay.h
+++ b/gst/rtp/gstrtpjpegpay.h
@@ -57,7 +57,5 @@ struct _GstRtpJPEGPayClass
 
 GType gst_rtp_jpeg_pay_get_type (void);
 
-gboolean gst_rtp_jpeg_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_JPEG_PAY_H__ */
diff --git a/gst/rtp/gstrtpklvdepay.c b/gst/rtp/gstrtpklvdepay.c
index a5026712b..1cb8bc3ab 100644
--- a/gst/rtp/gstrtpklvdepay.c
+++ b/gst/rtp/gstrtpklvdepay.c
@@ -37,6 +37,7 @@
 #include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtpklvdepay.h"
 
 #include <string.h>
@@ -59,6 +60,8 @@ static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
 
 #define gst_rtp_klv_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpKlvDepay, gst_rtp_klv_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpklvdepay, "rtpklvdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_KLV_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_klv_depay_finalize (GObject * object);
 
@@ -388,10 +391,3 @@ gst_rtp_klv_depay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-gboolean
-gst_rtp_klv_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpklvdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_KLV_DEPAY);
-}
diff --git a/gst/rtp/gstrtpklvdepay.h b/gst/rtp/gstrtpklvdepay.h
index 71a256d2b..e1042a736 100644
--- a/gst/rtp/gstrtpklvdepay.h
+++ b/gst/rtp/gstrtpklvdepay.h
@@ -58,8 +58,6 @@ struct _GstRtpKlvDepayClass
 
 G_GNUC_INTERNAL GType     gst_rtp_klv_depay_get_type (void);
 
-G_GNUC_INTERNAL gboolean  gst_rtp_klv_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_KLV_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpklvpay.c b/gst/rtp/gstrtpklvpay.c
index f24d29f3c..00f1f4321 100644
--- a/gst/rtp/gstrtpklvpay.c
+++ b/gst/rtp/gstrtpklvpay.c
@@ -37,6 +37,7 @@
 #include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtpklvpay.h"
 #include "gstrtputils.h"
 
@@ -60,6 +61,8 @@ static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
 
 #define gst_rtp_klv_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpKlvPay, gst_rtp_klv_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpklvpay, "rtpklvpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_KLV_PAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_klv_pay_setcaps (GstRTPBasePayload * pay,
     GstCaps * caps);
@@ -147,13 +150,14 @@ gst_rtp_klv_pay_handle_buffer (GstRTPBasePayload * basepayload, GstBuffer * buf)
     bytes_left = map.size - offset;
     payload_size = MIN (bytes_left, max_payload_size);
 
-    outbuf = gst_rtp_buffer_new_allocate (0, 0, 0);
+    outbuf = gst_rtp_base_payload_allocate_output_buffer (basepayload, 0, 0, 0);
 
     if (payload_size == bytes_left) {
       GST_LOG_OBJECT (pay, "last packet of KLV unit");
       gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
       gst_rtp_buffer_set_marker (&rtp, 1);
       gst_rtp_buffer_unmap (&rtp);
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
     }
 
     GST_LOG_OBJECT (pay, "packet with payload size %u", payload_size);
@@ -195,10 +199,3 @@ bad_input:
     goto done;
   }
 }
-
-gboolean
-gst_rtp_klv_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpklvpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_KLV_PAY);
-}
diff --git a/gst/rtp/gstrtpklvpay.h b/gst/rtp/gstrtpklvpay.h
index 9ee813429..41187d6cd 100644
--- a/gst/rtp/gstrtpklvpay.h
+++ b/gst/rtp/gstrtpklvpay.h
@@ -53,8 +53,6 @@ struct _GstRtpKlvPayClass
 
 G_GNUC_INTERNAL  GType     gst_rtp_klv_pay_get_type (void);
 
-G_GNUC_INTERNAL  gboolean  gst_rtp_klv_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_KLV_PAY_H__ */
diff --git a/gst/rtp/gstrtpldacpay.c b/gst/rtp/gstrtpldacpay.c
new file mode 100644
index 000000000..aa30673e7
--- /dev/null
+++ b/gst/rtp/gstrtpldacpay.c
@@ -0,0 +1,228 @@
+/* GStreamer RTP LDAC payloader
+ * Copyright (C) 2020 Asymptotic <sanchayan@asymptotic.io>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-rtpldacpay
+ * @title: rtpldacpay
+ *
+ * Payload LDAC encoded audio into RTP packets.
+ *
+ * LDAC does not have a public specification and concerns itself only with
+ * bluetooth transmission. Due to the unavailability of a specification, we
+ * consider the encoding-name as X-GST-LDAC.
+ *
+ * The best reference is [libldac](https://android.googlesource.com/platform/external/libldac/)
+ * and the A2DP LDAC implementation in Android's bluetooth stack [Flouride]
+ * (https://android.googlesource.com/platform/system/bt/+/refs/heads/master/stack/a2dp/a2dp_vendor_ldac_encoder.cc).
+ *
+ * ## Example pipeline
+ * |[
+ * gst-launch-1.0 -v audiotestsrc ! ldacenc ! rtpldacpay mtu=679 ! avdtpsink
+ * ]| This example pipeline will payload LDAC encoded audio.
+ *
+ * Since: 1.20
+ */
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <gst/audio/audio.h>
+#include "gstrtpelements.h"
+#include "gstrtpldacpay.h"
+#include "gstrtputils.h"
+
+#define GST_RTP_LDAC_PAYLOAD_HEADER_SIZE 1
+/* MTU size required for LDAC A2DP streaming */
+#define GST_LDAC_MTU_REQUIRED    679
+
+GST_DEBUG_CATEGORY_STATIC (gst_rtp_ldac_pay_debug);
+#define GST_CAT_DEFAULT gst_rtp_ldac_pay_debug
+
+#define parent_class gst_rtp_ldac_pay_parent_class
+G_DEFINE_TYPE (GstRtpLdacPay, gst_rtp_ldac_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpldacpay, "rtpldacpay", GST_RANK_NONE,
+    GST_TYPE_RTP_LDAC_PAY, rtp_element_init (plugin));
+
+static GstStaticPadTemplate gst_rtp_ldac_pay_sink_factory =
+GST_STATIC_PAD_TEMPLATE ("sink", GST_PAD_SINK, GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("audio/x-ldac, "
+        "channels = (int) [ 1, 2 ], "
+        "eqmid = (int) { 0, 1, 2 }, "
+        "rate = (int) { 44100, 48000, 88200, 96000 }")
+    );
+
+static GstStaticPadTemplate gst_rtp_ldac_pay_src_factory =
+GST_STATIC_PAD_TEMPLATE ("src", GST_PAD_SRC, GST_PAD_ALWAYS,
+    GST_STATIC_CAPS ("application/x-rtp, "
+        "media = (string) audio,"
+        "payload = (int) " GST_RTP_PAYLOAD_DYNAMIC_STRING ", "
+        "clock-rate = (int) { 44100, 48000, 88200, 96000 },"
+        "encoding-name = (string) \"X-GST-LDAC\"")
+    );
+
+static gboolean gst_rtp_ldac_pay_set_caps (GstRTPBasePayload * payload,
+    GstCaps * caps);
+static GstFlowReturn gst_rtp_ldac_pay_handle_buffer (GstRTPBasePayload *
+    payload, GstBuffer * buffer);
+
+/**
+ * gst_rtp_ldac_pay_get_num_frames
+ * @eqmid: Encode Quality Mode Index
+ * @channels: Number of channels
+ *
+ * Returns: Number of LDAC frames per packet.
+ */
+static guint8
+gst_rtp_ldac_pay_get_num_frames (gint eqmid, gint channels)
+{
+  g_assert (channels == 1 || channels == 2);
+
+  switch (eqmid) {
+      /* Encode setting for High Quality */
+    case 0:
+      return 4 / channels;
+      /* Encode setting for Standard Quality */
+    case 1:
+      return 6 / channels;
+      /* Encode setting for Mobile use Quality */
+    case 2:
+      return 12 / channels;
+    default:
+      break;
+  }
+
+  g_assert_not_reached ();
+
+  /* If assertion gets compiled out */
+  return 6 / channels;
+}
+
+static void
+gst_rtp_ldac_pay_class_init (GstRtpLdacPayClass * klass)
+{
+  GstRTPBasePayloadClass *payload_class = GST_RTP_BASE_PAYLOAD_CLASS (klass);
+  GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
+
+  payload_class->set_caps = GST_DEBUG_FUNCPTR (gst_rtp_ldac_pay_set_caps);
+  payload_class->handle_buffer =
+      GST_DEBUG_FUNCPTR (gst_rtp_ldac_pay_handle_buffer);
+
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_rtp_ldac_pay_sink_factory);
+  gst_element_class_add_static_pad_template (element_class,
+      &gst_rtp_ldac_pay_src_factory);
+
+  gst_element_class_set_static_metadata (element_class, "RTP packet payloader",
+      "Codec/Payloader/Network", "Payload LDAC audio as RTP packets",
+      "Sanchayan Maity <sanchayan@asymptotic.io>");
+
+  GST_DEBUG_CATEGORY_INIT (gst_rtp_ldac_pay_debug, "rtpldacpay", 0,
+      "RTP LDAC payloader");
+}
+
+static void
+gst_rtp_ldac_pay_init (GstRtpLdacPay * self)
+{
+
+}
+
+static gboolean
+gst_rtp_ldac_pay_set_caps (GstRTPBasePayload * payload, GstCaps * caps)
+{
+  GstRtpLdacPay *ldacpay = GST_RTP_LDAC_PAY (payload);
+  GstStructure *structure;
+  gint channels, eqmid, rate;
+
+  if (GST_RTP_BASE_PAYLOAD_MTU (ldacpay) < GST_LDAC_MTU_REQUIRED) {
+    GST_ERROR_OBJECT (ldacpay, "Invalid MTU %d, should be >= %d",
+        GST_RTP_BASE_PAYLOAD_MTU (ldacpay), GST_LDAC_MTU_REQUIRED);
+    return FALSE;
+  }
+
+  structure = gst_caps_get_structure (caps, 0);
+  if (!gst_structure_get_int (structure, "rate", &rate)) {
+    GST_ERROR_OBJECT (ldacpay, "Failed to get audio rate from caps");
+    return FALSE;
+  }
+
+  if (!gst_structure_get_int (structure, "channels", &channels)) {
+    GST_ERROR_OBJECT (ldacpay, "Failed to get audio rate from caps");
+    return FALSE;
+  }
+
+  if (!gst_structure_get_int (structure, "eqmid", &eqmid)) {
+    GST_ERROR_OBJECT (ldacpay, "Failed to get eqmid from caps");
+    return FALSE;
+  }
+
+  ldacpay->frame_count = gst_rtp_ldac_pay_get_num_frames (eqmid, channels);
+
+  gst_rtp_base_payload_set_options (payload, "audio", TRUE, "X-GST-LDAC", rate);
+
+  return gst_rtp_base_payload_set_outcaps (payload, NULL);
+}
+
+/*
+ * LDAC encoder does not handle split frames. Currently, the encoder will
+ * always emit 660 bytes worth of payload encapsulating multiple LDAC frames.
+ * This is as per eqmid and GST_LDAC_MTU_REQUIRED passed for configuring the
+ * encoder upstream. Since the encoder always emit full frames and we do not
+ * need to handle frame splitting, we do not use an adapter and also push out
+ * the buffer as it is received.
+ */
+static GstFlowReturn
+gst_rtp_ldac_pay_handle_buffer (GstRTPBasePayload * payload, GstBuffer * buffer)
+{
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  GstRtpLdacPay *ldacpay = GST_RTP_LDAC_PAY (payload);
+  GstBuffer *outbuf;
+  GstClockTime outbuf_frame_duration, outbuf_pts;
+  guint8 *payload_data;
+  gsize buf_sz;
+
+  outbuf =
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+      (ldacpay), GST_RTP_LDAC_PAYLOAD_HEADER_SIZE, 0, 0);
+
+  /* Get payload */
+  gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
+
+  /* Write header and copy data into payload */
+  payload_data = gst_rtp_buffer_get_payload (&rtp);
+  /* Upper 3 fragment bits not used, ref A2DP v13, 4.3.4 */
+  payload_data[0] = ldacpay->frame_count & 0x0f;
+
+  gst_rtp_buffer_unmap (&rtp);
+
+  outbuf_pts = GST_BUFFER_PTS (buffer);
+  outbuf_frame_duration = GST_BUFFER_DURATION (buffer);
+  buf_sz = gst_buffer_get_size (buffer);
+
+  gst_rtp_copy_audio_meta (ldacpay, outbuf, buffer);
+  outbuf = gst_buffer_append (outbuf, buffer);
+
+  GST_BUFFER_PTS (outbuf) = outbuf_pts;
+  GST_BUFFER_DURATION (outbuf) = outbuf_frame_duration;
+  GST_DEBUG_OBJECT (ldacpay,
+      "Pushing %" G_GSIZE_FORMAT " bytes: %" GST_TIME_FORMAT, buf_sz,
+      GST_TIME_ARGS (GST_BUFFER_PTS (outbuf)));
+
+  return gst_rtp_base_payload_push (GST_RTP_BASE_PAYLOAD (ldacpay), outbuf);
+}
diff --git a/gst/rtp/gstrtpldacpay.h b/gst/rtp/gstrtpldacpay.h
new file mode 100644
index 000000000..013449175
--- /dev/null
+++ b/gst/rtp/gstrtpldacpay.h
@@ -0,0 +1,56 @@
+/* GStreamer RTP LDAC payloader
+ * Copyright (C) 2020 Asymptotic <sanchayan@asymptotic.io>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include <gst/gst.h>
+#include <gst/base/gstadapter.h>
+#include <gst/rtp/gstrtpbasepayload.h>
+#include <gst/rtp/gstrtpbuffer.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_LDAC_PAY \
+  (gst_rtp_ldac_pay_get_type())
+#define GST_RTP_LDAC_PAY(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_LDAC_PAY,\
+                              GstRtpLdacPay))
+#define GST_RTP_LDAC_PAY_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_LDAC_PAY,\
+                           GstRtpLdacPayClass))
+#define GST_IS_RTP_LDAC_PAY(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_LDAC_PAY))
+#define GST_IS_RTP_LDAC_PAY_CLASS(obj) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_LDAC_PAY))
+
+typedef struct _GstRtpLdacPay GstRtpLdacPay;
+typedef struct _GstRtpLdacPayClass GstRtpLdacPayClass;
+
+struct _GstRtpLdacPay {
+  GstRTPBasePayload base;
+  guint8 frame_count;
+};
+
+struct _GstRtpLdacPayClass {
+  GstRTPBasePayloadClass parent_class;
+};
+
+GType gst_rtp_ldac_pay_get_type(void);
+
+gboolean gst_rtp_ldac_pay_plugin_init (GstPlugin * plugin);
+
+G_END_DECLS
diff --git a/gst/rtp/gstrtpmp1sdepay.c b/gst/rtp/gstrtpmp1sdepay.c
index 31a3108d2..e07dc2cd3 100644
--- a/gst/rtp/gstrtpmp1sdepay.c
+++ b/gst/rtp/gstrtpmp1sdepay.c
@@ -24,6 +24,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpmp1sdepay.h"
 #include "gstrtputils.h"
 
@@ -63,6 +64,8 @@ static GstStaticPadTemplate gst_rtp_mp1s_depay_sink_template =
 
 G_DEFINE_TYPE (GstRtpMP1SDepay, gst_rtp_mp1s_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp1sdepay, "rtpmp1sdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP1S_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_mp1s_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -134,10 +137,3 @@ gst_rtp_mp1s_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_mp1s_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp1sdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP1S_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmp1sdepay.h b/gst/rtp/gstrtpmp1sdepay.h
index 582933bad..e2e582c52 100644
--- a/gst/rtp/gstrtpmp1sdepay.h
+++ b/gst/rtp/gstrtpmp1sdepay.h
@@ -51,8 +51,6 @@ struct _GstRtpMP1SDepayClass
 
 GType gst_rtp_mp1s_depay_get_type (void);
 
-gboolean gst_rtp_mp1s_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP1S_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmp2tdepay.c b/gst/rtp/gstrtpmp2tdepay.c
index f8e0d0c7b..7acf3f819 100644
--- a/gst/rtp/gstrtpmp2tdepay.c
+++ b/gst/rtp/gstrtpmp2tdepay.c
@@ -24,6 +24,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpmp2tdepay.h"
 #include "gstrtputils.h"
 
@@ -71,6 +72,8 @@ static GstStaticPadTemplate gst_rtp_mp2t_depay_sink_template =
 
 G_DEFINE_TYPE (GstRtpMP2TDepay, gst_rtp_mp2t_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp2tdepay, "rtpmp2tdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP2T_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_mp2t_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -234,10 +237,3 @@ gst_rtp_mp2t_depay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_mp2t_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp2tdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP2T_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmp2tdepay.h b/gst/rtp/gstrtpmp2tdepay.h
index aa936dca9..f1e5d0829 100644
--- a/gst/rtp/gstrtpmp2tdepay.h
+++ b/gst/rtp/gstrtpmp2tdepay.h
@@ -53,8 +53,6 @@ struct _GstRtpMP2TDepayClass
 
 GType gst_rtp_mp2t_depay_get_type (void);
 
-gboolean gst_rtp_mp2t_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP2T_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmp2tpay.c b/gst/rtp/gstrtpmp2tpay.c
index 8dac50b9a..ecde5a298 100644
--- a/gst/rtp/gstrtpmp2tpay.c
+++ b/gst/rtp/gstrtpmp2tpay.c
@@ -25,6 +25,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpmp2tpay.h"
 #include "gstrtputils.h"
 
@@ -59,6 +60,8 @@ static void gst_rtp_mp2t_pay_finalize (GObject * object);
 
 #define gst_rtp_mp2t_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPMP2TPay, gst_rtp_mp2t_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp2tpay, "rtpmp2tpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP2T_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_mp2t_pay_class_init (GstRTPMP2TPayClass * klass)
@@ -230,10 +233,3 @@ again:
   return ret;
 
 }
-
-gboolean
-gst_rtp_mp2t_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp2tpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP2T_PAY);
-}
diff --git a/gst/rtp/gstrtpmp2tpay.h b/gst/rtp/gstrtpmp2tpay.h
index 12f49599f..9ed02d998 100644
--- a/gst/rtp/gstrtpmp2tpay.h
+++ b/gst/rtp/gstrtpmp2tpay.h
@@ -57,8 +57,6 @@ struct _GstRTPMP2TPayClass
 
 GType gst_rtp_mp2t_pay_get_type (void);
 
-gboolean gst_rtp_mp2t_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP2T_PAY_H__ */
diff --git a/gst/rtp/gstrtpmp4adepay.c b/gst/rtp/gstrtpmp4adepay.c
index 9177d7c3d..f278fc598 100644
--- a/gst/rtp/gstrtpmp4adepay.c
+++ b/gst/rtp/gstrtpmp4adepay.c
@@ -26,6 +26,7 @@
 #include <gst/audio/audio.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpmp4adepay.h"
 #include "gstrtputils.h"
 
@@ -60,6 +61,8 @@ GST_STATIC_PAD_TEMPLATE ("sink",
 #define gst_rtp_mp4a_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMP4ADepay, gst_rtp_mp4a_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp4adepay, "rtpmp4adepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP4A_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_mp4a_depay_finalize (GObject * object);
 
@@ -457,10 +460,3 @@ gst_rtp_mp4a_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_mp4a_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp4adepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP4A_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmp4adepay.h b/gst/rtp/gstrtpmp4adepay.h
index 31eaf560e..c5aaaa349 100644
--- a/gst/rtp/gstrtpmp4adepay.h
+++ b/gst/rtp/gstrtpmp4adepay.h
@@ -56,8 +56,6 @@ struct _GstRtpMP4ADepayClass
 
 GType gst_rtp_mp4a_depay_get_type (void);
 
-gboolean gst_rtp_mp4a_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP4A_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmp4apay.c b/gst/rtp/gstrtpmp4apay.c
index ab1eeb55a..f94bb723d 100644
--- a/gst/rtp/gstrtpmp4apay.c
+++ b/gst/rtp/gstrtpmp4apay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpmp4apay.h"
 #include "gstrtputils.h"
 
@@ -68,6 +69,8 @@ static GstFlowReturn gst_rtp_mp4a_pay_handle_buffer (GstRTPBasePayload *
 
 #define gst_rtp_mp4a_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMP4APay, gst_rtp_mp4a_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp4apay, "rtpmp4apay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP4A_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_mp4a_pay_class_init (GstRtpMP4APayClass * klass)
@@ -429,6 +432,8 @@ gst_rtp_mp4a_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
     /* marker only if the packet is complete */
     gst_rtp_buffer_set_marker (&rtp, size == payload_len);
+    if (size == payload_len)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
 
     gst_rtp_buffer_unmap (&rtp);
 
@@ -456,10 +461,3 @@ gst_rtp_mp4a_pay_handle_buffer (GstRTPBasePayload * basepayload,
 
   return ret;
 }
-
-gboolean
-gst_rtp_mp4a_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp4apay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP4A_PAY);
-}
diff --git a/gst/rtp/gstrtpmp4apay.h b/gst/rtp/gstrtpmp4apay.h
index 49d9b650d..997aa3541 100644
--- a/gst/rtp/gstrtpmp4apay.h
+++ b/gst/rtp/gstrtpmp4apay.h
@@ -58,8 +58,6 @@ struct _GstRtpMP4APayClass
 
 GType gst_rtp_mp4a_pay_get_type (void);
 
-gboolean gst_rtp_mp4a_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP4A_PAY_H__ */
diff --git a/gst/rtp/gstrtpmp4gdepay.c b/gst/rtp/gstrtpmp4gdepay.c
index a734be065..8ee094d5b 100644
--- a/gst/rtp/gstrtpmp4gdepay.c
+++ b/gst/rtp/gstrtpmp4gdepay.c
@@ -25,6 +25,7 @@
 #include <stdlib.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpmp4gdepay.h"
 #include "gstrtputils.h"
 
@@ -129,6 +130,8 @@ gst_bs_parse_read (GstBsParse * bs, guint n)
 #define gst_rtp_mp4g_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMP4GDepay, gst_rtp_mp4g_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp4gdepay, "rtpmp4gdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP4G_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_mp4g_depay_finalize (GObject * object);
 
@@ -806,10 +809,3 @@ gst_rtp_mp4g_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_mp4g_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp4gdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP4G_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmp4gdepay.h b/gst/rtp/gstrtpmp4gdepay.h
index 843732813..a6a88a0d4 100644
--- a/gst/rtp/gstrtpmp4gdepay.h
+++ b/gst/rtp/gstrtpmp4gdepay.h
@@ -82,8 +82,6 @@ struct _GstRtpMP4GDepayClass
 
 GType gst_rtp_mp4g_depay_get_type (void);
 
-gboolean gst_rtp_mp4g_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP4G_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmp4gpay.c b/gst/rtp/gstrtpmp4gpay.c
index 532e2de25..2434d9035 100644
--- a/gst/rtp/gstrtpmp4gpay.c
+++ b/gst/rtp/gstrtpmp4gpay.c
@@ -26,6 +26,7 @@
 #include <gst/base/gstbitreader.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpmp4gpay.h"
 #include "gstrtputils.h"
 
@@ -88,6 +89,8 @@ static gboolean gst_rtp_mp4g_pay_sink_event (GstRTPBasePayload * payload,
 
 #define gst_rtp_mp4g_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMP4GPay, gst_rtp_mp4g_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp4gpay, "rtpmp4gpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP4G_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_mp4g_pay_class_init (GstRtpMP4GPayClass * klass)
@@ -531,6 +534,8 @@ gst_rtp_mp4g_pay_flush (GstRtpMP4GPay * rtpmp4gpay)
 
     /* marker only if the packet is complete */
     gst_rtp_buffer_set_marker (&rtp, avail <= payload_len);
+    if (avail <= payload_len)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
 
     gst_rtp_buffer_unmap (&rtp);
 
@@ -632,10 +637,3 @@ gst_rtp_mp4g_pay_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-gboolean
-gst_rtp_mp4g_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp4gpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP4G_PAY);
-}
diff --git a/gst/rtp/gstrtpmp4gpay.h b/gst/rtp/gstrtpmp4gpay.h
index 14fd68ab1..6e7a62584 100644
--- a/gst/rtp/gstrtpmp4gpay.h
+++ b/gst/rtp/gstrtpmp4gpay.h
@@ -65,8 +65,6 @@ struct _GstRtpMP4GPayClass
 
 GType gst_rtp_mp4g_pay_get_type (void);
 
-gboolean gst_rtp_mp4g_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP4G_PAY_H__ */
diff --git a/gst/rtp/gstrtpmp4vdepay.c b/gst/rtp/gstrtpmp4vdepay.c
index c860f88b8..204828c47 100644
--- a/gst/rtp/gstrtpmp4vdepay.c
+++ b/gst/rtp/gstrtpmp4vdepay.c
@@ -25,6 +25,7 @@
 #include <gst/video/video.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpmp4vdepay.h"
 #include "gstrtputils.h"
 
@@ -57,6 +58,8 @@ GST_STATIC_PAD_TEMPLATE ("sink",
 #define gst_rtp_mp4v_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMP4VDepay, gst_rtp_mp4v_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp4vdepay, "rtpmp4vdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MP4V_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_mp4v_depay_finalize (GObject * object);
 
@@ -218,10 +221,3 @@ gst_rtp_mp4v_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_mp4v_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmp4vdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MP4V_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmp4vdepay.h b/gst/rtp/gstrtpmp4vdepay.h
index 436e0db31..0eecdf07f 100644
--- a/gst/rtp/gstrtpmp4vdepay.h
+++ b/gst/rtp/gstrtpmp4vdepay.h
@@ -54,8 +54,6 @@ struct _GstRtpMP4VDepayClass
 
 GType gst_rtp_mp4v_depay_get_type (void);
 
-gboolean gst_rtp_mp4v_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP4V_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmp4vpay.c b/gst/rtp/gstrtpmp4vpay.c
index 29803392a..530df853d 100644
--- a/gst/rtp/gstrtpmp4vpay.c
+++ b/gst/rtp/gstrtpmp4vpay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpmp4vpay.h"
 #include "gstrtputils.h"
 
@@ -81,6 +82,12 @@ static gboolean gst_rtp_mp4v_pay_sink_event (GstRTPBasePayload * pay,
 
 #define gst_rtp_mp4v_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMP4VPay, gst_rtp_mp4v_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+/* Note: This element is marked at a "+1" rank to make sure that
+ * auto-plugging of payloaders for MPEG4 elementary streams don't
+ * end up using the 'rtpmp4gpay' element (generic mpeg4) which isn't
+ * as well supported as this RFC */
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmp4vpay, "rtpmp4vpay",
+    GST_RANK_SECONDARY + 1, GST_TYPE_RTP_MP4V_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_mp4v_pay_class_init (GstRtpMP4VPayClass * klass)
@@ -278,7 +285,9 @@ gst_rtp_mp4v_pay_flush (GstRtpMP4VPay * rtpmp4vpay)
 
     /* create buffer without payload. The payload will be put
      * in next buffer instead. Both buffers will be merged */
-    outbuf = gst_rtp_buffer_new_allocate (0, 0, 0);
+    outbuf =
+        gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+        (rtpmp4vpay), 0, 0, 0);
 
     /* Take buffer with the payload from the adapter */
     outbuf_data = gst_adapter_take_buffer_fast (rtpmp4vpay->adapter,
@@ -288,6 +297,8 @@ gst_rtp_mp4v_pay_flush (GstRtpMP4VPay * rtpmp4vpay)
 
     gst_rtp_buffer_map (outbuf, GST_MAP_WRITE, &rtp);
     gst_rtp_buffer_set_marker (&rtp, avail == 0);
+    if (avail == 0)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
     gst_rtp_buffer_unmap (&rtp);
     gst_rtp_copy_video_meta (rtpmp4vpay, outbuf, outbuf_data);
     outbuf = gst_buffer_append (outbuf, outbuf_data);
@@ -629,14 +640,3 @@ gst_rtp_mp4v_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_mp4v_pay_plugin_init (GstPlugin * plugin)
-{
-  /* Note: This element is marked at a "+1" rank to make sure that
-   * auto-plugging of payloaders for MPEG4 elementary streams don't
-   * end up using the 'rtpmp4gpay' element (generic mpeg4) which isn't
-   * as well supported as this RFC */
-  return gst_element_register (plugin, "rtpmp4vpay",
-      GST_RANK_SECONDARY + 1, GST_TYPE_RTP_MP4V_PAY);
-}
diff --git a/gst/rtp/gstrtpmp4vpay.h b/gst/rtp/gstrtpmp4vpay.h
index 26c0ba0dd..1d906fd6f 100644
--- a/gst/rtp/gstrtpmp4vpay.h
+++ b/gst/rtp/gstrtpmp4vpay.h
@@ -67,8 +67,6 @@ struct _GstRtpMP4VPayClass
 
 GType gst_rtp_mp4v_pay_get_type (void);
 
-gboolean gst_rtp_mp4v_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MP4V_PAY_H__ */
diff --git a/gst/rtp/gstrtpmpadepay.c b/gst/rtp/gstrtpmpadepay.c
index 18506db25..afa852f32 100644
--- a/gst/rtp/gstrtpmpadepay.c
+++ b/gst/rtp/gstrtpmpadepay.c
@@ -25,6 +25,7 @@
 #include <gst/audio/audio.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpmpadepay.h"
 #include "gstrtputils.h"
 
@@ -53,6 +54,8 @@ static GstStaticPadTemplate gst_rtp_mpa_depay_sink_template =
 
 #define gst_rtp_mpa_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMPADepay, gst_rtp_mpa_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmpadepay, "rtpmpadepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MPA_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_mpa_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -172,10 +175,3 @@ empty_packet:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_mpa_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmpadepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MPA_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmpadepay.h b/gst/rtp/gstrtpmpadepay.h
index 1070d779b..9c06df345 100644
--- a/gst/rtp/gstrtpmpadepay.h
+++ b/gst/rtp/gstrtpmpadepay.h
@@ -51,8 +51,6 @@ struct _GstRtpMPADepayClass
 
 GType gst_rtp_mpa_depay_get_type (void);
 
-gboolean gst_rtp_mpa_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MPA_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmpapay.c b/gst/rtp/gstrtpmpapay.c
index 62639f712..2c59a85e6 100644
--- a/gst/rtp/gstrtpmpapay.c
+++ b/gst/rtp/gstrtpmpapay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpmpapay.h"
 #include "gstrtputils.h"
 
@@ -68,6 +69,8 @@ static GstFlowReturn gst_rtp_mpa_pay_handle_buffer (GstRTPBasePayload * payload,
 
 #define gst_rtp_mpa_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMPAPay, gst_rtp_mpa_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmpapay, "rtpmpapay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MPA_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_mpa_pay_class_init (GstRtpMPAPayClass * klass)
@@ -239,8 +242,10 @@ gst_rtp_mpa_pay_flush (GstRtpMPAPay * rtpmpapay)
     avail -= payload_len;
     frag_offset += payload_len;
 
-    if (avail == 0)
+    if (avail == 0) {
       gst_rtp_buffer_set_marker (&rtp, TRUE);
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
+    }
 
     gst_rtp_buffer_unmap (&rtp);
 
@@ -336,10 +341,3 @@ gst_rtp_mpa_pay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-gboolean
-gst_rtp_mpa_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmpapay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MPA_PAY);
-}
diff --git a/gst/rtp/gstrtpmpapay.h b/gst/rtp/gstrtpmpapay.h
index db298528e..759ce87e8 100644
--- a/gst/rtp/gstrtpmpapay.h
+++ b/gst/rtp/gstrtpmpapay.h
@@ -56,8 +56,6 @@ struct _GstRtpMPAPayClass
 
 GType gst_rtp_mpa_pay_get_type (void);
 
-gboolean gst_rtp_mpa_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MPA_PAY_H__ */
diff --git a/gst/rtp/gstrtpmparobustdepay.c b/gst/rtp/gstrtpmparobustdepay.c
index 702d2b0ea..ca7f1f19a 100644
--- a/gst/rtp/gstrtpmparobustdepay.c
+++ b/gst/rtp/gstrtpmparobustdepay.c
@@ -26,6 +26,7 @@
 
 #include <stdio.h>
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpmparobustdepay.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpmparobustdepay_debug);
@@ -70,6 +71,9 @@ typedef struct _GstADUFrame
 #define gst_rtp_mpa_robust_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpMPARobustDepay, gst_rtp_mpa_robust_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmparobustdepay, "rtpmparobustdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MPA_ROBUST_DEPAY,
+    rtp_element_init (plugin));
 
 static GstStateChangeReturn gst_rtp_mpa_robust_change_state (GstElement *
     element, GstStateChange transition);
@@ -802,10 +806,3 @@ gst_rtp_mpa_robust_change_state (GstElement * element,
 
   return ret;
 }
-
-gboolean
-gst_rtp_mpa_robust_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmparobustdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MPA_ROBUST_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmparobustdepay.h b/gst/rtp/gstrtpmparobustdepay.h
index fc9ec0b69..8a3f51bc5 100644
--- a/gst/rtp/gstrtpmparobustdepay.h
+++ b/gst/rtp/gstrtpmparobustdepay.h
@@ -71,8 +71,6 @@ struct _GstRtpMPARobustDepayClass
 
 GType gst_rtp_mpa_robust_depay_get_type (void);
 
-gboolean gst_rtp_mpa_robust_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MPA_ROBUST_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmpvdepay.c b/gst/rtp/gstrtpmpvdepay.c
index 973194605..71c071251 100644
--- a/gst/rtp/gstrtpmpvdepay.c
+++ b/gst/rtp/gstrtpmpvdepay.c
@@ -25,6 +25,7 @@
 #include <gst/video/video.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpmpvdepay.h"
 #include "gstrtputils.h"
 
@@ -55,6 +56,8 @@ static GstStaticPadTemplate gst_rtp_mpv_depay_sink_template =
     );
 
 G_DEFINE_TYPE (GstRtpMPVDepay, gst_rtp_mpv_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmpvdepay, "rtpmpvdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MPV_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_mpv_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -189,10 +192,3 @@ empty_packet:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_mpv_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmpvdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MPV_DEPAY);
-}
diff --git a/gst/rtp/gstrtpmpvdepay.h b/gst/rtp/gstrtpmpvdepay.h
index 80f6c4332..158c2dcd4 100644
--- a/gst/rtp/gstrtpmpvdepay.h
+++ b/gst/rtp/gstrtpmpvdepay.h
@@ -51,8 +51,6 @@ struct _GstRtpMPVDepayClass
 
 GType gst_rtp_mpv_depay_get_type (void);
 
-gboolean gst_rtp_mpv_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MPV_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpmpvpay.c b/gst/rtp/gstrtpmpvpay.c
index eb73af25e..9d3f30f1c 100644
--- a/gst/rtp/gstrtpmpvpay.c
+++ b/gst/rtp/gstrtpmpvpay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpmpvpay.h"
 #include "gstrtputils.h"
 
@@ -69,6 +70,8 @@ static gboolean gst_rtp_mpv_pay_sink_event (GstRTPBasePayload * payload,
 
 #define gst_rtp_mpv_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRTPMPVPay, gst_rtp_mpv_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpmpvpay, "rtpmpvpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_MPV_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_mpv_pay_class_init (GstRTPMPVPayClass * klass)
@@ -204,7 +207,9 @@ gst_rtp_mpv_pay_flush (GstRTPMPVPay * rtpmpvpay)
 
     payload_len = gst_rtp_buffer_calc_payload_len (towrite, 0, 0);
 
-    outbuf = gst_rtp_buffer_new_allocate (4, 0, 0);
+    outbuf =
+        gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+        (rtpmpvpay), 4, 0, 0);
 
     payload_len -= 4;
 
@@ -229,6 +234,8 @@ gst_rtp_mpv_pay_flush (GstRTPMPVPay * rtpmpvpay)
     avail -= payload_len;
 
     gst_rtp_buffer_set_marker (&rtp, avail == 0);
+    if (avail == 0)
+      GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
     gst_rtp_buffer_unmap (&rtp);
 
     paybuf = gst_adapter_take_buffer_fast (rtpmpvpay->adapter, payload_len);
@@ -325,11 +332,3 @@ gst_rtp_mpv_pay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-
-gboolean
-gst_rtp_mpv_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpmpvpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_MPV_PAY);
-}
diff --git a/gst/rtp/gstrtpmpvpay.h b/gst/rtp/gstrtpmpvpay.h
index bcebad932..a909ce92a 100644
--- a/gst/rtp/gstrtpmpvpay.h
+++ b/gst/rtp/gstrtpmpvpay.h
@@ -57,8 +57,6 @@ struct _GstRTPMPVPayClass
 
 GType gst_rtp_mpv_pay_get_type (void);
 
-gboolean gst_rtp_mpv_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_MPV_PAY_H__ */
diff --git a/gst/rtp/gstrtpopusdepay.c b/gst/rtp/gstrtpopusdepay.c
index f672339f4..d20dd7d85 100644
--- a/gst/rtp/gstrtpopusdepay.c
+++ b/gst/rtp/gstrtpopusdepay.c
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpopusdepay.h"
 #include "gstrtputils.h"
 
@@ -41,14 +42,14 @@ GST_STATIC_PAD_TEMPLATE ("sink",
         "media = (string) \"audio\", "
         "payload = (int) " GST_RTP_PAYLOAD_DYNAMIC_STRING ","
         "clock-rate = (int) 48000, "
-        "encoding-name = (string) { \"OPUS\", \"X-GST-OPUS-DRAFT-SPITTKA-00\" }")
+        "encoding-name = (string) { \"OPUS\", \"X-GST-OPUS-DRAFT-SPITTKA-00\", \"MULTIOPUS\" }")
     );
 
 static GstStaticPadTemplate gst_rtp_opus_depay_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/x-opus, channel-mapping-family = (int) 0")
+    GST_STATIC_CAPS ("audio/x-opus, channel-mapping-family = (int) [ 0, 1 ]")
     );
 
 static GstBuffer *gst_rtp_opus_depay_process (GstRTPBaseDepayload * depayload,
@@ -58,6 +59,8 @@ static gboolean gst_rtp_opus_depay_setcaps (GstRTPBaseDepayload * depayload,
 
 G_DEFINE_TYPE (GstRTPOpusDepay, gst_rtp_opus_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpopusdepay, "rtpopusdepay",
+    GST_RANK_PRIMARY, GST_TYPE_RTP_OPUS_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_opus_depay_class_init (GstRTPOpusDepayClass * klass)
@@ -96,21 +99,118 @@ gst_rtp_opus_depay_setcaps (GstRTPBaseDepayload * depayload, GstCaps * caps)
   GstCaps *srccaps;
   GstStructure *s;
   gboolean ret;
-  const gchar *sprop_stereo, *sprop_maxcapturerate;
+  const gchar *sprop_maxcapturerate;
 
-  srccaps =
-      gst_caps_new_simple ("audio/x-opus", "channel-mapping-family", G_TYPE_INT,
-      0, NULL);
+  srccaps = gst_caps_new_empty_simple ("audio/x-opus");
 
   s = gst_caps_get_structure (caps, 0);
-  if ((sprop_stereo = gst_structure_get_string (s, "sprop-stereo"))) {
-    if (strcmp (sprop_stereo, "0") == 0)
-      gst_caps_set_simple (srccaps, "channels", G_TYPE_INT, 1, NULL);
-    else if (strcmp (sprop_stereo, "1") == 0)
+
+  if (g_str_equal (gst_structure_get_string (s, "encoding-name"), "MULTIOPUS")) {
+    gint channels;
+    gint stream_count;
+    gint coupled_count;
+    const gchar *encoding_params;
+    const gchar *num_streams;
+    const gchar *coupled_streams;
+    const gchar *channel_mapping;
+    gchar *endptr;
+
+    if (!gst_structure_has_field_typed (s, "encoding-params", G_TYPE_STRING) ||
+        !gst_structure_has_field_typed (s, "num_streams", G_TYPE_STRING) ||
+        !gst_structure_has_field_typed (s, "coupled_streams", G_TYPE_STRING) ||
+        !gst_structure_has_field_typed (s, "channel_mapping", G_TYPE_STRING)) {
+      GST_WARNING_OBJECT (depayload, "Encoding name 'MULTIOPUS' requires "
+          "encoding-params, num_streams, coupled_streams and channel_mapping "
+          "as string fields in caps.");
+      goto reject_caps;
+    }
+
+    gst_caps_set_simple (srccaps, "channel-mapping-family", G_TYPE_INT, 1,
+        NULL);
+
+    encoding_params = gst_structure_get_string (s, "encoding-params");
+    channels = g_ascii_strtoull (encoding_params, &endptr, 10);
+    if (*endptr != '\0' || channels > 255) {
+      GST_WARNING_OBJECT (depayload, "Invalid encoding-params value '%s'",
+          encoding_params);
+      goto reject_caps;
+    }
+    gst_caps_set_simple (srccaps, "channels", G_TYPE_INT, channels, NULL);
+
+    num_streams = gst_structure_get_string (s, "num_streams");
+    stream_count = g_ascii_strtoull (num_streams, &endptr, 10);
+    if (*endptr != '\0' || stream_count > channels) {
+      GST_WARNING_OBJECT (depayload, "Invalid num_streams value '%s'",
+          num_streams);
+      goto reject_caps;
+    }
+    gst_caps_set_simple (srccaps, "stream-count", G_TYPE_INT, stream_count,
+        NULL);
+
+    coupled_streams = gst_structure_get_string (s, "coupled_streams");
+    coupled_count = g_ascii_strtoull (coupled_streams, &endptr, 10);
+    if (*endptr != '\0' || coupled_count > stream_count) {
+      GST_WARNING_OBJECT (depayload, "Invalid coupled_streams value '%s'",
+          coupled_streams);
+      goto reject_caps;
+    }
+    gst_caps_set_simple (srccaps, "coupled-count", G_TYPE_INT, coupled_count,
+        NULL);
+
+    channel_mapping = gst_structure_get_string (s, "channel_mapping");
+    {
+      gchar **split;
+      gchar **ptr;
+      GValue mapping = G_VALUE_INIT;
+      GValue v = G_VALUE_INIT;
+
+      split = g_strsplit (channel_mapping, ",", -1);
+
+      g_value_init (&mapping, GST_TYPE_ARRAY);
+      g_value_init (&v, G_TYPE_INT);
+
+      for (ptr = split; *ptr; ++ptr) {
+        gint channel = g_ascii_strtoull (*ptr, &endptr, 10);
+        if (*endptr != '\0' || channel > channels) {
+          GST_WARNING_OBJECT (depayload, "Invalid channel_mapping value '%s'",
+              channel_mapping);
+          g_value_unset (&mapping);
+          break;
+        }
+        g_value_set_int (&v, channel);
+        gst_value_array_append_value (&mapping, &v);
+      }
+
+      g_value_unset (&v);
+      g_strfreev (split);
+
+      if (G_IS_VALUE (&mapping)) {
+        gst_caps_set_value (srccaps, "channel-mapping", &mapping);
+        g_value_unset (&mapping);
+      } else {
+        goto reject_caps;
+      }
+    }
+  } else {
+    const gchar *sprop_stereo;
+
+    gst_caps_set_simple (srccaps, "channel-mapping-family", G_TYPE_INT, 0,
+        NULL);
+
+    if ((sprop_stereo = gst_structure_get_string (s, "sprop-stereo"))) {
+      if (strcmp (sprop_stereo, "0") == 0)
+        gst_caps_set_simple (srccaps, "channels", G_TYPE_INT, 1, NULL);
+      else if (strcmp (sprop_stereo, "1") == 0)
+        gst_caps_set_simple (srccaps, "channels", G_TYPE_INT, 2, NULL);
+      else
+        GST_WARNING_OBJECT (depayload, "Unknown sprop-stereo value '%s'",
+            sprop_stereo);
+    } else {
+      /* Although sprop-stereo defaults to mono as per RFC 7587, this just means
+         that the signal is likely mono and can be safely downmixed, it may
+         still be stereo at times. */
       gst_caps_set_simple (srccaps, "channels", G_TYPE_INT, 2, NULL);
-    else
-      GST_WARNING_OBJECT (depayload, "Unknown sprop-stereo value '%s'",
-          sprop_stereo);
+    }
   }
 
   if ((sprop_maxcapturerate =
@@ -137,6 +237,11 @@ gst_rtp_opus_depay_setcaps (GstRTPBaseDepayload * depayload, GstCaps * caps)
   depayload->clock_rate = 48000;
 
   return ret;
+
+reject_caps:
+  gst_caps_unref (srccaps);
+
+  return FALSE;
 }
 
 static GstBuffer *
@@ -151,10 +256,3 @@ gst_rtp_opus_depay_process (GstRTPBaseDepayload * depayload,
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_opus_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpopusdepay",
-      GST_RANK_PRIMARY, GST_TYPE_RTP_OPUS_DEPAY);
-}
diff --git a/gst/rtp/gstrtpopusdepay.h b/gst/rtp/gstrtpopusdepay.h
index 38cc85108..7890eb19d 100644
--- a/gst/rtp/gstrtpopusdepay.h
+++ b/gst/rtp/gstrtpopusdepay.h
@@ -53,7 +53,5 @@ struct _GstRTPOpusDepayClass
 
 GType gst_rtp_opus_depay_get_type (void);
 
-gboolean gst_rtp_opus_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_OPUS_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpopuspay.c b/gst/rtp/gstrtpopuspay.c
index 871a18248..e62868c37 100644
--- a/gst/rtp/gstrtpopuspay.c
+++ b/gst/rtp/gstrtpopuspay.c
@@ -19,6 +19,29 @@
  * Boston, MA 02110-1301, USA.
  */
 
+/**
+ * SECTION:element-rtpopuspay
+ * @title: rtpopuspay
+ *
+ * rtpopuspay encapsulates Opus-encoded audio data into RTP packets following
+ * the payload format described in RFC 7587.
+ *
+ * In addition to the RFC, which assumes only mono and stereo payload,
+ * the element supports multichannel Opus audio streams using a non-standardized
+ * SDP config and "MULTIOPUS" codec developed by Google for libwebrtc. When the
+ * input data have more than 2 channels, rtpopuspay will add extra fields to
+ * output caps that can be used to generate SDP in the syntax understood by
+ * libwebrtc. For example in the case of 5.1 audio:
+ *
+ * |[
+ *  a=rtpmap:96 multiopus/48000/6
+ *  a=fmtp:96 num_streams=4;coupled_streams=2;channel_mapping=0,4,1,2,3,5
+ * ]|
+ *
+ * See https://webrtc-review.googlesource.com/c/src/+/129768 for more details on
+ * multichannel Opus in libwebrtc.
+ */
+
 #ifdef HAVE_CONFIG_H
 #  include "config.h"
 #endif
@@ -28,18 +51,28 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpopuspay.h"
 #include "gstrtputils.h"
 
 GST_DEBUG_CATEGORY_STATIC (rtpopuspay_debug);
 #define GST_CAT_DEFAULT (rtpopuspay_debug)
 
+enum
+{
+  PROP_0,
+  PROP_DTX,
+};
+
+#define DEFAULT_DTX FALSE
 
 static GstStaticPadTemplate gst_rtp_opus_pay_sink_template =
-GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
     GST_PAD_ALWAYS,
-    GST_STATIC_CAPS ("audio/x-opus, channel-mapping-family = (int) 0")
+    GST_STATIC_CAPS ("audio/x-opus, channel-mapping-family = (int) 0;"
+        "audio/x-opus, channel-mapping-family = (int) 0, channels = (int) [1, 2];"
+        "audio/x-opus, channel-mapping-family = (int) 1, channels = (int) [3, 255]")
     );
 
 static GstStaticPadTemplate gst_rtp_opus_pay_src_template =
@@ -50,8 +83,7 @@ GST_STATIC_PAD_TEMPLATE ("src",
         "media = (string) \"audio\", "
         "payload = (int) " GST_RTP_PAYLOAD_DYNAMIC_STRING ", "
         "clock-rate = (int) 48000, "
-        "encoding-params = (string) \"2\", "
-        "encoding-name = (string) { \"OPUS\", \"X-GST-OPUS-DRAFT-SPITTKA-00\" }")
+        "encoding-name = (string) { \"OPUS\", \"X-GST-OPUS-DRAFT-SPITTKA-00\", \"MULTIOPUS\" }")
     );
 
 static gboolean gst_rtp_opus_pay_setcaps (GstRTPBasePayload * payload,
@@ -62,25 +94,108 @@ static GstFlowReturn gst_rtp_opus_pay_handle_buffer (GstRTPBasePayload *
     payload, GstBuffer * buffer);
 
 G_DEFINE_TYPE (GstRtpOPUSPay, gst_rtp_opus_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpopuspay, "rtpopuspay",
+    GST_RANK_PRIMARY, GST_TYPE_RTP_OPUS_PAY, rtp_element_init (plugin));
+
+#define GST_RTP_OPUS_PAY_CAST(obj) ((GstRtpOPUSPay *)(obj))
+
+static void
+gst_rtp_opus_pay_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstRtpOPUSPay *self = GST_RTP_OPUS_PAY (object);
+
+  switch (prop_id) {
+    case PROP_DTX:
+      self->dtx = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_opus_pay_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstRtpOPUSPay *self = GST_RTP_OPUS_PAY (object);
+
+  switch (prop_id) {
+    case PROP_DTX:
+      g_value_set_boolean (value, self->dtx);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static GstStateChangeReturn
+gst_rtp_opus_pay_change_state (GstElement * element, GstStateChange transition)
+{
+  GstRtpOPUSPay *self = GST_RTP_OPUS_PAY (element);
+  GstStateChangeReturn ret;
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      self->marker = TRUE;
+      break;
+    default:
+      break;
+  }
+
+  ret =
+      GST_ELEMENT_CLASS (gst_rtp_opus_pay_parent_class)->change_state (element,
+      transition);
+
+  switch (transition) {
+    default:
+      break;
+  }
+
+  return ret;
+}
 
 static void
 gst_rtp_opus_pay_class_init (GstRtpOPUSPayClass * klass)
 {
   GstRTPBasePayloadClass *gstbasertppayload_class;
   GstElementClass *element_class;
+  GObjectClass *gobject_class;
 
   gstbasertppayload_class = (GstRTPBasePayloadClass *) klass;
   element_class = GST_ELEMENT_CLASS (klass);
+  gobject_class = (GObjectClass *) klass;
+
+  element_class->change_state = gst_rtp_opus_pay_change_state;
 
   gstbasertppayload_class->set_caps = gst_rtp_opus_pay_setcaps;
   gstbasertppayload_class->get_caps = gst_rtp_opus_pay_getcaps;
   gstbasertppayload_class->handle_buffer = gst_rtp_opus_pay_handle_buffer;
 
+  gobject_class->set_property = gst_rtp_opus_pay_set_property;
+  gobject_class->get_property = gst_rtp_opus_pay_get_property;
+
   gst_element_class_add_static_pad_template (element_class,
       &gst_rtp_opus_pay_src_template);
   gst_element_class_add_static_pad_template (element_class,
       &gst_rtp_opus_pay_sink_template);
 
+  /**
+   * GstRtpOPUSPay:dtx:
+   *
+   * If enabled, the payloader will not transmit empty packets.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_DTX,
+      g_param_spec_boolean ("dtx", "Discontinuous Transmission",
+          "If enabled, the payloader will not transmit empty packets",
+          DEFAULT_DTX,
+          G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
+          G_PARAM_STATIC_STRINGS));
+
   gst_element_class_set_static_metadata (element_class,
       "RTP Opus payloader",
       "Codec/Payloader/Network/RTP",
@@ -94,6 +209,7 @@ gst_rtp_opus_pay_class_init (GstRtpOPUSPayClass * klass)
 static void
 gst_rtp_opus_pay_init (GstRtpOPUSPay * rtpopuspay)
 {
+  rtpopuspay->dtx = DEFAULT_DTX;
 }
 
 static gboolean
@@ -101,11 +217,13 @@ gst_rtp_opus_pay_setcaps (GstRTPBasePayload * payload, GstCaps * caps)
 {
   gboolean res;
   GstCaps *src_caps;
-  GstStructure *s;
+  GstStructure *s, *outcaps;
   const char *encoding_name = "OPUS";
-  gint channels, rate;
-  const char *sprop_stereo = NULL;
-  char *sprop_maxcapturerate = NULL;
+  gint channels = 2;
+  gint rate;
+  gchar *encoding_params;
+
+  outcaps = gst_structure_new_empty ("unused");
 
   src_caps = gst_pad_get_allowed_caps (GST_RTP_BASE_PAYLOAD_SRCPAD (payload));
   if (src_caps) {
@@ -130,41 +248,75 @@ gst_rtp_opus_pay_setcaps (GstRTPBasePayload * payload, GstCaps * caps)
   s = gst_caps_get_structure (caps, 0);
   if (gst_structure_get_int (s, "channels", &channels)) {
     if (channels > 2) {
-      GST_ERROR_OBJECT (payload,
-          "More than 2 channels with channel-mapping-family=0 is invalid");
-      return FALSE;
-    } else if (channels == 2) {
-      sprop_stereo = "1";
+      /* Implies channel-mapping-family = 1. */
+
+      gint stream_count, coupled_count;
+      const GValue *channel_mapping_array;
+
+      /* libwebrtc only supports "multiopus" when channels > 2. Mono and stereo
+       * sound must always be payloaded according to RFC 7587. */
+      encoding_name = "MULTIOPUS";
+
+      if (gst_structure_get_int (s, "stream-count", &stream_count)) {
+        char *num_streams = g_strdup_printf ("%d", stream_count);
+        gst_structure_set (outcaps, "num_streams", G_TYPE_STRING, num_streams,
+            NULL);
+        g_free (num_streams);
+      }
+      if (gst_structure_get_int (s, "coupled-count", &coupled_count)) {
+        char *coupled_streams = g_strdup_printf ("%d", coupled_count);
+        gst_structure_set (outcaps, "coupled_streams", G_TYPE_STRING,
+            coupled_streams, NULL);
+        g_free (coupled_streams);
+      }
+
+      channel_mapping_array = gst_structure_get_value (s, "channel-mapping");
+      if (GST_VALUE_HOLDS_ARRAY (channel_mapping_array)) {
+        GString *str = g_string_new (NULL);
+        guint i;
+
+        for (i = 0; i < gst_value_array_get_size (channel_mapping_array); ++i) {
+          if (i != 0) {
+            g_string_append_c (str, ',');
+          }
+          g_string_append_printf (str, "%d",
+              g_value_get_int (gst_value_array_get_value (channel_mapping_array,
+                      i)));
+        }
+
+        gst_structure_set (outcaps, "channel_mapping", G_TYPE_STRING, str->str,
+            NULL);
+
+        g_string_free (str, TRUE);
+      }
     } else {
-      sprop_stereo = "0";
+      gst_structure_set (outcaps, "sprop-stereo", G_TYPE_STRING,
+          (channels == 2) ? "1" : "0", NULL);
+      /* RFC 7587 requires the number of channels always be 2. */
+      channels = 2;
     }
   }
 
+  encoding_params = g_strdup_printf ("%d", channels);
+  gst_structure_set (outcaps, "encoding-params", G_TYPE_STRING,
+      encoding_params, NULL);
+  g_free (encoding_params);
+
   if (gst_structure_get_int (s, "rate", &rate)) {
-    sprop_maxcapturerate = g_strdup_printf ("%d", rate);
+    gchar *sprop_maxcapturerate = g_strdup_printf ("%d", rate);
+
+    gst_structure_set (outcaps, "sprop-maxcapturerate", G_TYPE_STRING,
+        sprop_maxcapturerate, NULL);
+
+    g_free (sprop_maxcapturerate);
   }
 
   gst_rtp_base_payload_set_options (payload, "audio", FALSE,
       encoding_name, 48000);
 
-  if (sprop_maxcapturerate && sprop_stereo) {
-    res =
-        gst_rtp_base_payload_set_outcaps (payload, "sprop-maxcapturerate",
-        G_TYPE_STRING, sprop_maxcapturerate, "sprop-stereo", G_TYPE_STRING,
-        sprop_stereo, NULL);
-  } else if (sprop_maxcapturerate) {
-    res =
-        gst_rtp_base_payload_set_outcaps (payload, "sprop-maxcapturerate",
-        G_TYPE_STRING, sprop_maxcapturerate, NULL);
-  } else if (sprop_stereo) {
-    res =
-        gst_rtp_base_payload_set_outcaps (payload, "sprop-stereo",
-        G_TYPE_STRING, sprop_stereo, NULL);
-  } else {
-    res = gst_rtp_base_payload_set_outcaps (payload, NULL);
-  }
+  res = gst_rtp_base_payload_set_outcaps_structure (payload, outcaps);
 
-  g_free (sprop_maxcapturerate);
+  gst_structure_free (outcaps);
 
   return res;
 }
@@ -173,9 +325,19 @@ static GstFlowReturn
 gst_rtp_opus_pay_handle_buffer (GstRTPBasePayload * basepayload,
     GstBuffer * buffer)
 {
+  GstRtpOPUSPay *self = GST_RTP_OPUS_PAY_CAST (basepayload);
   GstBuffer *outbuf;
   GstClockTime pts, dts, duration;
 
+  /* DTX packets are zero-length frames, with a 1 or 2-bytes header */
+  if (self->dtx && gst_buffer_get_size (buffer) <= 2) {
+    GST_LOG_OBJECT (self,
+        "discard empty buffer as DTX is enabled: %" GST_PTR_FORMAT, buffer);
+    self->marker = TRUE;
+    gst_buffer_unref (buffer);
+    return GST_FLOW_OK;
+  }
+
   pts = GST_BUFFER_PTS (buffer);
   dts = GST_BUFFER_DTS (buffer);
   duration = GST_BUFFER_DURATION (buffer);
@@ -190,6 +352,17 @@ gst_rtp_opus_pay_handle_buffer (GstRTPBasePayload * basepayload,
   GST_BUFFER_DTS (outbuf) = dts;
   GST_BUFFER_DURATION (outbuf) = duration;
 
+  if (self->marker) {
+    GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+
+    gst_rtp_buffer_map (outbuf, GST_MAP_READWRITE, &rtp);
+    gst_rtp_buffer_set_marker (&rtp, TRUE);
+    gst_rtp_buffer_unmap (&rtp);
+
+    GST_BUFFER_FLAG_SET (outbuf, GST_BUFFER_FLAG_MARKER);
+    self->marker = FALSE;
+  }
+
   /* Push out */
   return gst_rtp_base_payload_push (basepayload, outbuf);
 }
@@ -198,9 +371,13 @@ static GstCaps *
 gst_rtp_opus_pay_getcaps (GstRTPBasePayload * payload,
     GstPad * pad, GstCaps * filter)
 {
-  GstCaps *caps, *peercaps, *tcaps;
   GstStructure *s;
-  const gchar *stereo;
+  int channel_mapping_family = 0;
+  GstCaps *caps, *peercaps, *tcaps, *tempcaps;
+  static GstStaticCaps opus_static_caps = GST_STATIC_CAPS ("application/x-rtp, "
+      "encoding-name=(string) { \"OPUS\", \"X-GST-OPUS-DRAFT-SPITTKA-00\"}");
+  static GstStaticCaps multiopus_static_caps =
+      GST_STATIC_CAPS ("application/x-rtp, encoding-name=(string)MULTIOPUS");
 
   if (pad == GST_RTP_BASE_PAYLOAD_SRCPAD (payload))
     return
@@ -221,23 +398,59 @@ gst_rtp_opus_pay_getcaps (GstRTPBasePayload * payload,
 
   caps = gst_pad_get_pad_template_caps (GST_RTP_BASE_PAYLOAD_SINKPAD (payload));
 
-  s = gst_caps_get_structure (peercaps, 0);
-  stereo = gst_structure_get_string (s, "stereo");
-  if (stereo != NULL) {
-    caps = gst_caps_make_writable (caps);
+  tempcaps = gst_static_caps_get (&opus_static_caps);
+  if (!gst_caps_can_intersect (peercaps, tempcaps)) {
+    GstCaps *multiopuscaps = gst_caps_new_simple ("audio/x-opus",
+        "channel-mapping-family", G_TYPE_INT, 1,
+        "channels", GST_TYPE_INT_RANGE, 3, 255,
+        NULL);
+    GstCaps *intersect_caps;
 
-    if (!strcmp (stereo, "1")) {
-      GstCaps *caps2 = gst_caps_copy (caps);
+    intersect_caps = gst_caps_intersect_full (caps, multiopuscaps,
+        GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (caps);
+    gst_caps_unref (multiopuscaps);
+    caps = intersect_caps;
+  }
+  gst_caps_unref (tempcaps);
 
-      gst_caps_set_simple (caps, "channels", G_TYPE_INT, 2, NULL);
-      gst_caps_set_simple (caps2, "channels", G_TYPE_INT, 1, NULL);
-      caps = gst_caps_merge (caps, caps2);
-    } else if (!strcmp (stereo, "0")) {
-      GstCaps *caps2 = gst_caps_copy (caps);
+  tempcaps = gst_static_caps_get (&multiopus_static_caps);
+  if (!gst_caps_can_intersect (peercaps, tempcaps)) {
+    GstCaps *opuscaps = gst_caps_new_simple ("audio/x-opus",
+        "channel-mapping-family", G_TYPE_INT, 0,
+        "channels", GST_TYPE_INT_RANGE, 1, 2,
+        NULL);
+    GstCaps *intersect_caps;
 
-      gst_caps_set_simple (caps, "channels", G_TYPE_INT, 1, NULL);
-      gst_caps_set_simple (caps2, "channels", G_TYPE_INT, 2, NULL);
-      caps = gst_caps_merge (caps, caps2);
+    intersect_caps = gst_caps_intersect_full (caps, opuscaps,
+        GST_CAPS_INTERSECT_FIRST);
+    gst_caps_unref (caps);
+    gst_caps_unref (opuscaps);
+    caps = intersect_caps;
+  }
+  gst_caps_unref (tempcaps);
+
+  s = gst_caps_get_structure (caps, 0);
+  gst_structure_get_int (s, "channel-mapping-family", &channel_mapping_family);
+  if (channel_mapping_family == 0) {
+    GstStructure *sp = gst_caps_get_structure (peercaps, 0);
+    const gchar *stereo = gst_structure_get_string (sp, "stereo");
+
+    if (stereo != NULL) {
+      guint channels = 0;
+
+      if (!strcmp (stereo, "1"))
+        channels = 2;
+      else if (!strcmp (stereo, "0"))
+        channels = 1;
+
+      if (channels) {
+        GstCaps *caps2 = gst_caps_copy_nth (caps, 0);
+
+        gst_caps_set_simple (caps2, "channels", G_TYPE_INT, channels, NULL);
+        caps = gst_caps_make_writable (caps);
+        caps = gst_caps_merge (caps2, caps);
+      }
     }
   }
   gst_caps_unref (peercaps);
@@ -252,10 +465,3 @@ gst_rtp_opus_pay_getcaps (GstRTPBasePayload * payload,
   GST_DEBUG_OBJECT (payload, "Returning caps: %" GST_PTR_FORMAT, caps);
   return caps;
 }
-
-gboolean
-gst_rtp_opus_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpopuspay",
-      GST_RANK_PRIMARY, GST_TYPE_RTP_OPUS_PAY);
-}
diff --git a/gst/rtp/gstrtpopuspay.h b/gst/rtp/gstrtpopuspay.h
index 45f40d85e..b862913af 100644
--- a/gst/rtp/gstrtpopuspay.h
+++ b/gst/rtp/gstrtpopuspay.h
@@ -44,6 +44,11 @@ typedef struct _GstRtpOPUSPayClass GstRtpOPUSPayClass;
 struct _GstRtpOPUSPay
 {
   GstRTPBasePayload payload;
+
+  gboolean dtx;
+
+  /* if the next produced buffer should have the MARKER flag */
+  gboolean marker;
 };
 
 struct _GstRtpOPUSPayClass
@@ -53,8 +58,6 @@ struct _GstRtpOPUSPayClass
 
 GType gst_rtp_opus_pay_get_type (void);
 
-gboolean gst_rtp_opus_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_OPUS_PAY_H__ */
diff --git a/gst/rtp/gstrtppcmadepay.c b/gst/rtp/gstrtppcmadepay.c
index 476a20aad..82727fbe9 100644
--- a/gst/rtp/gstrtppcmadepay.c
+++ b/gst/rtp/gstrtppcmadepay.c
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtppcmadepay.h"
 #include "gstrtputils.h"
 
@@ -69,6 +70,8 @@ static gboolean gst_rtp_pcma_depay_setcaps (GstRTPBaseDepayload * depayload,
 #define gst_rtp_pcma_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpPcmaDepay, gst_rtp_pcma_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtppcmadepay, "rtppcmadepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_PCMA_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_pcma_depay_class_init (GstRtpPcmaDepayClass * klass)
@@ -155,10 +158,3 @@ gst_rtp_pcma_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_pcma_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtppcmadepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_PCMA_DEPAY);
-}
diff --git a/gst/rtp/gstrtppcmadepay.h b/gst/rtp/gstrtppcmadepay.h
index e664a2d3d..c74bd0531 100644
--- a/gst/rtp/gstrtppcmadepay.h
+++ b/gst/rtp/gstrtppcmadepay.h
@@ -46,8 +46,6 @@ struct _GstRtpPcmaDepayClass
 
 GType gst_rtp_pcma_depay_get_type (void);
 
-gboolean gst_rtp_pcma_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_PCMA_DEPAY_H__ */
diff --git a/gst/rtp/gstrtppcmapay.c b/gst/rtp/gstrtppcmapay.c
index fde1b647c..c51639633 100644
--- a/gst/rtp/gstrtppcmapay.c
+++ b/gst/rtp/gstrtppcmapay.c
@@ -27,6 +27,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtppcmapay.h"
 
 static GstStaticPadTemplate gst_rtp_pcma_pay_sink_template =
@@ -56,6 +57,8 @@ static gboolean gst_rtp_pcma_pay_setcaps (GstRTPBasePayload * payload,
 #define gst_rtp_pcma_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpPcmaPay, gst_rtp_pcma_pay,
     GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtppcmapay, "rtppcmapay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_PCMA_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_pcma_pay_class_init (GstRtpPcmaPayClass * klass)
@@ -107,10 +110,3 @@ gst_rtp_pcma_pay_setcaps (GstRTPBasePayload * payload, GstCaps * caps)
 
   return res;
 }
-
-gboolean
-gst_rtp_pcma_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtppcmapay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_PCMA_PAY);
-}
diff --git a/gst/rtp/gstrtppcmapay.h b/gst/rtp/gstrtppcmapay.h
index 4e084ad09..7f67dffcd 100644
--- a/gst/rtp/gstrtppcmapay.h
+++ b/gst/rtp/gstrtppcmapay.h
@@ -47,8 +47,6 @@ struct _GstRtpPcmaPayClass
 
 GType gst_rtp_pcma_pay_get_type (void);
 
-gboolean gst_rtp_pcma_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_PCMA_PAY_H__ */
diff --git a/gst/rtp/gstrtppcmudepay.c b/gst/rtp/gstrtppcmudepay.c
index 1a06d187a..9bd3afb3d 100644
--- a/gst/rtp/gstrtppcmudepay.c
+++ b/gst/rtp/gstrtppcmudepay.c
@@ -26,6 +26,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtppcmudepay.h"
 #include "gstrtputils.h"
 
@@ -70,6 +71,8 @@ static gboolean gst_rtp_pcmu_depay_setcaps (GstRTPBaseDepayload * depayload,
 #define gst_rtp_pcmu_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpPcmuDepay, gst_rtp_pcmu_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtppcmudepay, "rtppcmudepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_PCMU_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_pcmu_depay_class_init (GstRtpPcmuDepayClass * klass)
@@ -156,10 +159,3 @@ gst_rtp_pcmu_depay_process (GstRTPBaseDepayload * depayload, GstRTPBuffer * rtp)
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_pcmu_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtppcmudepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_PCMU_DEPAY);
-}
diff --git a/gst/rtp/gstrtppcmudepay.h b/gst/rtp/gstrtppcmudepay.h
index 6a97559f8..a3d017349 100644
--- a/gst/rtp/gstrtppcmudepay.h
+++ b/gst/rtp/gstrtppcmudepay.h
@@ -46,8 +46,6 @@ struct _GstRtpPcmuDepayClass
 
 GType gst_rtp_pcmu_depay_get_type (void);
 
-gboolean gst_rtp_pcmu_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_PCMU_DEPAY_H__ */
diff --git a/gst/rtp/gstrtppcmupay.c b/gst/rtp/gstrtppcmupay.c
index 5931f85e2..5662789cb 100644
--- a/gst/rtp/gstrtppcmupay.c
+++ b/gst/rtp/gstrtppcmupay.c
@@ -27,6 +27,7 @@
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "gstrtppcmupay.h"
 
 static GstStaticPadTemplate gst_rtp_pcmu_pay_sink_template =
@@ -56,6 +57,8 @@ static gboolean gst_rtp_pcmu_pay_setcaps (GstRTPBasePayload * payload,
 #define gst_rtp_pcmu_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpPcmuPay, gst_rtp_pcmu_pay,
     GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtppcmupay, "rtppcmupay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_PCMU_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_pcmu_pay_class_init (GstRtpPcmuPayClass * klass)
@@ -107,10 +110,3 @@ gst_rtp_pcmu_pay_setcaps (GstRTPBasePayload * payload, GstCaps * caps)
 
   return res;
 }
-
-gboolean
-gst_rtp_pcmu_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtppcmupay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_PCMU_PAY);
-}
diff --git a/gst/rtp/gstrtppcmupay.h b/gst/rtp/gstrtppcmupay.h
index 7529d461c..cdeb3a2bf 100644
--- a/gst/rtp/gstrtppcmupay.h
+++ b/gst/rtp/gstrtppcmupay.h
@@ -47,8 +47,6 @@ struct _GstRtpPcmuPayClass
 
 GType gst_rtp_pcmu_pay_get_type (void);
 
-gboolean gst_rtp_pcmu_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_PCMU_PAY_H__ */
diff --git a/gst/rtp/gstrtpqcelpdepay.c b/gst/rtp/gstrtpqcelpdepay.c
index cb5d9eb95..949cf605b 100644
--- a/gst/rtp/gstrtpqcelpdepay.c
+++ b/gst/rtp/gstrtpqcelpdepay.c
@@ -26,6 +26,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpqcelpdepay.h"
 #include "gstrtputils.h"
 
@@ -81,6 +82,8 @@ static GstBuffer *gst_rtp_qcelp_depay_process (GstRTPBaseDepayload * depayload,
 #define gst_rtp_qcelp_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpQCELPDepay, gst_rtp_qcelp_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpqcelpdepay, "rtpqcelpdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_QCELP_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_qcelp_depay_class_init (GstRtpQCELPDepayClass * klass)
@@ -423,10 +426,3 @@ invalid_frame:
     return NULL;
   }
 }
-
-gboolean
-gst_rtp_qcelp_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpqcelpdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_QCELP_DEPAY);
-}
diff --git a/gst/rtp/gstrtpqcelpdepay.h b/gst/rtp/gstrtpqcelpdepay.h
index ade274de0..f278a7339 100644
--- a/gst/rtp/gstrtpqcelpdepay.h
+++ b/gst/rtp/gstrtpqcelpdepay.h
@@ -55,8 +55,6 @@ struct _GstRtpQCELPDepayClass
 
 GType gst_rtp_qcelp_depay_get_type (void);
 
-gboolean gst_rtp_qcelp_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_QCELP_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpqdmdepay.c b/gst/rtp/gstrtpqdmdepay.c
index 898663aa7..3edfb4630 100644
--- a/gst/rtp/gstrtpqdmdepay.c
+++ b/gst/rtp/gstrtpqdmdepay.c
@@ -25,6 +25,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpqdmdepay.h"
 #include "gstrtputils.h"
 
@@ -49,6 +50,12 @@ GST_STATIC_PAD_TEMPLATE ("sink",
 #define gst_rtp_qdm2_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpQDM2Depay, gst_rtp_qdm2_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+#define _do_init \
+  GST_DEBUG_CATEGORY_INIT (rtpqdm2depay_debug, "rtpqdm2depay", 0, \
+      "RTP QDM2 depayloader"); \
+  rtp_element_init (plugin)
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpqdm2depay, "rtpqdm2depay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_QDM2_DEPAY, _do_init);
 
 static const guint8 headheader[20] = {
   0x0, 0x0, 0x0, 0xc, 0x66, 0x72, 0x6d, 0x61,
@@ -402,13 +409,3 @@ gst_rtp_qdm2_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_qdm2_depay_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (rtpqdm2depay_debug, "rtpqdm2depay", 0,
-      "RTP QDM2 depayloader");
-
-  return gst_element_register (plugin, "rtpqdm2depay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_QDM2_DEPAY);
-}
diff --git a/gst/rtp/gstrtpqdmdepay.h b/gst/rtp/gstrtpqdmdepay.h
index 8a6b2b20a..d5d37566e 100644
--- a/gst/rtp/gstrtpqdmdepay.h
+++ b/gst/rtp/gstrtpqdmdepay.h
@@ -78,8 +78,6 @@ struct _GstRtpQDM2DepayClass
 
 GType gst_rtp_qdm2_depay_get_type (void);
 
-gboolean gst_rtp_qdm2_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_QDM2_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpreddec.c b/gst/rtp/gstrtpreddec.c
index 1e4781727..6c7ba363f 100644
--- a/gst/rtp/gstrtpreddec.c
+++ b/gst/rtp/gstrtpreddec.c
@@ -48,6 +48,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 
+#include "gstrtpelements.h"
 #include "rtpredcommon.h"
 #include "gstrtpreddec.h"
 #include "rtpulpfeccommon.h"
@@ -82,12 +83,15 @@ GST_DEBUG_CATEGORY_STATIC (gst_rtp_red_dec_debug);
 #define GST_CAT_DEFAULT gst_rtp_red_dec_debug
 
 G_DEFINE_TYPE (GstRtpRedDec, gst_rtp_red_dec, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpreddec, "rtpreddec", GST_RANK_NONE,
+    GST_TYPE_RTP_RED_DEC, rtp_element_init (plugin));
 
 enum
 {
   PROP_0,
   PROP_PT,
-  PROP_RECEIVED
+  PROP_RECEIVED,
+  PROP_PAYLOADS,
 };
 
 static RTPHistItem *
@@ -120,7 +124,8 @@ gst_rtp_red_history_find_less (gconstpointer item, gconstpointer timestamp)
 }
 
 static void
-gst_rtp_red_history_update (GstRtpRedDec * self, GstRTPBuffer * rtp)
+gst_rtp_red_history_update (GstRtpRedDec * self, GQueue * rtp_history,
+    GstRTPBuffer * rtp)
 {
   RTPHistItem *item;
   GList *link, *sibling;
@@ -129,12 +134,12 @@ gst_rtp_red_history_update (GstRtpRedDec * self, GstRTPBuffer * rtp)
    * allocate a new link and a new item,
    * otherwise reuse the tail (the oldest data) without any reallocations
    */
-  if (self->rtp_history->length < RTP_HISTORY_MAX_SIZE) {
+  if (rtp_history->length < RTP_HISTORY_MAX_SIZE) {
     item = rtp_hist_item_alloc ();
     link = g_list_alloc ();
     link->data = item;
   } else {
-    link = g_queue_pop_tail_link (self->rtp_history);
+    link = g_queue_pop_tail_link (rtp_history);
     item = link->data;
   }
 
@@ -144,11 +149,11 @@ gst_rtp_red_history_update (GstRtpRedDec * self, GstRTPBuffer * rtp)
   /* Looking for a place to insert new link.
    * The queue has newest to oldest rtp timestamps, so in 99% cases
    * it is inserted before the head of the queue */
-  sibling = g_list_find_custom (self->rtp_history->head,
+  sibling = g_list_find_custom (rtp_history->head,
       GUINT_TO_POINTER (item->timestamp),
       gst_rtp_red_history_find_less_or_equal);
-  g_queue_push_nth_link (self->rtp_history,
-      g_list_position (self->rtp_history->head, sibling), link);
+  g_queue_push_nth_link (rtp_history,
+      g_list_position (rtp_history->head, sibling), link);
 }
 
 static gboolean
@@ -216,9 +221,9 @@ red_buffer_invalid:
 
 static gboolean
 gst_red_history_lost_seq_num_for_timestamp (GstRtpRedDec * self,
-    guint32 timestamp, guint16 * dst_seq_num)
+    GQueue * rtp_history, guint32 timestamp, guint16 * dst_seq_num)
 {
-  GList *older_sibling = g_list_find_custom (self->rtp_history->head,
+  GList *older_sibling = g_list_find_custom (rtp_history->head,
       GUINT_TO_POINTER (timestamp),
       gst_rtp_red_history_find_less);
   RTPHistItem *older;
@@ -227,19 +232,19 @@ gst_red_history_lost_seq_num_for_timestamp (GstRtpRedDec * self,
   gint seq_diff, lost_packet_idx;
 
   if (NULL == older_sibling) {
-    if (self->rtp_history->length == RTP_HISTORY_MAX_SIZE)
+    if (rtp_history->length == RTP_HISTORY_MAX_SIZE)
       GST_WARNING_OBJECT (self, "History is too short. "
           "Oldest rtp timestamp %u, looking for %u, size %u",
-          RTP_HIST_ITEM_TIMESTAMP (self->rtp_history->tail->data),
-          timestamp, self->rtp_history->length);
+          RTP_HIST_ITEM_TIMESTAMP (rtp_history->tail->data),
+          timestamp, rtp_history->length);
     return FALSE;
   }
 
   if (NULL == older_sibling->prev) {
     GST_WARNING_OBJECT (self, "RED block timestamp offset probably wrong. "
         "Latest rtp timestamp %u, looking for %u, size %u",
-        RTP_HIST_ITEM_TIMESTAMP (self->rtp_history->head->data),
-        timestamp, self->rtp_history->length);
+        RTP_HIST_ITEM_TIMESTAMP (rtp_history->head->data),
+        timestamp, rtp_history->length);
     return FALSE;
   }
 
@@ -308,12 +313,15 @@ gst_rtp_red_create_packet (GstRtpRedDec * self, GstRTPBuffer * red_rtp,
 
   /* Timestamps, meta, flags from the RED packet should go to main block packet */
   gst_buffer_copy_into (ret, red_rtp->buffer, GST_BUFFER_COPY_METADATA, 0, -1);
+  if (marker)
+    GST_BUFFER_FLAG_SET (ret, GST_BUFFER_FLAG_MARKER);
   return ret;
 }
 
 static GstBuffer *
 gst_rtp_red_create_from_redundant_block (GstRtpRedDec * self,
-    GstRTPBuffer * red_rtp, gsize * red_hdr_offset, gsize * red_payload_offset)
+    GQueue * rtp_history, GstRTPBuffer * red_rtp, gsize * red_hdr_offset,
+    gsize * red_payload_offset)
 {
   guint8 *payload = gst_rtp_buffer_get_payload (red_rtp);
   guint8 *red_hdr = payload + *red_hdr_offset;
@@ -322,11 +330,12 @@ gst_rtp_red_create_from_redundant_block (GstRtpRedDec * self,
 
   GstBuffer *ret = NULL;
   guint16 lost_seq = 0;
-  if (gst_red_history_lost_seq_num_for_timestamp (self, lost_timestamp,
-          &lost_seq)) {
-    GST_LOG_OBJECT (self, "Recovering from RED packet pt=%u ts=%u seq=%u"
-        " len=%u present", rtp_red_block_get_payload_type (red_hdr),
-        lost_timestamp, lost_seq, rtp_red_block_get_payload_length (red_hdr));
+  if (gst_red_history_lost_seq_num_for_timestamp (self, rtp_history,
+          lost_timestamp, &lost_seq)) {
+    GST_LOG_OBJECT (self,
+        "Recovering from RED packet pt=%u ts=%u seq=%u" " len=%u present",
+        rtp_red_block_get_payload_type (red_hdr), lost_timestamp, lost_seq,
+        rtp_red_block_get_payload_length (red_hdr));
     ret =
         gst_rtp_red_create_packet (self, red_rtp, FALSE,
         rtp_red_block_get_payload_type (red_hdr), lost_seq, lost_timestamp,
@@ -364,13 +373,13 @@ gst_rtp_red_create_from_main_block (GstRtpRedDec * self,
 }
 
 static GstBuffer *
-gst_rtp_red_create_from_block (GstRtpRedDec * self, GstRTPBuffer * red_rtp,
-    gsize * red_hdr_offset, gsize * red_payload_offset)
+gst_rtp_red_create_from_block (GstRtpRedDec * self, GQueue * rtp_history,
+    GstRTPBuffer * red_rtp, gsize * red_hdr_offset, gsize * red_payload_offset)
 {
   guint8 *payload = gst_rtp_buffer_get_payload (red_rtp);
 
   if (rtp_red_block_is_redundant (payload + (*red_hdr_offset)))
-    return gst_rtp_red_create_from_redundant_block (self, red_rtp,
+    return gst_rtp_red_create_from_redundant_block (self, rtp_history, red_rtp,
         red_hdr_offset, red_payload_offset);
 
   return gst_rtp_red_create_from_main_block (self, red_rtp, *red_hdr_offset,
@@ -378,8 +387,8 @@ gst_rtp_red_create_from_block (GstRtpRedDec * self, GstRTPBuffer * red_rtp,
 }
 
 static GstFlowReturn
-gst_rtp_red_process (GstRtpRedDec * self, GstRTPBuffer * red_rtp,
-    gsize first_red_payload_offset)
+gst_rtp_red_process (GstRtpRedDec * self, GQueue * rtp_history,
+    GstRTPBuffer * red_rtp, gsize first_red_payload_offset)
 {
   gsize red_hdr_offset = 0;
   gsize red_payload_offset = first_red_payload_offset;
@@ -387,8 +396,8 @@ gst_rtp_red_process (GstRtpRedDec * self, GstRTPBuffer * red_rtp,
   GstFlowReturn ret = GST_FLOW_OK;
 
   do {
-    GstBuffer *buf =
-        gst_rtp_red_create_from_block (self, red_rtp, &red_hdr_offset,
+    GstBuffer *buf = gst_rtp_red_create_from_block (self, rtp_history, red_rtp,
+        &red_hdr_offset,
         &red_payload_offset);
     if (buf)
       ret = gst_pad_push (self->srcpad, buf);
@@ -397,6 +406,25 @@ gst_rtp_red_process (GstRtpRedDec * self, GstRTPBuffer * red_rtp,
   return ret;
 }
 
+static gboolean
+is_red_pt (GstRtpRedDec * self, guint8 pt)
+{
+  gboolean ret;
+
+  g_mutex_lock (&self->lock);
+  if (pt == self->pt) {
+    ret = TRUE;
+    goto done;
+  }
+
+  ret = self->payloads
+      && g_hash_table_contains (self->payloads, GINT_TO_POINTER (pt));
+
+done:
+  g_mutex_unlock (&self->lock);
+  return ret;
+}
+
 static GstFlowReturn
 gst_rtp_red_dec_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 {
@@ -404,16 +432,27 @@ gst_rtp_red_dec_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   GstRTPBuffer irtp = GST_RTP_BUFFER_INIT;
   GstFlowReturn ret = GST_FLOW_OK;
   gsize first_red_payload_offset = 0;
+  GQueue *rtp_history;
+  guint32 ssrc;
 
-  if (self->pt == UNDEF_PT)
+  if (self->pt == UNDEF_PT && self->payloads == NULL)
     return gst_pad_push (self->srcpad, buffer);
 
   if (!gst_rtp_buffer_map (buffer, GST_MAP_READ, &irtp))
     return gst_pad_push (self->srcpad, buffer);
 
-  gst_rtp_red_history_update (self, &irtp);
+  ssrc = gst_rtp_buffer_get_ssrc (&irtp);
+
+  if (!(rtp_history =
+          g_hash_table_lookup (self->rtp_histories, GUINT_TO_POINTER (ssrc)))) {
+    rtp_history = g_queue_new ();
+    g_hash_table_insert (self->rtp_histories, GUINT_TO_POINTER (ssrc),
+        rtp_history);
+  }
+
+  gst_rtp_red_history_update (self, rtp_history, &irtp);
 
-  if (self->pt != gst_rtp_buffer_get_payload_type (&irtp)) {
+  if (!is_red_pt (self, gst_rtp_buffer_get_payload_type (&irtp))) {
     GST_LOG_RTP_PACKET (self, "rtp header (incoming)", &irtp);
 
     gst_rtp_buffer_unmap (&irtp);
@@ -424,7 +463,9 @@ gst_rtp_red_dec_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 
   if (rtp_red_buffer_is_valid (self, &irtp, &first_red_payload_offset)) {
     GST_DEBUG_RTP_PACKET (self, "rtp header (red)", &irtp);
-    ret = gst_rtp_red_process (self, &irtp, first_red_payload_offset);
+    ret =
+        gst_rtp_red_process (self, rtp_history, &irtp,
+        first_red_payload_offset);
   }
 
   gst_rtp_buffer_unmap (&irtp);
@@ -437,11 +478,23 @@ gst_rtp_red_dec_dispose (GObject * obj)
 {
   GstRtpRedDec *self = GST_RTP_RED_DEC (obj);
 
-  g_queue_free_full (self->rtp_history, rtp_hist_item_free);
+  g_hash_table_unref (self->rtp_histories);
+
+  if (self->payloads) {
+    g_hash_table_unref (self->payloads);
+  }
+
+  g_mutex_clear (&self->lock);
 
   G_OBJECT_CLASS (gst_rtp_red_dec_parent_class)->dispose (obj);
 }
 
+static void
+free_rtp_history (GQueue * rtp_history)
+{
+  g_queue_free_full (rtp_history, rtp_hist_item_free);
+}
+
 static void
 gst_rtp_red_dec_init (GstRtpRedDec * self)
 {
@@ -463,10 +516,13 @@ gst_rtp_red_dec_init (GstRtpRedDec * self)
 
   self->pt = DEFAULT_PT;
   self->num_received = 0;
-  self->rtp_history = g_queue_new ();
+  self->rtp_histories =
+      g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL,
+      (GDestroyNotify) free_rtp_history);
+  self->payloads = NULL;
+  g_mutex_init (&self->lock);
 }
 
-
 static void
 gst_rtp_red_dec_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -475,14 +531,51 @@ gst_rtp_red_dec_set_property (GObject * object, guint prop_id,
 
   switch (prop_id) {
     case PROP_PT:
+      g_mutex_lock (&self->lock);
       self->pt = g_value_get_int (value);
+      g_mutex_unlock (&self->lock);
+      break;
+    case PROP_PAYLOADS:
+    {
+      guint i, n_vals;
+
+      g_mutex_lock (&self->lock);
+      if (self->payloads) {
+        g_hash_table_unref (self->payloads);
+        self->payloads = NULL;
+      }
+
+      n_vals = gst_value_array_get_size (value);
+
+      if (n_vals > 0) {
+        self->payloads = g_hash_table_new (g_direct_hash, g_direct_equal);
+
+        for (i = 0; i < gst_value_array_get_size (value); i++) {
+          const GValue *val = gst_value_array_get_value (value, i);
+
+          g_hash_table_insert (self->payloads,
+              GINT_TO_POINTER (g_value_get_int (val)), NULL);
+        }
+      }
+      g_mutex_unlock (&self->lock);
       break;
+    }
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
   }
 }
 
+static void
+append_payload (gpointer key, gpointer value, GValue * array)
+{
+  GValue v = { 0, };
+  g_value_init (&v, G_TYPE_INT);
+  g_value_set_int (&v, GPOINTER_TO_INT (key));
+  gst_value_array_append_value (array, &v);
+  g_value_unset (&v);
+}
+
 static void
 gst_rtp_red_dec_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec)
@@ -490,11 +583,22 @@ gst_rtp_red_dec_get_property (GObject * object, guint prop_id,
   GstRtpRedDec *self = GST_RTP_RED_DEC (object);
   switch (prop_id) {
     case PROP_PT:
+      g_mutex_lock (&self->lock);
       g_value_set_int (value, self->pt);
+      g_mutex_unlock (&self->lock);
       break;
     case PROP_RECEIVED:
       g_value_set_uint (value, self->num_received);
       break;
+    case PROP_PAYLOADS:
+    {
+      g_mutex_lock (&self->lock);
+      if (self->payloads) {
+        g_hash_table_foreach (self->payloads, (GHFunc) append_payload, value);
+      }
+      g_mutex_unlock (&self->lock);
+      break;
+    }
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -538,6 +642,27 @@ gst_rtp_red_dec_class_init (GstRtpRedDecClass * klass)
           "Count of received packets",
           0, G_MAXUINT32, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * rtpreddec:payloads:
+   *
+   * All the RED payloads this decoder may encounter
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (G_OBJECT_CLASS (klass),
+      PROP_PAYLOADS,
+      gst_param_spec_array ("payloads",
+          "RED payloads",
+          "All the RED payloads this decoder may encounter",
+          g_param_spec_int ("pt",
+              "payload type",
+              "A RED payload type",
+              MIN_PT, MAX_PT,
+              DEFAULT_PT,
+              G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS),
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)
+      );
+
   GST_DEBUG_CATEGORY_INIT (gst_rtp_red_dec_debug, "rtpreddec", 0,
       "RTP RED Decoder");
 }
diff --git a/gst/rtp/gstrtpreddec.h b/gst/rtp/gstrtpreddec.h
index 1ab864e2c..a1d89bf05 100644
--- a/gst/rtp/gstrtpreddec.h
+++ b/gst/rtp/gstrtpreddec.h
@@ -51,7 +51,14 @@ struct _GstRtpRedDec {
   gint pt;
   guint num_received;
 
-  GQueue *rtp_history;
+  /* Per ssrc */
+  GHashTable *rtp_histories;
+
+  /* To track all FEC payload types */
+  GHashTable *payloads;
+
+  /* Protects pt and payloads */
+  GMutex lock;
 };
 
 GType gst_rtp_red_dec_get_type (void);
diff --git a/gst/rtp/gstrtpredenc.c b/gst/rtp/gstrtpredenc.c
index f192b7862..7f234bc0d 100644
--- a/gst/rtp/gstrtpredenc.c
+++ b/gst/rtp/gstrtpredenc.c
@@ -52,6 +52,7 @@
 #include <string.h>
 #include <stdio.h>
 
+#include "gstrtpelements.h"
 #include "rtpredcommon.h"
 #include "gstrtpredenc.h"
 
@@ -78,8 +79,9 @@ static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
 
 GST_DEBUG_CATEGORY_STATIC (gst_rtp_red_enc_debug);
 #define GST_CAT_DEFAULT (gst_rtp_red_enc_debug)
-
 G_DEFINE_TYPE (GstRtpRedEnc, gst_rtp_red_enc, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpredenc, "rtpredenc", GST_RANK_NONE,
+    GST_TYPE_RTP_RED_ENC, rtp_element_init (plugin));
 
 enum
 {
@@ -155,8 +157,11 @@ _alloc_red_packet_and_fill_headers (GstRtpRedEnc * self,
     g_assert_not_reached ();
 
   /* Copying RTP header of incoming packet */
-  if (gst_rtp_buffer_get_extension (inp_rtp))
-    GST_WARNING_OBJECT (self, "FIXME: Ignoring RTP extension");
+  if (gst_rtp_buffer_get_extension (inp_rtp)
+      && !self->ignoring_extension_warned) {
+    GST_FIXME_OBJECT (self, "Ignoring RTP extension");
+    self->ignoring_extension_warned = TRUE;
+  }
 
   gst_rtp_buffer_set_marker (&red_rtp, gst_rtp_buffer_get_marker (inp_rtp));
   gst_rtp_buffer_set_payload_type (&red_rtp, self->pt);
@@ -183,6 +188,27 @@ _alloc_red_packet_and_fill_headers (GstRtpRedEnc * self,
   rtp_red_block_set_payload_type (red_block_header,
       gst_rtp_buffer_get_payload_type (inp_rtp));
 
+  /* FIXME: remove that logic once https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/923
+   * has been addressed. */
+  if (self->twcc_ext_id != 0) {
+    guint8 appbits;
+    gpointer inp_data;
+    guint inp_size;
+    guint16 data;
+
+    /* If the input buffer was meant to hold a TWCC seqnum, we also do that
+     * for our wrapper */
+    if (gst_rtp_buffer_get_extension_onebyte_header (inp_rtp, self->twcc_ext_id,
+            0, &inp_data, &inp_size)) {
+      gst_rtp_buffer_add_extension_onebyte_header (&red_rtp, 1, &data,
+          sizeof (guint16));
+    } else if (gst_rtp_buffer_get_extension_twobytes_header (inp_rtp, &appbits,
+            self->twcc_ext_id, 0, &inp_data, &inp_size)) {
+      gst_rtp_buffer_add_extension_twobytes_header (&red_rtp, appbits,
+          self->twcc_ext_id, &data, sizeof (guint16));
+    }
+  }
+
   gst_rtp_buffer_unmap (&red_rtp);
 
   gst_buffer_copy_into (red, inp_rtp->buffer, GST_BUFFER_COPY_METADATA, 0, -1);
@@ -358,6 +384,31 @@ gst_rtp_red_enc_chain (GstPad G_GNUC_UNUSED * pad, GstObject * parent,
   return _push_red_packet (self, &rtp, buffer, redundant_block, distance);
 }
 
+static guint8
+_get_extmap_id_for_attribute (const GstStructure * s, const gchar * ext_name)
+{
+  guint i;
+  guint8 extmap_id = 0;
+  guint n_fields = gst_structure_n_fields (s);
+
+  for (i = 0; i < n_fields; i++) {
+    const gchar *field_name = gst_structure_nth_field_name (s, i);
+    if (g_str_has_prefix (field_name, "extmap-")) {
+      const gchar *str = gst_structure_get_string (s, field_name);
+      if (str && g_strcmp0 (str, ext_name) == 0) {
+        gint64 id = g_ascii_strtoll (field_name + 7, NULL, 10);
+        if (id > 0 && id < 15) {
+          extmap_id = id;
+          break;
+        }
+      }
+    }
+  }
+  return extmap_id;
+}
+
+#define TWCC_EXTMAP_STR "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
+
 static gboolean
 gst_rtp_red_enc_event_sink (GstPad * pad, GstObject * parent, GstEvent * event)
 {
@@ -366,12 +417,18 @@ gst_rtp_red_enc_event_sink (GstPad * pad, GstObject * parent, GstEvent * event)
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_CAPS:
     {
+      GstCaps *caps;
+      GstStructure *s;
       gboolean replace_with_red_caps =
           self->is_current_caps_red || self->allow_no_red_blocks;
 
+      gst_event_parse_caps (event, &caps);
+      s = gst_caps_get_structure (caps, 0);
+      self->twcc_ext_id = _get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
+
+      GST_INFO_OBJECT (self, "TWCC extension ID: %u", self->twcc_ext_id);
+
       if (replace_with_red_caps) {
-        GstCaps *caps;
-        gst_event_parse_caps (event, &caps);
         gst_event_take (&event, _create_caps_event (caps, self->pt));
 
         self->is_current_caps_red = TRUE;
@@ -421,6 +478,7 @@ gst_rtp_red_enc_init (GstRtpRedEnc * self)
   self->allow_no_red_blocks = DEFAULT_ALLOW_NO_RED_BLOCKS;
   self->num_sent = 0;
   self->rtp_history = g_queue_new ();
+  self->ignoring_extension_warned = FALSE;
 }
 
 
diff --git a/gst/rtp/gstrtpredenc.h b/gst/rtp/gstrtpredenc.h
index dc2b1ebbc..848aeea67 100644
--- a/gst/rtp/gstrtpredenc.h
+++ b/gst/rtp/gstrtpredenc.h
@@ -56,6 +56,9 @@ struct _GstRtpRedEnc {
   GQueue *rtp_history;
   gboolean send_caps;
   gboolean is_current_caps_red;
+  guint8 twcc_ext_id;
+
+  gboolean ignoring_extension_warned;
 };
 
 GType gst_rtp_red_enc_get_type (void);
diff --git a/gst/rtp/gstrtpsbcdepay.c b/gst/rtp/gstrtpsbcdepay.c
index 9549bb06a..f5dec8b78 100644
--- a/gst/rtp/gstrtpsbcdepay.c
+++ b/gst/rtp/gstrtpsbcdepay.c
@@ -26,6 +26,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpsbcdepay.h"
 #include "gstrtputils.h"
 
@@ -64,6 +65,8 @@ enum
 
 #define gst_rtp_sbc_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpSbcDepay, gst_rtp_sbc_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpsbcdepay, "rtpsbcdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_SBC_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_sbc_depay_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec);
@@ -386,10 +389,3 @@ bad_packet:
       ("Received invalid RTP payload, dropping"), (NULL));
   goto out;
 }
-
-gboolean
-gst_rtp_sbc_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpsbcdepay", GST_RANK_SECONDARY,
-      GST_TYPE_RTP_SBC_DEPAY);
-}
diff --git a/gst/rtp/gstrtpsbcdepay.h b/gst/rtp/gstrtpsbcdepay.h
index 9cac3add2..bc5a39672 100644
--- a/gst/rtp/gstrtpsbcdepay.h
+++ b/gst/rtp/gstrtpsbcdepay.h
@@ -64,7 +64,5 @@ struct _GstRtpSbcDepayClass
 
 GType gst_rtp_sbc_depay_get_type (void);
 
-gboolean gst_rtp_sbc_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif
diff --git a/gst/rtp/gstrtpsbcpay.c b/gst/rtp/gstrtpsbcpay.c
index f2cf849ec..676416bc0 100644
--- a/gst/rtp/gstrtpsbcpay.c
+++ b/gst/rtp/gstrtpsbcpay.c
@@ -24,6 +24,7 @@
 #endif
 
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpsbcpay.h"
 #include <math.h>
 #include <string.h>
@@ -33,42 +34,6 @@
 #define DEFAULT_MIN_FRAMES 0
 #define RTP_SBC_HEADER_TOTAL (12 + RTP_SBC_PAYLOAD_HEADER_SIZE)
 
-/* BEGIN: Packing for rtp_payload */
-#ifdef _MSC_VER
-#pragma pack(push, 1)
-#endif
-
-#if G_BYTE_ORDER == G_LITTLE_ENDIAN
-/* FIXME: this seems all a bit over the top for a single byte.. */
-struct rtp_payload
-{
-  guint8 frame_count:4;
-  guint8 rfa0:1;
-  guint8 is_last_fragment:1;
-  guint8 is_first_fragment:1;
-  guint8 is_fragmented:1;
-}
-#elif G_BYTE_ORDER == G_BIG_ENDIAN
-struct rtp_payload
-{
-  guint8 is_fragmented:1;
-  guint8 is_first_fragment:1;
-  guint8 is_last_fragment:1;
-  guint8 rfa0:1;
-  guint8 frame_count:4;
-}
-#else
-#error "Unknown byte order"
-#endif
-
-#ifdef _MSC_VER
-;
-#pragma pack(pop)
-#else
-__attribute__ ((packed));
-#endif
-/* END: Packing for rtp_payload */
-
 enum
 {
   PROP_0,
@@ -80,6 +45,8 @@ GST_DEBUG_CATEGORY_STATIC (gst_rtp_sbc_pay_debug);
 
 #define parent_class gst_rtp_sbc_pay_parent_class
 G_DEFINE_TYPE (GstRtpSBCPay, gst_rtp_sbc_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpsbcpay, "rtpsbcpay", GST_RANK_NONE,
+    GST_TYPE_RTP_SBC_PAY, rtp_element_init (plugin));
 
 static GstStaticPadTemplate gst_rtp_sbc_pay_sink_factory =
 GST_STATIC_PAD_TEMPLATE ("sink", GST_PAD_SINK, GST_PAD_ALWAYS,
@@ -106,6 +73,8 @@ static void gst_rtp_sbc_pay_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 static void gst_rtp_sbc_pay_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
+static GstStateChangeReturn gst_rtp_sbc_pay_change_state (GstElement * element,
+    GstStateChange transition);
 
 static gint
 gst_rtp_sbc_pay_get_frame_len (gint subbands, gint channels,
@@ -168,7 +137,7 @@ gst_rtp_sbc_pay_set_caps (GstRTPBasePayload * payload, GstCaps * caps)
 }
 
 static GstFlowReturn
-gst_rtp_sbc_pay_flush_buffers (GstRtpSBCPay * sbcpay)
+gst_rtp_sbc_pay_drain_buffers (GstRtpSBCPay * sbcpay)
 {
   GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
   guint available;
@@ -177,7 +146,6 @@ gst_rtp_sbc_pay_flush_buffers (GstRtpSBCPay * sbcpay)
   guint8 *payload_data;
   guint frame_count;
   guint payload_length;
-  struct rtp_payload *payload;
   GstFlowReturn res;
 
   if (sbcpay->frame_length == 0) {
@@ -209,9 +177,8 @@ gst_rtp_sbc_pay_flush_buffers (GstRtpSBCPay * sbcpay)
 
     /* write header and copy data into payload */
     payload_data = gst_rtp_buffer_get_payload (&rtp);
-    payload = (struct rtp_payload *) payload_data;
-    memset (payload, 0, sizeof (struct rtp_payload));
-    payload->frame_count = frame_count;
+    /* upper 3 fragment bits not used, ref A2DP v13, 4.3.4 */
+    payload_data[0] = frame_count & 0x0f;
 
     gst_rtp_buffer_unmap (&rtp);
 
@@ -246,7 +213,7 @@ gst_rtp_sbc_pay_handle_buffer (GstRTPBasePayload * payload, GstBuffer * buffer)
 
   if (GST_BUFFER_IS_DISCONT (buffer)) {
     /* Try to flush whatever's left */
-    gst_rtp_sbc_pay_flush_buffers (sbcpay);
+    gst_rtp_sbc_pay_drain_buffers (sbcpay);
     /* Drop the rest */
     gst_adapter_flush (sbcpay->adapter,
         gst_adapter_available (sbcpay->adapter));
@@ -263,7 +230,7 @@ gst_rtp_sbc_pay_handle_buffer (GstRTPBasePayload * payload, GstBuffer * buffer)
   if (available + RTP_SBC_HEADER_TOTAL >=
       GST_RTP_BASE_PAYLOAD_MTU (sbcpay) ||
       (available > (sbcpay->min_frames * sbcpay->frame_length)))
-    return gst_rtp_sbc_pay_flush_buffers (sbcpay);
+    return gst_rtp_sbc_pay_drain_buffers (sbcpay);
 
   return GST_FLOW_OK;
 }
@@ -275,7 +242,13 @@ gst_rtp_sbc_pay_sink_event (GstRTPBasePayload * payload, GstEvent * event)
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_EOS:
-      gst_rtp_sbc_pay_flush_buffers (sbcpay);
+      gst_rtp_sbc_pay_drain_buffers (sbcpay);
+      break;
+    case GST_EVENT_FLUSH_STOP:
+      gst_adapter_clear (sbcpay->adapter);
+      break;
+    case GST_EVENT_SEGMENT:
+      gst_rtp_sbc_pay_drain_buffers (sbcpay);
       break;
     default:
       break;
@@ -284,6 +257,25 @@ gst_rtp_sbc_pay_sink_event (GstRTPBasePayload * payload, GstEvent * event)
   return GST_RTP_BASE_PAYLOAD_CLASS (parent_class)->sink_event (payload, event);
 }
 
+static GstStateChangeReturn
+gst_rtp_sbc_pay_change_state (GstElement * element, GstStateChange transition)
+{
+  GstStateChangeReturn ret;
+  GstRtpSBCPay *sbcpay = GST_RTP_SBC_PAY (element);
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_adapter_clear (sbcpay->adapter);
+      break;
+    default:
+      break;
+  }
+
+  return ret;
+}
+
 static void
 gst_rtp_sbc_pay_finalize (GObject * object)
 {
@@ -310,6 +302,8 @@ gst_rtp_sbc_pay_class_init (GstRtpSBCPayClass * klass)
       GST_DEBUG_FUNCPTR (gst_rtp_sbc_pay_handle_buffer);
   payload_class->sink_event = GST_DEBUG_FUNCPTR (gst_rtp_sbc_pay_sink_event);
 
+  element_class->change_state = gst_rtp_sbc_pay_change_state;
+
   /* properties */
   g_object_class_install_property (G_OBJECT_CLASS (klass),
       PROP_MIN_FRAMES,
@@ -376,10 +370,3 @@ gst_rtp_sbc_pay_init (GstRtpSBCPay * self)
 
   self->min_frames = DEFAULT_MIN_FRAMES;
 }
-
-gboolean
-gst_rtp_sbc_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpsbcpay", GST_RANK_NONE,
-      GST_TYPE_RTP_SBC_PAY);
-}
diff --git a/gst/rtp/gstrtpsbcpay.h b/gst/rtp/gstrtpsbcpay.h
index e57022980..6f42c1e74 100644
--- a/gst/rtp/gstrtpsbcpay.h
+++ b/gst/rtp/gstrtpsbcpay.h
@@ -60,6 +60,4 @@ struct _GstRtpSBCPayClass {
 
 GType gst_rtp_sbc_pay_get_type(void);
 
-gboolean gst_rtp_sbc_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
diff --git a/gst/rtp/gstrtpsirendepay.c b/gst/rtp/gstrtpsirendepay.c
index f22726810..86a9dfffe 100644
--- a/gst/rtp/gstrtpsirendepay.c
+++ b/gst/rtp/gstrtpsirendepay.c
@@ -27,6 +27,7 @@
 #include <stdlib.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
+#include "gstrtpelements.h"
 #include "gstrtpsirendepay.h"
 #include "gstrtputils.h"
 
@@ -55,6 +56,8 @@ GST_STATIC_PAD_TEMPLATE ("sink",
 
 G_DEFINE_TYPE (GstRTPSirenDepay, gst_rtp_siren_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpsirendepay, "rtpsirendepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_SIREN_DEPAY, rtp_element_init (plugin));
 
      static void gst_rtp_siren_depay_class_init (GstRTPSirenDepayClass * klass)
 {
@@ -116,10 +119,3 @@ gst_rtp_siren_depay_process (GstRTPBaseDepayload * depayload,
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_siren_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpsirendepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_SIREN_DEPAY);
-}
diff --git a/gst/rtp/gstrtpsirendepay.h b/gst/rtp/gstrtpsirendepay.h
index d1ffb11e0..cdc108add 100644
--- a/gst/rtp/gstrtpsirendepay.h
+++ b/gst/rtp/gstrtpsirendepay.h
@@ -53,7 +53,5 @@ struct _GstRTPSirenDepayClass
 
 GType gst_rtp_siren_depay_get_type (void);
 
-gboolean gst_rtp_siren_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_SIREN_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpsirenpay.c b/gst/rtp/gstrtpsirenpay.c
index 04f9aa817..93385a43f 100644
--- a/gst/rtp/gstrtpsirenpay.c
+++ b/gst/rtp/gstrtpsirenpay.c
@@ -23,6 +23,7 @@
 #include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtpsirenpay.h"
 #include <gst/rtp/gstrtpbuffer.h>
 
@@ -53,6 +54,8 @@ static gboolean gst_rtp_siren_pay_setcaps (GstRTPBasePayload * payload,
 
 G_DEFINE_TYPE (GstRTPSirenPay, gst_rtp_siren_pay,
     GST_TYPE_RTP_BASE_AUDIO_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpsirenpay, "rtpsirenpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_SIREN_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_siren_pay_class_init (GstRTPSirenPayClass * klass)
@@ -138,10 +141,3 @@ wrong_caps:
     return FALSE;
   }
 }
-
-gboolean
-gst_rtp_siren_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpsirenpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_SIREN_PAY);
-}
diff --git a/gst/rtp/gstrtpsirenpay.h b/gst/rtp/gstrtpsirenpay.h
index eaba5b5a4..56fc664ba 100644
--- a/gst/rtp/gstrtpsirenpay.h
+++ b/gst/rtp/gstrtpsirenpay.h
@@ -51,7 +51,5 @@ struct _GstRTPSirenPayClass
 
 GType gst_rtp_siren_pay_get_type (void);
 
-gboolean gst_rtp_siren_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 #endif /* __GST_RTP_SIREN_PAY_H__ */
diff --git a/gst/rtp/gstrtpspeexdepay.c b/gst/rtp/gstrtpspeexdepay.c
index a2c987bd6..ca70cd3e2 100644
--- a/gst/rtp/gstrtpspeexdepay.c
+++ b/gst/rtp/gstrtpspeexdepay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpspeexdepay.h"
 #include "gstrtputils.h"
 
@@ -66,6 +67,8 @@ static gboolean gst_rtp_speex_depay_setcaps (GstRTPBaseDepayload * depayload,
 
 G_DEFINE_TYPE (GstRtpSPEEXDepay, gst_rtp_speex_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpspeexdepay, "rtpspeexdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_SPEEX_DEPAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_speex_depay_class_init (GstRtpSPEEXDepayClass * klass)
@@ -217,10 +220,3 @@ gst_rtp_speex_depay_process (GstRTPBaseDepayload * depayload,
 
   return outbuf;
 }
-
-gboolean
-gst_rtp_speex_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpspeexdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_SPEEX_DEPAY);
-}
diff --git a/gst/rtp/gstrtpspeexdepay.h b/gst/rtp/gstrtpspeexdepay.h
index 59ffed030..3961ef1cd 100644
--- a/gst/rtp/gstrtpspeexdepay.h
+++ b/gst/rtp/gstrtpspeexdepay.h
@@ -46,8 +46,6 @@ struct _GstRtpSPEEXDepayClass
 
 GType gst_rtp_speex_depay_get_type (void);
 
-gboolean gst_rtp_speex_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_SPEEX_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpspeexpay.c b/gst/rtp/gstrtpspeexpay.c
index 6f086b010..17b2aa59e 100644
--- a/gst/rtp/gstrtpspeexpay.c
+++ b/gst/rtp/gstrtpspeexpay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpspeexpay.h"
 #include "gstrtputils.h"
 
@@ -64,6 +65,8 @@ static GstFlowReturn gst_rtp_speex_pay_handle_buffer (GstRTPBasePayload *
 
 #define gst_rtp_speex_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpSPEEXPay, gst_rtp_speex_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpspeexpay, "rtpspeexpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_SPEEX_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_speex_pay_class_init (GstRtpSPEEXPayClass * klass)
@@ -341,10 +344,3 @@ gst_rtp_speex_pay_change_state (GstElement * element, GstStateChange transition)
   }
   return ret;
 }
-
-gboolean
-gst_rtp_speex_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpspeexpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_SPEEX_PAY);
-}
diff --git a/gst/rtp/gstrtpspeexpay.h b/gst/rtp/gstrtpspeexpay.h
index 0ccaefbae..a89350e4c 100644
--- a/gst/rtp/gstrtpspeexpay.h
+++ b/gst/rtp/gstrtpspeexpay.h
@@ -49,8 +49,6 @@ struct _GstRtpSPEEXPayClass
 
 GType gst_rtp_speex_pay_get_type (void);
 
-gboolean gst_rtp_speex_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_SPEEX_PAY_H__ */
diff --git a/gst/rtp/gstrtpstorage.c b/gst/rtp/gstrtpstorage.c
index b43eb982c..a3e1593ce 100644
--- a/gst/rtp/gstrtpstorage.c
+++ b/gst/rtp/gstrtpstorage.c
@@ -53,6 +53,7 @@
  * Since: 1.14
  */
 
+#include "gstrtpelements.h"
 #include "gstrtpstorage.h"
 
 static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE ("sink",
@@ -83,6 +84,8 @@ GST_DEBUG_CATEGORY (gst_rtp_storage_debug);
 #define GST_CAT_DEFAULT (gst_rtp_storage_debug)
 
 G_DEFINE_TYPE (GstRtpStorage, gst_rtp_storage, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpstorage, "rtpstorage", GST_RANK_NONE,
+    GST_TYPE_RTP_STORAGE, rtp_element_init (plugin));
 
 static GstFlowReturn
 gst_rtp_storage_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
diff --git a/gst/rtp/gstrtpstreamdepay.c b/gst/rtp/gstrtpstreamdepay.c
index bcaec19ea..978c75301 100644
--- a/gst/rtp/gstrtpstreamdepay.c
+++ b/gst/rtp/gstrtpstreamdepay.c
@@ -36,6 +36,7 @@
 #include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtpstreamdepay.h"
 
 GST_DEBUG_CATEGORY (gst_rtp_stream_depay_debug);
@@ -57,6 +58,8 @@ static GstStaticPadTemplate sink_template =
 
 #define parent_class gst_rtp_stream_depay_parent_class
 G_DEFINE_TYPE (GstRtpStreamDepay, gst_rtp_stream_depay, GST_TYPE_BASE_PARSE);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpstreamdepay, "rtpstreamdepay",
+    GST_RANK_NONE, GST_TYPE_RTP_STREAM_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_stream_depay_set_sink_caps (GstBaseParse * parse,
     GstCaps * caps);
@@ -223,10 +226,3 @@ gst_rtp_stream_depay_sink_activate (GstPad * pad, GstObject * parent)
 {
   return gst_pad_activate_mode (pad, GST_PAD_MODE_PUSH, TRUE);
 }
-
-gboolean
-gst_rtp_stream_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpstreamdepay",
-      GST_RANK_NONE, GST_TYPE_RTP_STREAM_DEPAY);
-}
diff --git a/gst/rtp/gstrtpstreamdepay.h b/gst/rtp/gstrtpstreamdepay.h
index b6011cb55..32bd6c142 100644
--- a/gst/rtp/gstrtpstreamdepay.h
+++ b/gst/rtp/gstrtpstreamdepay.h
@@ -50,7 +50,6 @@ struct _GstRtpStreamDepayClass
 };
 
 GType gst_rtp_stream_depay_get_type (void);
-gboolean gst_rtp_stream_depay_plugin_init (GstPlugin * plugin);
 
 G_END_DECLS
 
diff --git a/gst/rtp/gstrtpstreampay.c b/gst/rtp/gstrtpstreampay.c
index b5758228b..51206ffb9 100644
--- a/gst/rtp/gstrtpstreampay.c
+++ b/gst/rtp/gstrtpstreampay.c
@@ -37,6 +37,7 @@
 #include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtpstreampay.h"
 
 #define GST_CAT_DEFAULT gst_rtp_stream_pay_debug
@@ -58,6 +59,8 @@ static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
 
 #define parent_class gst_rtp_stream_pay_parent_class
 G_DEFINE_TYPE (GstRtpStreamPay, gst_rtp_stream_pay, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpstreampay, "rtpstreampay",
+    GST_RANK_NONE, GST_TYPE_RTP_STREAM_PAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_stream_pay_sink_query (GstPad * pad, GstObject * parent,
     GstQuery * query);
@@ -277,10 +280,3 @@ gst_rtp_stream_pay_sink_chain (GstPad * pad, GstObject * parent,
 
   return gst_pad_push (self->srcpad, outbuf);
 }
-
-gboolean
-gst_rtp_stream_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpstreampay",
-      GST_RANK_NONE, GST_TYPE_RTP_STREAM_PAY);
-}
diff --git a/gst/rtp/gstrtpstreampay.h b/gst/rtp/gstrtpstreampay.h
index a9436a8fd..b90165af2 100644
--- a/gst/rtp/gstrtpstreampay.h
+++ b/gst/rtp/gstrtpstreampay.h
@@ -47,8 +47,6 @@ struct _GstRtpStreamPayClass {
 
 GType gst_rtp_stream_pay_get_type (void);
 
-gboolean gst_rtp_stream_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_STREAM_PAY_H__ */
diff --git a/gst/rtp/gstrtpsv3vdepay.c b/gst/rtp/gstrtpsv3vdepay.c
index 3d091c2b8..bac99458a 100644
--- a/gst/rtp/gstrtpsv3vdepay.c
+++ b/gst/rtp/gstrtpsv3vdepay.c
@@ -25,6 +25,7 @@
 
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "gstrtpsv3vdepay.h"
 #include "gstrtputils.h"
 
@@ -49,8 +50,11 @@ GST_STATIC_PAD_TEMPLATE ("sink",
     );
 
 #define gst_rtp_sv3v_depay_parent_class parent_class
-G_DEFINE_TYPE (GstRtpSV3VDepay, gst_rtp_sv3v_depay,
-    GST_TYPE_RTP_BASE_DEPAYLOAD);
+G_DEFINE_TYPE_WITH_CODE (GstRtpSV3VDepay, gst_rtp_sv3v_depay,
+    GST_TYPE_RTP_BASE_DEPAYLOAD, GST_DEBUG_CATEGORY_INIT (rtpsv3vdepay_debug,
+        "rtpsv3vdepay", 0, "RTP SV3V depayloader"));
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpsv3vdepay, "rtpsv3vdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_SV3V_DEPAY, rtp_element_init (plugin));
 
 static void gst_rtp_sv3v_depay_finalize (GObject * object);
 
@@ -310,13 +314,3 @@ gst_rtp_sv3v_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_sv3v_depay_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (rtpsv3vdepay_debug, "rtpsv3vdepay", 0,
-      "RTP SV3V depayloader");
-
-  return gst_element_register (plugin, "rtpsv3vdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_SV3V_DEPAY);
-}
diff --git a/gst/rtp/gstrtpsv3vdepay.h b/gst/rtp/gstrtpsv3vdepay.h
index 428684a7d..1f3fc7f9b 100644
--- a/gst/rtp/gstrtpsv3vdepay.h
+++ b/gst/rtp/gstrtpsv3vdepay.h
@@ -60,8 +60,6 @@ struct _GstRtpSV3VDepayClass
 
 GType gst_rtp_sv3v_depay_get_type (void);
 
-gboolean gst_rtp_sv3v_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_SV3V_DEPAY_H__ */
diff --git a/gst/rtp/gstrtptheoradepay.c b/gst/rtp/gstrtptheoradepay.c
index c8af97495..e7ff9e18c 100644
--- a/gst/rtp/gstrtptheoradepay.c
+++ b/gst/rtp/gstrtptheoradepay.c
@@ -26,6 +26,7 @@
 #include <gst/video/video.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtptheoradepay.h"
 #include "gstrtputils.h"
 
@@ -64,6 +65,8 @@ GST_STATIC_PAD_TEMPLATE ("src",
 #define gst_rtp_theora_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpTheoraDepay, gst_rtp_theora_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtptheoradepay, "rtptheoradepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_THEORA_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_theora_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -680,13 +683,6 @@ gst_rtp_theora_depay_change_state (GstElement * element,
   return ret;
 }
 
-gboolean
-gst_rtp_theora_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtptheoradepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_THEORA_DEPAY);
-}
-
 static gboolean
 gst_rtp_theora_depay_packet_lost (GstRTPBaseDepayload * depayload,
     GstEvent * event)
diff --git a/gst/rtp/gstrtptheoradepay.h b/gst/rtp/gstrtptheoradepay.h
index 2b0b26016..492d33dc0 100644
--- a/gst/rtp/gstrtptheoradepay.h
+++ b/gst/rtp/gstrtptheoradepay.h
@@ -65,8 +65,6 @@ struct _GstRtpTheoraDepayClass
 
 GType gst_rtp_theora_depay_get_type (void);
 
-gboolean gst_rtp_theora_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_THEORA_DEPAY_H__ */
diff --git a/gst/rtp/gstrtptheorapay.c b/gst/rtp/gstrtptheorapay.c
index 61fb90bc6..57807570e 100644
--- a/gst/rtp/gstrtptheorapay.c
+++ b/gst/rtp/gstrtptheorapay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "fnv1hash.h"
 #include "gstrtptheorapay.h"
 #include "gstrtputils.h"
@@ -79,6 +80,8 @@ enum
 
 #define gst_rtp_theora_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpTheoraPay, gst_rtp_theora_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtptheorapay, "rtptheorapay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_THEORA_PAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_theora_pay_setcaps (GstRTPBasePayload * basepayload,
     GstCaps * caps);
@@ -281,8 +284,8 @@ gst_rtp_theora_pay_init_packet (GstRtpTheoraPay * rtptheorapay, guint8 TDT,
 
   /* new packet allocate max packet size */
   rtptheorapay->packet =
-      gst_rtp_buffer_new_allocate_len (GST_RTP_BASE_PAYLOAD_MTU
-      (rtptheorapay), 0, 0);
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD
+      (rtptheorapay), GST_RTP_BASE_PAYLOAD_MTU (rtptheorapay), 0, 0);
   gst_rtp_theora_pay_reset_packet (rtptheorapay, TDT);
 
   GST_BUFFER_PTS (rtptheorapay->packet) = timestamp;
@@ -976,10 +979,3 @@ gst_rtp_theora_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_theora_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtptheorapay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_THEORA_PAY);
-}
diff --git a/gst/rtp/gstrtptheorapay.h b/gst/rtp/gstrtptheorapay.h
index 22bc01df1..d009364fe 100644
--- a/gst/rtp/gstrtptheorapay.h
+++ b/gst/rtp/gstrtptheorapay.h
@@ -79,8 +79,6 @@ struct _GstRtpTheoraPayClass
 
 GType gst_rtp_theora_pay_get_type (void);
 
-gboolean gst_rtp_theora_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_THEORA_PAY_H__ */
diff --git a/gst/rtp/gstrtpulpfecdec.c b/gst/rtp/gstrtpulpfecdec.c
index 709309ad1..beb0432ca 100644
--- a/gst/rtp/gstrtpulpfecdec.c
+++ b/gst/rtp/gstrtpulpfecdec.c
@@ -62,6 +62,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/rtp/gstrtp-enumtypes.h>
 
+#include "gstrtpelements.h"
 #include "rtpulpfeccommon.h"
 #include "gstrtpulpfecdec.h"
 
@@ -84,10 +85,12 @@ enum
   PROP_STORAGE,
   PROP_RECOVERED,
   PROP_UNRECOVERED,
+  PROP_PASSTHROUGH,
   N_PROPERTIES
 };
 
 #define DEFAULT_FEC_PT 0
+#define DEFAULT_PASSTHROUGH FALSE
 
 static GParamSpec *klass_properties[N_PROPERTIES] = { NULL, };
 
@@ -95,6 +98,8 @@ GST_DEBUG_CATEGORY (gst_rtp_ulpfec_dec_debug);
 #define GST_CAT_DEFAULT (gst_rtp_ulpfec_dec_debug)
 
 G_DEFINE_TYPE (GstRtpUlpFecDec, gst_rtp_ulpfec_dec, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpulpfecdec, "rtpulpfecdec",
+    GST_RANK_NONE, GST_TYPE_RTP_ULPFEC_DEC, rtp_element_init (plugin));
 
 #define RTP_FEC_MAP_INFO_NTH(dec, data) (&g_array_index (\
     ((GstRtpUlpFecDec *)dec)->info_arr, \
@@ -375,6 +380,7 @@ gst_rtp_ulpfec_dec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
 
   if (G_LIKELY (GST_FLOW_OK == self->chain_return_val)) {
     GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+    gboolean passthrough;
     buf = gst_buffer_make_writable (buf);
 
     if (G_UNLIKELY (self->unset_discont_flag)) {
@@ -382,8 +388,20 @@ gst_rtp_ulpfec_dec_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
       GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);
     }
 
+    GST_OBJECT_LOCK (self);
+    if (G_UNLIKELY (self->needs_discont)) {
+      self->needs_discont = FALSE;
+      GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
+    }
+    passthrough = self->passthrough;
+    GST_OBJECT_UNLOCK (self);
+
     gst_rtp_buffer_map (buf, GST_MAP_WRITE, &rtp);
-    gst_rtp_buffer_set_seq (&rtp, self->next_seqnum++);
+    if (passthrough) {
+      self->next_seqnum = gst_rtp_buffer_get_seq (&rtp) + 1;
+    } else {
+      gst_rtp_buffer_set_seq (&rtp, self->next_seqnum++);
+    }
     gst_rtp_buffer_unmap (&rtp);
 
     return gst_pad_push (self->srcpad, buf);
@@ -439,6 +457,13 @@ gst_rtp_ulpfec_dec_handle_packet_loss (GstRtpUlpFecDec * self, guint16 seqnum,
         gst_rtp_buffer_set_seq (&rtp, self->next_seqnum++);
         gst_rtp_buffer_unmap (&rtp);
 
+        GST_OBJECT_LOCK (self);
+        if (G_UNLIKELY (self->needs_discont)) {
+          self->needs_discont = FALSE;
+          GST_BUFFER_FLAG_SET (sent_buffer, GST_BUFFER_FLAG_DISCONT);
+        }
+        GST_OBJECT_UNLOCK (self);
+
         ret = FALSE;
         self->unset_discont_flag = TRUE;
         self->chain_return_val = gst_pad_push (self->srcpad, sent_buffer);
@@ -478,6 +503,18 @@ gst_rtp_ulpfec_dec_handle_sink_event (GstPad * pad, GstObject * parent,
     guint seqnum;
     GstClockTime timestamp, duration;
     GstStructure *s;
+    gboolean passthrough;
+
+    GST_OBJECT_LOCK (self);
+    passthrough = self->passthrough;
+    GST_OBJECT_UNLOCK (self);
+
+    if (passthrough) {
+      GST_TRACE_OBJECT (self,
+          "in passthrough mode, ignoring packet loss event");
+      forward = TRUE;
+      goto out;
+    }
 
     event = gst_event_make_writable (event);
     s = gst_event_writable_structure (event);
@@ -552,6 +589,7 @@ gst_rtp_ulpfec_dec_handle_sink_event (GstPad * pad, GstObject * parent,
     self->caps_pt = caps_pt;
   }
 
+out:
   if (forward)
     return gst_pad_push_event (self->srcpad, event);
   gst_event_unref (event);
@@ -574,6 +612,7 @@ gst_rtp_ulpfec_dec_init (GstRtpUlpFecDec * self)
   gst_element_add_pad (GST_ELEMENT (self), self->sinkpad);
 
   self->fec_pt = DEFAULT_FEC_PT;
+  self->passthrough = DEFAULT_PASSTHROUGH;
 
   self->next_seqnum = g_random_int_range (0, G_MAXINT16);
 
@@ -639,6 +678,20 @@ gst_rtp_ulpfec_dec_set_property (GObject * object, guint prop_id,
       if (self->storage)
         g_object_ref (self->storage);
       break;
+    case PROP_PASSTHROUGH:{
+      gboolean newval = g_value_get_boolean (value);
+      GST_OBJECT_LOCK (self);
+      /* if we changing into non-passthrough mode, then the sequence numbers may
+       * be completely different and we need to advertise that with a discont */
+      GST_INFO_OBJECT (self, "passthrough changing from %u to %u",
+          self->passthrough, newval);
+      if (self->passthrough && !newval) {
+        self->needs_discont = TRUE;
+      }
+      self->passthrough = newval;
+      GST_OBJECT_UNLOCK (self);
+      break;
+    }
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -664,6 +717,9 @@ gst_rtp_ulpfec_dec_get_property (GObject * object, guint prop_id,
     case PROP_UNRECOVERED:
       g_value_set_uint (value, (guint) self->packets_unrecovered);
       break;
+    case PROP_PASSTHROUGH:
+      g_value_set_boolean (value, self->passthrough);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -709,6 +765,19 @@ gst_rtp_ulpfec_dec_class_init (GstRtpUlpFecDecClass * klass)
       g_param_spec_uint ("unrecovered", "unrecovered",
       "The number of unrecovered packets", 0, G_MAXUINT, 0,
       G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
+  /**
+   * GstRtpUlpFecDec:passthrough:
+   *
+   * Whether to push data through without any modification.  If passthrough is
+   * enabled, then no packets will ever be recovered.
+   *
+   * Since: 1.22
+   */
+  klass_properties[PROP_PASSTHROUGH] =
+      g_param_spec_boolean ("passthrough", "Passthrough",
+      "Whether to passthrough all data as-is without modification and "
+      "never attempt to recover packets", DEFAULT_PASSTHROUGH,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
   g_object_class_install_properties (gobject_class, N_PROPERTIES,
       klass_properties);
diff --git a/gst/rtp/gstrtpulpfecdec.h b/gst/rtp/gstrtpulpfecdec.h
index f9b10b068..b54e82ee2 100644
--- a/gst/rtp/gstrtpulpfecdec.h
+++ b/gst/rtp/gstrtpulpfecdec.h
@@ -55,10 +55,12 @@ struct _GstRtpUlpFecDec {
   RtpStorage *storage;
   gsize packets_recovered;
   gsize packets_unrecovered;
+  gboolean passthrough;
 
   /* internal stuff */
   GstFlowReturn chain_return_val;
   gboolean unset_discont_flag;
+  gboolean needs_discont;
   gboolean have_caps_ssrc;
   gboolean have_caps_pt;
   guint32 caps_ssrc;
diff --git a/gst/rtp/gstrtpulpfecenc.c b/gst/rtp/gstrtpulpfecenc.c
index bd2df23bb..c95fe0d89 100644
--- a/gst/rtp/gstrtpulpfecenc.c
+++ b/gst/rtp/gstrtpulpfecenc.c
@@ -88,6 +88,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <string.h>
 
+#include "gstrtpelements.h"
 #include "rtpulpfeccommon.h"
 #include "gstrtpulpfecenc.h"
 
@@ -114,6 +115,8 @@ GST_DEBUG_CATEGORY (gst_rtp_ulpfec_enc_debug);
 #define GST_CAT_DEFAULT (gst_rtp_ulpfec_enc_debug)
 
 G_DEFINE_TYPE (GstRtpUlpFecEnc, gst_rtp_ulpfec_enc, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpulpfecenc, "rtpulpfecenc",
+    GST_RANK_NONE, GST_TYPE_RTP_ULPFEC_ENC, rtp_element_init (plugin));
 
 enum
 {
@@ -130,6 +133,15 @@ enum
     RtpUlpFecMapInfo, \
     GPOINTER_TO_UINT(data)))
 
+static void
+dump_stream_ctx_settings (GstRtpUlpFecEncStreamCtx * ctx)
+{
+  GST_DEBUG_OBJECT (ctx->parent, "rtpulpfec settings for ssrc 0x%x, pt %u, "
+      "percentage %u, percentage important %u, multipacket %u, mux_seq %u",
+      ctx->ssrc, ctx->pt, ctx->percentage, ctx->percentage_important,
+      ctx->multipacket, ctx->mux_seq);
+};
+
 static void
 gst_rtp_ulpfec_enc_stream_ctx_start (GstRtpUlpFecEncStreamCtx * ctx,
     GQueue * packets, guint fec_packets)
@@ -328,12 +340,15 @@ gst_rtp_ulpfec_enc_stream_ctx_prepend_to_fec_buffer (GstRtpUlpFecEncStreamCtx *
 
 static GstFlowReturn
 gst_rtp_ulpfec_enc_stream_ctx_push_fec_packets (GstRtpUlpFecEncStreamCtx * ctx,
-    guint8 pt, guint16 seq, guint32 timestamp, guint32 ssrc)
+    guint8 pt, guint16 seq, guint32 timestamp, guint32 ssrc, guint8 twcc_ext_id,
+    GstRTPHeaderExtensionFlags twcc_ext_flags, guint8 twcc_appbits)
 {
   GstFlowReturn ret = GST_FLOW_OK;
   guint fec_packets_num =
       gst_rtp_ulpfec_enc_stream_ctx_get_fec_packets_num (ctx);
 
+  GST_LOG_OBJECT (ctx->parent, "ctx %p have %u fec packets to push", ctx,
+      fec_packets_num);
   if (fec_packets_num) {
     guint fec_packets_pushed = 0;
     GstBuffer *latest_packet = ctx->packets_buf.head->data;
@@ -348,6 +363,33 @@ gst_rtp_ulpfec_enc_stream_ctx_push_fec_packets (GstRtpUlpFecEncStreamCtx * ctx,
       gst_buffer_copy_into (fec, latest_packet, GST_BUFFER_COPY_TIMESTAMPS, 0,
           -1);
 
+      /* If buffers in the stream we are protecting were meant to hold a TWCC seqnum,
+       * we also indicate that our protection buffers need one. At this point no seqnum
+       * has actually been set, we thus don't need to rewrite seqnums, simply indicate
+       * to RTPSession that the FEC buffers need one too */
+
+      /* FIXME: remove this logic once https://gitlab.freedesktop.org/gstreamer/gstreamer/-/issues/923
+       * is addressed */
+      if (twcc_ext_id != 0) {
+        GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+        guint16 data;
+
+        if (!gst_rtp_buffer_map (fec, GST_MAP_READWRITE, &rtp))
+          g_assert_not_reached ();
+
+        if (twcc_ext_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+          gst_rtp_buffer_add_extension_onebyte_header (&rtp, twcc_ext_id,
+              &data, sizeof (guint16));
+        } else if (twcc_ext_flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) {
+          gst_rtp_buffer_add_extension_twobytes_header (&rtp, twcc_appbits,
+              twcc_ext_id, &data, sizeof (guint16));
+        }
+
+        gst_rtp_buffer_unmap (&rtp);
+      }
+
+      GST_LOG_OBJECT (ctx->parent, "ctx %p pushing generated fec buffer %"
+          GST_PTR_FORMAT, ctx, fec);
       ret = gst_pad_push (ctx->srcpad, fec);
       if (GST_FLOW_OK == ret)
         ++fec_packets_pushed;
@@ -381,6 +423,8 @@ gst_rtp_ulpfec_enc_stream_ctx_cache_packet (GstRtpUlpFecEncStreamCtx * ctx,
 
     *dst_empty_packet_buffer = gst_rtp_buffer_get_marker (rtp);
     *dst_push_fec = *dst_empty_packet_buffer;
+
+    GST_TRACE ("ctx %p pushing fec %u", ctx, *dst_push_fec);
   } else {
     gboolean push_fec;
 
@@ -394,6 +438,8 @@ gst_rtp_ulpfec_enc_stream_ctx_cache_packet (GstRtpUlpFecEncStreamCtx * ctx,
 
     *dst_push_fec = push_fec;
     *dst_empty_packet_buffer = FALSE;
+
+    GST_TRACE ("ctx %p pushing fec %u", ctx, *dst_push_fec);
   }
 }
 
@@ -420,6 +466,8 @@ gst_rtp_ulpfec_enc_stream_ctx_configure (GstRtpUlpFecEncStreamCtx * ctx,
 */
   ctx->budget_inc_important = percentage > percentage_important ?
       ctx->budget_inc : percentage_important / 100.;
+
+  dump_stream_ctx_settings (ctx);
 }
 
 static GstRtpUlpFecEncStreamCtx *
@@ -460,17 +508,19 @@ gst_rtp_ulpfec_enc_stream_ctx_free (GstRtpUlpFecEncStreamCtx * ctx)
   g_assert (0 == ctx->info_arr->len);
   g_array_free (ctx->info_arr, TRUE);
   g_array_free (ctx->scratch_buf, TRUE);
-  g_slice_free1 (sizeof (GstRtpUlpFecEncStreamCtx), ctx);
+  g_free (ctx);
 }
 
 static GstFlowReturn
 gst_rtp_ulpfec_enc_stream_ctx_process (GstRtpUlpFecEncStreamCtx * ctx,
-    GstBuffer * buffer)
+    GstBuffer * buffer, guint8 twcc_ext_id)
 {
   GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
   GstFlowReturn ret;
   gboolean push_fec = FALSE;
   gboolean empty_packet_buffer = FALSE;
+  GstRTPHeaderExtensionFlags twcc_ext_flags = 0;
+  guint8 twcc_appbits = 0;
 
   ctx->num_packets_received++;
 
@@ -487,6 +537,21 @@ gst_rtp_ulpfec_enc_stream_ctx_process (GstRtpUlpFecEncStreamCtx * ctx,
       g_assert_not_reached ();
   }
 
+  if (twcc_ext_id != 0) {
+    gpointer data;
+    guint size;
+
+    if (gst_rtp_buffer_get_extension_onebyte_header (&rtp, twcc_ext_id, 0,
+            &data, &size)) {
+      twcc_ext_flags |= GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+    } else if (gst_rtp_buffer_get_extension_twobytes_header (&rtp,
+            &twcc_appbits, twcc_ext_id, 0, &data, &size)) {
+      twcc_ext_flags |= GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+    } else {
+      twcc_ext_id = 0;
+    }
+  }
+
   gst_rtp_ulpfec_enc_stream_ctx_cache_packet (ctx, &rtp, &empty_packet_buffer,
       &push_fec);
 
@@ -501,7 +566,7 @@ gst_rtp_ulpfec_enc_stream_ctx_process (GstRtpUlpFecEncStreamCtx * ctx,
     if (GST_FLOW_OK == ret)
       ret =
           gst_rtp_ulpfec_enc_stream_ctx_push_fec_packets (ctx, ctx->pt, fec_seq,
-          fec_timestamp, fec_ssrc);
+          fec_timestamp, fec_ssrc, twcc_ext_id, twcc_ext_flags, twcc_appbits);
   } else {
     gst_rtp_buffer_unmap (&rtp);
     ret = gst_pad_push (ctx->srcpad, buffer);
@@ -555,7 +620,7 @@ gst_rtp_ulpfec_enc_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 
   ctx = gst_rtp_ulpfec_enc_aquire_ctx (fec, ssrc);
 
-  ret = gst_rtp_ulpfec_enc_stream_ctx_process (ctx, buffer);
+  ret = gst_rtp_ulpfec_enc_stream_ctx_process (ctx, buffer, fec->twcc_ext_id);
 
   /* FIXME: does not work for multiple ssrcs */
   fec->num_packets_protected = ctx->num_packets_protected;
@@ -574,6 +639,58 @@ gst_rtp_ulpfec_enc_configure_ctx (gpointer key, gpointer value,
       fec->percentage, fec->percentage_important, fec->multipacket);
 }
 
+static guint8
+_get_extmap_id_for_attribute (const GstStructure * s, const gchar * ext_name)
+{
+  guint i;
+  guint8 extmap_id = 0;
+  guint n_fields = gst_structure_n_fields (s);
+
+  for (i = 0; i < n_fields; i++) {
+    const gchar *field_name = gst_structure_nth_field_name (s, i);
+    if (g_str_has_prefix (field_name, "extmap-")) {
+      const gchar *str = gst_structure_get_string (s, field_name);
+      if (str && g_strcmp0 (str, ext_name) == 0) {
+        gint64 id = g_ascii_strtoll (field_name + 7, NULL, 10);
+        if (id > 0 && id < 15) {
+          extmap_id = id;
+          break;
+        }
+      }
+    }
+  }
+  return extmap_id;
+}
+
+#define TWCC_EXTMAP_STR "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
+
+static gboolean
+gst_rtp_ulpfec_enc_event_sink (GstPad * pad, GstObject * parent,
+    GstEvent * event)
+{
+  GstRtpUlpFecEnc *self = GST_RTP_ULPFEC_ENC (parent);
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_CAPS:
+    {
+      GstCaps *caps;
+      GstStructure *s;
+
+      gst_event_parse_caps (event, &caps);
+      s = gst_caps_get_structure (caps, 0);
+      self->twcc_ext_id = _get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
+
+      GST_INFO_OBJECT (self, "TWCC extension ID: %u", self->twcc_ext_id);
+
+      break;
+    }
+    default:
+      break;
+  }
+
+  return gst_pad_event_default (pad, parent, event);
+}
+
 static void
 gst_rtp_ulpfec_enc_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -636,7 +753,9 @@ gst_rtp_ulpfec_enc_dispose (GObject * obj)
 {
   GstRtpUlpFecEnc *fec = GST_RTP_ULPFEC_ENC (obj);
 
-  g_hash_table_destroy (fec->ssrc_to_ctx);
+  if (fec->ssrc_to_ctx)
+    g_hash_table_destroy (fec->ssrc_to_ctx);
+  fec->ssrc_to_ctx = NULL;
 
   G_OBJECT_CLASS (gst_rtp_ulpfec_enc_parent_class)->dispose (obj);
 }
@@ -652,6 +771,8 @@ gst_rtp_ulpfec_enc_init (GstRtpUlpFecEnc * fec)
   GST_PAD_SET_PROXY_ALLOCATION (fec->sinkpad);
   gst_pad_set_chain_function (fec->sinkpad,
       GST_DEBUG_FUNCPTR (gst_rtp_ulpfec_enc_chain));
+  gst_pad_set_event_function (fec->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_rtp_ulpfec_enc_event_sink));
   gst_element_add_pad (GST_ELEMENT (fec), fec->sinkpad);
 
   fec->ssrc_to_ctx = g_hash_table_new_full (NULL, NULL, NULL,
diff --git a/gst/rtp/gstrtpulpfecenc.h b/gst/rtp/gstrtpulpfecenc.h
index 885c6ad61..a92fc3d1a 100644
--- a/gst/rtp/gstrtpulpfecenc.h
+++ b/gst/rtp/gstrtpulpfecenc.h
@@ -47,6 +47,7 @@ struct _GstRtpUlpFecEnc {
   GstElement parent;
   GstPad *srcpad;
   GstPad *sinkpad;
+  guint8 twcc_ext_id;
 
   GHashTable *ssrc_to_ctx;
 
diff --git a/gst/rtp/gstrtpvorbisdepay.c b/gst/rtp/gstrtpvorbisdepay.c
index 556bd76c0..053e64795 100644
--- a/gst/rtp/gstrtpvorbisdepay.c
+++ b/gst/rtp/gstrtpvorbisdepay.c
@@ -26,6 +26,7 @@
 #include <gst/audio/audio.h>
 
 #include <string.h>
+#include "gstrtpelements.h"
 #include "gstrtpvorbisdepay.h"
 #include "gstrtputils.h"
 
@@ -61,6 +62,8 @@ GST_STATIC_PAD_TEMPLATE ("src",
 #define gst_rtp_vorbis_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpVorbisDepay, gst_rtp_vorbis_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvorbisdepay, "rtpvorbisdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_VORBIS_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_vorbis_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -702,10 +705,3 @@ gst_rtp_vorbis_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_vorbis_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpvorbisdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_VORBIS_DEPAY);
-}
diff --git a/gst/rtp/gstrtpvorbisdepay.h b/gst/rtp/gstrtpvorbisdepay.h
index a343d04e1..40f8d5f5f 100644
--- a/gst/rtp/gstrtpvorbisdepay.h
+++ b/gst/rtp/gstrtpvorbisdepay.h
@@ -63,8 +63,6 @@ struct _GstRtpVorbisDepayClass
 
 GType gst_rtp_vorbis_depay_get_type (void);
 
-gboolean gst_rtp_vorbis_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_VORBIS_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpvorbispay.c b/gst/rtp/gstrtpvorbispay.c
index 8a3c249c0..e54e2a7cd 100644
--- a/gst/rtp/gstrtpvorbispay.c
+++ b/gst/rtp/gstrtpvorbispay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/audio/audio.h>
 
+#include "gstrtpelements.h"
 #include "fnv1hash.h"
 #include "gstrtpvorbispay.h"
 #include "gstrtputils.h"
@@ -70,6 +71,8 @@ enum
 
 #define gst_rtp_vorbis_pay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpVorbisPay, gst_rtp_vorbis_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvorbispay, "rtpvorbispay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_VORBIS_PAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_vorbis_pay_setcaps (GstRTPBasePayload * basepayload,
     GstCaps * caps);
@@ -997,10 +1000,3 @@ gst_rtp_vorbis_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_vorbis_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpvorbispay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_VORBIS_PAY);
-}
diff --git a/gst/rtp/gstrtpvorbispay.h b/gst/rtp/gstrtpvorbispay.h
index a5d693a72..e1625efb0 100644
--- a/gst/rtp/gstrtpvorbispay.h
+++ b/gst/rtp/gstrtpvorbispay.h
@@ -78,8 +78,6 @@ struct _GstRtpVorbisPayClass
 
 GType gst_rtp_vorbis_pay_get_type (void);
 
-gboolean gst_rtp_vorbis_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_VORBIS_PAY_H__ */
diff --git a/gst/rtp/gstrtpvp8depay.c b/gst/rtp/gstrtpvp8depay.c
index e71baf816..3428f43f6 100644
--- a/gst/rtp/gstrtpvp8depay.c
+++ b/gst/rtp/gstrtpvp8depay.c
@@ -22,6 +22,7 @@
 # include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtpvp8depay.h"
 #include "gstrtputils.h"
 
@@ -43,8 +44,12 @@ static GstStateChangeReturn gst_rtp_vp8_depay_change_state (GstElement *
     element, GstStateChange transition);
 static gboolean gst_rtp_vp8_depay_handle_event (GstRTPBaseDepayload * depay,
     GstEvent * event);
+static gboolean gst_rtp_vp8_depay_packet_lost (GstRTPBaseDepayload * depay,
+    GstEvent * event);
 
 G_DEFINE_TYPE (GstRtpVP8Depay, gst_rtp_vp8_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvp8depay, "rtpvp8depay",
+    GST_RANK_MARGINAL, GST_TYPE_RTP_VP8_DEPAY, rtp_element_init (plugin));
 
 static GstStaticPadTemplate gst_rtp_vp8_depay_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -62,19 +67,26 @@ GST_STATIC_PAD_TEMPLATE ("sink",
         "encoding-name = (string) { \"VP8\", \"VP8-DRAFT-IETF-01\" }"));
 
 #define DEFAULT_WAIT_FOR_KEYFRAME FALSE
+#define DEFAULT_REQUEST_KEYFRAME FALSE
 
 enum
 {
   PROP_0,
-  PROP_WAIT_FOR_KEYFRAME
+  PROP_WAIT_FOR_KEYFRAME,
+  PROP_REQUEST_KEYFRAME,
 };
 
+#define PICTURE_ID_NONE (UINT_MAX)
+#define IS_PICTURE_ID_15BITS(pid) (((guint)(pid) & 0x8000) != 0)
+
 static void
 gst_rtp_vp8_depay_init (GstRtpVP8Depay * self)
 {
   self->adapter = gst_adapter_new ();
   self->started = FALSE;
   self->wait_for_keyframe = DEFAULT_WAIT_FOR_KEYFRAME;
+  self->request_keyframe = DEFAULT_REQUEST_KEYFRAME;
+  self->last_pushed_was_lost_event = FALSE;
 }
 
 static void
@@ -105,10 +117,24 @@ gst_rtp_vp8_depay_class_init (GstRtpVP8DepayClass * gst_rtp_vp8_depay_class)
           DEFAULT_WAIT_FOR_KEYFRAME,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRtpVP8Depay:request-keyframe:
+   *
+   * Request new keyframe when packet loss is detected
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (object_class, PROP_REQUEST_KEYFRAME,
+      g_param_spec_boolean ("request-keyframe", "Request Keyframe",
+          "Request new keyframe when packet loss is detected",
+          DEFAULT_REQUEST_KEYFRAME,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   element_class->change_state = gst_rtp_vp8_depay_change_state;
 
   depay_class->process_rtp_packet = gst_rtp_vp8_depay_process;
   depay_class->handle_event = gst_rtp_vp8_depay_handle_event;
+  depay_class->packet_lost = gst_rtp_vp8_depay_packet_lost;
 
   GST_DEBUG_CATEGORY_INIT (gst_rtp_vp8_depay_debug, "rtpvp8depay", 0,
       "VP8 Video RTP Depayloader");
@@ -139,6 +165,9 @@ gst_rtp_vp8_depay_set_property (GObject * object, guint prop_id,
     case PROP_WAIT_FOR_KEYFRAME:
       self->wait_for_keyframe = g_value_get_boolean (value);
       break;
+    case PROP_REQUEST_KEYFRAME:
+      self->request_keyframe = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -155,31 +184,129 @@ gst_rtp_vp8_depay_get_property (GObject * object, guint prop_id,
     case PROP_WAIT_FOR_KEYFRAME:
       g_value_set_boolean (value, self->wait_for_keyframe);
       break;
+    case PROP_REQUEST_KEYFRAME:
+      g_value_set_boolean (value, self->request_keyframe);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
   }
 }
 
+static gint
+picture_id_compare (guint16 id0, guint16 id1)
+{
+  guint shift = 16 - (IS_PICTURE_ID_15BITS (id1) ? 15 : 7);
+  id0 = id0 << shift;
+  id1 = id1 << shift;
+  return ((gint16) (id1 - id0)) >> shift;
+}
+
+static void
+send_last_lost_event (GstRtpVP8Depay * self)
+{
+  if (self->last_lost_event) {
+    GST_ERROR_OBJECT (self,
+        "Sending the last stopped lost event: %" GST_PTR_FORMAT,
+        self->last_lost_event);
+    GST_RTP_BASE_DEPAYLOAD_CLASS (gst_rtp_vp8_depay_parent_class)
+        ->packet_lost (GST_RTP_BASE_DEPAYLOAD_CAST (self),
+        self->last_lost_event);
+    gst_event_replace (&self->last_lost_event, NULL);
+    self->last_pushed_was_lost_event = TRUE;
+  }
+}
+
+static void
+send_new_lost_event (GstRtpVP8Depay * self, GstClockTime timestamp,
+    guint new_picture_id, const gchar * reason)
+{
+  GstEvent *event;
+
+  if (!GST_CLOCK_TIME_IS_VALID (timestamp)) {
+    GST_WARNING_OBJECT (self, "Can't create lost event with invalid timestmap");
+    return;
+  }
+
+  event = gst_event_new_custom (GST_EVENT_CUSTOM_DOWNSTREAM,
+      gst_structure_new ("GstRTPPacketLost",
+          "timestamp", G_TYPE_UINT64, timestamp,
+          "duration", G_TYPE_UINT64, G_GUINT64_CONSTANT (0), NULL));
+
+  GST_DEBUG_OBJECT (self, "Pushing lost event "
+      "(picids 0x%x 0x%x, reason \"%s\"): %" GST_PTR_FORMAT,
+      self->last_picture_id, new_picture_id, reason, event);
+
+  GST_RTP_BASE_DEPAYLOAD_CLASS (gst_rtp_vp8_depay_parent_class)
+      ->packet_lost (GST_RTP_BASE_DEPAYLOAD_CAST (self), event);
+
+  gst_event_unref (event);
+}
+
+static void
+send_last_lost_event_if_needed (GstRtpVP8Depay * self, guint new_picture_id)
+{
+  if (self->last_picture_id == PICTURE_ID_NONE)
+    return;
+
+  if (self->last_lost_event) {
+    gboolean send_lost_event = FALSE;
+    if (new_picture_id == PICTURE_ID_NONE) {
+      GST_DEBUG_OBJECT (self, "Dropping the last stopped lost event "
+          "(picture id does not exist): %" GST_PTR_FORMAT,
+          self->last_lost_event);
+    } else if (IS_PICTURE_ID_15BITS (self->last_picture_id) &&
+        !IS_PICTURE_ID_15BITS (new_picture_id)) {
+      GST_DEBUG_OBJECT (self, "Dropping the last stopped lost event "
+          "(picture id has less bits than before): %" GST_PTR_FORMAT,
+          self->last_lost_event);
+    } else if (picture_id_compare (self->last_picture_id, new_picture_id) != 1) {
+      GstStructure *s = gst_event_writable_structure (self->last_lost_event);
+
+      GST_DEBUG_OBJECT (self, "Sending the last stopped lost event "
+          "(gap in picture id %u %u): %" GST_PTR_FORMAT,
+          self->last_picture_id, new_picture_id, self->last_lost_event);
+      send_lost_event = TRUE;
+      /* Prevent rtpbasedepayload from dropping the event now
+       * that we have made sure the lost packet was not FEC */
+      gst_structure_remove_field (s, "might-have-been-fec");
+    }
+    if (send_lost_event)
+      GST_RTP_BASE_DEPAYLOAD_CLASS (gst_rtp_vp8_depay_parent_class)
+          ->packet_lost (GST_RTP_BASE_DEPAYLOAD_CAST (self),
+          self->last_lost_event);
+
+    gst_event_replace (&self->last_lost_event, NULL);
+  }
+}
+
 static GstBuffer *
 gst_rtp_vp8_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
 {
   GstRtpVP8Depay *self = GST_RTP_VP8_DEPAY (depay);
   GstBuffer *payload;
   guint8 *data;
-  guint hdrsize;
-  guint size;
+  guint hdrsize = 1;
+  guint picture_id = PICTURE_ID_NONE;
+  guint size = gst_rtp_buffer_get_payload_len (rtp);
+  guint s_bit;
+  guint part_id;
+  gboolean frame_start;
+  gboolean sent_lost_event = FALSE;
 
   if (G_UNLIKELY (GST_BUFFER_IS_DISCONT (rtp->buffer))) {
-    GST_LOG_OBJECT (self, "Discontinuity, flushing adapter");
+    GST_DEBUG_OBJECT (self, "Discontinuity, flushing adapter");
     gst_adapter_clear (self->adapter);
     self->started = FALSE;
 
     if (self->wait_for_keyframe)
       self->waiting_for_keyframe = TRUE;
-  }
 
-  size = gst_rtp_buffer_get_payload_len (rtp);
+    if (self->request_keyframe)
+      gst_pad_push_event (GST_RTP_BASE_DEPAYLOAD_SINKPAD (depay),
+          gst_video_event_new_upstream_force_key_unit (GST_CLOCK_TIME_NONE,
+              TRUE, 0));
+  }
 
   /* At least one header and one vp8 byte */
   if (G_UNLIKELY (size < 2))
@@ -187,16 +314,9 @@ gst_rtp_vp8_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
 
   data = gst_rtp_buffer_get_payload (rtp);
 
-  if (G_UNLIKELY (!self->started)) {
-    /* Check if this is the start of a VP8 frame, otherwise bail */
-    /* S=1 and PartID= 0 */
-    if ((data[0] & 0x17) != 0x10)
-      goto done;
+  s_bit = (data[0] >> 4) & 0x1;
+  part_id = (data[0] >> 0) & 0x7;
 
-    self->started = TRUE;
-  }
-
-  hdrsize = 1;
   /* Check X optional header */
   if ((data[0] & 0x80) != 0) {
     hdrsize++;
@@ -206,8 +326,13 @@ gst_rtp_vp8_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
         goto too_small;
       hdrsize++;
       /* Check for 16 bits PictureID */
-      if ((data[2] & 0x80) != 0)
+      picture_id = data[2];
+      if ((data[2] & 0x80) != 0) {
+        if (G_UNLIKELY (size < 4))
+          goto too_small;
         hdrsize++;
+        picture_id = (picture_id << 8) | data[3];
+      }
     }
     /* Check L optional header */
     if ((data[1] & 0x40) != 0)
@@ -216,19 +341,73 @@ gst_rtp_vp8_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
     if ((data[1] & 0x20) != 0 || (data[1] & 0x10) != 0)
       hdrsize++;
   }
-  GST_DEBUG_OBJECT (depay, "hdrsize %u, size %u", hdrsize, size);
-
+  GST_LOG_OBJECT (depay,
+      "hdrsize %u, size %u, picture id 0x%x, s %u, part_id %u", hdrsize, size,
+      picture_id, s_bit, part_id);
   if (G_UNLIKELY (hdrsize >= size))
     goto too_small;
 
+  frame_start = (s_bit == 1) && (part_id == 0);
+  if (frame_start) {
+    if (G_UNLIKELY (self->started)) {
+      GST_DEBUG_OBJECT (depay, "Incomplete frame, flushing adapter");
+      gst_adapter_clear (self->adapter);
+      self->started = FALSE;
+
+      if (self->wait_for_keyframe)
+        self->waiting_for_keyframe = TRUE;
+      if (self->request_keyframe)
+        gst_pad_push_event (GST_RTP_BASE_DEPAYLOAD_SINKPAD (depay),
+            gst_video_event_new_upstream_force_key_unit (GST_CLOCK_TIME_NONE,
+                TRUE, 0));
+
+      send_new_lost_event (self, GST_BUFFER_PTS (rtp->buffer), picture_id,
+          "Incomplete frame detected");
+      sent_lost_event = TRUE;
+    }
+  }
+
+  if (!self->started) {
+    if (G_UNLIKELY (!frame_start)) {
+      GST_DEBUG_OBJECT (depay,
+          "The frame is missing the first packet, ignoring the packet");
+      if (self->stop_lost_events && !sent_lost_event) {
+        send_last_lost_event (self);
+        self->stop_lost_events = FALSE;
+      }
+
+      if (self->wait_for_keyframe)
+        self->waiting_for_keyframe = TRUE;
+      if (self->request_keyframe)
+        gst_pad_push_event (GST_RTP_BASE_DEPAYLOAD_SINKPAD (depay),
+            gst_video_event_new_upstream_force_key_unit (GST_CLOCK_TIME_NONE,
+                TRUE, 0));
+
+      goto done;
+    }
+
+    GST_LOG_OBJECT (depay, "Found the start of the frame");
+
+    if (self->stop_lost_events && !sent_lost_event) {
+      send_last_lost_event_if_needed (self, picture_id);
+      self->stop_lost_events = FALSE;
+    }
+
+    self->started = TRUE;
+  }
+
   payload = gst_rtp_buffer_get_payload_subbuffer (rtp, hdrsize, -1);
   gst_adapter_push (self->adapter, payload);
+  self->last_picture_id = picture_id;
 
   /* Marker indicates that it was the last rtp packet for this frame */
   if (gst_rtp_buffer_get_marker (rtp)) {
     GstBuffer *out;
     guint8 header[10];
 
+    GST_LOG_OBJECT (depay,
+        "Found the end of the frame (%" G_GSIZE_FORMAT " bytes)",
+        gst_adapter_available (self->adapter));
     if (gst_adapter_available (self->adapter) < 10)
       goto too_small;
     gst_adapter_copy (self->adapter, &header, 0, 10);
@@ -257,6 +436,7 @@ gst_rtp_vp8_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
       guint profile, width, height;
 
       GST_BUFFER_FLAG_UNSET (out, GST_BUFFER_FLAG_DELTA_UNIT);
+      GST_DEBUG_OBJECT (self, "Processed keyframe");
 
       profile = (header[0] & 0x0e) >> 1;
       width = GST_READ_UINT16_LE (header + 6) & 0x3fff;
@@ -284,6 +464,11 @@ gst_rtp_vp8_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
       self->waiting_for_keyframe = FALSE;
     }
 
+    if (picture_id != PICTURE_ID_NONE)
+      self->stop_lost_events = TRUE;
+
+    self->last_pushed_was_lost_event = FALSE;
+
     return out;
   }
 
@@ -291,7 +476,7 @@ done:
   return NULL;
 
 too_small:
-  GST_LOG_OBJECT (self, "Invalid rtp packet (too small), ignoring");
+  GST_DEBUG_OBJECT (self, "Invalid rtp packet (too small), ignoring");
   gst_adapter_clear (self->adapter);
   self->started = FALSE;
 
@@ -309,6 +494,10 @@ gst_rtp_vp8_depay_change_state (GstElement * element, GstStateChange transition)
       self->last_height = -1;
       self->last_width = -1;
       self->waiting_for_keyframe = TRUE;
+      self->caps_sent = FALSE;
+      self->last_picture_id = PICTURE_ID_NONE;
+      gst_event_replace (&self->last_lost_event, NULL);
+      self->stop_lost_events = FALSE;
       break;
     default:
       break;
@@ -329,6 +518,9 @@ gst_rtp_vp8_depay_handle_event (GstRTPBaseDepayload * depay, GstEvent * event)
       self->last_profile = -1;
       self->last_height = -1;
       self->last_width = -1;
+      self->last_picture_id = PICTURE_ID_NONE;
+      gst_event_replace (&self->last_lost_event, NULL);
+      self->stop_lost_events = FALSE;
       break;
     default:
       break;
@@ -339,9 +531,48 @@ gst_rtp_vp8_depay_handle_event (GstRTPBaseDepayload * depay, GstEvent * event)
       (gst_rtp_vp8_depay_parent_class)->handle_event (depay, event);
 }
 
-gboolean
-gst_rtp_vp8_depay_plugin_init (GstPlugin * plugin)
+static gboolean
+gst_rtp_vp8_depay_packet_lost (GstRTPBaseDepayload * depay, GstEvent * event)
 {
-  return gst_element_register (plugin, "rtpvp8depay",
-      GST_RANK_MARGINAL, GST_TYPE_RTP_VP8_DEPAY);
+  GstRtpVP8Depay *self = GST_RTP_VP8_DEPAY (depay);
+  const GstStructure *s;
+  gboolean might_have_been_fec;
+  gboolean unref_event = FALSE;
+  gboolean ret;
+
+  s = gst_event_get_structure (event);
+
+  if (self->stop_lost_events) {
+    if (gst_structure_get_boolean (s, "might-have-been-fec",
+            &might_have_been_fec)
+        && might_have_been_fec) {
+      GST_DEBUG_OBJECT (depay, "Stopping lost event %" GST_PTR_FORMAT, event);
+      gst_event_replace (&self->last_lost_event, event);
+      return TRUE;
+    }
+  } else if (self->last_picture_id != PICTURE_ID_NONE) {
+    GstStructure *s;
+
+    if (!gst_event_is_writable (event)) {
+      event = gst_event_copy (event);
+      unref_event = TRUE;
+    }
+
+    s = gst_event_writable_structure (event);
+
+    /* We are currently processing a picture, let's make sure the
+     * base depayloader doesn't drop this lost event */
+    gst_structure_remove_field (s, "might-have-been-fec");
+  }
+
+  self->last_pushed_was_lost_event = TRUE;
+
+  ret =
+      GST_RTP_BASE_DEPAYLOAD_CLASS
+      (gst_rtp_vp8_depay_parent_class)->packet_lost (depay, event);
+
+  if (unref_event)
+    gst_event_unref (event);
+
+  return ret;
 }
diff --git a/gst/rtp/gstrtpvp8depay.h b/gst/rtp/gstrtpvp8depay.h
index cde8e5ea8..76be52adc 100644
--- a/gst/rtp/gstrtpvp8depay.h
+++ b/gst/rtp/gstrtpvp8depay.h
@@ -54,18 +54,28 @@ struct _GstRtpVP8Depay
   GstAdapter *adapter;
   gboolean started;
 
+  gboolean caps_sent;
+  /* In between pictures, we might store GstRTPPacketLost events instead
+   * of forwarding them immediately, we check upon reception of a new
+   * picture id whether a gap was introduced, in which case we do forward
+   * the event. This is to avoid forwarding spurious lost events for FEC
+   * packets.
+   */
+  gboolean stop_lost_events;
+  GstEvent *last_lost_event;
   gboolean waiting_for_keyframe;
   gint last_profile;
   gint last_width;
   gint last_height;
+  guint last_picture_id;
 
   gboolean wait_for_keyframe;
+  gboolean request_keyframe;
+  gboolean last_pushed_was_lost_event;
 };
 
 GType gst_rtp_vp8_depay_get_type (void);
 
-gboolean gst_rtp_vp8_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* #ifndef __GST_RTP_VP8_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpvp8pay.c b/gst/rtp/gstrtpvp8pay.c
index 4d6d20f7f..f4b4031d6 100644
--- a/gst/rtp/gstrtpvp8pay.c
+++ b/gst/rtp/gstrtpvp8pay.c
@@ -31,6 +31,7 @@
 #include <gst/rtp/gstrtppayloads.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "dboolhuff.h"
 #include "gstrtpvp8pay.h"
 #include "gstrtputils.h"
@@ -39,11 +40,13 @@ GST_DEBUG_CATEGORY_STATIC (gst_rtp_vp8_pay_debug);
 #define GST_CAT_DEFAULT gst_rtp_vp8_pay_debug
 
 #define DEFAULT_PICTURE_ID_MODE VP8_PAY_NO_PICTURE_ID
+#define DEFAULT_PICTURE_ID_OFFSET (-1)
 
 enum
 {
   PROP_0,
-  PROP_PICTURE_ID_MODE
+  PROP_PICTURE_ID_MODE,
+  PROP_PICTURE_ID_OFFSET
 };
 
 #define GST_TYPE_RTP_VP8_PAY_PICTURE_ID_MODE (gst_rtp_vp8_pay_picture_id_mode_get_type())
@@ -77,6 +80,8 @@ static gboolean gst_rtp_vp8_pay_set_caps (GstRTPBasePayload * payload,
     GstCaps * caps);
 
 G_DEFINE_TYPE (GstRtpVP8Pay, gst_rtp_vp8_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvp8pay, "rtpvp8pay",
+    GST_RANK_MARGINAL, GST_TYPE_RTP_VP8_PAY, rtp_element_init (plugin));
 
 static GstStaticPadTemplate gst_rtp_vp8_pay_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -92,14 +97,59 @@ GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_ALWAYS,
     GST_STATIC_CAPS ("video/x-vp8"));
 
+static gint
+picture_id_field_len (PictureIDMode mode)
+{
+  if (VP8_PAY_NO_PICTURE_ID == mode)
+    return 0;
+  if (VP8_PAY_PICTURE_ID_7BITS == mode)
+    return 7;
+  return 15;
+}
+
+static void
+gst_rtp_vp8_pay_picture_id_reset (GstRtpVP8Pay * obj)
+{
+  gint nbits;
+
+  if (obj->picture_id_offset == -1)
+    obj->picture_id = g_random_int ();
+  else
+    obj->picture_id = obj->picture_id_offset;
+
+  nbits = picture_id_field_len (obj->picture_id_mode);
+  obj->picture_id &= (1 << nbits) - 1;
+}
+
+static void
+gst_rtp_vp8_pay_picture_id_increment (GstRtpVP8Pay * obj)
+{
+  gint nbits;
+
+  if (obj->picture_id_mode == VP8_PAY_NO_PICTURE_ID)
+    return;
+
+  nbits = picture_id_field_len (obj->picture_id_mode);
+  obj->picture_id++;
+  obj->picture_id &= (1 << nbits) - 1;
+}
+
+static void
+gst_rtp_vp8_pay_reset (GstRtpVP8Pay * obj)
+{
+  gst_rtp_vp8_pay_picture_id_reset (obj);
+  /* tl0picidx MAY start at a random value, but there's no point. Initialize
+   * so that first packet will use 0 for convenience */
+  obj->tl0picidx = -1;
+  obj->temporal_scalability_fields_present = FALSE;
+}
+
 static void
 gst_rtp_vp8_pay_init (GstRtpVP8Pay * obj)
 {
   obj->picture_id_mode = DEFAULT_PICTURE_ID_MODE;
-  if (obj->picture_id_mode == VP8_PAY_PICTURE_ID_7BITS)
-    obj->picture_id = g_random_int_range (0, G_MAXUINT8) & 0x7F;
-  else if (obj->picture_id_mode == VP8_PAY_PICTURE_ID_15BITS)
-    obj->picture_id = g_random_int_range (0, G_MAXUINT16) & 0x7FFF;
+  obj->picture_id_offset = DEFAULT_PICTURE_ID_OFFSET;
+  gst_rtp_vp8_pay_reset (obj);
 }
 
 static void
@@ -118,6 +168,18 @@ gst_rtp_vp8_pay_class_init (GstRtpVP8PayClass * gst_rtp_vp8_pay_class)
           "The picture ID mode for payloading",
           GST_TYPE_RTP_VP8_PAY_PICTURE_ID_MODE, DEFAULT_PICTURE_ID_MODE,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+  /**
+   * rtpvp8pay:picture-id-offset:
+   *
+   * Offset to add to the initial picture-id (-1 = random)
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_PICTURE_ID_OFFSET,
+      g_param_spec_int ("picture-id-offset", "Picture ID offset",
+          "Offset to add to the initial picture-id (-1 = random)",
+          -1, 0x7FFF, DEFAULT_PICTURE_ID_OFFSET,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   gst_element_class_add_static_pad_template (element_class,
       &gst_rtp_vp8_pay_sink_template);
@@ -147,10 +209,11 @@ gst_rtp_vp8_pay_set_property (GObject * object,
   switch (prop_id) {
     case PROP_PICTURE_ID_MODE:
       rtpvp8pay->picture_id_mode = g_value_get_enum (value);
-      if (rtpvp8pay->picture_id_mode == VP8_PAY_PICTURE_ID_7BITS)
-        rtpvp8pay->picture_id = g_random_int_range (0, G_MAXUINT8) & 0x7F;
-      else if (rtpvp8pay->picture_id_mode == VP8_PAY_PICTURE_ID_15BITS)
-        rtpvp8pay->picture_id = g_random_int_range (0, G_MAXUINT16) & 0x7FFF;
+      gst_rtp_vp8_pay_picture_id_reset (rtpvp8pay);
+      break;
+    case PROP_PICTURE_ID_OFFSET:
+      rtpvp8pay->picture_id_offset = g_value_get_int (value);
+      gst_rtp_vp8_pay_picture_id_reset (rtpvp8pay);
       break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -168,6 +231,9 @@ gst_rtp_vp8_pay_get_property (GObject * object,
     case PROP_PICTURE_ID_MODE:
       g_value_set_enum (value, rtpvp8pay->picture_id_mode);
       break;
+    case PROP_PICTURE_ID_OFFSET:
+      g_value_set_int (value, rtpvp8pay->picture_id_offset);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -339,6 +405,10 @@ gst_rtp_vp8_pay_parse_frame (GstRtpVP8Pay * self, GstBuffer * buffer,
   self->partition_offset[i + 1] = size;
 
   gst_buffer_unmap (buffer, &map);
+
+  if (keyframe)
+    GST_DEBUG_OBJECT (self, "Parsed keyframe");
+
   return TRUE;
 
 error:
@@ -365,47 +435,121 @@ gst_rtp_vp8_offset_to_partition (GstRtpVP8Pay * self, guint offset)
 static gsize
 gst_rtp_vp8_calc_header_len (GstRtpVP8Pay * self)
 {
+  gsize len;
+
   switch (self->picture_id_mode) {
     case VP8_PAY_PICTURE_ID_7BITS:
-      return 3;
+      len = 1;
+      break;
     case VP8_PAY_PICTURE_ID_15BITS:
-      return 4;
+      len = 2;
+      break;
     case VP8_PAY_NO_PICTURE_ID:
     default:
-      return 1;
+      len = 0;
+      break;
+  }
+
+  if (self->temporal_scalability_fields_present) {
+    /* Add on space for TL0PICIDX and TID/Y/KEYIDX */
+    len += 2;
+  }
+
+  if (len > 0) {
+    /* All fields above are extension, so allocate space for the ECB field */
+    len++;
   }
+
+  return len + 1;               /* computed + fixed size header */
 }
 
 /* When growing the vp8 header keep max payload len calculation in sync */
 static GstBuffer *
 gst_rtp_vp8_create_header_buffer (GstRtpVP8Pay * self, guint8 partid,
-    gboolean start, gboolean mark, GstBuffer * in)
+    gboolean start, gboolean mark, GstBuffer * in, GstCustomMeta * meta)
 {
   GstBuffer *out;
   guint8 *p;
   GstRTPBuffer rtpbuffer = GST_RTP_BUFFER_INIT;
 
-  out = gst_rtp_buffer_new_allocate (gst_rtp_vp8_calc_header_len (self), 0, 0);
+  out =
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD_CAST
+      (self), gst_rtp_vp8_calc_header_len (self), 0, 0);
   gst_rtp_buffer_map (out, GST_MAP_READWRITE, &rtpbuffer);
   p = gst_rtp_buffer_get_payload (&rtpbuffer);
+
   /* X=0,R=0,N=0,S=start,PartID=partid */
   p[0] = (start << 4) | partid;
-  if (self->picture_id_mode != VP8_PAY_NO_PICTURE_ID) {
+  if (GST_BUFFER_FLAG_IS_SET (in, GST_BUFFER_FLAG_DROPPABLE)) {
+    /* Enable N=1 */
+    p[0] |= 0x20;
+  }
+
+  if (self->picture_id_mode != VP8_PAY_NO_PICTURE_ID ||
+      self->temporal_scalability_fields_present) {
+    gint index;
+
     /* Enable X=1 */
     p[0] |= 0x80;
-    /* X: I=1,L=0,T=0,K=0,RSV=0 */
-    p[1] = 0x80;
+
+    /* X: I=0,L=0,T=0,K=0,RSV=0 */
+    p[1] = 0x00;
+    if (self->picture_id_mode != VP8_PAY_NO_PICTURE_ID) {
+      /* Set I bit */
+      p[1] |= 0x80;
+    }
+    if (self->temporal_scalability_fields_present) {
+      /* Set L and T bits */
+      p[1] |= 0x60;
+    }
+
+    /* Insert picture ID */
     if (self->picture_id_mode == VP8_PAY_PICTURE_ID_7BITS) {
       /* I: 7 bit picture_id */
       p[2] = self->picture_id & 0x7F;
-    } else {
+      index = 3;
+    } else if (self->picture_id_mode == VP8_PAY_PICTURE_ID_15BITS) {
       /* I: 15 bit picture_id */
       p[2] = 0x80 | ((self->picture_id & 0x7FFF) >> 8);
       p[3] = self->picture_id & 0xFF;
+      index = 4;
+    } else {
+      index = 2;
+    }
+
+    /* Insert TL0PICIDX and TID/Y/KEYIDX */
+    if (self->temporal_scalability_fields_present) {
+      /* The meta contains tl0picidx from the encoder, but we need to ensure
+       * that tl0picidx is increasing correctly. The encoder may reset it's
+       * state and counter, but we cannot. Therefore, we cannot simply copy
+       * the value into the header.*/
+      guint temporal_layer = 0;
+      gboolean layer_sync = FALSE;
+      gboolean use_temporal_scaling = FALSE;
+
+      if (meta) {
+        GstStructure *s = gst_custom_meta_get_structure (meta);
+        gst_structure_get_boolean (s, "use-temporal-scaling",
+            &use_temporal_scaling);
+
+        if (use_temporal_scaling)
+          gst_structure_get (s, "layer-id", G_TYPE_UINT, &temporal_layer,
+              "layer-sync", G_TYPE_BOOLEAN, &layer_sync, NULL);
+      }
+
+      /* FIXME: Support a prediction structure where higher layers don't
+       * necessarily refer to the last base layer frame, ie they use an older
+       * tl0picidx as signalled in the meta */
+      if (temporal_layer == 0 && start)
+        self->tl0picidx++;
+      p[index] = self->tl0picidx & 0xFF;
+      p[index + 1] = ((temporal_layer << 6) | (layer_sync << 5)) & 0xFF;
     }
   }
 
   gst_rtp_buffer_set_marker (&rtpbuffer, mark);
+  if (mark)
+    GST_BUFFER_FLAG_SET (out, GST_BUFFER_FLAG_MARKER);
 
   gst_rtp_buffer_unmap (&rtpbuffer);
 
@@ -415,15 +559,38 @@ gst_rtp_vp8_create_header_buffer (GstRtpVP8Pay * self, guint8 partid,
   return out;
 }
 
+static gboolean
+foreach_metadata_drop (GstBuffer * buf, GstMeta ** meta, gpointer user_data)
+{
+  GstElement *element = user_data;
+  const GstMetaInfo *info = (*meta)->info;
+
+  if (gst_meta_info_is_custom (info) &&
+      gst_custom_meta_has_name ((GstCustomMeta *) * meta, "GstVP8Meta")) {
+    GST_DEBUG_OBJECT (element, "dropping GstVP8Meta");
+    *meta = NULL;
+  }
+
+  return TRUE;
+}
+
+static void
+gst_rtp_vp8_drop_vp8_meta (gpointer element, GstBuffer * buf)
+{
+  gst_buffer_foreach_meta (buf, foreach_metadata_drop, element);
+}
+
 static guint
 gst_rtp_vp8_payload_next (GstRtpVP8Pay * self, GstBufferList * list,
-    guint offset, GstBuffer * buffer, gsize buffer_size, gsize max_payload_len)
+    guint offset, GstBuffer * buffer, gsize buffer_size, gsize max_payload_len,
+    GstCustomMeta * meta)
 {
   guint partition;
   GstBuffer *header;
   GstBuffer *sub;
   GstBuffer *out;
   gboolean mark;
+  gboolean start;
   gsize remaining;
   gsize available;
 
@@ -432,16 +599,27 @@ gst_rtp_vp8_payload_next (GstRtpVP8Pay * self, GstBufferList * list,
   if (available > remaining)
     available = remaining;
 
-  partition = gst_rtp_vp8_offset_to_partition (self, offset);
-  g_assert (partition < self->n_partitions);
+  if (meta) {
+    /* If meta is present, then we have no partition offset information,
+     * so always emit PID 0 and set the start bit for the first packet
+     * of a frame only (c.f. RFC7741 $4.4)
+     */
+    partition = 0;
+    start = (offset == 0);
+  } else {
+    partition = gst_rtp_vp8_offset_to_partition (self, offset);
+    g_assert (partition < self->n_partitions);
+    start = (offset == self->partition_offset[partition]);
+  }
 
   mark = (remaining == available);
   /* whole set of partitions, payload them and done */
   header = gst_rtp_vp8_create_header_buffer (self, partition,
-      offset == self->partition_offset[partition], mark, buffer);
+      start, mark, buffer, meta);
   sub = gst_buffer_copy_region (buffer, GST_BUFFER_COPY_ALL, offset, available);
 
   gst_rtp_copy_video_meta (self, header, buffer);
+  gst_rtp_vp8_drop_vp8_meta (self, header);
 
   out = gst_buffer_append (header, sub);
 
@@ -457,37 +635,48 @@ gst_rtp_vp8_pay_handle_buffer (GstRTPBasePayload * payload, GstBuffer * buffer)
   GstRtpVP8Pay *self = GST_RTP_VP8_PAY (payload);
   GstFlowReturn ret;
   GstBufferList *list;
+  GstCustomMeta *meta;
   gsize size, max_paylen;
   guint offset, mtu, vp8_hdr_len;
 
   size = gst_buffer_get_size (buffer);
-
+  meta = gst_buffer_get_custom_meta (buffer, "GstVP8Meta");
   if (G_UNLIKELY (!gst_rtp_vp8_pay_parse_frame (self, buffer, size))) {
     GST_ELEMENT_ERROR (self, STREAM, ENCODE, (NULL),
         ("Failed to parse VP8 frame"));
     return GST_FLOW_ERROR;
   }
 
+  if (meta) {
+    GstStructure *s = gst_custom_meta_get_structure (meta);
+    gboolean use_temporal_scaling;
+    /* For interop it's most likely better to keep the temporal scalability
+     * fields present if the stream previously had them present. Alternating
+     * whether these fields are present or not may confuse the receiver. */
+
+    gst_structure_get_boolean (s, "use-temporal-scaling",
+        &use_temporal_scaling);
+    if (use_temporal_scaling)
+      self->temporal_scalability_fields_present = TRUE;
+  }
+
   mtu = GST_RTP_BASE_PAYLOAD_MTU (payload);
   vp8_hdr_len = gst_rtp_vp8_calc_header_len (self);
-  max_paylen = gst_rtp_buffer_calc_payload_len (mtu - vp8_hdr_len, 0, 0);
+  max_paylen = gst_rtp_buffer_calc_payload_len (mtu - vp8_hdr_len, 0,
+      gst_rtp_base_payload_get_source_count (payload, buffer));
 
   list = gst_buffer_list_new_sized ((size / max_paylen) + 1);
 
   offset = 0;
   while (offset < size) {
     offset +=
-        gst_rtp_vp8_payload_next (self, list, offset, buffer, size, max_paylen);
+        gst_rtp_vp8_payload_next (self, list, offset, buffer, size,
+        max_paylen, meta);
   }
 
   ret = gst_rtp_base_payload_push_list (payload, list);
 
-  /* Incremenent and wrap the picture id if it overflows */
-  if ((self->picture_id_mode == VP8_PAY_PICTURE_ID_7BITS &&
-          ++self->picture_id >= 0x80) ||
-      (self->picture_id_mode == VP8_PAY_PICTURE_ID_15BITS &&
-          ++self->picture_id >= 0x8000))
-    self->picture_id = 0;
+  gst_rtp_vp8_pay_picture_id_increment (self);
 
   gst_buffer_unref (buffer);
 
@@ -500,10 +689,7 @@ gst_rtp_vp8_pay_sink_event (GstRTPBasePayload * payload, GstEvent * event)
   GstRtpVP8Pay *self = GST_RTP_VP8_PAY (payload);
 
   if (GST_EVENT_TYPE (event) == GST_EVENT_FLUSH_START) {
-    if (self->picture_id_mode == VP8_PAY_PICTURE_ID_7BITS)
-      self->picture_id = g_random_int_range (0, G_MAXUINT8) & 0x7F;
-    else if (self->picture_id_mode == VP8_PAY_PICTURE_ID_15BITS)
-      self->picture_id = g_random_int_range (0, G_MAXUINT16) & 0x7FFF;
+    gst_rtp_vp8_pay_reset (self);
   }
 
   return GST_RTP_BASE_PAYLOAD_CLASS (gst_rtp_vp8_pay_parent_class)->sink_event
@@ -541,10 +727,3 @@ gst_rtp_vp8_pay_set_caps (GstRTPBasePayload * payload, GstCaps * caps)
 
   return gst_rtp_base_payload_set_outcaps (payload, NULL);
 }
-
-gboolean
-gst_rtp_vp8_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpvp8pay",
-      GST_RANK_MARGINAL, GST_TYPE_RTP_VP8_PAY);
-}
diff --git a/gst/rtp/gstrtpvp8pay.h b/gst/rtp/gstrtpvp8pay.h
index 247206067..30ad99a67 100644
--- a/gst/rtp/gstrtpvp8pay.h
+++ b/gst/rtp/gstrtpvp8pay.h
@@ -62,13 +62,14 @@ struct _GstRtpVP8Pay
   guint partition_offset[10];
   guint partition_size[9];
   PictureIDMode picture_id_mode;
+  gint picture_id_offset;
   guint16 picture_id;
+  gboolean temporal_scalability_fields_present;
+  guint8 tl0picidx;
 };
 
 GType gst_rtp_vp8_pay_get_type (void);
 
-gboolean gst_rtp_vp8_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* #ifndef __GST_RTP_VP8_PAY_H__ */
diff --git a/gst/rtp/gstrtpvp9depay.c b/gst/rtp/gstrtpvp9depay.c
index c61affca5..94348c5c8 100644
--- a/gst/rtp/gstrtpvp9depay.c
+++ b/gst/rtp/gstrtpvp9depay.c
@@ -23,6 +23,7 @@
 # include "config.h"
 #endif
 
+#include "gstrtpelements.h"
 #include "gstrtpvp9depay.h"
 #include "gstrtputils.h"
 
@@ -34,14 +35,22 @@ GST_DEBUG_CATEGORY_STATIC (gst_rtp_vp9_depay_debug);
 #define GST_CAT_DEFAULT gst_rtp_vp9_depay_debug
 
 static void gst_rtp_vp9_depay_dispose (GObject * object);
+static void gst_rtp_vp9_depay_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec);
+static void gst_rtp_vp9_depay_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec);
 static GstBuffer *gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depayload,
     GstRTPBuffer * rtp);
 static GstStateChangeReturn gst_rtp_vp9_depay_change_state (GstElement *
     element, GstStateChange transition);
 static gboolean gst_rtp_vp9_depay_handle_event (GstRTPBaseDepayload * depay,
     GstEvent * event);
+static gboolean gst_rtp_vp9_depay_packet_lost (GstRTPBaseDepayload * depay,
+    GstEvent * event);
 
 G_DEFINE_TYPE (GstRtpVP9Depay, gst_rtp_vp9_depay, GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvp9depay, "rtpvp9depay",
+    GST_RANK_MARGINAL, GST_TYPE_RTP_VP9_DEPAY, rtp_element_init (plugin));
 
 static GstStaticPadTemplate gst_rtp_vp9_depay_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -58,11 +67,27 @@ GST_STATIC_PAD_TEMPLATE ("sink",
         "media = (string) \"video\","
         "encoding-name = (string) { \"VP9\", \"VP9-DRAFT-IETF-01\" }"));
 
+#define DEFAULT_WAIT_FOR_KEYFRAME FALSE
+#define DEFAULT_REQUEST_KEYFRAME FALSE
+
+enum
+{
+  PROP_0,
+  PROP_WAIT_FOR_KEYFRAME,
+  PROP_REQUEST_KEYFRAME,
+};
+
+#define PICTURE_ID_NONE (UINT_MAX)
+#define IS_PICTURE_ID_15BITS(pid) (((guint)(pid) & 0x8000) != 0)
+
 static void
 gst_rtp_vp9_depay_init (GstRtpVP9Depay * self)
 {
   self->adapter = gst_adapter_new ();
   self->started = FALSE;
+  self->inter_picture = FALSE;
+  self->wait_for_keyframe = DEFAULT_WAIT_FOR_KEYFRAME;
+  self->request_keyframe = DEFAULT_REQUEST_KEYFRAME;
 }
 
 static void
@@ -84,11 +109,40 @@ gst_rtp_vp9_depay_class_init (GstRtpVP9DepayClass * gst_rtp_vp9_depay_class)
       "Extracts VP9 video from RTP packets)", "Stian Selnes <stian@pexip.com>");
 
   object_class->dispose = gst_rtp_vp9_depay_dispose;
+  object_class->set_property = gst_rtp_vp9_depay_set_property;
+  object_class->get_property = gst_rtp_vp9_depay_get_property;
+
+  /**
+   * GstRtpVP9Depay:wait-for-keyframe:
+   *
+   * Wait for the next keyframe after packet loss
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (object_class, PROP_WAIT_FOR_KEYFRAME,
+      g_param_spec_boolean ("wait-for-keyframe", "Wait for Keyframe",
+          "Wait for the next keyframe after packet loss",
+          DEFAULT_WAIT_FOR_KEYFRAME,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRtpVP9Depay:request-keyframe:
+   *
+   * Request new keyframe when packet loss is detected
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (object_class, PROP_REQUEST_KEYFRAME,
+      g_param_spec_boolean ("request-keyframe", "Request Keyframe",
+          "Request new keyframe when packet loss is detected",
+          DEFAULT_REQUEST_KEYFRAME,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
   element_class->change_state = gst_rtp_vp9_depay_change_state;
 
   depay_class->process_rtp_packet = gst_rtp_vp9_depay_process;
   depay_class->handle_event = gst_rtp_vp9_depay_handle_event;
+  depay_class->packet_lost = gst_rtp_vp9_depay_packet_lost;
 
   GST_DEBUG_CATEGORY_INIT (gst_rtp_vp9_depay_debug, "rtpvp9depay", 0,
       "VP9 Video RTP Depayloader");
@@ -109,6 +163,106 @@ gst_rtp_vp9_depay_dispose (GObject * object)
     G_OBJECT_CLASS (gst_rtp_vp9_depay_parent_class)->dispose (object);
 }
 
+static void
+gst_rtp_vp9_depay_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstRtpVP9Depay *self = GST_RTP_VP9_DEPAY (object);
+
+  switch (prop_id) {
+    case PROP_WAIT_FOR_KEYFRAME:
+      self->wait_for_keyframe = g_value_get_boolean (value);
+      break;
+    case PROP_REQUEST_KEYFRAME:
+      self->request_keyframe = g_value_get_boolean (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_vp9_depay_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstRtpVP9Depay *self = GST_RTP_VP9_DEPAY (object);
+
+  switch (prop_id) {
+    case PROP_WAIT_FOR_KEYFRAME:
+      g_value_set_boolean (value, self->wait_for_keyframe);
+      break;
+    case PROP_REQUEST_KEYFRAME:
+      g_value_set_boolean (value, self->request_keyframe);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+
+static gint
+picture_id_compare (guint16 id0, guint16 id1)
+{
+  guint shift = 16 - (IS_PICTURE_ID_15BITS (id1) ? 15 : 7);
+  id0 = id0 << shift;
+  id1 = id1 << shift;
+  return ((gint16) (id1 - id0)) >> shift;
+}
+
+static void
+send_last_lost_event (GstRtpVP9Depay * self)
+{
+  if (self->last_lost_event) {
+    GST_DEBUG_OBJECT (self,
+        "Sending the last stopped lost event: %" GST_PTR_FORMAT,
+        self->last_lost_event);
+    GST_RTP_BASE_DEPAYLOAD_CLASS (gst_rtp_vp9_depay_parent_class)
+        ->packet_lost (GST_RTP_BASE_DEPAYLOAD_CAST (self),
+        self->last_lost_event);
+    gst_event_replace (&self->last_lost_event, NULL);
+  }
+}
+
+static void
+send_last_lost_event_if_needed (GstRtpVP9Depay * self, guint new_picture_id)
+{
+  if (self->last_picture_id == PICTURE_ID_NONE ||
+      self->last_picture_id == new_picture_id)
+    return;
+
+  if (self->last_lost_event) {
+    gboolean send_lost_event = FALSE;
+    if (new_picture_id == PICTURE_ID_NONE) {
+      GST_DEBUG_OBJECT (self, "Dropping the last stopped lost event "
+          "(picture id does not exist): %" GST_PTR_FORMAT,
+          self->last_lost_event);
+    } else if (IS_PICTURE_ID_15BITS (self->last_picture_id) &&
+        !IS_PICTURE_ID_15BITS (new_picture_id)) {
+      GST_DEBUG_OBJECT (self, "Dropping the last stopped lost event "
+          "(picture id has less bits than before): %" GST_PTR_FORMAT,
+          self->last_lost_event);
+    } else if (picture_id_compare (self->last_picture_id, new_picture_id) != 1) {
+      GstStructure *s = gst_event_writable_structure (self->last_lost_event);
+
+      GST_DEBUG_OBJECT (self, "Sending the last stopped lost event "
+          "(gap in picture id %u %u): %" GST_PTR_FORMAT,
+          self->last_picture_id, new_picture_id, self->last_lost_event);
+      send_lost_event = TRUE;
+      /* Prevent rtpbasedepayload from dropping the event now
+       * that we have made sure the lost packet was not FEC */
+      gst_structure_remove_field (s, "might-have-been-fec");
+    }
+    if (send_lost_event)
+      GST_RTP_BASE_DEPAYLOAD_CLASS (gst_rtp_vp9_depay_parent_class)
+          ->packet_lost (GST_RTP_BASE_DEPAYLOAD_CAST (self),
+          self->last_lost_event);
+
+    gst_event_replace (&self->last_lost_event, NULL);
+  }
+}
+
 static GstBuffer *
 gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
 {
@@ -118,12 +272,16 @@ gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
   guint hdrsize = 1;
   guint size;
   gint spatial_layer = 0;
-  gboolean i_bit, p_bit, l_bit, f_bit, b_bit, e_bit, v_bit;
+  guint picture_id = PICTURE_ID_NONE;
+  gboolean i_bit, p_bit, l_bit, f_bit, b_bit, e_bit, v_bit, d_bit = 0;
+  gboolean is_start_of_picture;
+  gboolean flushed_adapter = FALSE;
 
   if (G_UNLIKELY (GST_BUFFER_IS_DISCONT (rtp->buffer))) {
     GST_LOG_OBJECT (self, "Discontinuity, flushing adapter");
     gst_adapter_clear (self->adapter);
     self->started = FALSE;
+    flushed_adapter = TRUE;
   }
 
   size = gst_rtp_buffer_get_payload_len (rtp);
@@ -141,14 +299,6 @@ gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
   e_bit = (data[0] & 0x04) != 0;
   v_bit = (data[0] & 0x02) != 0;
 
-  if (G_UNLIKELY (!self->started)) {
-    /* Check if this is the start of a VP9 layer frame, otherwise bail */
-    if (!b_bit)
-      goto done;
-
-    self->started = TRUE;
-  }
-
   GST_TRACE_OBJECT (self, "IPLFBEV : %d%d%d%d%d%d%d", i_bit, p_bit, l_bit,
       f_bit, b_bit, e_bit, v_bit);
 
@@ -157,16 +307,31 @@ gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
     hdrsize++;
     if (G_UNLIKELY (size < hdrsize + 1))
       goto too_small;
+    picture_id = data[1];
     /* Check M for 15 bits PictureID */
     if ((data[1] & 0x80) != 0) {
       hdrsize++;
       if (G_UNLIKELY (size < hdrsize + 1))
         goto too_small;
+      picture_id = (picture_id << 8) | data[2];
     }
   }
 
   /* Check L optional header layer indices */
   if (l_bit) {
+    spatial_layer = (data[hdrsize] >> 1) & 0x07;
+    d_bit = (data[hdrsize] >> 0) & 0x01;
+    GST_TRACE_OBJECT (self, "TID=%d, U=%d, SID=%d, D=%d",
+        (data[hdrsize] >> 5) & 0x07, (data[hdrsize] >> 4) & 0x01,
+        (data[hdrsize] >> 1) & 0x07, (data[hdrsize] >> 0) & 0x01);
+
+    if (spatial_layer == 0 && d_bit != 0) {
+      /* Invalid according to draft-ietf-payload-vp9-06, but firefox 61 and
+       * chrome 66 sends enchanment layers with SID=0, so let's not drop the
+       * packet. */
+      GST_LOG_OBJECT (self, "Invalid inter-layer dependency for base layer");
+    }
+
     hdrsize++;
     /* Check TL0PICIDX temporal layer zero index (non-flexible mode) */
     if (!f_bit)
@@ -245,24 +410,82 @@ gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
     hdrsize += sssize;
   }
 
-  GST_DEBUG_OBJECT (depay, "hdrsize %u, size %u", hdrsize, size);
+  GST_DEBUG_OBJECT (depay, "hdrsize %u, size %u, picture id 0x%x",
+      hdrsize, size, picture_id);
 
   if (G_UNLIKELY (hdrsize >= size))
     goto too_small;
 
+  is_start_of_picture = b_bit && (!l_bit || !d_bit);
+  /* If this is a start frame AND we are already processing a frame, we need to flush and wait for next start frame */
+  if (is_start_of_picture) {
+    if (G_UNLIKELY (self->started)) {
+      GST_DEBUG_OBJECT (depay, "Incomplete frame, flushing adapter");
+      gst_adapter_clear (self->adapter);
+      self->started = FALSE;
+      flushed_adapter = TRUE;
+    }
+  }
+
+  if (G_UNLIKELY (!self->started)) {
+    self->inter_picture = FALSE;
+
+    /* We have flushed the adapter and this packet does not
+     * start a keyframe, request one if needed */
+    if (flushed_adapter && (!b_bit || p_bit)) {
+      if (self->wait_for_keyframe) {
+        GST_DEBUG_OBJECT (self, "Waiting for keyframe after flushing adapter");
+        self->waiting_for_keyframe = TRUE;
+      }
+
+      if (self->request_keyframe) {
+        GST_DEBUG_OBJECT (self, "Requesting keyframe after flushing adapter");
+        gst_pad_push_event (GST_RTP_BASE_DEPAYLOAD_SINKPAD (depay),
+            gst_video_event_new_upstream_force_key_unit (GST_CLOCK_TIME_NONE,
+                TRUE, 0));
+      }
+    }
+
+    /* Check if this is the start of a VP9 layer frame, otherwise bail */
+    if (!b_bit) {
+      GST_DEBUG_OBJECT (depay,
+          "The layer is missing the first packets, ignoring the packet");
+      if (self->stop_lost_events) {
+        send_last_lost_event (self);
+        self->stop_lost_events = FALSE;
+      }
+      goto done;
+    }
+
+    GST_DEBUG_OBJECT (depay, "Found the start of the layer");
+    if (self->stop_lost_events) {
+      send_last_lost_event_if_needed (self, picture_id);
+      self->stop_lost_events = FALSE;
+    }
+    self->started = TRUE;
+  }
+
   payload = gst_rtp_buffer_get_payload_subbuffer (rtp, hdrsize, -1);
-  {
+  if (GST_LEVEL_MEMDUMP <= gst_debug_category_get_threshold (GST_CAT_DEFAULT)) {
     GstMapInfo map;
     gst_buffer_map (payload, &map, GST_MAP_READ);
     GST_MEMDUMP_OBJECT (self, "vp9 payload", map.data, 16);
     gst_buffer_unmap (payload, &map);
   }
   gst_adapter_push (self->adapter, payload);
+  self->last_picture_id = picture_id;
+  self->inter_picture |= p_bit;
 
-  /* Marker indicates that it was the last rtp packet for this frame */
+  /* Marker indicates that it was the last rtp packet for this picture. Note
+   * that if spatial scalability is used, e_bit will be set for the last
+   * packet of a frame while the marker bit is not set until the last packet
+   * of the picture. */
   if (gst_rtp_buffer_get_marker (rtp)) {
     GstBuffer *out;
-    gboolean key_frame_first_layer = !p_bit && spatial_layer == 0;
+
+    GST_DEBUG_OBJECT (depay,
+        "Found the end of the frame (%" G_GSIZE_FORMAT " bytes)",
+        gst_adapter_available (self->adapter));
 
     if (gst_adapter_available (self->adapter) < 10)
       goto too_small;
@@ -276,10 +499,10 @@ gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
     out = gst_buffer_make_writable (out);
     /* Filter away all metas that are not sensible to copy */
     gst_rtp_drop_non_video_meta (self, out);
-    if (!key_frame_first_layer) {
+    if (self->inter_picture) {
       GST_BUFFER_FLAG_SET (out, GST_BUFFER_FLAG_DELTA_UNIT);
 
-      if (!self->caps_sent) {
+      if (self->waiting_for_keyframe) {
         gst_buffer_unref (out);
         out = NULL;
         GST_INFO_OBJECT (self, "Dropping inter-frame before intra-frame");
@@ -309,14 +532,17 @@ gst_rtp_vp9_depay_process (GstRTPBaseDepayload * depay, GstRTPBuffer * rtp)
         gst_pad_set_caps (GST_RTP_BASE_DEPAYLOAD_SRCPAD (depay), srccaps);
         gst_caps_unref (srccaps);
 
-        self->caps_sent = TRUE;
         self->last_width = self->ss_width;
         self->last_height = self->ss_height;
         self->ss_width = 0;
         self->ss_height = 0;
       }
+
+      self->waiting_for_keyframe = FALSE;
     }
 
+    if (picture_id != PICTURE_ID_NONE)
+      self->stop_lost_events = TRUE;
     return out;
   }
 
@@ -327,7 +553,6 @@ too_small:
   GST_LOG_OBJECT (self, "Invalid rtp packet (too small), ignoring");
   gst_adapter_clear (self->adapter);
   self->started = FALSE;
-
   goto done;
 }
 
@@ -340,7 +565,10 @@ gst_rtp_vp9_depay_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_READY_TO_PAUSED:
       self->last_width = -1;
       self->last_height = -1;
-      self->caps_sent = FALSE;
+      self->last_picture_id = PICTURE_ID_NONE;
+      gst_event_replace (&self->last_lost_event, NULL);
+      self->stop_lost_events = FALSE;
+      self->waiting_for_keyframe = TRUE;
       break;
     default:
       break;
@@ -360,6 +588,9 @@ gst_rtp_vp9_depay_handle_event (GstRTPBaseDepayload * depay, GstEvent * event)
     case GST_EVENT_FLUSH_STOP:
       self->last_width = -1;
       self->last_height = -1;
+      self->last_picture_id = PICTURE_ID_NONE;
+      gst_event_replace (&self->last_lost_event, NULL);
+      self->stop_lost_events = FALSE;
       break;
     default:
       break;
@@ -370,9 +601,32 @@ gst_rtp_vp9_depay_handle_event (GstRTPBaseDepayload * depay, GstEvent * event)
       (gst_rtp_vp9_depay_parent_class)->handle_event (depay, event);
 }
 
-gboolean
-gst_rtp_vp9_depay_plugin_init (GstPlugin * plugin)
+static gboolean
+gst_rtp_vp9_depay_packet_lost (GstRTPBaseDepayload * depay, GstEvent * event)
 {
-  return gst_element_register (plugin, "rtpvp9depay",
-      GST_RANK_MARGINAL, GST_TYPE_RTP_VP9_DEPAY);
+  GstRtpVP9Depay *self = GST_RTP_VP9_DEPAY (depay);
+  const GstStructure *s;
+  gboolean might_have_been_fec;
+
+  s = gst_event_get_structure (event);
+
+  if (self->stop_lost_events) {
+    if (gst_structure_get_boolean (s, "might-have-been-fec",
+            &might_have_been_fec)
+        && might_have_been_fec) {
+      GST_DEBUG_OBJECT (depay, "Stopping lost event %" GST_PTR_FORMAT, event);
+      gst_event_replace (&self->last_lost_event, event);
+      return TRUE;
+    }
+  } else if (self->last_picture_id != PICTURE_ID_NONE) {
+    GstStructure *s = gst_event_writable_structure (self->last_lost_event);
+
+    /* We are currently processing a picture, let's make sure the
+     * base depayloader doesn't drop this lost event */
+    gst_structure_remove_field (s, "might-have-been-fec");
+  }
+
+  return
+      GST_RTP_BASE_DEPAYLOAD_CLASS
+      (gst_rtp_vp9_depay_parent_class)->packet_lost (depay, event);
 }
diff --git a/gst/rtp/gstrtpvp9depay.h b/gst/rtp/gstrtpvp9depay.h
index 6f783ab65..8c98a5bf1 100644
--- a/gst/rtp/gstrtpvp9depay.h
+++ b/gst/rtp/gstrtpvp9depay.h
@@ -59,13 +59,26 @@ struct _GstRtpVP9Depay
   gint ss_height;
   gint last_width;
   gint last_height;
-  gboolean caps_sent;
+  guint last_picture_id;
+  GstEvent *last_lost_event;
+  /* In between pictures, we might store GstRTPPacketLost events instead
+   * of forwarding them immediately, we check upon reception of a new
+   * picture id whether a gap was introduced, in which case we do forward
+   * the event. This is to avoid forwarding spurious lost events for FEC
+   * packets.
+   */
+  gboolean stop_lost_events;
+  gboolean inter_picture;
+
+  gboolean waiting_for_keyframe;
+
+  /* Properties */
+  gboolean wait_for_keyframe;
+  gboolean request_keyframe;
 };
 
 GType gst_rtp_vp9_depay_get_type (void);
 
-gboolean gst_rtp_vp9_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* #ifndef __GST_RTP_VP9_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpvp9pay.c b/gst/rtp/gstrtpvp9pay.c
index ce79c6463..0d29ac992 100644
--- a/gst/rtp/gstrtpvp9pay.c
+++ b/gst/rtp/gstrtpvp9pay.c
@@ -32,6 +32,7 @@
 #include <gst/rtp/gstrtppayloads.h>
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
+#include "gstrtpelements.h"
 #include "dboolhuff.h"
 #include "gstrtpvp9pay.h"
 #include "gstrtputils.h"
@@ -78,6 +79,8 @@ static gboolean gst_rtp_vp9_pay_set_caps (GstRTPBasePayload * payload,
     GstCaps * caps);
 
 G_DEFINE_TYPE (GstRtpVP9Pay, gst_rtp_vp9_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvp9pay, "rtpvp9pay",
+    GST_RANK_MARGINAL, GST_TYPE_RTP_VP9_PAY, rtp_element_init (plugin));
 
 static GstStaticPadTemplate gst_rtp_vp9_pay_src_template =
 GST_STATIC_PAD_TEMPLATE ("src",
@@ -386,7 +389,9 @@ gst_rtp_vp9_create_header_buffer (GstRtpVP9Pay * self,
   guint off = 1;
   guint hdrlen = gst_rtp_vp9_calc_header_len (self, start);
 
-  out = gst_rtp_buffer_new_allocate (hdrlen, 0, 0);
+  out =
+      gst_rtp_base_payload_allocate_output_buffer (GST_RTP_BASE_PAYLOAD (self),
+      hdrlen, 0, 0);
   gst_rtp_buffer_map (out, GST_MAP_READWRITE, &rtpbuffer);
   p = gst_rtp_buffer_get_payload (&rtpbuffer);
   p[0] = 0x0;
@@ -427,6 +432,8 @@ gst_rtp_vp9_create_header_buffer (GstRtpVP9Pay * self,
   g_assert_cmpint (off, ==, hdrlen);
 
   gst_rtp_buffer_set_marker (&rtpbuffer, mark);
+  if (mark)
+    GST_BUFFER_FLAG_SET (out, GST_BUFFER_FLAG_MARKER);
 
   gst_rtp_buffer_unmap (&rtpbuffer);
 
@@ -556,10 +563,3 @@ gst_rtp_vp9_pay_set_caps (GstRTPBasePayload * payload, GstCaps * caps)
 
   return gst_rtp_base_payload_set_outcaps (payload, NULL);
 }
-
-gboolean
-gst_rtp_vp9_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpvp9pay",
-      GST_RANK_MARGINAL, GST_TYPE_RTP_VP9_PAY);
-}
diff --git a/gst/rtp/gstrtpvp9pay.h b/gst/rtp/gstrtpvp9pay.h
index fc2aa8efd..407e3e08c 100644
--- a/gst/rtp/gstrtpvp9pay.h
+++ b/gst/rtp/gstrtpvp9pay.h
@@ -65,8 +65,6 @@ struct _GstRtpVP9Pay
 
 GType gst_rtp_vp9_pay_get_type (void);
 
-gboolean gst_rtp_vp9_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* #ifndef __GST_RTP_VP9_PAY_H__ */
diff --git a/gst/rtp/gstrtpvrawdepay.c b/gst/rtp/gstrtpvrawdepay.c
index d679f6879..d3bb5af05 100644
--- a/gst/rtp/gstrtpvrawdepay.c
+++ b/gst/rtp/gstrtpvrawdepay.c
@@ -26,6 +26,7 @@
 
 #include <string.h>
 #include <stdlib.h>
+#include "gstrtpelements.h"
 #include "gstrtpvrawdepay.h"
 #include "gstrtputils.h"
 
@@ -60,6 +61,8 @@ GST_STATIC_PAD_TEMPLATE ("sink",
 #define gst_rtp_vraw_depay_parent_class parent_class
 G_DEFINE_TYPE (GstRtpVRawDepay, gst_rtp_vraw_depay,
     GST_TYPE_RTP_BASE_DEPAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvrawdepay, "rtpvrawdepay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_VRAW_DEPAY, rtp_element_init (plugin));
 
 static gboolean gst_rtp_vraw_depay_setcaps (GstRTPBaseDepayload * depayload,
     GstCaps * caps);
@@ -658,10 +661,3 @@ gst_rtp_vraw_depay_change_state (GstElement * element,
   }
   return ret;
 }
-
-gboolean
-gst_rtp_vraw_depay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpvrawdepay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_VRAW_DEPAY);
-}
diff --git a/gst/rtp/gstrtpvrawdepay.h b/gst/rtp/gstrtpvrawdepay.h
index 18ca755d3..736da7583 100644
--- a/gst/rtp/gstrtpvrawdepay.h
+++ b/gst/rtp/gstrtpvrawdepay.h
@@ -64,8 +64,6 @@ struct _GstRtpVRawDepayClass
 
 GType gst_rtp_vraw_depay_get_type (void);
 
-gboolean gst_rtp_vraw_depay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_VRAW_DEPAY_H__ */
diff --git a/gst/rtp/gstrtpvrawpay.c b/gst/rtp/gstrtpvrawpay.c
index fa43ac87a..b2f807867 100644
--- a/gst/rtp/gstrtpvrawpay.c
+++ b/gst/rtp/gstrtpvrawpay.c
@@ -26,6 +26,7 @@
 #include <gst/rtp/gstrtpbuffer.h>
 #include <gst/video/video.h>
 
+#include "gstrtpelements.h"
 #include "gstrtpvrawpay.h"
 #include "gstrtputils.h"
 
@@ -85,6 +86,8 @@ static void gst_rtp_vraw_pay_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec);
 
 G_DEFINE_TYPE (GstRtpVRawPay, gst_rtp_vraw_pay, GST_TYPE_RTP_BASE_PAYLOAD);
+GST_ELEMENT_REGISTER_DEFINE_WITH_CODE (rtpvrawpay, "rtpvrawpay",
+    GST_RANK_SECONDARY, GST_TYPE_RTP_VRAW_PAY, rtp_element_init (plugin));
 
 static void
 gst_rtp_vraw_pay_class_init (GstRtpVRawPayClass * klass)
@@ -353,7 +356,7 @@ gst_rtp_vraw_pay_handle_buffer (GstRTPBasePayload * payload, GstBuffer * buffer)
 
       /* get the max allowed payload length size, we try to fill the complete MTU */
       left = gst_rtp_buffer_calc_payload_len (mtu, 0, 0);
-      out = gst_rtp_buffer_new_allocate (left, 0, 0);
+      out = gst_rtp_base_payload_allocate_output_buffer (payload, left, 0, 0);
 
       if (discont) {
         GST_BUFFER_FLAG_SET (out, GST_BUFFER_FLAG_DISCONT);
@@ -563,6 +566,7 @@ gst_rtp_vraw_pay_handle_buffer (GstRTPBasePayload * payload, GstBuffer * buffer)
       if (line >= height) {
         GST_LOG_OBJECT (rtpvrawpay, "field/frame complete, set marker");
         gst_rtp_buffer_set_marker (&rtp, TRUE);
+        GST_BUFFER_FLAG_SET (out, GST_BUFFER_FLAG_MARKER);
         complete = TRUE;
       }
       gst_rtp_buffer_unmap (&rtp);
@@ -656,10 +660,3 @@ gst_rtp_vraw_pay_get_property (GObject * object, guint prop_id,
       break;
   }
 }
-
-gboolean
-gst_rtp_vraw_pay_plugin_init (GstPlugin * plugin)
-{
-  return gst_element_register (plugin, "rtpvrawpay",
-      GST_RANK_SECONDARY, GST_TYPE_RTP_VRAW_PAY);
-}
diff --git a/gst/rtp/gstrtpvrawpay.h b/gst/rtp/gstrtpvrawpay.h
index 3fd2442d6..008cbee93 100644
--- a/gst/rtp/gstrtpvrawpay.h
+++ b/gst/rtp/gstrtpvrawpay.h
@@ -60,8 +60,6 @@ struct _GstRtpVRawPayClass
 
 GType gst_rtp_vraw_pay_get_type (void);
 
-gboolean gst_rtp_vraw_pay_plugin_init (GstPlugin * plugin);
-
 G_END_DECLS
 
 #endif /* __GST_RTP_VRAW_PAY_H__ */
diff --git a/gst/rtp/meson.build b/gst/rtp/meson.build
index d57a195ae..aa76523ec 100644
--- a/gst/rtp/meson.build
+++ b/gst/rtp/meson.build
@@ -2,6 +2,7 @@ rtp_sources = [
   'dboolhuff.c',
   'fnv1hash.c',
   'gstbuffermemory.c',
+  'gstrtpelement.c',
   'gstrtp.c',
   'gstrtpchannels.c',
   'gstrtpac3depay.c',
@@ -41,6 +42,7 @@ rtp_sources = [
   'gstrtpgsmpay.c',
   'gstrtpamrdepay.c',
   'gstrtpamrpay.c',
+  'gstrtphdrext-colorspace.c',
   'gstrtph261depay.c',
   'gstrtph261pay.c',
   'gstrtph263pdepay.c',
@@ -61,6 +63,7 @@ rtp_sources = [
   'gstrtpL16pay.c',
   'gstrtpL24depay.c',
   'gstrtpL24pay.c',
+  'gstrtpldacpay.c',
   'gstasteriskh263.c',
   'gstrtpmp1sdepay.c',
   'gstrtpmp2tdepay.c',
@@ -102,6 +105,8 @@ rtp_sources = [
   'rtpstorage.c',
   'rtpstoragestream.c',
   'gstrtpstorage.c',
+  'gstrtpisacdepay.c',
+  'gstrtpisacpay.c',
 ]
 
 rtp_args = [
@@ -119,5 +124,4 @@ gstrtp = library('gstrtp',
   install : true,
   install_dir : plugins_install_dir,
 )
-pkgconfig.generate(gstrtp, install_dir : plugins_pkgconfig_install_dir)
 plugins += [gstrtp]
diff --git a/gst/rtp/rtpulpfeccommon.c b/gst/rtp/rtpulpfeccommon.c
index 7c6bf5876..10687fc12 100644
--- a/gst/rtp/rtpulpfeccommon.c
+++ b/gst/rtp/rtpulpfeccommon.c
@@ -123,7 +123,13 @@ _xor_mem (guint8 * restrict dst, const guint8 * restrict src, gsize length)
   guint i;
 
   for (i = 0; i < (length / sizeof (guint64)); ++i) {
-    *((guint64 *) dst) ^= *((const guint64 *) src);
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+    GST_WRITE_UINT64_LE (dst,
+        GST_READ_UINT64_LE (dst) ^ GST_READ_UINT64_LE (src));
+#else
+    GST_WRITE_UINT64_BE (dst,
+        GST_READ_UINT64_BE (dst) ^ GST_READ_UINT64_BE (src));
+#endif
     dst += sizeof (guint64);
     src += sizeof (guint64);
   }
@@ -304,6 +310,8 @@ rtp_ulpfec_bitstring_to_fec_rtp_buffer (GArray * arr,
     g_assert_not_reached ();
 
   gst_rtp_buffer_set_marker (&rtp, marker);
+  if (marker)
+    GST_BUFFER_FLAG_SET (ret, GST_BUFFER_FLAG_MARKER);
   gst_rtp_buffer_set_payload_type (&rtp, pt);
   gst_rtp_buffer_set_seq (&rtp, seq);
   gst_rtp_buffer_set_timestamp (&rtp, timestamp);
diff --git a/gst/rtpmanager/gstrtpbin.c b/gst/rtpmanager/gstrtpbin.c
index 1fb98ffc7..0fbf0820c 100644
--- a/gst/rtpmanager/gstrtpbin.c
+++ b/gst/rtpmanager/gstrtpbin.c
@@ -151,6 +151,7 @@
 #include "rtpsession.h"
 #include "gstrtpsession.h"
 #include "gstrtpjitterbuffer.h"
+#include "gstrtputils.h"
 
 #include <gst/glib-compat-private.h>
 
@@ -165,6 +166,40 @@ static GstStaticPadTemplate rtpbin_recv_rtp_sink_template =
     GST_STATIC_CAPS ("application/x-rtp;application/x-srtp")
     );
 
+/**
+ * GstRtpBin!recv_fec_sink_%u_%u:
+ *
+ * Sink template for receiving Forward Error Correction packets,
+ * in the form recv_fec_sink_<session_idx>_<fec_stream_idx>
+ *
+ * See #GstRTPST_2022_1_FecDec for example usage
+ *
+ * Since: 1.20
+ */
+static GstStaticPadTemplate rtpbin_recv_fec_sink_template =
+GST_STATIC_PAD_TEMPLATE ("recv_fec_sink_%u_%u",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS ("application/x-rtp")
+    );
+
+/**
+ * GstRtpBin!send_fec_src_%u_%u:
+ *
+ * Src template for sending Forward Error Correction packets,
+ * in the form send_fec_src_<session_idx>_<fec_stream_idx>
+ *
+ * See #GstRTPST_2022_1_FecEnc for example usage
+ *
+ * Since: 1.20
+ */
+static GstStaticPadTemplate rtpbin_send_fec_src_template =
+GST_STATIC_PAD_TEMPLATE ("send_fec_src_%u_%u",
+    GST_PAD_SRC,
+    GST_PAD_SOMETIMES,
+    GST_STATIC_CAPS ("application/x-rtp")
+    );
+
 static GstStaticPadTemplate rtpbin_recv_rtcp_sink_template =
     GST_STATIC_PAD_TEMPLATE ("recv_rtcp_sink_%u",
     GST_PAD_SINK,
@@ -226,7 +261,7 @@ G_STMT_START {                                   \
 
 /* Minimum time offset to apply. This compensates for rounding errors in NTP to
  * RTP timestamp conversions */
-#define MIN_TS_OFFSET (4 * GST_MSECOND)
+#define MIN_TS_OFFSET_ROUND_OFF_COMP (4 * GST_MSECOND)
 
 struct _GstRtpBinPrivate
 {
@@ -258,6 +293,7 @@ enum
   SIGNAL_GET_INTERNAL_SESSION,
   SIGNAL_GET_STORAGE,
   SIGNAL_GET_INTERNAL_STORAGE,
+  SIGNAL_CLEAR_SSRC,
 
   SIGNAL_ON_NEW_SSRC,
   SIGNAL_ON_SSRC_COLLISION,
@@ -276,6 +312,7 @@ enum
   SIGNAL_REQUEST_RTCP_DECODER,
 
   SIGNAL_REQUEST_FEC_DECODER,
+  SIGNAL_REQUEST_FEC_DECODER_FULL,
   SIGNAL_REQUEST_FEC_ENCODER,
 
   SIGNAL_REQUEST_JITTERBUFFER,
@@ -314,9 +351,13 @@ enum
 #define DEFAULT_MAX_DROPOUT_TIME     60000
 #define DEFAULT_MAX_MISORDER_TIME    2000
 #define DEFAULT_RFC7273_SYNC         FALSE
+#define DEFAULT_ADD_REFERENCE_TIMESTAMP_META FALSE
 #define DEFAULT_MAX_STREAMS          G_MAXUINT
 #define DEFAULT_MAX_TS_OFFSET_ADJUSTMENT G_GUINT64_CONSTANT(0)
 #define DEFAULT_MAX_TS_OFFSET        G_GINT64_CONSTANT(3000000000)
+#define DEFAULT_MIN_TS_OFFSET        MIN_TS_OFFSET_ROUND_OFF_COMP
+#define DEFAULT_TS_OFFSET_SMOOTHING_FACTOR  0
+#define DEFAULT_UPDATE_NTP64_HEADER_EXT TRUE
 
 enum
 {
@@ -341,9 +382,15 @@ enum
   PROP_MAX_DROPOUT_TIME,
   PROP_MAX_MISORDER_TIME,
   PROP_RFC7273_SYNC,
+  PROP_ADD_REFERENCE_TIMESTAMP_META,
   PROP_MAX_STREAMS,
   PROP_MAX_TS_OFFSET_ADJUSTMENT,
   PROP_MAX_TS_OFFSET,
+  PROP_MIN_TS_OFFSET,
+  PROP_TS_OFFSET_SMOOTHING_FACTOR,
+  PROP_FEC_DECODERS,
+  PROP_FEC_ENCODERS,
+  PROP_UPDATE_NTP64_HEADER_EXT,
 };
 
 #define GST_RTP_BIN_RTCP_SYNC_TYPE (gst_rtp_bin_rtcp_sync_get_type())
@@ -377,7 +424,9 @@ static void payload_type_change (GstElement * element, guint pt,
     GstRtpBinSession * session);
 static void remove_recv_rtp (GstRtpBin * rtpbin, GstRtpBinSession * session);
 static void remove_recv_rtcp (GstRtpBin * rtpbin, GstRtpBinSession * session);
+static void remove_recv_fec (GstRtpBin * rtpbin, GstRtpBinSession * session);
 static void remove_send_rtp (GstRtpBin * rtpbin, GstRtpBinSession * session);
+static void remove_send_fec (GstRtpBin * rtpbin, GstRtpBinSession * session);
 static void remove_rtcp (GstRtpBin * rtpbin, GstRtpBinSession * session);
 static void free_client (GstRtpBinClient * client, GstRtpBin * bin);
 static void free_stream (GstRtpBinStream * stream, GstRtpBin * bin);
@@ -429,6 +478,8 @@ struct _GstRtpBinStream
   /* mapping to local RTP and NTP time */
   gint64 rt_delta;
   gint64 rtp_delta;
+  gint64 avg_ts_offset;
+  gboolean is_initialized;
   /* base rtptime in gst time */
   gint64 clock_base;
 };
@@ -486,6 +537,15 @@ struct _GstRtpBinSession
   GstPad *send_rtp_src_ghost;
   GstPad *send_rtcp_src;
   GstPad *send_rtcp_src_ghost;
+
+  GSList *recv_fec_sinks;
+  GSList *recv_fec_sink_ghosts;
+  /* fec decoder placed before the rtpjitterbuffer but after the rtpssrcdemux.
+   * XXX: This does not yet support multiple ssrc's in the same rtp session
+   */
+  GstElement *early_fec_decoder;
+
+  GSList *send_fec_src_ghosts;
 };
 
 /* Manages the RTP streams that come from one client and should therefore be
@@ -517,6 +577,12 @@ find_session_by_id (GstRtpBin * rtpbin, gint id)
   return NULL;
 }
 
+static gboolean
+pad_is_recv_fec (GstRtpBinSession * session, GstPad * pad)
+{
+  return g_slist_find (session->recv_fec_sink_ghosts, pad) != NULL;
+}
+
 /* find a session with the given request pad. Must be called with RTP_BIN_LOCK */
 static GstRtpBinSession *
 find_session_by_pad (GstRtpBin * rtpbin, GstPad * pad)
@@ -528,8 +594,8 @@ find_session_by_pad (GstRtpBin * rtpbin, GstPad * pad)
 
     if ((sess->recv_rtp_sink_ghost == pad) ||
         (sess->recv_rtcp_sink_ghost == pad) ||
-        (sess->send_rtp_sink_ghost == pad)
-        || (sess->send_rtcp_src_ghost == pad))
+        (sess->send_rtp_sink_ghost == pad) ||
+        (sess->send_rtcp_src_ghost == pad) || pad_is_recv_fec (sess, pad))
       return sess;
   }
   return NULL;
@@ -713,6 +779,10 @@ create_session (GstRtpBin * rtpbin, gint id)
 
   g_object_set (session, "max-dropout-time", rtpbin->max_dropout_time,
       "max-misorder-time", rtpbin->max_misorder_time, NULL);
+
+  g_object_set (session, "update-ntp64-header-ext",
+      rtpbin->update_ntp64_header_ext, NULL);
+
   GST_OBJECT_UNLOCK (rtpbin);
 
   /* provide clock_rate to the session manager when needed */
@@ -850,7 +920,9 @@ free_session (GstRtpBinSession * sess, GstRtpBin * bin)
 
   remove_recv_rtp (bin, sess);
   remove_recv_rtcp (bin, sess);
+  remove_recv_fec (bin, sess);
   remove_send_rtp (bin, sess);
+  remove_send_fec (bin, sess);
   remove_rtcp (bin, sess);
 
   gst_bin_remove (GST_BIN_CAST (bin), sess->session);
@@ -973,6 +1045,8 @@ gst_rtp_bin_reset_sync (GstRtpBin * rtpbin)
        * lip-sync */
       stream->have_sync = FALSE;
       stream->rt_delta = 0;
+      stream->avg_ts_offset = 0;
+      stream->is_initialized = FALSE;
       stream->rtp_delta = 0;
       stream->clock_base = -100 * GST_SECOND;
     }
@@ -1086,6 +1160,25 @@ gst_rtp_bin_get_internal_storage (GstRtpBin * bin, guint session_id)
   return internal_storage;
 }
 
+static void
+gst_rtp_bin_clear_ssrc (GstRtpBin * bin, guint session_id, guint32 ssrc)
+{
+  GstRtpBinSession *session;
+  GstElement *demux = NULL;
+
+  GST_RTP_BIN_LOCK (bin);
+  GST_DEBUG_OBJECT (bin, "clearing ssrc %u for session %u", ssrc, session_id);
+  session = find_session_by_id (bin, (gint) session_id);
+  if (session)
+    demux = gst_object_ref (session->demux);
+  GST_RTP_BIN_UNLOCK (bin);
+
+  if (demux) {
+    g_signal_emit_by_name (demux, "clear-ssrc", ssrc, NULL);
+    gst_object_unref (demux);
+  }
+}
+
 static GstElement *
 gst_rtp_bin_request_encoder (GstRtpBin * bin, guint session_id)
 {
@@ -1150,7 +1243,8 @@ gst_rtp_bin_propagate_property_to_session (GstRtpBin * bin,
 
 /* get a client with the given SDES name. Must be called with RTP_BIN_LOCK */
 static GstRtpBinClient *
-get_client (GstRtpBin * bin, guint8 len, guint8 * data, gboolean * created)
+get_client (GstRtpBin * bin, guint8 len, const guint8 * data,
+    gboolean * created)
 {
   GstRtpBinClient *result = NULL;
   GSList *walk;
@@ -1211,7 +1305,7 @@ get_current_times (GstRtpBin * bin, GstClockTime * running_time,
     if (bin->use_pipeline_clock) {
       ntpns = rt;
       /* add constant to convert from 1970 based time to 1900 based time */
-      ntpns += (2208988800LL * GST_SECOND);
+      ntpns += (GST_RTP_NTP_UNIX_OFFSET * GST_SECOND);
     } else {
       switch (bin->ntp_time_source) {
         case GST_RTP_NTP_TIME_SOURCE_NTP:
@@ -1221,7 +1315,7 @@ get_current_times (GstRtpBin * bin, GstClockTime * running_time,
 
           /* add constant to convert from 1970 based time to 1900 based time */
           if (bin->ntp_time_source == GST_RTP_NTP_TIME_SOURCE_NTP)
-            ntpns += (2208988800LL * GST_SECOND);
+            ntpns += (GST_RTP_NTP_UNIX_OFFSET * GST_SECOND);
           break;
         }
         case GST_RTP_NTP_TIME_SOURCE_RUNNING_TIME:
@@ -1251,7 +1345,7 @@ get_current_times (GstRtpBin * bin, GstClockTime * running_time,
 
 static void
 stream_set_ts_offset (GstRtpBin * bin, GstRtpBinStream * stream,
-    gint64 ts_offset, gint64 max_ts_offset, gint64 min_ts_offset,
+    gint64 ts_offset, gint64 max_ts_offset, guint64 min_ts_offset,
     gboolean allow_positive_ts_offset)
 {
   gint64 prev_ts_offset;
@@ -1265,17 +1359,51 @@ stream_set_ts_offset (GstRtpBin * bin, GstRtpBinStream * stream,
     return;
   }
 
+  if (bin->ts_offset_smoothing_factor > 0) {
+    if (!stream->is_initialized) {
+      stream->avg_ts_offset = ts_offset;
+      stream->is_initialized = TRUE;
+    } else {
+      /* RMA algorithm using smoothing factor is following, but split into
+       * parts to check for overflows:
+       * stream->avg_ts_offset =
+       *   ((bin->ts_offset_smoothing_factor - 1) * stream->avg_ts_offset
+       *    + ts_offset) / bin->ts_offset_smoothing_factor
+       */
+      guint64 max_possible_smoothing_factor = G_MAXUINT64;
+      gint64 cur_avg_product =
+          (bin->ts_offset_smoothing_factor - 1) * stream->avg_ts_offset;
+      if (stream->avg_ts_offset != 0)
+        max_possible_smoothing_factor =
+            G_MAXINT64 / ABS (stream->avg_ts_offset);
+
+      if ((max_possible_smoothing_factor < bin->ts_offset_smoothing_factor) ||
+          (cur_avg_product > 0 && G_MAXINT64 - cur_avg_product < ts_offset) ||
+          (cur_avg_product < 0 && G_MININT64 - cur_avg_product > ts_offset)) {
+        GST_WARNING_OBJECT (bin,
+            "ts-offset-smoothing-factor calculation overflow, fallback to using ts-offset directly");
+        stream->avg_ts_offset = ts_offset;
+      } else {
+        stream->avg_ts_offset =
+            (cur_avg_product + ts_offset) / bin->ts_offset_smoothing_factor;
+      }
+    }
+  } else {
+    stream->avg_ts_offset = ts_offset;
+  }
+
   g_object_get (stream->buffer, "ts-offset", &prev_ts_offset, NULL);
 
   /* delta changed, see how much */
-  if (prev_ts_offset != ts_offset) {
+  if (prev_ts_offset != stream->avg_ts_offset) {
     gint64 diff;
 
-    diff = prev_ts_offset - ts_offset;
+    diff = prev_ts_offset - stream->avg_ts_offset;
 
     GST_DEBUG_OBJECT (bin,
         "ts-offset %" G_GINT64_FORMAT ", prev %" G_GINT64_FORMAT
-        ", diff: %" G_GINT64_FORMAT, ts_offset, prev_ts_offset, diff);
+        ", diff: %" G_GINT64_FORMAT, stream->avg_ts_offset, prev_ts_offset,
+        diff);
 
     /* ignore minor offsets */
     if (ABS (diff) < min_ts_offset) {
@@ -1285,21 +1413,21 @@ stream_set_ts_offset (GstRtpBin * bin, GstRtpBinStream * stream,
 
     /* sanity check offset */
     if (max_ts_offset > 0) {
-      if (ts_offset > 0 && !allow_positive_ts_offset) {
+      if (stream->avg_ts_offset > 0 && !allow_positive_ts_offset) {
         GST_DEBUG_OBJECT (bin,
             "offset is positive (clocks are out of sync), ignoring");
         return;
       }
-      if (ABS (ts_offset) > max_ts_offset) {
+      if (ABS (stream->avg_ts_offset) > max_ts_offset) {
         GST_DEBUG_OBJECT (bin, "offset too large, ignoring");
         return;
       }
     }
 
-    g_object_set (stream->buffer, "ts-offset", ts_offset, NULL);
+    g_object_set (stream->buffer, "ts-offset", stream->avg_ts_offset, NULL);
   }
   GST_DEBUG_OBJECT (bin, "stream SSRC %08x, delta %" G_GINT64_FORMAT,
-      stream->ssrc, ts_offset);
+      stream->ssrc, stream->avg_ts_offset);
 }
 
 static void
@@ -1326,7 +1454,7 @@ gst_rtp_bin_send_sync_event (GstRtpBinStream * stream)
  * Must be called with GST_RTP_BIN_LOCK */
 static void
 gst_rtp_bin_associate (GstRtpBin * bin, GstRtpBinStream * stream, guint8 len,
-    guint8 * data, guint64 ntptime, guint64 last_extrtptime,
+    const guint8 * data, guint64 ntpnstime, guint64 last_extrtptime,
     guint64 base_rtptime, guint64 base_time, guint clock_rate,
     gint64 rtp_clock_base)
 {
@@ -1334,7 +1462,6 @@ gst_rtp_bin_associate (GstRtpBin * bin, GstRtpBinStream * stream, guint8 len,
   gboolean created;
   GSList *walk;
   GstClockTime running_time, running_time_rtp;
-  guint64 ntpnstime;
 
   /* first find or create the CNAME */
   client = get_client (bin, len, data, &created);
@@ -1392,10 +1519,6 @@ gst_rtp_bin_associate (GstRtpBin * bin, GstRtpBinStream * stream, guint8 len,
       gst_util_uint64_scale_int (running_time_rtp, GST_SECOND, clock_rate);
   running_time += base_time;
 
-  /* convert ntptime to nanoseconds */
-  ntpnstime = gst_util_uint64_scale (ntptime, GST_SECOND,
-      (G_GINT64_CONSTANT (1) << 32));
-
   stream->have_sync = TRUE;
 
   GST_DEBUG_OBJECT (bin,
@@ -1437,7 +1560,7 @@ gst_rtp_bin_associate (GstRtpBin * bin, GstRtpBinStream * stream, guint8 len,
     stream->rt_delta = rtdiff - ntpdiff;
 
     stream_set_ts_offset (bin, stream, stream->rt_delta, bin->max_ts_offset,
-        0, FALSE);
+        bin->min_ts_offset, FALSE);
   } else {
     gint64 min, rtp_min, clock_base = stream->clock_base;
     gboolean all_sync, use_rtp;
@@ -1590,7 +1713,7 @@ gst_rtp_bin_associate (GstRtpBin * bin, GstRtpBinStream * stream, guint8 len,
         ts_offset = ostream->rt_delta - min;
 
       stream_set_ts_offset (bin, ostream, ts_offset, bin->max_ts_offset,
-          MIN_TS_OFFSET, TRUE);
+          bin->min_ts_offset, TRUE);
     }
   }
   gst_rtp_bin_send_sync_event (stream);
@@ -1617,15 +1740,16 @@ gst_rtp_bin_handle_sync (GstElement * jitterbuffer, GstStructure * s,
   GstRtpBin *bin;
   GstRTCPPacket packet;
   guint32 ssrc;
-  guint64 ntptime;
-  gboolean have_sr, have_sdes;
+  guint64 ntpnstime, inband_ntpnstime;
+  gboolean have_sr;
   gboolean more;
   guint64 base_rtptime;
   guint64 base_time;
   guint clock_rate;
   guint64 clock_base;
-  guint64 extrtptime;
+  guint64 extrtptime, inband_ext_rtptime;
   GstBuffer *buffer;
+  const gchar *cname;
   GstRTCPBuffer rtcp = { NULL, };
 
   bin = stream->bin;
@@ -1636,17 +1760,59 @@ gst_rtp_bin_handle_sync (GstElement * jitterbuffer, GstStructure * s,
    * timestamps. We get this info directly from the jitterbuffer which
    * constructs gstreamer timestamps from rtp timestamps and so it know exactly
    * what the current situation is. */
-  base_rtptime =
-      g_value_get_uint64 (gst_structure_get_value (s, "base-rtptime"));
-  base_time = g_value_get_uint64 (gst_structure_get_value (s, "base-time"));
-  clock_rate = g_value_get_uint (gst_structure_get_value (s, "clock-rate"));
-  clock_base = g_value_get_uint64 (gst_structure_get_value (s, "clock-base"));
-  extrtptime =
-      g_value_get_uint64 (gst_structure_get_value (s, "sr-ext-rtptime"));
+  if (!gst_structure_get_uint64 (s, "base-rtptime", &base_rtptime) ||
+      !gst_structure_get_uint64 (s, "base-time", &base_time) ||
+      !gst_structure_get_uint (s, "clock-rate", &clock_rate) ||
+      !gst_structure_get_uint64 (s, "clock-base", &clock_base)) {
+    /* invalid structure */
+    return;
+  }
+
+  cname = gst_structure_get_string (s, "cname");
+
+  /* if the jitterbuffer directly got the NTP timestamp then don't work
+   * through the RTCP SR, otherwise extract it from there */
+  if (gst_structure_get_uint64 (s, "inband-ntpnstime", &inband_ntpnstime)
+      && gst_structure_get_uint64 (s, "inband-ext-rtptime", &inband_ext_rtptime)
+      && (cname = gst_structure_get_string (s, "cname"))
+      && gst_structure_get_uint (s, "ssrc", &ssrc)) {
+    GST_DEBUG_OBJECT (bin,
+        "handle sync from inband NTP-64 information for SSRC %08x", ssrc);
+
+    if (ssrc != stream->ssrc)
+      return;
+
+    GST_RTP_BIN_LOCK (bin);
+    gst_rtp_bin_associate (bin, stream, strlen (cname), (const guint8 *) cname,
+        inband_ntpnstime, inband_ext_rtptime, base_rtptime, base_time,
+        clock_rate, clock_base);
+    GST_RTP_BIN_UNLOCK (bin);
+    return;
+  }
+
+  if (!gst_structure_get_uint64 (s, "sr-ext-rtptime", &extrtptime)
+      || !gst_structure_has_field_typed (s, "sr-buffer", GST_TYPE_BUFFER)) {
+    /* invalid structure */
+    return;
+  }
+
+  GST_DEBUG_OBJECT (bin, "handle sync from RTCP SR information");
+
+  /* get RTCP SR ntpnstime if available */
+  if (gst_structure_get_uint64 (s, "sr-ntpnstime", &ntpnstime) && cname) {
+    GST_RTP_BIN_LOCK (bin);
+    /* associate the stream to CNAME */
+    gst_rtp_bin_associate (bin, stream, strlen (cname),
+        (const guint8 *) cname, ntpnstime, extrtptime, base_rtptime,
+        base_time, clock_rate, clock_base);
+    GST_RTP_BIN_UNLOCK (bin);
+    return;
+  }
+
+  /* otherwise parse the RTCP packet */
   buffer = gst_value_get_buffer (gst_structure_get_value (s, "sr-buffer"));
 
   have_sr = FALSE;
-  have_sdes = FALSE;
 
   gst_rtcp_buffer_map (buffer, GST_MAP_READ, &rtcp);
 
@@ -1655,31 +1821,51 @@ gst_rtp_bin_handle_sync (GstElement * jitterbuffer, GstStructure * s,
     switch (gst_rtcp_packet_get_type (&packet)) {
       case GST_RTCP_TYPE_SR:
         /* only parse first. There is only supposed to be one SR in the packet
-         * but we will deal with malformed packets gracefully */
+         * but we will deal with malformed packets gracefully by trying the
+         * next RTCP packet. */
         if (have_sr)
-          break;
-        /* get NTP and RTP times */
-        gst_rtcp_packet_sr_get_sender_info (&packet, &ssrc, &ntptime, NULL,
+          continue;
+
+        /* get NTP time */
+        gst_rtcp_packet_sr_get_sender_info (&packet, &ssrc, &ntpnstime, NULL,
             NULL, NULL);
 
+        /* convert ntptime to nanoseconds */
+        ntpnstime = gst_util_uint64_scale (ntpnstime, GST_SECOND,
+            (G_GINT64_CONSTANT (1) << 32));
+
         GST_DEBUG_OBJECT (bin, "received sync packet from SSRC %08x", ssrc);
-        /* ignore SR that is not ours */
+
+        /* ignore SR that is not ours and check the next RTCP packet */
         if (ssrc != stream->ssrc)
           continue;
 
         have_sr = TRUE;
+
+        /* If we already have the CNAME don't require parsing SDES */
+        if (cname) {
+          GST_RTP_BIN_LOCK (bin);
+          /* associate the stream to CNAME */
+          gst_rtp_bin_associate (bin, stream, strlen (cname),
+              (const guint8 *) cname, ntpnstime, extrtptime, base_rtptime,
+              base_time, clock_rate, clock_base);
+          GST_RTP_BIN_UNLOCK (bin);
+
+          goto out;
+        }
+
         break;
       case GST_RTCP_TYPE_SDES:
       {
-        gboolean more_items, more_entries;
+        gboolean more_items;
 
-        /* only deal with first SDES, there is only supposed to be one SDES in
-         * the RTCP packet but we deal with bad packets gracefully. Also bail
-         * out if we have not seen an SR item yet. */
-        if (have_sdes || !have_sr)
-          break;
+        /* Bail out if we have not seen an SR item yet. */
+        if (!have_sr)
+          goto out;
 
         GST_RTCP_SDES_FOR_ITEMS (more_items, &packet) {
+          gboolean more_entries;
+
           /* skip items that are not about the SSRC of the sender */
           if (gst_rtcp_packet_sdes_get_ssrc (&packet) != ssrc)
             continue;
@@ -1688,28 +1874,34 @@ gst_rtp_bin_handle_sync (GstElement * jitterbuffer, GstStructure * s,
           GST_RTCP_SDES_FOR_ENTRIES (more_entries, &packet) {
             GstRTCPSDESType type;
             guint8 len;
-            guint8 *data;
+            const guint8 *data;
 
-            gst_rtcp_packet_sdes_get_entry (&packet, &type, &len, &data);
+            gst_rtcp_packet_sdes_get_entry (&packet, &type, &len,
+                (guint8 **) & data);
 
             if (type == GST_RTCP_SDES_CNAME) {
               GST_RTP_BIN_LOCK (bin);
               /* associate the stream to CNAME */
               gst_rtp_bin_associate (bin, stream, len, data,
-                  ntptime, extrtptime, base_rtptime, base_time, clock_rate,
+                  ntpnstime, extrtptime, base_rtptime, base_time, clock_rate,
                   clock_base);
               GST_RTP_BIN_UNLOCK (bin);
+
+              goto out;
             }
           }
         }
-        have_sdes = TRUE;
-        break;
+
+        /* only deal with first SDES, there is only supposed to be one SDES in
+         * the RTCP packet but we deal with bad packets gracefully. */
+        goto out;
       }
       default:
         /* we can ignore these packets */
         break;
     }
   }
+out:
   gst_rtcp_buffer_unmap (&rtcp);
 }
 
@@ -1747,6 +1939,8 @@ create_stream (GstRtpBinSession * session, guint32 ssrc)
 
   stream->have_sync = FALSE;
   stream->rt_delta = 0;
+  stream->avg_ts_offset = 0;
+  stream->is_initialized = FALSE;
   stream->rtp_delta = 0;
   stream->percent = 100;
   stream->clock_base = -100 * GST_SECOND;
@@ -1787,9 +1981,14 @@ create_stream (GstRtpBinSession * session, guint32 ssrc)
     g_object_set (buffer, "max-misorder-time", rtpbin->max_misorder_time, NULL);
   if (g_object_class_find_property (jb_class, "rfc7273-sync"))
     g_object_set (buffer, "rfc7273-sync", rtpbin->rfc7273_sync, NULL);
+  if (g_object_class_find_property (jb_class, "add-reference-timestamp-meta"))
+    g_object_set (buffer, "add-reference-timestamp-meta",
+        rtpbin->add_reference_timestamp_meta, NULL);
   if (g_object_class_find_property (jb_class, "max-ts-offset-adjustment"))
     g_object_set (buffer, "max-ts-offset-adjustment",
         rtpbin->max_ts_offset_adjustment, NULL);
+  if (g_object_class_find_property (jb_class, "sync-interval"))
+    g_object_set (buffer, "sync-interval", rtpbin->rtcp_sync_interval, NULL);
 
   g_signal_emit (rtpbin, gst_rtp_bin_signals[SIGNAL_NEW_JITTERBUFFER], 0,
       buffer, session->id, ssrc);
@@ -1928,6 +2127,7 @@ static void gst_rtp_bin_handle_message (GstBin * bin, GstMessage * message);
 
 #define gst_rtp_bin_parent_class parent_class
 G_DEFINE_TYPE_WITH_PRIVATE (GstRtpBin, gst_rtp_bin, GST_TYPE_BIN);
+GST_ELEMENT_REGISTER_DEFINE (rtpbin, "rtpbin", GST_RANK_NONE, GST_TYPE_RTP_BIN);
 
 static gboolean
 _gst_element_accumulator (GSignalInvocationHint * ihint,
@@ -1938,8 +2138,7 @@ _gst_element_accumulator (GSignalInvocationHint * ihint,
   element = g_value_get_object (handler_return);
   GST_DEBUG ("got element %" GST_PTR_FORMAT, element);
 
-  if (!(ihint->run_type & G_SIGNAL_RUN_CLEANUP))
-    g_value_set_object (return_accu, element);
+  g_value_set_object (return_accu, element);
 
   /* stop emission if we have an element */
   return (element == NULL);
@@ -1954,8 +2153,7 @@ _gst_caps_accumulator (GSignalInvocationHint * ihint,
   caps = g_value_get_boxed (handler_return);
   GST_DEBUG ("got caps %" GST_PTR_FORMAT, caps);
 
-  if (!(ihint->run_type & G_SIGNAL_RUN_CLEANUP))
-    g_value_set_boxed (return_accu, caps);
+  g_value_set_boxed (return_accu, caps);
 
   /* stop emission if we have a caps */
   return (caps == NULL);
@@ -2099,6 +2297,24 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstRtpBinClass,
           get_storage), NULL, NULL, NULL, GST_TYPE_ELEMENT, 1, G_TYPE_UINT);
 
+  /**
+   * GstRtpBin::clear-ssrc:
+   * @rtpbin: the object which received the signal
+   * @id: the session id
+   * @ssrc: the ssrc
+   *
+   * Remove all pads from rtpssrcdemux element associated with the specified
+   * ssrc. This delegate the action signal to the rtpssrcdemux element
+   * associated with the specified session.
+   *
+   * Since: 1.20
+   */
+  gst_rtp_bin_signals[SIGNAL_CLEAR_SSRC] =
+      g_signal_new ("clear-ssrc", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstRtpBinClass,
+          clear_ssrc), NULL, NULL, NULL, G_TYPE_NONE, 2,
+      G_TYPE_UINT, G_TYPE_UINT);
+
   /**
    * GstRtpBin::on-new-ssrc:
    * @rtpbin: the object which received the signal
@@ -2399,10 +2615,15 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
    * @session: the session index
    *
    * Request a FEC decoder element for the given @session. The element
-   * will be added to the bin after the pt demuxer.
+   * will be added to the bin after the pt demuxer.  If there are multiple
+   * ssrc's and pt's in @session, this signal may be called multiple times for
+   * the same @session each corresponding to a newly discovered ssrc.
    *
    * If no handler is connected, no FEC decoder will be used.
    *
+   * Warning: usage of this signal is not appropriate for the BUNDLE case,
+   * connect to #GstRtpBin::request-fec-decoder-full instead.
+   *
    * Since: 1.14
    */
   gst_rtp_bin_signals[SIGNAL_REQUEST_FEC_DECODER] =
@@ -2411,6 +2632,29 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
           request_fec_decoder), _gst_element_accumulator, NULL, NULL,
       GST_TYPE_ELEMENT, 1, G_TYPE_UINT);
 
+  /**
+   * GstRtpBin::request-fec-decoder-full:
+   * @rtpbin: the object which received the signal
+   * @session: the session index
+   * @ssrc: the ssrc of the stream
+   * @pt: the payload type
+   *
+   * Request a FEC decoder element for the given @session. The element
+   * will be added to the bin after the pt demuxer.  If there are multiple
+   * ssrc's and pt's in @session, this signal may be called multiple times for
+   * the same @session each corresponding to a newly discovered ssrc and payload
+   * type, those are provided as parameters.
+   *
+   * If no handler is connected, no FEC decoder will be used.
+   *
+   * Since: 1.20
+   */
+  gst_rtp_bin_signals[SIGNAL_REQUEST_FEC_DECODER_FULL] =
+      g_signal_new ("request-fec-decoder-full", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstRtpBinClass,
+          request_fec_decoder), _gst_element_accumulator, NULL, NULL,
+      GST_TYPE_ELEMENT, 3, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_UINT);
+
   /**
    * GstRtpBin::request-fec-encoder:
    * @rtpbin: the object which received the signal
@@ -2523,11 +2767,12 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
   /**
    * GstRtpBin:rtcp-sync-interval:
    *
-   * Determines how often to sync streams using RTCP data.
+   * Determines how often to sync streams using RTCP data or inband NTP-64
+   * header extensions.
    */
   g_object_class_install_property (gobject_class, PROP_RTCP_SYNC_INTERVAL,
       g_param_spec_uint ("rtcp-sync-interval", "RTCP Sync Interval",
-          "RTCP SR interval synchronization (ms) (0 = always)",
+          "RTCP SR / NTP-64 interval synchronization (ms) (0 = always)",
           0, G_MAXUINT, DEFAULT_RTCP_SYNC_INTERVAL,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
@@ -2600,6 +2845,25 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
           "(requires clock and offset to be provided)", DEFAULT_RFC7273_SYNC,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRtpBin:add-reference-timestamp-meta:
+   *
+   * When syncing to a RFC7273 clock or after clock synchronization via RTCP or
+   * inband NTP-64 header extensions has happened, add #GstReferenceTimestampMeta
+   * to buffers with the original reconstructed reference clock timestamp.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_ADD_REFERENCE_TIMESTAMP_META,
+      g_param_spec_boolean ("add-reference-timestamp-meta",
+          "Add Reference Timestamp Meta",
+          "Add Reference Timestamp Meta to buffers with the original clock timestamp "
+          "before any adjustments when syncing to an RFC7273 clock or after clock "
+          "synchronization via RTCP or inband NTP-64 header extensions has happened.",
+          DEFAULT_ADD_REFERENCE_TIMESTAMP_META,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   g_object_class_install_property (gobject_class, PROP_MAX_STREAMS,
       g_param_spec_uint ("max-streams", "Max Streams",
           "The maximum number of streams to create for one session",
@@ -2640,6 +2904,104 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
           "changed to 0 (no limit)", 0, G_MAXINT64, DEFAULT_MAX_TS_OFFSET,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRtpBin:min-ts-offset:
+   *
+   * Used to set an lower limit for when a time offset is deemed large enough
+   * to be useful for sync corrections.
+   *
+   * When streaming for instance audio, even very small ts_offsets cause
+   * audible glitches. This property is used for controlling how sensitive the
+   * adjustments should be to small deviations in ts_offset, occurring for
+   * instance due to jittery network conditions or system load.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_MIN_TS_OFFSET,
+      g_param_spec_uint64 ("min-ts-offset", "Min TS Offset",
+          "The minimum absolute value of the time offset in (nanoseconds). "
+          "Used to set an lower limit for when a time offset is deemed large "
+          "enough to be useful for sync corrections."
+          "Note, if the ntp-sync parameter is set the default value is "
+          "changed to 0 (no limit)", 0, G_MAXUINT64, DEFAULT_MIN_TS_OFFSET,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRtpBin:ts-offset-smoothing-factor:
+   *
+   * Controls the weighting between previous and current timestamp offsets in
+   * a running moving average (RMA):
+   * ts_offset_average(n) =
+   *   ((ts-offset-smoothing-factor - 1) * ts_offset_average(n - 1) + ts_offset(n)) /
+   *   ts-offset-smoothing-factor
+   *
+   * This can stabilize the timestamp offset and prevent unnecessary skew
+   * corrections due to jitter introduced by network or system load.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_TS_OFFSET_SMOOTHING_FACTOR,
+      g_param_spec_uint ("ts-offset-smoothing-factor",
+          "Timestamp Offset Smoothing Factor",
+          "Sets a smoothing factor for the timestamp offset in number of "
+          "values for a calculated running moving average. "
+          "(0 = no smoothing factor)", 0, G_MAXUINT,
+          DEFAULT_TS_OFFSET_SMOOTHING_FACTOR,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRtpBin:fec-decoders:
+   *
+   * Used to provide a factory used to build the FEC decoder for a
+   * given session, as a command line alternative to
+   * #GstRtpBin::request-fec-decoder.
+   *
+   * Expects a GstStructure in the form session_id (gint) -> factory (string)
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_FEC_DECODERS,
+      g_param_spec_boxed ("fec-decoders", "Fec Decoders",
+          "GstStructure mapping from session index to FEC decoder "
+          "factory, eg "
+          "fec-decoders='fec,0=\"rtpst2022-1-fecdec\\ size-time\\=1000000000\";'",
+          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRtpBin:fec-encoders:
+   *
+   * Used to provide a factory used to build the FEC encoder for a
+   * given session, as a command line alternative to
+   * #GstRtpBin::request-fec-encoder.
+   *
+   * Expects a GstStructure in the form session_id (gint) -> factory (string)
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_FEC_ENCODERS,
+      g_param_spec_boxed ("fec-encoders", "Fec Encoders",
+          "GstStructure mapping from session index to FEC encoder "
+          "factory, eg "
+          "fec-encoders='fec,0=\"rtpst2022-1-fecenc\\ rows\\=5\\ columns\\=5\";'",
+          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * GstRtpBin:update-ntp64-header-ext:
+   *
+   * Whether RTP NTP header extension should be updated with actual
+   * NTP time. If not, use the NTP time from buffer timestamp metadata
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_UPDATE_NTP64_HEADER_EXT,
+      g_param_spec_boolean ("update-ntp64-header-ext",
+          "Update NTP-64 RTP Header Extension",
+          "Whether RTP NTP header extension should be updated with actual NTP time",
+          DEFAULT_UPDATE_NTP64_HEADER_EXT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   gstelement_class->change_state = GST_DEBUG_FUNCPTR (gst_rtp_bin_change_state);
   gstelement_class->request_new_pad =
       GST_DEBUG_FUNCPTR (gst_rtp_bin_request_new_pad);
@@ -2648,6 +3010,8 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
   /* sink pads */
   gst_element_class_add_static_pad_template (gstelement_class,
       &rtpbin_recv_rtp_sink_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &rtpbin_recv_fec_sink_template);
   gst_element_class_add_static_pad_template (gstelement_class,
       &rtpbin_recv_rtcp_sink_template);
   gst_element_class_add_static_pad_template (gstelement_class,
@@ -2660,6 +3024,8 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
       &rtpbin_send_rtcp_src_template);
   gst_element_class_add_static_pad_template (gstelement_class,
       &rtpbin_send_rtp_src_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &rtpbin_send_fec_src_template);
 
   gst_element_class_set_static_metadata (gstelement_class, "RTP Bin",
       "Filter/Network/RTP",
@@ -2676,6 +3042,7 @@ gst_rtp_bin_class_init (GstRtpBinClass * klass)
   klass->get_storage = GST_DEBUG_FUNCPTR (gst_rtp_bin_get_storage);
   klass->get_internal_storage =
       GST_DEBUG_FUNCPTR (gst_rtp_bin_get_internal_storage);
+  klass->clear_ssrc = GST_DEBUG_FUNCPTR (gst_rtp_bin_clear_ssrc);
   klass->request_rtp_encoder = GST_DEBUG_FUNCPTR (gst_rtp_bin_request_encoder);
   klass->request_rtp_decoder = GST_DEBUG_FUNCPTR (gst_rtp_bin_request_decoder);
   klass->request_rtcp_encoder = GST_DEBUG_FUNCPTR (gst_rtp_bin_request_encoder);
@@ -2717,15 +3084,24 @@ gst_rtp_bin_init (GstRtpBin * rtpbin)
   rtpbin->max_dropout_time = DEFAULT_MAX_DROPOUT_TIME;
   rtpbin->max_misorder_time = DEFAULT_MAX_MISORDER_TIME;
   rtpbin->rfc7273_sync = DEFAULT_RFC7273_SYNC;
+  rtpbin->add_reference_timestamp_meta = DEFAULT_ADD_REFERENCE_TIMESTAMP_META;
   rtpbin->max_streams = DEFAULT_MAX_STREAMS;
   rtpbin->max_ts_offset_adjustment = DEFAULT_MAX_TS_OFFSET_ADJUSTMENT;
   rtpbin->max_ts_offset = DEFAULT_MAX_TS_OFFSET;
   rtpbin->max_ts_offset_is_set = FALSE;
+  rtpbin->min_ts_offset = DEFAULT_MIN_TS_OFFSET;
+  rtpbin->min_ts_offset_is_set = FALSE;
+  rtpbin->ts_offset_smoothing_factor = DEFAULT_TS_OFFSET_SMOOTHING_FACTOR;
+  rtpbin->update_ntp64_header_ext = DEFAULT_UPDATE_NTP64_HEADER_EXT;
 
   /* some default SDES entries */
   cname = g_strdup_printf ("user%u@host-%x", g_random_int (), g_random_int ());
   rtpbin->sdes = gst_structure_new ("application/x-rtp-source-sdes",
       "cname", G_TYPE_STRING, cname, "tool", G_TYPE_STRING, "GStreamer", NULL);
+  rtpbin->fec_decoders =
+      gst_structure_new_empty ("application/x-rtp-fec-decoders");
+  rtpbin->fec_encoders =
+      gst_structure_new_empty ("application/x-rtp-fec-encoders");
   g_free (cname);
 }
 
@@ -2756,6 +3132,12 @@ gst_rtp_bin_finalize (GObject * object)
   if (rtpbin->sdes)
     gst_structure_free (rtpbin->sdes);
 
+  if (rtpbin->fec_decoders)
+    gst_structure_free (rtpbin->fec_decoders);
+
+  if (rtpbin->fec_encoders)
+    gst_structure_free (rtpbin->fec_encoders);
+
   g_mutex_clear (&rtpbin->priv->bin_lock);
   g_mutex_clear (&rtpbin->priv->dyn_lock);
 
@@ -2788,6 +3170,44 @@ gst_rtp_bin_set_sdes_struct (GstRtpBin * bin, const GstStructure * sdes)
   GST_RTP_BIN_UNLOCK (bin);
 }
 
+static void
+gst_rtp_bin_set_fec_decoders_struct (GstRtpBin * bin,
+    const GstStructure * decoders)
+{
+  if (decoders == NULL)
+    return;
+
+  GST_RTP_BIN_LOCK (bin);
+
+  GST_OBJECT_LOCK (bin);
+  if (bin->fec_decoders)
+    gst_structure_free (bin->fec_decoders);
+  bin->fec_decoders = gst_structure_copy (decoders);
+
+  GST_OBJECT_UNLOCK (bin);
+
+  GST_RTP_BIN_UNLOCK (bin);
+}
+
+static void
+gst_rtp_bin_set_fec_encoders_struct (GstRtpBin * bin,
+    const GstStructure * encoders)
+{
+  if (encoders == NULL)
+    return;
+
+  GST_RTP_BIN_LOCK (bin);
+
+  GST_OBJECT_LOCK (bin);
+  if (bin->fec_encoders)
+    gst_structure_free (bin->fec_encoders);
+  bin->fec_encoders = gst_structure_copy (encoders);
+
+  GST_OBJECT_UNLOCK (bin);
+
+  GST_RTP_BIN_UNLOCK (bin);
+}
+
 static GstStructure *
 gst_rtp_bin_get_sdes_struct (GstRtpBin * bin)
 {
@@ -2800,6 +3220,30 @@ gst_rtp_bin_get_sdes_struct (GstRtpBin * bin)
   return result;
 }
 
+static GstStructure *
+gst_rtp_bin_get_fec_decoders_struct (GstRtpBin * bin)
+{
+  GstStructure *result;
+
+  GST_OBJECT_LOCK (bin);
+  result = gst_structure_copy (bin->fec_decoders);
+  GST_OBJECT_UNLOCK (bin);
+
+  return result;
+}
+
+static GstStructure *
+gst_rtp_bin_get_fec_encoders_struct (GstRtpBin * bin)
+{
+  GstStructure *result;
+
+  GST_OBJECT_LOCK (bin);
+  result = gst_structure_copy (bin->fec_encoders);
+  GST_OBJECT_UNLOCK (bin);
+
+  return result;
+}
+
 static void
 gst_rtp_bin_set_property (GObject * object, guint prop_id,
     const GValue * value, GParamSpec * pspec)
@@ -2845,6 +3289,13 @@ gst_rtp_bin_set_property (GObject * object, guint prop_id,
           rtpbin->max_ts_offset = DEFAULT_MAX_TS_OFFSET;
         }
       }
+      if (!rtpbin->min_ts_offset_is_set) {
+        if (rtpbin->ntp_sync) {
+          rtpbin->min_ts_offset = 0;
+        } else {
+          rtpbin->min_ts_offset = DEFAULT_MIN_TS_OFFSET;
+        }
+      }
       break;
     case PROP_RTCP_SYNC:
       g_atomic_int_set (&rtpbin->rtcp_sync, g_value_get_enum (value));
@@ -2951,6 +3402,11 @@ gst_rtp_bin_set_property (GObject * object, guint prop_id,
       gst_rtp_bin_propagate_property_to_jitterbuffer (rtpbin,
           "rfc7273-sync", value);
       break;
+    case PROP_ADD_REFERENCE_TIMESTAMP_META:
+      rtpbin->add_reference_timestamp_meta = g_value_get_boolean (value);
+      gst_rtp_bin_propagate_property_to_jitterbuffer (rtpbin,
+          "add-reference-timestamp-meta", value);
+      break;
     case PROP_MAX_STREAMS:
       rtpbin->max_streams = g_value_get_uint (value);
       break;
@@ -2963,6 +3419,26 @@ gst_rtp_bin_set_property (GObject * object, guint prop_id,
       rtpbin->max_ts_offset = g_value_get_int64 (value);
       rtpbin->max_ts_offset_is_set = TRUE;
       break;
+    case PROP_MIN_TS_OFFSET:
+      rtpbin->min_ts_offset = g_value_get_uint64 (value);
+      rtpbin->min_ts_offset_is_set = TRUE;
+      break;
+    case PROP_TS_OFFSET_SMOOTHING_FACTOR:
+      rtpbin->ts_offset_smoothing_factor = g_value_get_uint (value);
+      break;
+    case PROP_FEC_DECODERS:
+      gst_rtp_bin_set_fec_decoders_struct (rtpbin, g_value_get_boxed (value));
+      break;
+    case PROP_FEC_ENCODERS:
+      gst_rtp_bin_set_fec_encoders_struct (rtpbin, g_value_get_boxed (value));
+      break;
+    case PROP_UPDATE_NTP64_HEADER_EXT:
+      GST_RTP_BIN_LOCK (rtpbin);
+      rtpbin->update_ntp64_header_ext = g_value_get_boolean (value);
+      GST_RTP_BIN_UNLOCK (rtpbin);
+      gst_rtp_bin_propagate_property_to_session (rtpbin,
+          "update-ntp64-header-ext", value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3048,6 +3524,9 @@ gst_rtp_bin_get_property (GObject * object, guint prop_id,
     case PROP_RFC7273_SYNC:
       g_value_set_boolean (value, rtpbin->rfc7273_sync);
       break;
+    case PROP_ADD_REFERENCE_TIMESTAMP_META:
+      g_value_set_boolean (value, rtpbin->add_reference_timestamp_meta);
+      break;
     case PROP_MAX_STREAMS:
       g_value_set_uint (value, rtpbin->max_streams);
       break;
@@ -3057,6 +3536,21 @@ gst_rtp_bin_get_property (GObject * object, guint prop_id,
     case PROP_MAX_TS_OFFSET:
       g_value_set_int64 (value, rtpbin->max_ts_offset);
       break;
+    case PROP_MIN_TS_OFFSET:
+      g_value_set_uint64 (value, rtpbin->min_ts_offset);
+      break;
+    case PROP_TS_OFFSET_SMOOTHING_FACTOR:
+      g_value_set_uint (value, rtpbin->ts_offset_smoothing_factor);
+      break;
+    case PROP_FEC_DECODERS:
+      g_value_take_boxed (value, gst_rtp_bin_get_fec_decoders_struct (rtpbin));
+      break;
+    case PROP_FEC_ENCODERS:
+      g_value_take_boxed (value, gst_rtp_bin_get_fec_encoders_struct (rtpbin));
+      break;
+    case PROP_UPDATE_NTP64_HEADER_EXT:
+      g_value_set_boolean (value, rtpbin->update_ntp64_header_ext);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -3308,6 +3802,32 @@ gst_rtp_bin_change_state (GstElement * element, GstStateChange transition)
   return res;
 }
 
+static GstElement *
+session_request_element_full (GstRtpBinSession * session, guint signal,
+    guint ssrc, guint8 pt)
+{
+  GstElement *element = NULL;
+  GstRtpBin *bin = session->bin;
+
+  g_signal_emit (bin, gst_rtp_bin_signals[signal], 0, session->id, ssrc, pt,
+      &element);
+
+  if (element) {
+    if (!bin_manage_element (bin, element))
+      goto manage_failed;
+    session->elements = g_slist_prepend (session->elements, element);
+  }
+  return element;
+
+  /* ERRORS */
+manage_failed:
+  {
+    GST_WARNING_OBJECT (bin, "unable to manage element");
+    gst_object_unref (element);
+    return NULL;
+  }
+}
+
 static GstElement *
 session_request_element (GstRtpBinSession * session, guint signal)
 {
@@ -3343,6 +3863,46 @@ copy_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
   return TRUE;
 }
 
+static gboolean
+ensure_early_fec_decoder (GstRtpBin * rtpbin, GstRtpBinSession * session)
+{
+  const gchar *factory;
+  gchar *sess_id_str;
+
+  if (session->early_fec_decoder)
+    goto done;
+
+  sess_id_str = g_strdup_printf ("%u", session->id);
+  factory = gst_structure_get_string (rtpbin->fec_decoders, sess_id_str);
+  g_free (sess_id_str);
+
+  /* First try the property */
+  if (factory) {
+    GError *err = NULL;
+
+    session->early_fec_decoder =
+        gst_parse_bin_from_description_full (factory, TRUE, NULL,
+        GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS | GST_PARSE_FLAG_FATAL_ERRORS,
+        &err);
+    if (!session->early_fec_decoder) {
+      GST_ERROR_OBJECT (rtpbin, "Failed to build decoder from factory: %s",
+          err->message);
+    }
+
+    bin_manage_element (session->bin, session->early_fec_decoder);
+    session->elements =
+        g_slist_prepend (session->elements, session->early_fec_decoder);
+    GST_INFO_OBJECT (rtpbin, "Built FEC decoder: %" GST_PTR_FORMAT
+        " for session %u", session->early_fec_decoder, session->id);
+  }
+
+  /* Do not fallback to the signal as the signal expects a fec decoder to
+   * be placed at a different place in the pipeline */
+
+done:
+  return session->early_fec_decoder != NULL;
+}
+
 static void
 expose_recv_src_pad (GstRtpBin * rtpbin, GstPad * pad, GstRtpBinStream * stream,
     guint8 pt)
@@ -3355,9 +3915,19 @@ expose_recv_src_pad (GstRtpBin * rtpbin, GstPad * pad, GstRtpBinStream * stream,
   gst_object_ref (pad);
 
   if (stream->session->storage) {
+    /* First try the legacy signal, with no ssrc and pt as parameters.
+     * This will likely cause issues for the BUNDLE case. */
     GstElement *fec_decoder =
         session_request_element (stream->session, SIGNAL_REQUEST_FEC_DECODER);
 
+    /* Now try the new signal, where the application can provide a FEC
+     * decoder according to ssrc and pt. */
+    if (!fec_decoder) {
+      fec_decoder =
+          session_request_element_full (stream->session,
+          SIGNAL_REQUEST_FEC_DECODER_FULL, stream->ssrc, pt);
+    }
+
     if (fec_decoder) {
       GstPad *sinkpad, *srcpad;
       GstPadLinkReturn ret;
@@ -3594,12 +4164,22 @@ new_ssrc_pad_found (GstElement * element, guint ssrc, GstPad * pad,
   padname = g_strdup_printf ("src_%u", ssrc);
   srcpad = gst_element_get_static_pad (element, padname);
   g_free (padname);
+
+  if (session->early_fec_decoder) {
+    GST_DEBUG_OBJECT (rtpbin, "linking fec decoder");
+    sinkpad = gst_element_get_static_pad (session->early_fec_decoder, "sink");
+    gst_pad_link_full (srcpad, sinkpad, GST_PAD_LINK_CHECK_NOTHING);
+    gst_object_unref (sinkpad);
+    gst_object_unref (srcpad);
+    srcpad = gst_element_get_static_pad (session->early_fec_decoder, "src");
+  }
+
   sinkpad = gst_element_get_static_pad (stream->buffer, "sink");
   gst_pad_link_full (srcpad, sinkpad, GST_PAD_LINK_CHECK_NOTHING);
   gst_object_unref (sinkpad);
   gst_object_unref (srcpad);
 
-  sinkpad = gst_element_get_request_pad (stream->buffer, "sink_rtcp");
+  sinkpad = gst_element_request_pad_simple (stream->buffer, "sink_rtcp");
   if (sinkpad) {
     GST_DEBUG_OBJECT (rtpbin, "linking jitterbuffer RTCP");
     padname = g_strdup_printf ("rtcp_src_%u", ssrc);
@@ -3678,7 +4258,7 @@ complete_session_sink (GstRtpBin * rtpbin, GstRtpBinSession * session)
 
   /* get recv_rtp pad and store */
   session->recv_rtp_sink =
-      gst_element_get_request_pad (session->session, "recv_rtp_sink");
+      gst_element_request_pad_simple (session->session, "recv_rtp_sink");
   if (session->recv_rtp_sink == NULL)
     goto pad_failed;
 
@@ -3879,8 +4459,6 @@ create_recv_rtp (GstRtpBin * rtpbin, GstPadTemplate * templ, const gchar * name)
   session->recv_rtp_sink_ghost =
       gst_ghost_pad_new_from_template (name, recv_rtp_sink, templ);
   gst_object_unref (recv_rtp_sink);
-  gst_pad_set_active (session->recv_rtp_sink_ghost, TRUE);
-  gst_element_add_pad (GST_ELEMENT_CAST (rtpbin), session->recv_rtp_sink_ghost);
 
   complete_session_receiver (rtpbin, session, sessid);
 
@@ -3933,6 +4511,68 @@ remove_recv_rtp (GstRtpBin * rtpbin, GstRtpBinSession * session)
   }
 }
 
+static gint
+fec_sinkpad_find (const GValue * item, gchar * padname)
+{
+  GstPad *pad = g_value_get_object (item);
+  return g_strcmp0 (GST_PAD_NAME (pad), padname);
+}
+
+static GstPad *
+complete_session_fec (GstRtpBin * rtpbin, GstRtpBinSession * session,
+    guint fec_idx)
+{
+  gboolean have_static_pad;
+  gchar *padname;
+
+  GstPad *ret;
+  GstIterator *it;
+  GValue item = { 0, };
+
+  if (!ensure_early_fec_decoder (rtpbin, session))
+    goto no_decoder;
+
+  padname = g_strdup_printf ("fec_%u", fec_idx);
+
+  GST_DEBUG_OBJECT (rtpbin, "getting FEC sink pad %s", padname);
+
+  /* First try to find the decoder static pad that matches the padname */
+  it = gst_element_iterate_sink_pads (session->early_fec_decoder);
+  have_static_pad =
+      gst_iterator_find_custom (it, (GCompareFunc) fec_sinkpad_find, &item,
+      padname);
+
+  if (have_static_pad) {
+    ret = g_value_get_object (&item);
+    gst_object_ref (ret);
+    g_value_unset (&item);
+  } else {
+    ret = gst_element_request_pad_simple (session->early_fec_decoder, padname);
+  }
+
+  g_free (padname);
+  gst_iterator_free (it);
+
+  if (ret == NULL)
+    goto pad_failed;
+
+  session->recv_fec_sinks = g_slist_prepend (session->recv_fec_sinks, ret);
+
+  return ret;
+
+pad_failed:
+  {
+    g_warning ("rtpbin: failed to get decoder fec pad");
+    return NULL;
+  }
+no_decoder:
+  {
+    g_warning ("rtpbin: failed to build FEC decoder for session %u",
+        session->id);
+    return NULL;
+  }
+}
+
 static GstPad *
 complete_session_rtcp (GstRtpBin * rtpbin, GstRtpBinSession * session,
     guint sessid)
@@ -3944,7 +4584,7 @@ complete_session_rtcp (GstRtpBin * rtpbin, GstRtpBinSession * session,
   /* get recv_rtp pad and store */
   GST_DEBUG_OBJECT (rtpbin, "getting RTCP sink pad");
   session->recv_rtcp_sink =
-      gst_element_get_request_pad (session->session, "recv_rtcp_sink");
+      gst_element_request_pad_simple (session->session, "recv_rtcp_sink");
   if (session->recv_rtcp_sink == NULL)
     goto pad_failed;
 
@@ -4056,9 +4696,6 @@ create_recv_rtcp (GstRtpBin * rtpbin, GstPadTemplate * templ,
   session->recv_rtcp_sink_ghost =
       gst_ghost_pad_new_from_template (name, decsink, templ);
   gst_object_unref (decsink);
-  gst_pad_set_active (session->recv_rtcp_sink_ghost, TRUE);
-  gst_element_add_pad (GST_ELEMENT_CAST (rtpbin),
-      session->recv_rtcp_sink_ghost);
 
   return session->recv_rtcp_sink_ghost;
 
@@ -4076,6 +4713,64 @@ create_error:
   }
 }
 
+static GstPad *
+create_recv_fec (GstRtpBin * rtpbin, GstPadTemplate * templ, const gchar * name)
+{
+  guint sessid, fec_idx;
+  GstRtpBinSession *session;
+  GstPad *decsink = NULL;
+  GstPad *ghost;
+
+  /* first get the session number */
+  if (name == NULL
+      || sscanf (name, "recv_fec_sink_%u_%u", &sessid, &fec_idx) != 2)
+    goto no_name;
+
+  if (fec_idx > 1)
+    goto invalid_idx;
+
+  GST_DEBUG_OBJECT (rtpbin, "finding session %u", sessid);
+
+  /* get or create the session */
+  session = find_session_by_id (rtpbin, sessid);
+  if (!session) {
+    GST_DEBUG_OBJECT (rtpbin, "creating session %u", sessid);
+    /* create session now */
+    session = create_session (rtpbin, sessid);
+    if (session == NULL)
+      goto create_error;
+  }
+
+  decsink = complete_session_fec (rtpbin, session, fec_idx);
+  if (!decsink)
+    goto create_error;
+
+  ghost = gst_ghost_pad_new_from_template (name, decsink, templ);
+  session->recv_fec_sink_ghosts =
+      g_slist_prepend (session->recv_fec_sink_ghosts, ghost);
+  gst_object_unref (decsink);
+
+  return ghost;
+
+  /* ERRORS */
+no_name:
+  {
+    g_warning ("rtpbin: cannot find session id for pad: %s",
+        GST_STR_NULL (name));
+    return NULL;
+  }
+invalid_idx:
+  {
+    g_warning ("rtpbin: invalid FEC index: %s", GST_STR_NULL (name));
+    return NULL;
+  }
+create_error:
+  {
+    /* create_session already warned */
+    return NULL;
+  }
+}
+
 static void
 remove_recv_rtcp (GstRtpBin * rtpbin, GstRtpBinSession * session)
 {
@@ -4097,6 +4792,64 @@ remove_recv_rtcp (GstRtpBin * rtpbin, GstRtpBinSession * session)
   }
 }
 
+static void
+remove_recv_fec_for_pad (GstRtpBin * rtpbin, GstRtpBinSession * session,
+    GstPad * ghost)
+{
+  GSList *item;
+  GstPad *target;
+
+  target = gst_ghost_pad_get_target (GST_GHOST_PAD (ghost));
+
+  if (target) {
+    item = g_slist_find (session->recv_fec_sinks, target);
+    if (item) {
+      GstPadTemplate *templ;
+      GstPad *pad;
+
+      pad = item->data;
+      templ = gst_pad_get_pad_template (pad);
+
+      if (GST_PAD_TEMPLATE_PRESENCE (templ) == GST_PAD_REQUEST) {
+        GST_DEBUG_OBJECT (rtpbin,
+            "Releasing FEC decoder pad %" GST_PTR_FORMAT, pad);
+        gst_element_release_request_pad (session->early_fec_decoder, pad);
+      } else {
+        gst_object_unref (pad);
+      }
+
+      session->recv_fec_sinks =
+          g_slist_delete_link (session->recv_fec_sinks, item);
+
+      gst_object_unref (templ);
+    }
+    gst_object_unref (target);
+  }
+
+  item = g_slist_find (session->recv_fec_sink_ghosts, ghost);
+  if (item)
+    session->recv_fec_sink_ghosts =
+        g_slist_delete_link (session->recv_fec_sink_ghosts, item);
+
+  gst_pad_set_active (ghost, FALSE);
+  gst_element_remove_pad (GST_ELEMENT_CAST (rtpbin), ghost);
+}
+
+static void
+remove_recv_fec (GstRtpBin * rtpbin, GstRtpBinSession * session)
+{
+  GSList *copy;
+  GSList *tmp;
+
+  copy = g_slist_copy (session->recv_fec_sink_ghosts);
+
+  for (tmp = copy; tmp; tmp = tmp->next) {
+    remove_recv_fec_for_pad (rtpbin, session, (GstPad *) tmp->data);
+  }
+
+  g_slist_free (copy);
+}
+
 static gboolean
 complete_session_src (GstRtpBin * rtpbin, GstRtpBinSession * session)
 {
@@ -4222,7 +4975,7 @@ setup_aux_sender_fold (const GValue * item, GValue * result, gpointer user_data)
 
   /* get send_rtp pad and store */
   newsess->send_rtp_sink =
-      gst_element_get_request_pad (newsess->session, "send_rtp_sink");
+      gst_element_request_pad_simple (newsess->session, "send_rtp_sink");
   if (newsess->send_rtp_sink == NULL)
     goto pad_failed;
 
@@ -4285,6 +5038,146 @@ setup_aux_sender (GstRtpBin * rtpbin, GstRtpBinSession * session,
   return res == GST_ITERATOR_DONE;
 }
 
+static void
+fec_encoder_add_pad_unlocked (GstPad * pad, GstRtpBinSession * session)
+{
+  GstElementClass *klass;
+  gchar *gname;
+  GstPadTemplate *templ;
+  guint fec_idx;
+  GstPad *ghost;
+
+  if (sscanf (GST_PAD_NAME (pad), "fec_%u", &fec_idx) != 1) {
+    GST_WARNING_OBJECT (session->bin,
+        "FEC encoder added pad with name not matching fec_%%u (%s)",
+        GST_PAD_NAME (pad));
+    goto done;
+  }
+
+  GST_INFO_OBJECT (session->bin, "FEC encoder for session %u exposed new pad",
+      session->id);
+
+  klass = GST_ELEMENT_GET_CLASS (session->bin);
+  gname = g_strdup_printf ("send_fec_src_%u_%u", session->id, fec_idx);
+  templ = gst_element_class_get_pad_template (klass, "send_fec_src_%u_%u");
+  ghost = gst_ghost_pad_new_from_template (gname, pad, templ);
+  session->send_fec_src_ghosts =
+      g_slist_prepend (session->send_fec_src_ghosts, ghost);
+  gst_pad_set_active (ghost, TRUE);
+  gst_pad_sticky_events_foreach (pad, copy_sticky_events, ghost);
+  gst_element_add_pad (GST_ELEMENT (session->bin), ghost);
+  g_free (gname);
+
+done:
+  return;
+}
+
+static void
+fec_encoder_add_pad (GstPad * pad, GstRtpBinSession * session)
+{
+  GST_RTP_BIN_LOCK (session->bin);
+  fec_encoder_add_pad_unlocked (pad, session);
+  GST_RTP_BIN_UNLOCK (session->bin);
+}
+
+static gint
+fec_srcpad_iterator_filter (const GValue * item, GValue * unused)
+{
+  guint fec_idx;
+  GstPad *pad = g_value_get_object (item);
+  GstPadTemplate *templ = gst_pad_get_pad_template (pad);
+
+  gint have_static_pad =
+      (GST_PAD_TEMPLATE_PRESENCE (templ) == GST_PAD_ALWAYS) &&
+      (sscanf (GST_PAD_NAME (pad), "fec_%u", &fec_idx) == 1);
+
+  gst_object_unref (templ);
+
+  /* return 0 to retain pad in filtered iterator */
+  return !have_static_pad;
+}
+
+static void
+fec_srcpad_iterator_foreach (const GValue * item, GstRtpBinSession * session)
+{
+  GstPad *pad = g_value_get_object (item);
+  fec_encoder_add_pad_unlocked (pad, session);
+}
+
+static void
+fec_encoder_pad_added_cb (GstElement * encoder, GstPad * pad,
+    GstRtpBinSession * session)
+{
+  fec_encoder_add_pad (pad, session);
+}
+
+static GstElement *
+request_fec_encoder (GstRtpBin * rtpbin, GstRtpBinSession * session,
+    guint sessid)
+{
+  GstElement *ret = NULL;
+  const gchar *factory;
+  gchar *sess_id_str;
+
+  sess_id_str = g_strdup_printf ("%u", sessid);
+  factory = gst_structure_get_string (rtpbin->fec_encoders, sess_id_str);
+  g_free (sess_id_str);
+
+  /* First try the property */
+  if (factory) {
+    GError *err = NULL;
+
+    ret =
+        gst_parse_bin_from_description_full (factory, TRUE, NULL,
+        GST_PARSE_FLAG_NO_SINGLE_ELEMENT_BINS | GST_PARSE_FLAG_FATAL_ERRORS,
+        &err);
+    if (!ret) {
+      GST_ERROR_OBJECT (rtpbin, "Failed to build encoder from factory: %s",
+          err->message);
+      goto done;
+    }
+
+    bin_manage_element (session->bin, ret);
+    session->elements = g_slist_prepend (session->elements, ret);
+    GST_INFO_OBJECT (rtpbin, "Built FEC encoder: %" GST_PTR_FORMAT
+        " for session %u", ret, sessid);
+  }
+
+  /* Fallback to the signal */
+  if (!ret)
+    ret = session_request_element (session, SIGNAL_REQUEST_FEC_ENCODER);
+
+  if (ret) {
+    /* First, add encoder pads that match fec_% template and are already present */
+    GstIterator *it, *filter;
+    GstIteratorResult it_ret = GST_ITERATOR_OK;
+
+    it = gst_element_iterate_src_pads (ret);
+    filter =
+        gst_iterator_filter (it, (GCompareFunc) fec_srcpad_iterator_filter,
+        NULL);
+
+    while (it_ret == GST_ITERATOR_OK || it_ret == GST_ITERATOR_RESYNC) {
+      it_ret =
+          gst_iterator_foreach (filter,
+          (GstIteratorForeachFunction) fec_srcpad_iterator_foreach, session);
+
+      if (it_ret == GST_ITERATOR_RESYNC)
+        gst_iterator_resync (filter);
+    }
+
+    gst_iterator_free (filter);
+
+    /* Finally, connect to pad-added signal if any of the encoder pads are
+     * added later */
+    g_signal_connect (ret, "pad-added", G_CALLBACK (fec_encoder_pad_added_cb),
+        session);
+  }
+
+done:
+  return ret;
+}
+
 /* Create a pad for sending RTP for the session in @name. Must be called with
  * RTP_BIN_LOCK.
  */
@@ -4320,7 +5213,7 @@ create_send_rtp (GstRtpBin * rtpbin, GstPadTemplate * templ, const gchar * name)
   if (session->send_rtp_sink != NULL)
     goto existing_session;
 
-  encoder = session_request_element (session, SIGNAL_REQUEST_FEC_ENCODER);
+  encoder = request_fec_encoder (rtpbin, session, sessid);
 
   if (encoder) {
     GST_DEBUG_OBJECT (rtpbin, "Linking FEC encoder");
@@ -4359,12 +5252,13 @@ create_send_rtp (GstRtpBin * rtpbin, GstPadTemplate * templ, const gchar * name)
       if (ret != GST_PAD_LINK_OK) {
         goto aux_link_failed;
       }
+      gst_object_unref (sinkpad);
     }
     prev = aux;
   } else {
     /* get send_rtp pad and store */
     session->send_rtp_sink =
-        gst_element_get_request_pad (session->session, "send_rtp_sink");
+        gst_element_request_pad_simple (session->session, "send_rtp_sink");
     if (session->send_rtp_sink == NULL)
       goto pad_failed;
 
@@ -4387,8 +5281,6 @@ create_send_rtp (GstRtpBin * rtpbin, GstPadTemplate * templ, const gchar * name)
   session->send_rtp_sink_ghost =
       gst_ghost_pad_new_from_template (name, send_rtp_sink, templ);
   gst_object_unref (send_rtp_sink);
-  gst_pad_set_active (session->send_rtp_sink_ghost, TRUE);
-  gst_element_add_pad (GST_ELEMENT_CAST (rtpbin), session->send_rtp_sink_ghost);
 
   return session->send_rtp_sink_ghost;
 
@@ -4472,6 +5364,21 @@ remove_send_rtp (GstRtpBin * rtpbin, GstRtpBinSession * session)
   }
 }
 
+static void
+remove_send_fec (GstRtpBin * rtpbin, GstRtpBinSession * session)
+{
+  GSList *tmp;
+
+  for (tmp = session->send_fec_src_ghosts; tmp; tmp = tmp->next) {
+    GstPad *ghost = GST_PAD (tmp->data);
+    gst_pad_set_active (ghost, FALSE);
+    gst_element_remove_pad (GST_ELEMENT_CAST (rtpbin), ghost);
+  }
+
+  g_slist_free (session->send_fec_src_ghosts);
+  session->send_fec_src_ghosts = NULL;
+}
+
 /* Create a pad for sending RTCP for the session in @name. Must be called with
  * RTP_BIN_LOCK.
  */
@@ -4504,7 +5411,7 @@ create_send_rtcp (GstRtpBin * rtpbin, GstPadTemplate * templ,
 
   /* get rtcp_src pad and store */
   session->send_rtcp_src =
-      gst_element_get_request_pad (session->session, "send_rtcp_src");
+      gst_element_request_pad_simple (session->session, "send_rtcp_src");
   if (session->send_rtcp_src == NULL)
     goto pad_failed;
 
@@ -4542,8 +5449,6 @@ create_send_rtcp (GstRtpBin * rtpbin, GstPadTemplate * templ,
   session->send_rtcp_src_ghost =
       gst_ghost_pad_new_from_template (name, encsrc, templ);
   gst_object_unref (encsrc);
-  gst_pad_set_active (session->send_rtcp_src_ghost, TRUE);
-  gst_element_add_pad (GST_ELEMENT_CAST (rtpbin), session->send_rtcp_src_ghost);
 
   return session->send_rtcp_src_ghost;
 
@@ -4699,12 +5604,20 @@ gst_rtp_bin_request_new_pad (GstElement * element,
   } else if (templ == gst_element_class_get_pad_template (klass,
           "send_rtcp_src_%u")) {
     result = create_send_rtcp (rtpbin, templ, pad_name);
+  } else if (templ == gst_element_class_get_pad_template (klass,
+          "recv_fec_sink_%u_%u")) {
+    result = create_recv_fec (rtpbin, templ, pad_name);
   } else
     goto wrong_template;
 
   g_free (pad_name);
   GST_RTP_BIN_UNLOCK (rtpbin);
 
+  if (result) {
+    gst_pad_set_active (result, TRUE);
+    gst_element_add_pad (GST_ELEMENT_CAST (rtpbin), result);
+  }
+
   return result;
 
   /* ERRORS */
@@ -4743,13 +5656,16 @@ gst_rtp_bin_release_pad (GstElement * element, GstPad * pad)
     remove_send_rtp (rtpbin, session);
   } else if (session->send_rtcp_src_ghost == pad) {
     remove_rtcp (rtpbin, session);
+  } else if (pad_is_recv_fec (session, pad)) {
+    remove_recv_fec_for_pad (rtpbin, session, pad);
   }
 
   /* no more request pads, free the complete session */
   if (session->recv_rtp_sink_ghost == NULL
       && session->recv_rtcp_sink_ghost == NULL
       && session->send_rtp_sink_ghost == NULL
-      && session->send_rtcp_src_ghost == NULL) {
+      && session->send_rtcp_src_ghost == NULL
+      && session->recv_fec_sink_ghosts == NULL) {
     GST_DEBUG_OBJECT (rtpbin, "no more pads for session %p", session);
     rtpbin->sessions = g_slist_remove (rtpbin->sessions, session);
     free_session (session, rtpbin);
diff --git a/gst/rtpmanager/gstrtpbin.h b/gst/rtpmanager/gstrtpbin.h
index fcea7cec8..eb98eb28e 100644
--- a/gst/rtpmanager/gstrtpbin.h
+++ b/gst/rtpmanager/gstrtpbin.h
@@ -74,10 +74,14 @@ struct _GstRtpBin {
   guint32         max_dropout_time;
   guint32         max_misorder_time;
   gboolean        rfc7273_sync;
+  gboolean        add_reference_timestamp_meta;
   guint           max_streams;
   guint64         max_ts_offset_adjustment;
   gint64          max_ts_offset;
   gboolean        max_ts_offset_is_set;
+  guint64         min_ts_offset;
+  gboolean        min_ts_offset_is_set;
+  guint           ts_offset_smoothing_factor;
 
   /* a list of session */
   GSList         *sessions;
@@ -88,6 +92,14 @@ struct _GstRtpBin {
   /* the default SDES items for sessions */
   GstStructure   *sdes;
 
+  /* the default FEC decoder factories for sessions */
+  GstStructure   *fec_decoders;
+
+  /* the default FEC encoder factories for sessions */
+  GstStructure   *fec_encoders;
+
+  gboolean       update_ntp64_header_ext;
+
   /*< private >*/
   GstRtpBinPrivate *priv;
 };
@@ -111,6 +123,7 @@ struct _GstRtpBinClass {
   RTPSession* (*get_internal_session) (GstRtpBin *rtpbin, guint session);
   GstElement* (*get_storage)          (GstRtpBin *rtpbin, guint session);
   GObject*    (*get_internal_storage) (GstRtpBin *rtpbin, guint session);
+  void        (*clear_ssrc)           (GstRtpBin *rtpbin, guint session, guint32 ssrc);
 
   /* session manager signals */
   void     (*on_new_ssrc)       (GstRtpBin *rtpbin, guint session, guint32 ssrc);
@@ -143,4 +156,6 @@ struct _GstRtpBinClass {
 
 GType gst_rtp_bin_get_type (void);
 
+GST_ELEMENT_REGISTER_DECLARE (rtpbin);
+
 #endif /* __GST_RTP_BIN_H__ */
diff --git a/gst/rtpmanager/gstrtpdtmfmux.c b/gst/rtpmanager/gstrtpdtmfmux.c
index cff68e518..b55c06724 100644
--- a/gst/rtpmanager/gstrtpdtmfmux.c
+++ b/gst/rtpmanager/gstrtpdtmfmux.c
@@ -68,7 +68,11 @@ static gboolean gst_rtp_dtmf_mux_accept_buffer_locked (GstRTPMux * rtp_mux,
 static gboolean gst_rtp_dtmf_mux_src_event (GstRTPMux * rtp_mux,
     GstEvent * event);
 
-G_DEFINE_TYPE (GstRTPDTMFMux, gst_rtp_dtmf_mux, GST_TYPE_RTP_MUX);
+G_DEFINE_TYPE_WITH_CODE (GstRTPDTMFMux, gst_rtp_dtmf_mux, GST_TYPE_RTP_MUX,
+    GST_DEBUG_CATEGORY_INIT (gst_rtp_dtmf_mux_debug, "rtpdtmfmux", 0,
+        "rtp dtmf muxer"););
+GST_ELEMENT_REGISTER_DEFINE (rtpdtmfmux, "rtpdtmfmux", GST_RANK_NONE,
+    GST_TYPE_RTP_DTMF_MUX);
 
 static void
 gst_rtp_dtmf_mux_init (GstRTPDTMFMux * mux)
@@ -222,13 +226,3 @@ gst_rtp_dtmf_mux_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-gboolean
-gst_rtp_dtmf_mux_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (gst_rtp_dtmf_mux_debug, "rtpdtmfmux", 0,
-      "rtp dtmf muxer");
-
-  return gst_element_register (plugin, "rtpdtmfmux", GST_RANK_NONE,
-      GST_TYPE_RTP_DTMF_MUX);
-}
diff --git a/gst/rtpmanager/gstrtpdtmfmux.h b/gst/rtpmanager/gstrtpdtmfmux.h
index 651e9ece7..df4eebd64 100644
--- a/gst/rtpmanager/gstrtpdtmfmux.h
+++ b/gst/rtpmanager/gstrtpdtmfmux.h
@@ -61,7 +61,8 @@ struct _GstRTPDTMFMuxClass
 };
 
 GType gst_rtp_dtmf_mux_get_type (void);
-gboolean gst_rtp_dtmf_mux_plugin_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (rtpdtmfmux);
 
 G_END_DECLS
 #endif /* __GST_RTP_DTMF_MUX_H__ */
diff --git a/gst/rtpmanager/gstrtpfunnel.c b/gst/rtpmanager/gstrtpfunnel.c
index 7638b3497..841b55b00 100644
--- a/gst/rtpmanager/gstrtpfunnel.c
+++ b/gst/rtpmanager/gstrtpfunnel.c
@@ -67,14 +67,14 @@
 #endif
 
 #include <gst/rtp/gstrtpbuffer.h>
+#include <gst/rtp/gstrtphdrext.h>
 
 #include "gstrtpfunnel.h"
+#include "gstrtputils.h"
 
 GST_DEBUG_CATEGORY_STATIC (gst_rtp_funnel_debug);
 #define GST_CAT_DEFAULT gst_rtp_funnel_debug
 
-#define TWCC_EXTMAP_STR "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
-
 /**************** GstRTPFunnelPad ****************/
 
 struct _GstRtpFunnelPadClass
@@ -90,6 +90,8 @@ struct _GstRtpFunnelPad
 };
 
 G_DEFINE_TYPE (GstRtpFunnelPad, gst_rtp_funnel_pad, GST_TYPE_PAD);
+GST_ELEMENT_REGISTER_DEFINE (rtpfunnel, "rtpfunnel", GST_RANK_NONE,
+    GST_TYPE_RTP_FUNNEL);
 
 static void
 gst_rtp_funnel_pad_class_init (G_GNUC_UNUSED GstRtpFunnelPadClass * klass)
@@ -127,9 +129,8 @@ struct _GstRtpFunnel
   /* The last pad data was chained on */
   GstPad *current_pad;
 
-  guint8 twcc_ext_id;           /* the negotiated twcc extmap id */
-  guint16 twcc_seqnum;          /* our internal twcc seqnum */
   guint twcc_pads;              /* numer of sinkpads with negotiated twcc */
+  GstRTPHeaderExtension *twcc_ext;
 
   /* properties */
   gint common_ts_offset;
@@ -189,18 +190,28 @@ done:
 static void
 gst_rtp_funnel_forward_segment (GstRtpFunnel * funnel, GstPad * pad)
 {
-  GstEvent *segment;
+  GstEvent *event;
+  guint i;
 
   if (pad == funnel->current_pad) {
     goto done;
   }
 
-  segment = gst_pad_get_sticky_event (pad, GST_EVENT_SEGMENT, 0);
-  if (segment && !gst_pad_push_event (funnel->srcpad, segment)) {
+  event = gst_pad_get_sticky_event (pad, GST_EVENT_SEGMENT, 0);
+  if (event && !gst_pad_push_event (funnel->srcpad, event)) {
     GST_ERROR_OBJECT (funnel, "Could not push segment");
     goto done;
   }
 
+  for (i = 0;; i++) {
+    event = gst_pad_get_sticky_event (pad, GST_EVENT_CUSTOM_DOWNSTREAM_STICKY,
+        i);
+    if (event == NULL)
+      break;
+    if (!gst_pad_push_event (funnel->srcpad, event))
+      GST_ERROR_OBJECT (funnel, "Could not push custom event");
+  }
+
   funnel->current_pad = pad;
 
 done:
@@ -212,36 +223,40 @@ gst_rtp_funnel_set_twcc_seqnum (GstRtpFunnel * funnel,
     GstPad * pad, GstBuffer ** buf)
 {
   GstRtpFunnelPad *fpad = GST_RTP_FUNNEL_PAD_CAST (pad);
+  guint8 twcc_seq[2] = { 0, };
   GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  guint ext_id = gst_rtp_header_extension_get_id (funnel->twcc_ext);
+  guint8 *existing;
+  guint size;
 
-  if (!funnel->twcc_ext_id || !fpad->has_twcc)
+  if (!funnel->twcc_ext || !fpad->has_twcc)
     return;
 
   *buf = gst_buffer_make_writable (*buf);
 
-  if (gst_rtp_buffer_map (*buf, GST_MAP_READWRITE, &rtp)) {
-    gpointer data;
+  gst_rtp_header_extension_write (funnel->twcc_ext, *buf,
+      GST_RTP_HEADER_EXTENSION_ONE_BYTE, *buf, twcc_seq, sizeof (twcc_seq));
 
-    /* if there already is a twcc-seqnum inside the packet */
-    if (gst_rtp_buffer_get_extension_onebyte_header (&rtp, funnel->twcc_ext_id,
-            0, &data, NULL)) {
+  if (!gst_rtp_buffer_map (*buf, GST_MAP_READWRITE, &rtp))
+    goto map_failed;
 
-      /* with only one pad, we read the twcc-seqnum instead of writing it */
-      if (funnel->twcc_pads == 1) {
-        funnel->twcc_seqnum = GST_READ_UINT16_BE (data);
-      } else {
-        GST_WRITE_UINT16_BE (data, funnel->twcc_seqnum);
-      }
-    } else {
-      guint16 seq_be;
-      GST_WRITE_UINT16_BE (&seq_be, funnel->twcc_seqnum);
-      gst_rtp_buffer_add_extension_onebyte_header (&rtp, funnel->twcc_ext_id,
-          &seq_be, 2);
+  if (gst_rtp_buffer_get_extension_onebyte_header (&rtp, ext_id,
+          0, (gpointer) & existing, &size)) {
+    if (size >= gst_rtp_header_extension_get_max_size (funnel->twcc_ext, *buf)) {
+      existing[0] = twcc_seq[0];
+      existing[1] = twcc_seq[1];
     }
   }
+  /* TODO: two-byte variant */
+
   gst_rtp_buffer_unmap (&rtp);
 
-  funnel->twcc_seqnum++;
+  return;
+
+map_failed:
+  {
+    GST_ERROR ("failed to map buffer %p", *buf);
+  }
 }
 
 static GstFlowReturn
@@ -292,48 +307,28 @@ static void
 gst_rtp_funnel_set_twcc_ext_id (GstRtpFunnel * funnel, guint8 twcc_ext_id)
 {
   gchar *name;
+  guint current_ext_id;
+
+  current_ext_id = gst_rtp_header_extension_get_id (funnel->twcc_ext);
+  g_object_set (funnel->twcc_ext, "n-streams", funnel->twcc_pads, NULL);
 
-  if (funnel->twcc_ext_id == twcc_ext_id)
+  if (current_ext_id == twcc_ext_id)
     return;
 
   name = g_strdup_printf ("extmap-%u", twcc_ext_id);
 
-  GST_OBJECT_LOCK (funnel);
-  gst_caps_set_simple (funnel->srccaps, name, G_TYPE_STRING, TWCC_EXTMAP_STR,
-      NULL);
-  GST_OBJECT_UNLOCK (funnel);
+  gst_caps_set_simple (funnel->srccaps, name, G_TYPE_STRING,
+      gst_rtp_header_extension_get_uri (funnel->twcc_ext), NULL);
 
   g_free (name);
 
   /* make sure we update the sticky with the new caps */
   funnel->send_sticky_events = TRUE;
 
-  GST_INFO_OBJECT (funnel, "Setting twcc-ext-id to %u", twcc_ext_id);
-  funnel->twcc_ext_id = twcc_ext_id;
+  gst_rtp_header_extension_set_id (funnel->twcc_ext, twcc_ext_id);
 }
 
-static guint8
-_get_extmap_id_for_attribute (const GstStructure * s, const gchar * ext_name)
-{
-  guint i;
-  guint8 extmap_id = 0;
-  guint n_fields = gst_structure_n_fields (s);
-
-  for (i = 0; i < n_fields; i++) {
-    const gchar *field_name = gst_structure_nth_field_name (s, i);
-    if (g_str_has_prefix (field_name, "extmap-")) {
-      const gchar *str = gst_structure_get_string (s, field_name);
-      if (str && g_strcmp0 (str, ext_name) == 0) {
-        gint64 id = g_ascii_strtoll (field_name + 7, NULL, 10);
-        if (id > 0 && id < 15) {
-          extmap_id = id;
-          break;
-        }
-      }
-    }
-  }
-  return extmap_id;
-}
+#define TWCC_EXTMAP_STR "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
 
 static gboolean
 gst_rtp_funnel_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
@@ -357,31 +352,37 @@ gst_rtp_funnel_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
       GstStructure *s;
       guint ssrc;
       guint8 ext_id;
+      GstCaps *rtpcaps = gst_caps_new_empty_simple (RTP_CAPS);
 
       gst_event_parse_caps (event, &caps);
 
       GST_OBJECT_LOCK (funnel);
-      if (!gst_caps_can_intersect (funnel->srccaps, caps)) {
+      if (!gst_caps_can_intersect (rtpcaps, caps)) {
         GST_ERROR_OBJECT (funnel, "Can't intersect with caps %" GST_PTR_FORMAT,
             caps);
         g_assert_not_reached ();
       }
-      GST_OBJECT_UNLOCK (funnel);
+
+      gst_caps_unref (rtpcaps);
 
       s = gst_caps_get_structure (caps, 0);
       if (gst_structure_get_uint (s, "ssrc", &ssrc)) {
         fpad->ssrc = ssrc;
         GST_DEBUG_OBJECT (pad, "Got ssrc: %u", ssrc);
-        GST_OBJECT_LOCK (funnel);
         g_hash_table_insert (funnel->ssrc_to_pad, GUINT_TO_POINTER (ssrc), pad);
-        GST_OBJECT_UNLOCK (funnel);
       }
-      ext_id = _get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
+
+      if (!funnel->twcc_ext)
+        funnel->twcc_ext =
+            gst_rtp_header_extension_create_from_uri (TWCC_EXTMAP_STR);
+
+      ext_id = gst_rtp_get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
       if (ext_id > 0) {
         fpad->has_twcc = TRUE;
         funnel->twcc_pads++;
         gst_rtp_funnel_set_twcc_ext_id (funnel, ext_id);
       }
+      GST_OBJECT_UNLOCK (funnel);
 
       forward = FALSE;
       break;
@@ -410,15 +411,17 @@ gst_rtp_funnel_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
     {
       GstCaps *filter_caps;
       GstCaps *new_caps;
+      GstCaps *rtpcaps = gst_caps_new_empty_simple (RTP_CAPS);
 
       gst_query_parse_caps (query, &filter_caps);
 
       GST_OBJECT_LOCK (funnel);
       if (filter_caps) {
-        new_caps = gst_caps_intersect_full (funnel->srccaps, filter_caps,
+        new_caps = gst_caps_intersect_full (rtpcaps, filter_caps,
             GST_CAPS_INTERSECT_FIRST);
+        gst_caps_unref (rtpcaps);
       } else {
-        new_caps = gst_caps_copy (funnel->srccaps);
+        new_caps = rtpcaps;
       }
       GST_OBJECT_UNLOCK (funnel);
 
@@ -440,7 +443,7 @@ gst_rtp_funnel_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
       gst_query_parse_accept_caps (query, &caps);
 
       GST_OBJECT_LOCK (funnel);
-      result = gst_caps_is_subset (caps, funnel->srccaps);
+      result = gst_caps_can_intersect (caps, funnel->srccaps);
       if (!result) {
         GST_ERROR_OBJECT (pad,
             "caps: %" GST_PTR_FORMAT " were not compatible with: %"
@@ -615,6 +618,8 @@ gst_rtp_funnel_finalize (GObject * object)
   gst_caps_unref (funnel->srccaps);
   g_hash_table_destroy (funnel->ssrc_to_pad);
 
+  gst_clear_object (&funnel->twcc_ext);
+
   G_OBJECT_CLASS (parent_class)->finalize (object);
 }
 
diff --git a/gst/rtpmanager/gstrtpfunnel.h b/gst/rtpmanager/gstrtpfunnel.h
index 6fb16d07b..fb436734d 100644
--- a/gst/rtpmanager/gstrtpfunnel.h
+++ b/gst/rtpmanager/gstrtpfunnel.h
@@ -35,6 +35,8 @@ typedef struct _GstRtpFunnel GstRtpFunnel;
 
 GType gst_rtp_funnel_get_type (void);
 
+GST_ELEMENT_REGISTER_DECLARE (rtpfunnel);
+
 typedef struct _GstRtpFunnelPadClass GstRtpFunnelPadClass;
 typedef struct _GstRtpFunnelPad GstRtpFunnelPad;
 
diff --git a/gst/rtpmanager/gstrtphdrext-clientaudiolevel.c b/gst/rtpmanager/gstrtphdrext-clientaudiolevel.c
new file mode 100644
index 000000000..4012e18bc
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-clientaudiolevel.c
@@ -0,0 +1,268 @@
+/* GStreamer
+ * Copyright (C) <2018> Havard Graff <havard.graff@gmail.com>
+ * Copyright (C) <2020-2021> Guillaume Desmottes <guillaume.desmottes@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+/**
+ * SECTION:element-rtphdrextclientaudiolevel
+ * @title: rtphdrextclientaudiolevel
+ * @short_description: Client-to-Mixer Audio Level Indication (RFC6464) RTP Header Extension
+ *
+ * Client-to-Mixer Audio Level Indication (RFC6464) RTP Header Extension.
+ * The extension should be automatically created by payloader and depayloaders,
+ * if their `auto-header-extension` property is enabled, if the extension
+ * is part of the RTP caps.
+ *
+ * ## Example pipeline
+ * |[
+ * gst-launch-1.0 pulsesrc ! level audio-level-meta=true ! audiconvert !
+ *   rtpL16pay ! application/x-rtp,
+ *     extmap-1=(string)\< \"\", urn:ietf:params:rtp-hdrext:ssrc-audio-level,
+ *     \"vad=on\" \> ! udpsink
+ * ]|
+ *
+ * Since: 1.20
+ *
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "gstrtphdrext-clientaudiolevel.h"
+
+#include <gst/audio/audio.h>
+
+#define CLIENT_AUDIO_LEVEL_HDR_EXT_URI GST_RTP_HDREXT_BASE"ssrc-audio-level"
+
+GST_DEBUG_CATEGORY_STATIC (rtphdrclient_audio_level_debug);
+#define GST_CAT_DEFAULT (rtphdrclient_audio_level_debug)
+
+#define DEFAULT_VAD TRUE
+
+enum
+{
+  PROP_0,
+  PROP_VAD,
+};
+
+struct _GstRTPHeaderExtensionClientAudioLevel
+{
+  GstRTPHeaderExtension parent;
+
+  gboolean vad;
+};
+
+G_DEFINE_TYPE_WITH_CODE (GstRTPHeaderExtensionClientAudioLevel,
+    gst_rtp_header_extension_client_audio_level, GST_TYPE_RTP_HEADER_EXTENSION,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "rtphdrextclientaudiolevel", 0,
+        "RTP RFC 6464 Header Extensions"););
+GST_ELEMENT_REGISTER_DEFINE (rtphdrextclientaudiolevel,
+    "rtphdrextclientaudiolevel", GST_RANK_MARGINAL,
+    GST_TYPE_RTP_HEADER_EXTENSION_CLIENT_AUDIO_LEVEL);
+
+static void
+gst_rtp_header_extension_client_audio_level_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionClientAudioLevel *self =
+      GST_RTP_HEADER_EXTENSION_CLIENT_AUDIO_LEVEL (object);
+
+  switch (prop_id) {
+    case PROP_VAD:
+      g_value_set_boolean (value, self->vad);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static GstRTPHeaderExtensionFlags
+    gst_rtp_header_extension_client_audio_level_get_supported_flags
+    (GstRTPHeaderExtension * ext)
+{
+  return GST_RTP_HEADER_EXTENSION_ONE_BYTE | GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+}
+
+static gsize
+gst_rtp_header_extension_client_audio_level_get_max_size (GstRTPHeaderExtension
+    * ext, const GstBuffer * input_meta)
+{
+  return 2;
+}
+
+static void
+set_vad (GstRTPHeaderExtension * ext, gboolean vad)
+{
+  GstRTPHeaderExtensionClientAudioLevel *self =
+      GST_RTP_HEADER_EXTENSION_CLIENT_AUDIO_LEVEL (ext);
+
+  if (self->vad == vad)
+    return;
+
+  GST_DEBUG_OBJECT (ext, "vad: %d", vad);
+  self->vad = vad;
+  g_object_notify (G_OBJECT (self), "vad");
+}
+
+static gboolean
+    gst_rtp_header_extension_client_audio_level_set_attributes
+    (GstRTPHeaderExtension * ext, GstRTPHeaderExtensionDirection direction,
+    const gchar * attributes)
+{
+  if (g_str_equal (attributes, "vad=on") || g_str_equal (attributes, "")) {
+    set_vad (ext, TRUE);
+  } else if (g_str_equal (attributes, "vad=off")) {
+    set_vad (ext, FALSE);
+  } else {
+    GST_WARNING_OBJECT (ext, "Invalid attribute: %s", attributes);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+static gboolean
+    gst_rtp_header_extension_client_audio_level_set_caps_from_attributes
+    (GstRTPHeaderExtension * ext, GstCaps * caps)
+{
+  GstRTPHeaderExtensionClientAudioLevel *self =
+      GST_RTP_HEADER_EXTENSION_CLIENT_AUDIO_LEVEL (ext);
+  const gchar *vad;
+
+  if (self->vad)
+    vad = "vad=on";
+  else
+    vad = "vad=off";
+
+  return gst_rtp_header_extension_set_caps_from_attributes_helper (ext, caps,
+      vad);
+}
+
+static gssize
+gst_rtp_header_extension_client_audio_level_write (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstAudioLevelMeta *meta;
+  guint level;
+
+  g_return_val_if_fail (size >=
+      gst_rtp_header_extension_client_audio_level_get_max_size (ext, NULL), -1);
+  g_return_val_if_fail (write_flags &
+      gst_rtp_header_extension_client_audio_level_get_supported_flags (ext),
+      -1);
+
+  meta = gst_buffer_get_audio_level_meta ((GstBuffer *) input_meta);
+  if (!meta) {
+    GST_LOG_OBJECT (ext, "no meta");
+    return 0;
+  }
+
+  level = meta->level;
+  if (level > 127) {
+    GST_LOG_OBJECT (ext, "level from meta is higher than 127: %d, cropping",
+        meta->level);
+    level = 127;
+  }
+
+  GST_LOG_OBJECT (ext, "writing ext (level: %d voice: %d)", meta->level,
+      meta->voice_activity);
+
+  /* Both one & two byte use the same format, the second byte being padding */
+  data[0] = (meta->level & 0x7F) | (meta->voice_activity << 7);
+  if (write_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+    return 1;
+  }
+  data[1] = 0;
+  return 2;
+}
+
+static gboolean
+gst_rtp_header_extension_client_audio_level_read (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionFlags read_flags, const guint8 * data, gsize size,
+    GstBuffer * buffer)
+{
+  guint8 level;
+  gboolean voice_activity;
+
+  g_return_val_if_fail (read_flags &
+      gst_rtp_header_extension_client_audio_level_get_supported_flags (ext),
+      -1);
+
+  /* Both one & two byte use the same format, the second byte being padding */
+  level = data[0] & 0x7F;
+  voice_activity = (data[0] & 0x80) >> 7;
+
+  GST_LOG_OBJECT (ext, "reading ext (level: %d voice: %d)", level,
+      voice_activity);
+
+  gst_buffer_add_audio_level_meta (buffer, level, voice_activity);
+
+  return TRUE;
+}
+
+static void
+    gst_rtp_header_extension_client_audio_level_class_init
+    (GstRTPHeaderExtensionClientAudioLevelClass * klass)
+{
+  GstRTPHeaderExtensionClass *rtp_hdr_class;
+  GstElementClass *gstelement_class;
+  GObjectClass *gobject_class;
+
+  rtp_hdr_class = GST_RTP_HEADER_EXTENSION_CLASS (klass);
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->get_property =
+      gst_rtp_header_extension_client_audio_level_get_property;
+
+  /**
+   * rtphdrextclientaudiolevel:vad:
+   *
+   * If the vad extension attribute is enabled or not, default to %FALSE.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_VAD,
+      g_param_spec_boolean ("vad", "vad",
+          "If the vad extension attribute is enabled or not",
+          DEFAULT_VAD, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+
+  rtp_hdr_class->get_supported_flags =
+      gst_rtp_header_extension_client_audio_level_get_supported_flags;
+  rtp_hdr_class->get_max_size =
+      gst_rtp_header_extension_client_audio_level_get_max_size;
+  rtp_hdr_class->set_attributes =
+      gst_rtp_header_extension_client_audio_level_set_attributes;
+  rtp_hdr_class->set_caps_from_attributes =
+      gst_rtp_header_extension_client_audio_level_set_caps_from_attributes;
+  rtp_hdr_class->write = gst_rtp_header_extension_client_audio_level_write;
+  rtp_hdr_class->read = gst_rtp_header_extension_client_audio_level_read;
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "Client-to-Mixer Audio Level Indication (RFC6464) RTP Header Extension",
+      GST_RTP_HDREXT_ELEMENT_CLASS,
+      "Client-to-Mixer Audio Level Indication (RFC6464) RTP Header Extension",
+      "Guillaume Desmottes <guillaume.desmottes@collabora.com>");
+  gst_rtp_header_extension_class_set_uri (rtp_hdr_class,
+      CLIENT_AUDIO_LEVEL_HDR_EXT_URI);
+}
+
+static void
+    gst_rtp_header_extension_client_audio_level_init
+    (GstRTPHeaderExtensionClientAudioLevel * self)
+{
+  GST_DEBUG_OBJECT (self, "creating element");
+  self->vad = DEFAULT_VAD;
+}
diff --git a/gst/rtpmanager/gstrtphdrext-clientaudiolevel.h b/gst/rtpmanager/gstrtphdrext-clientaudiolevel.h
new file mode 100644
index 000000000..3ca688850
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-clientaudiolevel.h
@@ -0,0 +1,32 @@
+/* GStreamer
+ * Copyright (C) <2018> Havard Graff <havard.graff@gmail.com>
+ * Copyright (C) <2020-2021> Guillaume Desmottes <guillaume.desmottes@collabora.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more
+ */
+
+#ifndef __GST_RTPHDREXT_CLIENT_AUDIO_LEVEL_H__
+#define __GST_RTPHDREXT_CLIENT_AUDIO_LEVEL_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtphdrext.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_HEADER_EXTENSION_CLIENT_AUDIO_LEVEL (gst_rtp_header_extension_client_audio_level_get_type())
+
+G_DECLARE_FINAL_TYPE (GstRTPHeaderExtensionClientAudioLevel, gst_rtp_header_extension_client_audio_level, GST, RTP_HEADER_EXTENSION_CLIENT_AUDIO_LEVEL, GstRTPHeaderExtension)
+
+GST_ELEMENT_REGISTER_DECLARE (rtphdrextclientaudiolevel);
+
+G_END_DECLS
+
+#endif /* __GST_RTPHDREXT_CLIENT_AUDIO_LEVEL_H__ */
diff --git a/gst/rtpmanager/gstrtphdrext-mid.c b/gst/rtpmanager/gstrtphdrext-mid.c
new file mode 100644
index 000000000..8f861503b
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-mid.c
@@ -0,0 +1,318 @@
+/* GStreamer
+ * Copyright (C) <2021> Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:element-rtphdrextmid
+ * @title: rtphdrextmid
+ * @short_description: RTP Bundle Media Identification (MID) RTP Header
+ *   Extension (RFC8843)
+ * @see_also: #GstRTPHeaderExtension, #GstRTPBasePayload, #GstRTPBaseDepayload, gstrtpbuffer
+ *
+ * Since: 1.22
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtphdrext-mid.h"
+
+GST_DEBUG_CATEGORY_STATIC (rtphdrext_mid_debug);
+#define GST_CAT_DEFAULT (rtphdrext_mid_debug)
+
+#define MID_EXTMAP_STR GST_RTP_HDREXT_BASE "sdes:mid"
+
+enum
+{
+  PROP_0,
+  PROP_MID,
+};
+
+struct _GstRTPHeaderExtensionMid
+{
+  GstRTPHeaderExtension parent;
+
+  char *mid;
+};
+
+#define parent_class gst_rtp_header_extension_mid_parent_class
+G_DEFINE_TYPE_WITH_CODE (GstRTPHeaderExtensionMid,
+    gst_rtp_header_extension_mid, GST_TYPE_RTP_HEADER_EXTENSION,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "rtphdrext-mid", 0,
+        "RTP BUNDLE MID Header Extensions (RFC8843)")
+    );
+GST_ELEMENT_REGISTER_DEFINE (rtphdrextmid, "rtphdrextmid",
+    GST_RANK_MARGINAL, GST_TYPE_RTP_HEADER_EXTENSION_MID);
+
+static GstRTPHeaderExtensionFlags
+gst_rtp_header_extension_mid_get_supported_flags (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionMid *self = GST_RTP_HEADER_EXTENSION_MID (ext);
+  GstRTPHeaderExtensionFlags flags =
+      GST_RTP_HEADER_EXTENSION_ONE_BYTE | GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+  gssize mid_len = -1;
+
+  GST_OBJECT_LOCK (ext);
+  if (self->mid)
+    mid_len = strlen (self->mid);
+  GST_OBJECT_UNLOCK (ext);
+  if (mid_len > 16)
+    flags = GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+
+  return flags;
+}
+
+static gsize
+gst_rtp_header_extension_mid_get_max_size (GstRTPHeaderExtension * ext,
+    const GstBuffer * buffer)
+{
+  if (gst_rtp_header_extension_mid_get_supported_flags (ext) &
+      GST_RTP_HEADER_EXTENSION_ONE_BYTE)
+    return 16;
+  else
+    return 255;
+}
+
+static gssize
+gst_rtp_header_extension_mid_write (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstRTPHeaderExtensionMid *self = GST_RTP_HEADER_EXTENSION_MID (ext);
+  gsize len = 0;
+
+  g_return_val_if_fail (size >=
+      gst_rtp_header_extension_mid_get_max_size (ext, NULL), -1);
+  g_return_val_if_fail (write_flags &
+      gst_rtp_header_extension_mid_get_supported_flags (ext), -1);
+
+  GST_OBJECT_LOCK (ext);
+  if (!self->mid) {
+    GST_LOG_OBJECT (self, "no mid to write");
+    goto out;
+  }
+
+  /* TODO: we don't need to always add mid, we can selectively omit it from e.g.
+   * non-video-keyframes or some percentage of the produced frames, e.g. RFC8843
+   * mentions possibly using packet-loss as a indication of how often to add mid
+   * to packets */
+  len = strlen (self->mid);
+  if ((write_flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) == 0 && len > 16) {
+    GST_DEBUG_OBJECT (self, "cannot write a mid of size %" G_GSIZE_FORMAT
+        " without using the two byte extension format", len);
+    len = 0;
+    goto out;
+  }
+  if (len > 0) {
+    GST_LOG_OBJECT (self, "writing mid \'%s\'", self->mid);
+    memcpy (data, self->mid, len);
+  }
+
+out:
+  GST_OBJECT_UNLOCK (ext);
+  return len;
+}
+
+static gboolean
+gst_rtp_header_extension_mid_read (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionFlags read_flags, const guint8 * data, gsize size,
+    GstBuffer * buffer)
+{
+  GstRTPHeaderExtensionMid *self = GST_RTP_HEADER_EXTENSION_MID (ext);
+  gboolean notify = FALSE;
+
+  if (!data || size == 0)
+    return TRUE;
+
+  if (read_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE && (size < 1 || size > 16)) {
+    GST_ERROR_OBJECT (ext,
+        "one-byte header extensions must be between 1 and 16 bytes inculusive");
+    return FALSE;
+  }
+
+  GST_OBJECT_LOCK (self);
+  if (!self->mid || strncmp ((const char *) data, self->mid, size) != 0) {
+    g_clear_pointer (&self->mid, g_free);
+    self->mid = g_strndup ((const char *) data, size);
+    notify = TRUE;
+  }
+  GST_OBJECT_UNLOCK (self);
+
+  if (notify)
+    g_object_notify ((GObject *) self, "mid");
+
+  return TRUE;
+}
+
+static void
+gst_rtp_header_extension_mid_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionMid *self = GST_RTP_HEADER_EXTENSION_MID (object);
+
+  switch (prop_id) {
+    case PROP_MID:
+      GST_OBJECT_LOCK (self);
+      g_value_set_string (value, self->mid);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+validate_mid (const char *rid)
+{
+  const char *iter;
+
+  /* For avoidance of doubt, the only allowed byte values for
+   * these IDs are decimal 48 through 57, 65 through 90, and 97 through
+   * 122.
+   */
+  for (iter = rid; iter && iter[0]; iter++) {
+    if (iter[0] < 48)
+      return FALSE;
+    if (iter[0] > 122)
+      return FALSE;
+    if (iter[0] > 57 && iter[0] < 65)
+      return FALSE;
+    if (iter[0] > 90 && iter[0] < 97)
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+static void
+gst_rtp_header_extension_mid_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionMid *self = GST_RTP_HEADER_EXTENSION_MID (object);
+
+  switch (prop_id) {
+    case PROP_MID:{
+      const char *mid;
+      GST_OBJECT_LOCK (self);
+      mid = g_value_get_string (value);
+      if (!validate_mid (mid)) {
+        GST_WARNING_OBJECT (self, "Could not set mid \'%s\'. Validation failed",
+            mid);
+      } else {
+        g_clear_pointer (&self->mid, g_free);
+        self->mid = g_strdup (mid);
+      }
+      GST_OBJECT_UNLOCK (self);
+      break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_header_extension_mid_finalize (GObject * object)
+{
+  GstRTPHeaderExtensionMid *self = GST_RTP_HEADER_EXTENSION_MID (object);
+
+  g_clear_pointer (&self->mid, g_free);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static gboolean
+gst_rtp_header_extension_mid_set_caps_from_attributes (GstRTPHeaderExtension
+    * ext, GstCaps * caps)
+{
+  GstRTPHeaderExtensionMid *self = GST_RTP_HEADER_EXTENSION_MID (ext);
+  GstStructure *s = gst_caps_get_structure (caps, 0);
+
+  if (!GST_RTP_HEADER_EXTENSION_CLASS (parent_class)->set_caps_from_attributes
+      (ext, caps))
+    return FALSE;
+
+  GST_OBJECT_LOCK (ext);
+  if (self->mid) {
+    if (gst_structure_has_field (s, "a-mid")) {
+      GST_WARNING_OBJECT (ext, "caps already contain the \'a-mid\' field!");
+      goto error;
+    }
+    gst_structure_set (s, "a-mid", G_TYPE_STRING, self->mid, NULL);
+    GST_DEBUG_OBJECT (ext, "set mid \'%s\' on output caps", self->mid);
+  }
+  GST_OBJECT_UNLOCK (ext);
+
+  return TRUE;
+
+error:
+  GST_OBJECT_UNLOCK (ext);
+  return FALSE;
+}
+
+static void
+gst_rtp_header_extension_mid_class_init (GstRTPHeaderExtensionMidClass * klass)
+{
+  GstRTPHeaderExtensionClass *rtp_hdr_class;
+  GstElementClass *gstelement_class;
+  GObjectClass *gobject_class;
+
+  rtp_hdr_class = (GstRTPHeaderExtensionClass *) klass;
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+
+  gobject_class->set_property = gst_rtp_header_extension_mid_set_property;
+  gobject_class->get_property = gst_rtp_header_extension_mid_get_property;
+  gobject_class->finalize = gst_rtp_header_extension_mid_finalize;
+
+  /**
+   * rtphdrextmid:mid:
+   *
+   * The Media Identification (MID) value either last retrieved from the RTP
+   * Header extension, or to set on outgoing RTP packets.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_MID,
+      g_param_spec_string ("mid", "mid",
+          "The Media Identification (MID) value last read or to write from/to "
+          "RTP buffers", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  rtp_hdr_class->get_supported_flags =
+      gst_rtp_header_extension_mid_get_supported_flags;
+  rtp_hdr_class->get_max_size = gst_rtp_header_extension_mid_get_max_size;
+  rtp_hdr_class->write = gst_rtp_header_extension_mid_write;
+  rtp_hdr_class->read = gst_rtp_header_extension_mid_read;
+  rtp_hdr_class->set_caps_from_attributes =
+      gst_rtp_header_extension_mid_set_caps_from_attributes;
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "RTP BUNDLE MID Header Extension", GST_RTP_HDREXT_ELEMENT_CLASS,
+      "Extends RTP packets to add or retrieve a Media Identification (MID) "
+      "value as specified in RFC8843",
+      "Matthew Waters <matthew@centricular.com>");
+  gst_rtp_header_extension_class_set_uri (rtp_hdr_class, MID_EXTMAP_STR);
+}
+
+static void
+gst_rtp_header_extension_mid_init (GstRTPHeaderExtensionMid * self)
+{
+}
diff --git a/gst/rtpmanager/gstrtphdrext-mid.h b/gst/rtpmanager/gstrtphdrext-mid.h
new file mode 100644
index 000000000..9e58598fd
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-mid.h
@@ -0,0 +1,36 @@
+/* GStreamer
+ * Copyright (C) 2021 Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_RTPHDREXT_MID_H__
+#define __GST_RTPHDREXT_MID_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtphdrext.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_HEADER_EXTENSION_MID (gst_rtp_header_extension_mid_get_type())
+
+G_DECLARE_FINAL_TYPE (GstRTPHeaderExtensionMid, gst_rtp_header_extension_mid, GST, RTP_HEADER_EXTENSION_MID, GstRTPHeaderExtension);
+
+GST_ELEMENT_REGISTER_DECLARE (rtphdrextmid);
+
+G_END_DECLS
+
+#endif /* __GST_RTPHDREXT_MID_H__ */
diff --git a/gst/rtpmanager/gstrtphdrext-ntp.c b/gst/rtpmanager/gstrtphdrext-ntp.c
new file mode 100644
index 000000000..a027138d5
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-ntp.c
@@ -0,0 +1,269 @@
+/* GStreamer
+ * Copyright (C) <2022> Sebastian Drge <sebastian@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:element-rtphdrextntp64
+ * @title: rtphdrextntp64
+ * @short_description: RTP Header Extension for RFC6051 64-bit NTP timestamps for rapid synchronization.
+ * @see_also: #GstRTPHeaderExtension, #GstRTPBasePayload, #GstRTPBaseDepayload, gstrtpbuffer
+ *
+ * Since: 1.22
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtphdrext-ntp.h"
+
+GST_DEBUG_CATEGORY_STATIC (rtphdrext_ntp_debug);
+#define GST_CAT_DEFAULT (rtphdrext_ntp_debug)
+
+enum
+{
+  PROP_0,
+  PROP_INTERVAL,
+  PROP_EVERY_PACKET,
+};
+
+#define DEFAULT_INTERVAL 0
+#define DEFAULT_EVERY_PACKET FALSE
+
+static GstStaticCaps ntp_reference_timestamp_caps =
+GST_STATIC_CAPS ("timestamp/x-ntp");
+
+struct _GstRTPHeaderExtensionNtp64
+{
+  GstRTPHeaderExtension parent;
+
+  GstClockTime last_pts;
+
+  GstClockTime interval;
+  gboolean every_packet;
+};
+
+G_DEFINE_TYPE_WITH_CODE (GstRTPHeaderExtensionNtp64,
+    gst_rtp_header_extension_ntp_64,
+    GST_TYPE_RTP_HEADER_EXTENSION, GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT,
+        "rtphdrextntp", 0, "RTP RFC6051 NTP Timestamps Header Extension");
+    );
+
+GST_ELEMENT_REGISTER_DEFINE (rtphdrextntp64,
+    "rtphdrextntp64", GST_RANK_MARGINAL, GST_TYPE_RTP_HEADER_EXTENSION_NTP_64);
+
+static GstRTPHeaderExtensionFlags
+    gst_rtp_header_extension_ntp_get_supported_flags
+    (GstRTPHeaderExtension * ext)
+{
+  return GST_RTP_HEADER_EXTENSION_ONE_BYTE | GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+}
+
+static gsize
+    gst_rtp_header_extension_ntp_64_get_max_size
+    (GstRTPHeaderExtension * ext, const GstBuffer * buffer)
+{
+  return 8;
+}
+
+static gssize
+gst_rtp_header_extension_ntp_64_write (GstRTPHeaderExtension
+    * ext, const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstRTPHeaderExtensionNtp64 *self = GST_RTP_HEADER_EXTENSION_NTP_64 (ext);
+
+  g_return_val_if_fail (size >=
+      gst_rtp_header_extension_ntp_64_get_max_size (ext, NULL), -1);
+  g_return_val_if_fail (write_flags &
+      gst_rtp_header_extension_ntp_get_supported_flags (ext), -1);
+
+  if (self->every_packet
+      || self->last_pts == GST_CLOCK_TIME_NONE
+      || !GST_BUFFER_PTS_IS_VALID (input_meta)
+      || (self->last_pts != GST_BUFFER_PTS (input_meta)
+          && (GST_BUFFER_IS_DISCONT (input_meta)
+              || (GST_BUFFER_PTS (input_meta) >= self->last_pts
+                  && GST_BUFFER_PTS (input_meta) - self->last_pts >=
+                  self->interval)))) {
+    GstCaps *caps;
+    GstReferenceTimestampMeta *meta;
+
+    caps = gst_static_caps_get (&ntp_reference_timestamp_caps);
+    meta =
+        gst_buffer_get_reference_timestamp_meta ((GstBuffer *) input_meta,
+        caps);
+    if (meta) {
+      guint64 ntptime =
+          gst_util_uint64_scale (meta->timestamp, G_GUINT64_CONSTANT (1) << 32,
+          GST_SECOND);
+
+      GST_WRITE_UINT64_BE (data, ntptime);
+    } else {
+      memset (data, 0, 8);
+    }
+    gst_caps_unref (caps);
+    self->last_pts = GST_BUFFER_PTS (input_meta);
+    return 8;
+  } else {
+    return 0;
+  }
+}
+
+static gboolean
+gst_rtp_header_extension_ntp_64_read (GstRTPHeaderExtension
+    * ext, GstRTPHeaderExtensionFlags read_flags, const guint8 * data,
+    gsize size, GstBuffer * buffer)
+{
+  GstCaps *caps;
+  guint64 ntptime;
+  GstClockTime timestamp;
+
+  if (size < 8)
+    return FALSE;
+
+  caps = gst_static_caps_get (&ntp_reference_timestamp_caps);
+
+  ntptime = GST_READ_UINT64_BE (data);
+  timestamp =
+      gst_util_uint64_scale (ntptime, GST_SECOND, G_GUINT64_CONSTANT (1) << 32);
+
+  gst_buffer_add_reference_timestamp_meta (buffer, caps, timestamp,
+      GST_CLOCK_TIME_NONE);
+
+  gst_caps_unref (caps);
+
+  return TRUE;
+}
+
+
+static void
+gst_rtp_header_extension_ntp_64_get_property (GObject *
+    object, guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionNtp64 *self = GST_RTP_HEADER_EXTENSION_NTP_64 (object);
+
+  switch (prop_id) {
+    case PROP_INTERVAL:
+      GST_OBJECT_LOCK (self);
+      g_value_set_uint64 (value, self->interval);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    case PROP_EVERY_PACKET:
+      GST_OBJECT_LOCK (self);
+      g_value_set_boolean (value, self->every_packet);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_header_extension_ntp_64_set_property (GObject *
+    object, guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionNtp64 *self = GST_RTP_HEADER_EXTENSION_NTP_64 (object);
+
+  switch (prop_id) {
+    case PROP_INTERVAL:
+      GST_OBJECT_LOCK (self);
+      self->interval = g_value_get_uint64 (value);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    case PROP_EVERY_PACKET:
+      GST_OBJECT_LOCK (self);
+      self->every_packet = g_value_get_boolean (value);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+    gst_rtp_header_extension_ntp_64_class_init
+    (GstRTPHeaderExtensionNtp64Class * klass)
+{
+  GstRTPHeaderExtensionClass *rtp_hdr_class;
+  GstElementClass *gstelement_class;
+  GObjectClass *gobject_class;
+
+  rtp_hdr_class = (GstRTPHeaderExtensionClass *) klass;
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+
+  gobject_class->set_property = gst_rtp_header_extension_ntp_64_set_property;
+  gobject_class->get_property = gst_rtp_header_extension_ntp_64_get_property;
+
+  /**
+   * rtphdrextntp64:interval:
+   *
+   * The minimum interval between packets that get the header extension added.
+   *
+   * On discontinuities the interval will be reset and the next packet gets
+   * the header extension added.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_INTERVAL,
+      g_param_spec_uint64 ("interval", "Interval",
+          "Interval between consecutive packets that get the header extension added",
+          0, G_MAXUINT64, DEFAULT_INTERVAL,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  /**
+   * rtphdrextntp64:every-packet:
+   *
+   * If set to %TRUE the header extension will be added to every packet,
+   * independent of its timestamp. By default only the first packet with a
+   * given timestamp will get the header extension added.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_EVERY_PACKET,
+      g_param_spec_boolean ("every-packet", "Every Packet",
+          "Add the header extension to every packet", DEFAULT_EVERY_PACKET,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  rtp_hdr_class->get_supported_flags =
+      gst_rtp_header_extension_ntp_get_supported_flags;
+  rtp_hdr_class->get_max_size = gst_rtp_header_extension_ntp_64_get_max_size;
+  rtp_hdr_class->write = gst_rtp_header_extension_ntp_64_write;
+  rtp_hdr_class->read = gst_rtp_header_extension_ntp_64_read;
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "RTP Header Extension RFC6051 64-bit NTP timestamp",
+      GST_RTP_HDREXT_ELEMENT_CLASS,
+      "Extends RTP packets to add or retrieve a 64-bit NTP "
+      "timestamp as specified in RFC6501",
+      "Sebastian Drge <sebastian@centricular.com>");
+  gst_rtp_header_extension_class_set_uri (rtp_hdr_class,
+      GST_RTP_HDREXT_BASE GST_RTP_HDREXT_NTP_64);
+}
+
+static void
+gst_rtp_header_extension_ntp_64_init (GstRTPHeaderExtensionNtp64 * self)
+{
+  self->last_pts = GST_CLOCK_TIME_NONE;
+  self->interval = DEFAULT_INTERVAL;
+  self->every_packet = DEFAULT_EVERY_PACKET;
+}
diff --git a/gst/rtpmanager/gstrtphdrext-ntp.h b/gst/rtpmanager/gstrtphdrext-ntp.h
new file mode 100644
index 000000000..0e468058b
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-ntp.h
@@ -0,0 +1,36 @@
+/* GStreamer
+ * Copyright (C) <2022> Sebastian Drge <sebastian@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_RTPHDREXT_NTP_H__
+#define __GST_RTPHDREXT_NTP_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtphdrext.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_HEADER_EXTENSION_NTP_64 (gst_rtp_header_extension_ntp_64_get_type())
+
+G_DECLARE_FINAL_TYPE (GstRTPHeaderExtensionNtp64, gst_rtp_header_extension_ntp_64, GST, RTP_HEADER_EXTENSION_NTP_64, GstRTPHeaderExtension);
+
+GST_ELEMENT_REGISTER_DECLARE (rtphdrextntp64);
+
+G_END_DECLS
+
+#endif /* __GST_RTPHDREXT_NTP_H__ */
diff --git a/gst/rtpmanager/gstrtphdrext-repairedstreamid.c b/gst/rtpmanager/gstrtphdrext-repairedstreamid.c
new file mode 100644
index 000000000..706176952
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-repairedstreamid.c
@@ -0,0 +1,307 @@
+/* GStreamer
+ * Copyright (C) <2021> Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:element-rtphdrextrepairedstreamid
+ * @title: rtphdrextrepairedstreamid
+ * @short_description: RTP SDES Header Extension for RFC8852 RepairedRtpStreamId
+ *   Extension
+ * @see_also: #GstRTPHeaderExtension, #GstRTPBasePayload, #GstRTPBaseDepayload, gstrtpbuffer
+ *
+ * Since: 1.22
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtphdrext-repairedstreamid.h"
+
+GST_DEBUG_CATEGORY_STATIC (rtphdrext_repaired_stream_id_debug);
+#define GST_CAT_DEFAULT (rtphdrext_repaired_stream_id_debug)
+
+#define REPAIRED_RID_EXTMAP_STR GST_RTP_HDREXT_BASE "sdes:repaired-rtp-stream-id"
+
+enum
+{
+  PROP_0,
+  PROP_RID,
+};
+
+struct _GstRTPHeaderExtensionRepairedStreamId
+{
+  GstRTPHeaderExtension parent;
+
+  char *rid;
+};
+
+#define gst_rtp_header_extension_repaired_stream_id_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstRTPHeaderExtensionRepairedStreamId,
+    gst_rtp_header_extension_repaired_stream_id,
+    GST_TYPE_RTP_HEADER_EXTENSION, GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT,
+        "rtphdrextrepairedstreamid", 0,
+        "RTP RFC8852 RepairedRtpStreamId Header Extensions");
+    );
+GST_ELEMENT_REGISTER_DEFINE (rtphdrextrepairedstreamid,
+    "rtphdrextrepairedstreamid", GST_RANK_MARGINAL,
+    GST_TYPE_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID);
+
+static GstRTPHeaderExtensionFlags
+    gst_rtp_header_extension_repaired_stream_id_get_supported_flags
+    (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionRepairedStreamId *self =
+      GST_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID (ext);
+  GstRTPHeaderExtensionFlags flags =
+      GST_RTP_HEADER_EXTENSION_ONE_BYTE | GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+  gssize rid_len = -1;
+
+  GST_OBJECT_LOCK (ext);
+  if (self->rid)
+    rid_len = strlen (self->rid);
+  GST_OBJECT_UNLOCK (ext);
+  /* One byte extensions only support [1, 16] bytes */
+  if (rid_len > 16)
+    flags = GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+
+  return flags;
+}
+
+static gsize
+    gst_rtp_header_extension_repaired_stream_id_get_max_size
+    (GstRTPHeaderExtension * ext, const GstBuffer * buffer)
+{
+  if (gst_rtp_header_extension_repaired_stream_id_get_supported_flags
+      (ext) & GST_RTP_HEADER_EXTENSION_ONE_BYTE)
+    return 16;
+  else
+    return 255;
+}
+
+static gssize
+gst_rtp_header_extension_repaired_stream_id_write (GstRTPHeaderExtension
+    * ext, const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstRTPHeaderExtensionRepairedStreamId *self =
+      GST_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID (ext);
+  gsize len = 0;
+
+  g_return_val_if_fail (size >=
+      gst_rtp_header_extension_repaired_stream_id_get_max_size (ext, NULL), -1);
+  g_return_val_if_fail (write_flags &
+      gst_rtp_header_extension_repaired_stream_id_get_supported_flags
+      (ext), -1);
+
+  GST_OBJECT_LOCK (ext);
+  if (!self->rid) {
+    GST_LOG_OBJECT (self, "no rid to write");
+    goto out;
+  }
+
+  /* TODO: we don't need to always add rid, we can selectively omit it from e.g.
+   * non-video-keyframes or some percentage of the produced frames, e.g. RFC8852
+   * mentions possibly using packet-loss as a indication of how often to add rid
+   * to packets */
+  GST_LOG_OBJECT (self, "writing rid \'%s\'", self->rid);
+  len = strlen (self->rid);
+  if ((write_flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) == 0 && len > 16) {
+    GST_DEBUG_OBJECT (self, "cannot write a rid of size %" G_GSIZE_FORMAT
+        " without using the two byte extension format", len);
+    len = 0;
+    goto out;
+  }
+  if (len > 0) {
+    GST_LOG_OBJECT (self, "writing rid \'%s\'", self->rid);
+    memcpy (data, self->rid, len);
+  }
+
+out:
+  GST_OBJECT_UNLOCK (ext);
+  return len;
+}
+
+static gboolean
+gst_rtp_header_extension_repaired_stream_id_read (GstRTPHeaderExtension
+    * ext, GstRTPHeaderExtensionFlags read_flags, const guint8 * data,
+    gsize size, GstBuffer * buffer)
+{
+  GstRTPHeaderExtensionRepairedStreamId *self =
+      GST_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID (ext);
+  gboolean notify = FALSE;
+
+  if (!data || size == 0)
+    return TRUE;
+
+  if (read_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE && (size < 1 || size > 16)) {
+    GST_ERROR_OBJECT (ext,
+        "one-byte header extensions must be between 1 and 16 bytes inculusive");
+    return FALSE;
+  }
+
+  GST_OBJECT_LOCK (self);
+  if (!self->rid || strncmp ((const char *) data, self->rid, size) != 0) {
+    g_clear_pointer (&self->rid, g_free);
+    self->rid = g_strndup ((const char *) data, size);
+    notify = TRUE;
+  }
+  GST_OBJECT_UNLOCK (self);
+
+  if (notify)
+    g_object_notify ((GObject *) self, "rid");
+
+  return TRUE;
+}
+
+static void
+gst_rtp_header_extension_repaired_stream_id_get_property (GObject *
+    object, guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionRepairedStreamId *self =
+      GST_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID (object);
+
+  switch (prop_id) {
+    case PROP_RID:
+      GST_OBJECT_LOCK (self);
+      g_value_set_string (value, self->rid);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+validate_rid (const char *rid)
+{
+  const char *iter;
+
+  /* For avoidance of doubt, the only allowed byte values for
+   * these IDs are decimal 48 through 57, 65 through 90, and 97 through
+   * 122.
+   */
+  for (iter = rid; iter && iter[0]; iter++) {
+    if (iter[0] < 48)
+      return FALSE;
+    if (iter[0] > 122)
+      return FALSE;
+    if (iter[0] > 57 && iter[0] < 65)
+      return FALSE;
+    if (iter[0] > 90 && iter[0] < 97)
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+static void
+gst_rtp_header_extension_repaired_stream_id_set_property (GObject *
+    object, guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionRepairedStreamId *self =
+      GST_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID (object);
+
+  switch (prop_id) {
+    case PROP_RID:{
+      const char *rid;
+      GST_OBJECT_LOCK (self);
+      rid = g_value_get_string (value);
+      if (!validate_rid (rid)) {
+        GST_WARNING_OBJECT (self, "Could not set rid \'%s\'. Validation failed",
+            rid);
+      } else {
+        g_clear_pointer (&self->rid, g_free);
+        self->rid = g_strdup (rid);
+      }
+      GST_OBJECT_UNLOCK (self);
+      break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_header_extension_repaired_stream_id_finalize (GObject * object)
+{
+  GstRTPHeaderExtensionRepairedStreamId *self =
+      GST_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID (object);
+
+  g_clear_pointer (&self->rid, g_free);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+    gst_rtp_header_extension_repaired_stream_id_class_init
+    (GstRTPHeaderExtensionRepairedStreamIdClass * klass)
+{
+  GstRTPHeaderExtensionClass *rtp_hdr_class;
+  GstElementClass *gstelement_class;
+  GObjectClass *gobject_class;
+
+  rtp_hdr_class = (GstRTPHeaderExtensionClass *) klass;
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+
+  gobject_class->set_property =
+      gst_rtp_header_extension_repaired_stream_id_set_property;
+  gobject_class->get_property =
+      gst_rtp_header_extension_repaired_stream_id_get_property;
+  gobject_class->finalize =
+      gst_rtp_header_extension_repaired_stream_id_finalize;
+
+  /**
+   * rtphdrextrepairedstreamid:rid:
+   *
+   * The RepairedRtpStreamID (RID) value either last retrieved from the RTP
+   * Header extension, or to set on outgoing RTP packets.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_RID,
+      g_param_spec_string ("rid", "rid",
+          "The RepairedRtpStreamId (RID) value last read or to write from/to "
+          "RTP buffers", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  rtp_hdr_class->get_supported_flags =
+      gst_rtp_header_extension_repaired_stream_id_get_supported_flags;
+  rtp_hdr_class->get_max_size =
+      gst_rtp_header_extension_repaired_stream_id_get_max_size;
+  rtp_hdr_class->write = gst_rtp_header_extension_repaired_stream_id_write;
+  rtp_hdr_class->read = gst_rtp_header_extension_repaired_stream_id_read;
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "RTP Header Extension Repaired RFC8852 Stream ID",
+      GST_RTP_HDREXT_ELEMENT_CLASS,
+      "Extends RTP packets to add or retrieve a RepairedStreamId (RID) "
+      "value as specified in RFC8852",
+      "Matthew Waters <matthew@centricular.com>");
+  gst_rtp_header_extension_class_set_uri (rtp_hdr_class,
+      REPAIRED_RID_EXTMAP_STR);
+}
+
+static void
+    gst_rtp_header_extension_repaired_stream_id_init
+    (GstRTPHeaderExtensionRepairedStreamId * self)
+{
+}
diff --git a/gst/rtpmanager/gstrtphdrext-repairedstreamid.h b/gst/rtpmanager/gstrtphdrext-repairedstreamid.h
new file mode 100644
index 000000000..7697c537c
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-repairedstreamid.h
@@ -0,0 +1,36 @@
+/* GStreamer
+ * Copyright (C) 2021 Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_RTPHDREXT_REPAIRED_STREAM_ID_H__
+#define __GST_RTPHDREXT_REPAIRED_STREAM_ID_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtphdrext.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID (gst_rtp_header_extension_repaired_stream_id_get_type())
+
+G_DECLARE_FINAL_TYPE (GstRTPHeaderExtensionRepairedStreamId, gst_rtp_header_extension_repaired_stream_id, GST, RTP_HEADER_EXTENSION_REPAIRED_STREAM_ID, GstRTPHeaderExtension);
+
+GST_ELEMENT_REGISTER_DECLARE (rtphdrextrepairedstreamid);
+
+G_END_DECLS
+
+#endif /* __GST_RTPHDREXT_REPAIRED_STREAM_ID_H__ */
diff --git a/gst/rtpmanager/gstrtphdrext-streamid.c b/gst/rtpmanager/gstrtphdrext-streamid.c
new file mode 100644
index 000000000..1705e1f98
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-streamid.c
@@ -0,0 +1,297 @@
+/* GStreamer
+ * Copyright (C) <2021> Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:element-rtphdrextstreamid
+ * @title: rtphdrextstreamid
+ * @short_description: RTP SDES Header Extension for RFC8852 RtpStreamId
+ *   Extension
+ * @see_also: #GstRTPHeaderExtension, #GstRTPBasePayload, #GstRTPBaseDepayload, gstrtpbuffer
+ *
+ * Since: 1.22
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtphdrext-streamid.h"
+
+GST_DEBUG_CATEGORY_STATIC (rtphdrext_stream_id_debug);
+#define GST_CAT_DEFAULT (rtphdrext_stream_id_debug)
+
+#define RID_EXTMAP_STR GST_RTP_HDREXT_BASE "sdes:rtp-stream-id"
+
+enum
+{
+  PROP_0,
+  PROP_RID,
+};
+
+struct _GstRTPHeaderExtensionStreamId
+{
+  GstRTPHeaderExtension parent;
+
+  char *rid;
+};
+
+#define gst_rtp_header_extension_stream_id_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstRTPHeaderExtensionStreamId,
+    gst_rtp_header_extension_stream_id, GST_TYPE_RTP_HEADER_EXTENSION,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "rtphdrextstreamid", 0,
+        "RTP RFC8852 RtpStreamId Header Extensions");
+    );
+GST_ELEMENT_REGISTER_DEFINE (rtphdrextstreamid,
+    "rtphdrextstreamid", GST_RANK_MARGINAL,
+    GST_TYPE_RTP_HEADER_EXTENSION_STREAM_ID);
+
+static GstRTPHeaderExtensionFlags
+    gst_rtp_header_extension_stream_id_get_supported_flags
+    (GstRTPHeaderExtension * ext)
+{
+  GstRTPHeaderExtensionStreamId *self =
+      GST_RTP_HEADER_EXTENSION_STREAM_ID (ext);
+  GstRTPHeaderExtensionFlags flags =
+      GST_RTP_HEADER_EXTENSION_ONE_BYTE | GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+  gssize rid_len = -1;
+
+  GST_OBJECT_LOCK (ext);
+  if (self->rid)
+    rid_len = strlen (self->rid);
+  GST_OBJECT_UNLOCK (ext);
+  if (rid_len > 16)
+    flags = GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+
+  return flags;
+}
+
+static gsize
+gst_rtp_header_extension_stream_id_get_max_size (GstRTPHeaderExtension *
+    ext, const GstBuffer * buffer)
+{
+  if (gst_rtp_header_extension_stream_id_get_supported_flags (ext) &
+      GST_RTP_HEADER_EXTENSION_ONE_BYTE)
+    return 16;
+  else
+    return 255;
+}
+
+static gssize
+gst_rtp_header_extension_stream_id_write (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstRTPHeaderExtensionStreamId *self =
+      GST_RTP_HEADER_EXTENSION_STREAM_ID (ext);
+  gsize len = 0;
+
+  g_return_val_if_fail (size >=
+      gst_rtp_header_extension_stream_id_get_max_size (ext, NULL), -1);
+  g_return_val_if_fail (write_flags &
+      gst_rtp_header_extension_stream_id_get_supported_flags (ext), -1);
+
+  GST_OBJECT_LOCK (ext);
+  if (!self->rid) {
+    GST_LOG_OBJECT (self, "no rid to write");
+    goto out;
+  }
+
+  /* TODO: we don't need to always add rid, we can selectively omit it from e.g.
+   * non-video-keyframes or some percentage of the produced frames, e.g. RFC8852
+   * mentions possibly using packet-loss as a indication of how often to add mid
+   * to packets */
+  len = strlen (self->rid);
+  if ((write_flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) == 0 && len > 16) {
+    GST_DEBUG_OBJECT (self, "cannot write a rid of size %" G_GSIZE_FORMAT
+        " without using the two byte extension format", len);
+    len = 0;
+    goto out;
+  }
+  if (len > 0) {
+    GST_LOG_OBJECT (self, "writing rid \'%s\'", self->rid);
+    memcpy (data, self->rid, len);
+  }
+
+out:
+  GST_OBJECT_UNLOCK (ext);
+  return len;
+}
+
+static gboolean
+gst_rtp_header_extension_stream_id_read (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionFlags read_flags, const guint8 * data, gsize size,
+    GstBuffer * buffer)
+{
+  GstRTPHeaderExtensionStreamId *self =
+      GST_RTP_HEADER_EXTENSION_STREAM_ID (ext);
+  gboolean notify = FALSE;
+
+  if (!data || size == 0)
+    return TRUE;
+
+  if (read_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE && (size < 1 || size > 16)) {
+    GST_ERROR_OBJECT (ext,
+        "one-byte header extensions must be between 1 and 16 bytes inculusive");
+    return FALSE;
+  }
+
+  GST_OBJECT_LOCK (self);
+  if (!self->rid || strncmp ((const char *) data, self->rid, size) != 0) {
+    g_clear_pointer (&self->rid, g_free);
+    self->rid = g_strndup ((const char *) data, size);
+    notify = TRUE;
+  }
+  GST_OBJECT_UNLOCK (self);
+
+  if (notify)
+    g_object_notify ((GObject *) self, "rid");
+
+  return TRUE;
+}
+
+static void
+gst_rtp_header_extension_stream_id_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionStreamId *self =
+      GST_RTP_HEADER_EXTENSION_STREAM_ID (object);
+
+  switch (prop_id) {
+    case PROP_RID:
+      GST_OBJECT_LOCK (self);
+      g_value_set_string (value, self->rid);
+      GST_OBJECT_UNLOCK (self);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+validate_rid (const char *rid)
+{
+  const char *iter;
+
+  /* For avoidance of doubt, the only allowed byte values for
+   * these IDs are decimal 48 through 57, 65 through 90, and 97 through
+   * 122.
+   */
+  for (iter = rid; iter && iter[0]; iter++) {
+    if (iter[0] < 48)
+      return FALSE;
+    if (iter[0] > 122)
+      return FALSE;
+    if (iter[0] > 57 && iter[0] < 65)
+      return FALSE;
+    if (iter[0] > 90 && iter[0] < 97)
+      return FALSE;
+  }
+
+  return TRUE;
+}
+
+static void
+gst_rtp_header_extension_stream_id_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionStreamId *self =
+      GST_RTP_HEADER_EXTENSION_STREAM_ID (object);
+
+  switch (prop_id) {
+    case PROP_RID:{
+      const char *rid;
+      GST_OBJECT_LOCK (self);
+      rid = g_value_get_string (value);
+      if (!validate_rid (rid)) {
+        GST_WARNING_OBJECT (self, "Could not set rid \'%s\'. Validation failed",
+            rid);
+      } else {
+        g_clear_pointer (&self->rid, g_free);
+        self->rid = g_strdup (rid);
+      }
+      GST_OBJECT_UNLOCK (self);
+      break;
+    }
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_header_extension_stream_id_finalize (GObject * object)
+{
+  GstRTPHeaderExtensionStreamId *self =
+      GST_RTP_HEADER_EXTENSION_STREAM_ID (object);
+
+  g_clear_pointer (&self->rid, g_free);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+    gst_rtp_header_extension_stream_id_class_init
+    (GstRTPHeaderExtensionStreamIdClass * klass)
+{
+  GstRTPHeaderExtensionClass *rtp_hdr_class;
+  GstElementClass *gstelement_class;
+  GObjectClass *gobject_class;
+
+  rtp_hdr_class = (GstRTPHeaderExtensionClass *) klass;
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+
+  gobject_class->set_property = gst_rtp_header_extension_stream_id_set_property;
+  gobject_class->get_property = gst_rtp_header_extension_stream_id_get_property;
+  gobject_class->finalize = gst_rtp_header_extension_stream_id_finalize;
+
+  /**
+   * rtphdrextstreamid:rid:
+   *
+   * The RtpStreamID (RID) value either last retrieved from the RTP
+   * Header extension, or to set on outgoing RTP packets.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_RID,
+      g_param_spec_string ("rid", "rid",
+          "The RtpStreamId (RID) value last read or to write from/to "
+          "RTP buffers", NULL, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  rtp_hdr_class->get_supported_flags =
+      gst_rtp_header_extension_stream_id_get_supported_flags;
+  rtp_hdr_class->get_max_size = gst_rtp_header_extension_stream_id_get_max_size;
+  rtp_hdr_class->write = gst_rtp_header_extension_stream_id_write;
+  rtp_hdr_class->read = gst_rtp_header_extension_stream_id_read;
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "RTP Header Extension RFC8852 Stream ID", GST_RTP_HDREXT_ELEMENT_CLASS,
+      "Extends RTP packets to add or retrieve a RtpStreamId (RID) "
+      "value as specified in RFC8852",
+      "Matthew Waters <matthew@centricular.com>");
+  gst_rtp_header_extension_class_set_uri (rtp_hdr_class, RID_EXTMAP_STR);
+}
+
+static void
+    gst_rtp_header_extension_stream_id_init
+    (GstRTPHeaderExtensionStreamId * self)
+{
+}
diff --git a/gst/rtpmanager/gstrtphdrext-streamid.h b/gst/rtpmanager/gstrtphdrext-streamid.h
new file mode 100644
index 000000000..17771321e
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-streamid.h
@@ -0,0 +1,36 @@
+/* GStreamer
+ * Copyright (C) 2021 Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_RTPHDREXT_STREAM_ID_H__
+#define __GST_RTPHDREXT_STREAM_ID_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtphdrext.h>
+
+G_BEGIN_DECLS
+
+#define GST_TYPE_RTP_HEADER_EXTENSION_STREAM_ID (gst_rtp_header_extension_stream_id_get_type())
+
+G_DECLARE_FINAL_TYPE (GstRTPHeaderExtensionStreamId, gst_rtp_header_extension_stream_id, GST, RTP_HEADER_EXTENSION_STREAM_ID, GstRTPHeaderExtension);
+
+GST_ELEMENT_REGISTER_DECLARE (rtphdrextstreamid);
+
+G_END_DECLS
+
+#endif /* __GST_RTPHDREXT_STREAM_ID_H__ */
diff --git a/gst/rtpmanager/gstrtphdrext-twcc.c b/gst/rtpmanager/gstrtphdrext-twcc.c
new file mode 100644
index 000000000..2457337d0
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-twcc.c
@@ -0,0 +1,230 @@
+/* GStreamer
+ * Copyright (C) <2020> Matthew Waters <matthew@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/**
+ * SECTION:rtphdrexttwcc
+ * @title: GstRtphdrext-TWCC
+ * @short_description: Helper methods for dealing with RTP header extensions
+ * in the Audio/Video RTP Profile for transport-wide-cc
+ * @see_also: #GstRTPHeaderExtension, #GstRTPBasePayload, #GstRTPBaseDepayload, gstrtpbuffer
+ *
+ * Since: 1.20
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtphdrext-twcc.h"
+
+GST_DEBUG_CATEGORY_STATIC (rtphdrext_twcc_debug);
+#define GST_CAT_DEFAULT (rtphdrext_twcc_debug)
+
+#define gst_gl_base_filter_parent_class parent_class
+G_DEFINE_TYPE_WITH_CODE (GstRTPHeaderExtensionTWCC,
+    gst_rtp_header_extension_twcc, GST_TYPE_RTP_HEADER_EXTENSION,
+    GST_DEBUG_CATEGORY_INIT (GST_CAT_DEFAULT, "rtphdrexttwcc", 0,
+        "RTP TWCC Header Extensions");
+    );
+GST_ELEMENT_REGISTER_DEFINE (rtphdrexttwcc, "rtphdrexttwcc", GST_RANK_MARGINAL,
+    GST_TYPE_RTP_HEADER_EXTENSION_TWCC);
+
+#define TWCC_EXTMAP_STR "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
+
+static void gst_rtp_header_extension_twcc_set_property (GObject * object,
+    guint prop_id, const GValue * value, GParamSpec * pspec);
+static void gst_rtp_header_extension_twcc_get_property (GObject * object,
+    guint prop_id, GValue * value, GParamSpec * pspec);
+
+static GstRTPHeaderExtensionFlags
+gst_rtp_header_extension_twcc_get_supported_flags (GstRTPHeaderExtension * ext);
+static gsize gst_rtp_header_extension_twcc_get_max_size (GstRTPHeaderExtension *
+    ext, const GstBuffer * buffer);
+static gssize gst_rtp_header_extension_twcc_write (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size);
+static gboolean gst_rtp_header_extension_twcc_read (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionFlags read_flags, const guint8 * data, gsize size,
+    GstBuffer * buffer);
+
+enum
+{
+  PROP_0,
+  PROP_N_STREAMS,
+};
+
+static void
+gst_rtp_header_extension_twcc_class_init (GstRTPHeaderExtensionTWCCClass *
+    klass)
+{
+  GstRTPHeaderExtensionClass *rtp_hdr_class;
+  GstElementClass *gstelement_class;
+  GObjectClass *gobject_class;
+
+  rtp_hdr_class = (GstRTPHeaderExtensionClass *) klass;
+  gobject_class = (GObjectClass *) klass;
+  gstelement_class = (GstElementClass *) klass;
+
+  gobject_class->set_property = gst_rtp_header_extension_twcc_set_property;
+  gobject_class->get_property = gst_rtp_header_extension_twcc_get_property;
+
+  /**
+   * rtphdrexttwcc:n-streams:
+   *
+   * The number of independant RTP streams that are being used for the transport
+   * wide counter for TWCC.  If set to 1 (the default), then any existing
+   * transport wide counter is kept.
+   *
+   * Since: 1.20
+   */
+  g_object_class_install_property (gobject_class, PROP_N_STREAMS,
+      g_param_spec_uint ("n-streams", "N Streams",
+          "The number of separate RTP streams this header applies to",
+          1, G_MAXUINT32, 1, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
+  rtp_hdr_class->get_supported_flags =
+      gst_rtp_header_extension_twcc_get_supported_flags;
+  rtp_hdr_class->get_max_size = gst_rtp_header_extension_twcc_get_max_size;
+  rtp_hdr_class->write = gst_rtp_header_extension_twcc_write;
+  rtp_hdr_class->read = gst_rtp_header_extension_twcc_read;
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "Transport Wide Congestion Control", GST_RTP_HDREXT_ELEMENT_CLASS,
+      "Extends RTP packets to add sequence number transport wide.",
+      "Matthew Waters <matthew@centricular.com>");
+  gst_rtp_header_extension_class_set_uri (rtp_hdr_class, TWCC_EXTMAP_STR);
+}
+
+static void
+gst_rtp_header_extension_twcc_init (GstRTPHeaderExtensionTWCC * twcc)
+{
+  twcc->n_streams = 1;
+}
+
+static void
+gst_rtp_header_extension_twcc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionTWCC *twcc = GST_RTP_HEADER_EXTENSION_TWCC (object);
+
+  switch (prop_id) {
+    case PROP_N_STREAMS:
+      twcc->n_streams = g_value_get_uint (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtp_header_extension_twcc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstRTPHeaderExtensionTWCC *twcc = GST_RTP_HEADER_EXTENSION_TWCC (object);
+
+  switch (prop_id) {
+    case PROP_N_STREAMS:
+      g_value_set_uint (value, twcc->n_streams);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static GstRTPHeaderExtensionFlags
+gst_rtp_header_extension_twcc_get_supported_flags (GstRTPHeaderExtension * ext)
+{
+  return GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+}
+
+static gsize
+gst_rtp_header_extension_twcc_get_max_size (GstRTPHeaderExtension * ext,
+    const GstBuffer * buffer)
+{
+  return 2;
+}
+
+static gssize
+gst_rtp_header_extension_twcc_write (GstRTPHeaderExtension * ext,
+    const GstBuffer * input_meta, GstRTPHeaderExtensionFlags write_flags,
+    GstBuffer * output, guint8 * data, gsize size)
+{
+  GstRTPHeaderExtensionTWCC *twcc = GST_RTP_HEADER_EXTENSION_TWCC (ext);
+  GstRTPBuffer rtp = { NULL, };
+  gpointer ext_data;
+  guint ext_size;
+  gsize written = 0;
+
+  g_return_val_if_fail (size >= gst_rtp_header_extension_twcc_get_max_size (ext,
+          NULL), -1);
+  g_return_val_if_fail (write_flags &
+      gst_rtp_header_extension_twcc_get_supported_flags (ext), -1);
+
+  if (!gst_rtp_buffer_map (output, GST_MAP_READWRITE, &rtp))
+    goto map_failed;
+
+  /* if there already is a twcc-seqnum inside the packet */
+  if (gst_rtp_buffer_get_extension_onebyte_header (&rtp,
+          gst_rtp_header_extension_get_id (ext), 0, &ext_data, &ext_size)) {
+    if (ext_size < gst_rtp_header_extension_twcc_get_max_size (ext, NULL))
+      goto existing_too_small;
+
+    /* with only one stream, we read the twcc-seqnum */
+    if (twcc->n_streams == 1)
+      twcc->seqnum = GST_READ_UINT16_BE (ext_data);
+  } else {
+    /* with only one stream, we read the existing seqnum */
+    if (twcc->n_streams == 1)
+      twcc->seqnum = gst_rtp_buffer_get_seq (&rtp);
+
+    written = 2;
+  }
+  GST_WRITE_UINT16_BE (data, twcc->seqnum);
+
+  gst_rtp_buffer_unmap (&rtp);
+
+  twcc->seqnum++;
+
+  return written;
+
+  /* ERRORS */
+map_failed:
+  {
+    GST_ERROR ("failed to map buffer %p", output);
+    return -1;
+  }
+
+existing_too_small:
+  {
+    GST_ERROR ("Cannot rewrite twcc data of smaller size (%u)", ext_size);
+    return 0;
+  }
+}
+
+static gboolean
+gst_rtp_header_extension_twcc_read (GstRTPHeaderExtension * ext,
+    GstRTPHeaderExtensionFlags read_flags, const guint8 * data, gsize size,
+    GstBuffer * buffer)
+{
+  /* TODO: does this need an extra GstMeta? */
+  return TRUE;
+}
diff --git a/gst/rtpmanager/gstrtphdrext-twcc.h b/gst/rtpmanager/gstrtphdrext-twcc.h
new file mode 100644
index 000000000..3df0249a6
--- /dev/null
+++ b/gst/rtpmanager/gstrtphdrext-twcc.h
@@ -0,0 +1,83 @@
+/* GStreamer
+ * Copyright (C) 2020 Matthew Waters <matthew@centricular.com>
+ *
+ * gstrtphdrexttwcc.h: transport-wide-cc RTP header extensions for the
+ *   Audio/Video RTP Profile
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GST_RTPHDREXT_TWCC_H__
+#define __GST_RTPHDREXT_TWCC_H__
+
+#include <gst/gst.h>
+#include <gst/rtp/gstrtphdrext.h>
+
+G_BEGIN_DECLS
+
+GType gst_rtp_header_extension_twcc_get_type (void);
+#define GST_TYPE_RTP_HEADER_EXTENSION_TWCC (gst_rtp_header_extension_twcc_get_type())
+#define GST_RTP_HEADER_EXTENSION_TWCC(obj) \
+  (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_HEADER_EXTENSION_TWCC,GstRTPHeaderExtensionTWCC))
+#define GST_RTP_HEADER_EXTENSION_TWCC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_HEADER_EXTENSION_TWCC,GstRTPHeaderExtensionTWCCClass))
+#define GST_RTP_HEADER_EXTENSION_TWCC_GET_CLASS(obj) \
+        (G_TYPE_INSTANCE_GET_CLASS ((obj),GST_TYPE_RTP_HEADER_EXTENSION_TWCC,GstRTPHeaderExtensionTWCCClass))
+#define GST_IS_RTP_HEADER_EXTENSION_TWCC(obj) \
+  (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_HEADER_EXTENSION_TWCC))
+#define GST_IS_RTP_HEADER_EXTENSION_TWCC_CLASS(klass) \
+  (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_HEADER_EXTENSION_TWCC))
+#define GST_RTP_HEADER_EXTENSION_TWCC_CAST(obj) ((GstRTPHeaderExtensionTWCC *)(obj))
+
+typedef struct _GstRTPHeaderExtensionTWCC      GstRTPHeaderExtensionTWCC;
+typedef struct _GstRTPHeaderExtensionTWCCClass GstRTPHeaderExtensionTWCCClass;
+
+/**
+ * GstRTPHeaderExtensionTWCC:
+ * @parent: the parent #GstRTPHeaderExtension
+ *
+ * Instance struct for a transport-wide-cc RTP Audio/Video header extension.
+ *
+ * http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01
+ */
+struct _GstRTPHeaderExtensionTWCC
+{
+  GstRTPHeaderExtension parent;
+
+  guint16 seqnum;
+  guint n_streams;
+
+  /*< private >*/
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+/**
+ * GstRTPHeaderExtensionTWCCClass:
+ * @parent_class: the parent class
+ */
+struct _GstRTPHeaderExtensionTWCCClass
+{
+  GstRTPHeaderExtensionClass parent_class;
+
+  /*< private >*/
+  gpointer _gst_reserved[GST_PADDING];
+};
+
+GST_ELEMENT_REGISTER_DECLARE (rtphdrexttwcc);
+
+G_END_DECLS
+
+#endif /* __GST_RTPHDREXT_TWCC_H__ */
diff --git a/gst/rtpmanager/gstrtpjitterbuffer.c b/gst/rtpmanager/gstrtpjitterbuffer.c
index 5bd15b3f4..063e39b9f 100644
--- a/gst/rtpmanager/gstrtpjitterbuffer.c
+++ b/gst/rtpmanager/gstrtpjitterbuffer.c
@@ -106,12 +106,14 @@
 #include <stdio.h>
 #include <string.h>
 #include <gst/rtp/gstrtpbuffer.h>
+#include <gst/rtp/gstrtcpbuffer.h>
 #include <gst/net/net.h>
 
 #include "gstrtpjitterbuffer.h"
 #include "rtpjitterbuffer.h"
 #include "rtpstats.h"
 #include "rtptimerqueue.h"
+#include "gstrtputils.h"
 
 #include <gst/glib-compat-private.h>
 
@@ -153,7 +155,9 @@ enum
 #define DEFAULT_MAX_DROPOUT_TIME    60000
 #define DEFAULT_MAX_MISORDER_TIME   2000
 #define DEFAULT_RFC7273_SYNC        FALSE
+#define DEFAULT_ADD_REFERENCE_TIMESTAMP_META FALSE
 #define DEFAULT_FASTSTART_MIN_PACKETS 0
+#define DEFAULT_SYNC_INTERVAL 0
 
 #define DEFAULT_AUTO_RTX_DELAY (20 * GST_MSECOND)
 #define DEFAULT_AUTO_RTX_TIMEOUT (40 * GST_MSECOND)
@@ -186,7 +190,9 @@ enum
   PROP_MAX_DROPOUT_TIME,
   PROP_MAX_MISORDER_TIME,
   PROP_RFC7273_SYNC,
-  PROP_FASTSTART_MIN_PACKETS
+  PROP_ADD_REFERENCE_TIMESTAMP_META,
+  PROP_FASTSTART_MIN_PACKETS,
+  PROP_SYNC_INTERVAL,
 };
 
 #define JBUF_LOCK(priv)   G_STMT_START {			\
@@ -226,6 +232,13 @@ enum
   (priv)->waiting_timer--;                                \
   GST_DEBUG ("waiting timer done");                       \
 } G_STMT_END
+#define JBUF_WAIT_TIMER_CHECK(priv, label) G_STMT_START { \
+    if (G_UNLIKELY (priv->srcresult != GST_FLOW_OK))	  \
+      goto label;					  \
+    JBUF_WAIT_TIMER (priv);				  \
+    if (G_UNLIKELY (priv->srcresult != GST_FLOW_OK))	  \
+      goto label;					  \
+  } G_STMT_END
 #define JBUF_SIGNAL_TIMER(priv) G_STMT_START {            \
   if (G_UNLIKELY ((priv)->waiting_timer)) {               \
     GST_DEBUG ("signal timer, %d waiters", (priv)->waiting_timer); \
@@ -273,18 +286,6 @@ enum
 #define GST_BUFFER_IS_RETRANSMISSION(buffer) \
   GST_BUFFER_FLAG_IS_SET (buffer, GST_RTP_BUFFER_FLAG_RETRANSMISSION)
 
-#if !GLIB_CHECK_VERSION(2, 60, 0)
-#define g_queue_clear_full queue_clear_full
-static void
-queue_clear_full (GQueue * queue, GDestroyNotify free_func)
-{
-  gpointer data;
-
-  while ((data = g_queue_pop_head (queue)) != NULL)
-    free_func (data);
-}
-#endif
-
 struct _GstRtpJitterBufferPrivate
 {
   GstPad *sinkpad, *srcpad;
@@ -334,6 +335,17 @@ struct _GstRtpJitterBufferPrivate
   guint32 max_dropout_time;
   guint32 max_misorder_time;
   guint faststart_min_packets;
+  gboolean add_reference_timestamp_meta;
+  guint sync_interval;
+
+  /* Reference for GstReferenceTimestampMeta */
+  GstCaps *reference_timestamp_caps;
+
+  /* RTP header extension ID for RFC6051 64-bit NTP timestamps */
+  guint8 ntp64_ext_id;
+
+  /* Known CNAME / SSRC mappings */
+  GList *cname_ssrc_mappings;
 
   /* the last seqnum we pushed out */
   guint32 last_popped_seqnum;
@@ -374,6 +386,7 @@ struct _GstRtpJitterBufferPrivate
 
   /* clock rate and rtp timestamp offset */
   gint last_pt;
+  guint32 last_ssrc;
   gint32 clock_rate;
   gint64 clock_base;
   gint64 ts_offset_remainder;
@@ -390,8 +403,13 @@ struct _GstRtpJitterBufferPrivate
   /* the latency of the upstream peer, we have to take this into account when
    * synchronizing the buffers. */
   GstClockTime peer_latency;
-  guint64 ext_rtptime;
+  guint64 last_sr_ext_rtptime;
   GstBuffer *last_sr;
+  guint32 last_sr_ssrc;
+  GstClockTime last_sr_ntpnstime;
+
+  GstClockTime last_known_ntpnstime;
+  guint64 last_known_ext_rtptime;
 
   /* some accounting */
   guint64 num_pushed;
@@ -409,6 +427,7 @@ struct _GstRtpJitterBufferPrivate
   GstClockTime last_dts;
   GstClockTime last_pts;
   guint64 last_rtptime;
+  GstClockTime last_ntpnstime;
   GstClockTime avg_jitter;
 
   /* for dropped packet messages */
@@ -423,6 +442,47 @@ typedef enum
   REASON_DROP_ON_LATENCY
 } DropMessageReason;
 
+typedef struct
+{
+  gchar *cname;
+  guint32 ssrc;
+} CNameSSRCMapping;
+
+static void
+cname_ssrc_mapping_free (CNameSSRCMapping * mapping)
+{
+  g_free (mapping->cname);
+  g_free (mapping);
+}
+
+static void
+insert_cname_ssrc_mapping (GstRtpJitterBuffer * jbuf, const gchar * cname,
+    guint32 ssrc)
+{
+  CNameSSRCMapping *map;
+  GList *l;
+
+  GST_DEBUG_OBJECT (jbuf, "Adding SSRC %08x to CNAME %s", ssrc, cname);
+
+  for (l = jbuf->priv->cname_ssrc_mappings; l; l = l->next) {
+    map = l->data;
+
+    if (map->ssrc == ssrc) {
+      if (strcmp (cname, map->cname) != 0) {
+        g_free (map->cname);
+        map->cname = g_strdup (cname);
+      }
+      return;
+    }
+  }
+
+  map = g_new0 (CNameSSRCMapping, 1);
+  map->cname = g_strdup (cname);
+  map->ssrc = ssrc;
+  jbuf->priv->cname_ssrc_mappings =
+      g_list_prepend (jbuf->priv->cname_ssrc_mappings, map);
+}
+
 static GstStaticPadTemplate gst_rtp_jitter_buffer_sink_template =
 GST_STATIC_PAD_TEMPLATE ("sink",
     GST_PAD_SINK,
@@ -457,6 +517,8 @@ static guint gst_rtp_jitter_buffer_signals[LAST_SIGNAL] = { 0 };
 #define gst_rtp_jitter_buffer_parent_class parent_class
 G_DEFINE_TYPE_WITH_PRIVATE (GstRtpJitterBuffer, gst_rtp_jitter_buffer,
     GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE (rtpjitterbuffer, "rtpjitterbuffer", GST_RANK_NONE,
+    GST_TYPE_RTP_JITTER_BUFFER);
 
 /* object overrides */
 static void gst_rtp_jitter_buffer_set_property (GObject * object,
@@ -512,6 +574,8 @@ static GstClockTime
 gst_rtp_jitter_buffer_set_active (GstRtpJitterBuffer * jitterbuffer,
     gboolean active, guint64 base_time);
 static void do_handle_sync (GstRtpJitterBuffer * jitterbuffer);
+static void do_handle_sync_inband (GstRtpJitterBuffer * jitterbuffer,
+    guint64 ntpnstime);
 
 static void unschedule_current_timer (GstRtpJitterBuffer * jitterbuffer);
 
@@ -883,6 +947,25 @@ gst_rtp_jitter_buffer_class_init (GstRtpJitterBufferClass * klass)
           "(requires clock and offset to be provided)", DEFAULT_RFC7273_SYNC,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRtpJitterBuffer:add-reference-timestamp-meta:
+   *
+   * When syncing to a RFC7273 clock or after clock synchronization via RTCP or
+   * inband NTP-64 header extensions has happened, add #GstReferenceTimestampMeta
+   * to buffers with the original reconstructed reference clock timestamp.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_ADD_REFERENCE_TIMESTAMP_META,
+      g_param_spec_boolean ("add-reference-timestamp-meta",
+          "Add Reference Timestamp Meta",
+          "Add Reference Timestamp Meta to buffers with the original clock timestamp "
+          "before any adjustments when syncing to an RFC7273 clock or after clock "
+          "synchronization via RTCP or inband NTP-64 header extensions has happened.",
+          DEFAULT_ADD_REFERENCE_TIMESTAMP_META,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstRtpJitterBuffer:faststart-min-packets
    *
@@ -900,6 +983,20 @@ gst_rtp_jitter_buffer_class_init (GstRtpJitterBufferClass * klass)
           0, G_MAXUINT, DEFAULT_FASTSTART_MIN_PACKETS,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRtpJitterBuffer:sync-interval:
+   *
+   * Determines how often to sync streams using RTCP data or inband NTP-64
+   * header extensions.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_SYNC_INTERVAL,
+      g_param_spec_uint ("sync-interval", "Sync Interval",
+          "RTCP SR / NTP-64 interval synchronization (ms) (0 = always)",
+          0, G_MAXUINT, DEFAULT_SYNC_INTERVAL,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   /**
    * GstRtpJitterBuffer::request-pt-map:
    * @buffer: the object which received the signal
@@ -928,7 +1025,7 @@ gst_rtp_jitter_buffer_class_init (GstRtpJitterBufferClass * klass)
    * GstRtpJitterBuffer::on-npt-stop:
    * @buffer: the object which received the signal
    *
-   * Signal that the jitterbufer has pushed the RTP packet that corresponds to
+   * Signal that the jitterbuffer has pushed the RTP packet that corresponds to
    * the npt-stop position.
    */
   gst_rtp_jitter_buffer_signals[SIGNAL_ON_NPT_STOP] =
@@ -1029,11 +1126,16 @@ gst_rtp_jitter_buffer_init (GstRtpJitterBuffer * jitterbuffer)
   priv->max_dropout_time = DEFAULT_MAX_DROPOUT_TIME;
   priv->max_misorder_time = DEFAULT_MAX_MISORDER_TIME;
   priv->faststart_min_packets = DEFAULT_FASTSTART_MIN_PACKETS;
+  priv->add_reference_timestamp_meta = DEFAULT_ADD_REFERENCE_TIMESTAMP_META;
+  priv->sync_interval = DEFAULT_SYNC_INTERVAL;
 
   priv->ts_offset_remainder = 0;
   priv->last_dts = -1;
   priv->last_pts = -1;
   priv->last_rtptime = -1;
+  priv->last_ntpnstime = -1;
+  priv->last_known_ext_rtptime = -1;
+  priv->last_known_ntpnstime = -1;
   priv->avg_jitter = 0;
   priv->last_drop_msg_timestamp = GST_CLOCK_TIME_NONE;
   priv->num_too_late = 0;
@@ -1119,6 +1221,9 @@ gst_rtp_jitter_buffer_finalize (GObject * object)
   g_cond_clear (&priv->jbuf_query);
 
   rtp_jitter_buffer_flush (priv->jbuf, NULL, NULL);
+  g_list_free_full (priv->cname_ssrc_mappings,
+      (GDestroyNotify) cname_ssrc_mapping_free);
+  priv->cname_ssrc_mappings = NULL;
   g_queue_foreach (&priv->gap_packets, (GFunc) gst_buffer_unref, NULL);
   g_queue_clear (&priv->gap_packets);
   g_object_unref (priv->jbuf);
@@ -1372,23 +1477,28 @@ gst_rtp_jitter_buffer_getcaps (GstPad * pad, GstCaps * filter)
   return caps;
 }
 
-/* g_ascii_string_to_unsigned is available since 2.54. Get rid of this wrapper
- * when we bump the version in 1.18 */
-#if !GLIB_CHECK_VERSION(2,54,0)
-#define g_ascii_string_to_unsigned _gst_jitter_buffer_ascii_string_to_unsigned
-static gboolean
-_gst_jitter_buffer_ascii_string_to_unsigned (const gchar * str, guint base,
-    guint64 min, guint64 max, guint64 * out_num, GError ** error)
+static void
+_get_cname_ssrc_mappings (GstRtpJitterBuffer * jitterbuffer,
+    const GstStructure * s)
 {
-  gchar *endptr = NULL;
-  *out_num = g_ascii_strtoull (str, &endptr, base);
-  if (errno)
-    return FALSE;
-  if (endptr == str)
-    return FALSE;
-  return TRUE;
+  guint i;
+  guint n_fields = gst_structure_n_fields (s);
+
+  for (i = 0; i < n_fields; i++) {
+    const gchar *field_name = gst_structure_nth_field_name (s, i);
+    if (g_str_has_prefix (field_name, "ssrc-")
+        && g_str_has_suffix (field_name, "-cname")) {
+      const gchar *str = gst_structure_get_string (s, field_name);
+      gchar *endptr;
+      guint32 ssrc = g_ascii_strtoll (field_name + 5, &endptr, 10);
+
+      if (!endptr || *endptr != '-')
+        continue;
+
+      insert_cname_ssrc_mapping (jitterbuffer, str, ssrc);
+    }
+  }
 }
-#endif
 
 /*
  * Must be called with JBUF_LOCK held
@@ -1404,6 +1514,7 @@ gst_jitter_buffer_sink_parse_caps (GstRtpJitterBuffer * jitterbuffer,
   gint payload = -1;
   GstClockTime tval;
   const gchar *ts_refclk, *mediaclk;
+  GstCaps *ts_meta_ref = NULL;
 
   priv = jitterbuffer->priv;
 
@@ -1519,6 +1630,10 @@ gst_jitter_buffer_sink_parse_caps (GstRtpJitterBuffer * jitterbuffer,
           hostname = g_strdup (host);
 
         clock = gst_ntp_clock_new (NULL, hostname, port, 0);
+
+        ts_meta_ref = gst_caps_new_simple ("timestamp/x-ntp",
+            "host", G_TYPE_STRING, hostname, "port", G_TYPE_INT, port, NULL);
+
         g_free (hostname);
       }
     } else if (g_str_has_prefix (ts_refclk, "ptp=IEEE1588-2008:")) {
@@ -1530,6 +1645,12 @@ gst_jitter_buffer_sink_parse_caps (GstRtpJitterBuffer * jitterbuffer,
         domain = 0;
 
       clock = gst_ptp_clock_new (NULL, domain);
+
+      ts_meta_ref = gst_caps_new_simple ("timestamp/x-ptp",
+          "version", G_TYPE_STRING, "IEEE1588-2008",
+          "domain", G_TYPE_INT, domain, NULL);
+    } else if (!g_strcmp0 (ts_refclk, "local")) {
+      ts_meta_ref = gst_caps_new_empty_simple ("timestamp/x-ntp");
     } else {
       GST_FIXME_OBJECT (jitterbuffer, "Unsupported timestamp reference clock");
     }
@@ -1550,8 +1671,16 @@ gst_jitter_buffer_sink_parse_caps (GstRtpJitterBuffer * jitterbuffer,
     rtp_jitter_buffer_set_media_clock (priv->jbuf, clock, clock_offset);
   } else {
     rtp_jitter_buffer_set_media_clock (priv->jbuf, NULL, -1);
+    ts_meta_ref = gst_caps_new_empty_simple ("timestamp/x-ntp");
   }
 
+  gst_caps_take (&priv->reference_timestamp_caps, ts_meta_ref);
+
+  _get_cname_ssrc_mappings (jitterbuffer, caps_struct);
+  priv->ntp64_ext_id =
+      gst_rtp_get_extmap_id_for_attribute (caps_struct,
+      GST_RTP_HDREXT_BASE GST_RTP_HDREXT_NTP_64);
+
   return TRUE;
 
   /* ERRORS */
@@ -1582,6 +1711,7 @@ gst_rtp_jitter_buffer_flush_start (GstRtpJitterBuffer * jitterbuffer)
   JBUF_SIGNAL_EVENT (priv);
   JBUF_SIGNAL_QUERY (priv, FALSE);
   JBUF_SIGNAL_QUEUE (priv);
+  JBUF_SIGNAL_TIMER (priv);
   JBUF_UNLOCK (priv);
 }
 
@@ -1606,7 +1736,9 @@ gst_rtp_jitter_buffer_flush_stop (GstRtpJitterBuffer * jitterbuffer)
   priv->packet_spacing = 0;
   priv->next_in_seqnum = -1;
   priv->clock_rate = -1;
+  priv->ntp64_ext_id = 0;
   priv->last_pt = -1;
+  priv->last_ssrc = -1;
   priv->eos = FALSE;
   priv->estimated_eos = -1;
   priv->last_elapsed = 0;
@@ -1614,12 +1746,18 @@ gst_rtp_jitter_buffer_flush_stop (GstRtpJitterBuffer * jitterbuffer)
   priv->avg_jitter = 0;
   priv->last_dts = -1;
   priv->last_rtptime = -1;
+  priv->last_ntpnstime = -1;
+  priv->last_known_ext_rtptime = -1;
+  priv->last_known_ntpnstime = -1;
   priv->last_in_pts = 0;
   priv->equidistant = 0;
   priv->segment_seqnum = GST_SEQNUM_INVALID;
   priv->last_drop_msg_timestamp = GST_CLOCK_TIME_NONE;
   priv->num_too_late = 0;
   priv->num_drop_on_latency = 0;
+  g_list_free_full (priv->cname_ssrc_mappings,
+      (GDestroyNotify) cname_ssrc_mapping_free);
+  priv->cname_ssrc_mappings = NULL;
   GST_DEBUG_OBJECT (jitterbuffer, "flush and reset jitterbuffer");
   rtp_jitter_buffer_flush (priv->jbuf, NULL, NULL);
   rtp_jitter_buffer_disable_buffering (priv->jbuf, FALSE);
@@ -1687,6 +1825,11 @@ gst_rtp_jitter_buffer_change_state (GstElement * element,
       priv->clock_base = -1;
       priv->peer_latency = 0;
       priv->last_pt = -1;
+      priv->last_ssrc = -1;
+      priv->ntp64_ext_id = 0;
+      g_list_free_full (priv->cname_ssrc_mappings,
+          (GDestroyNotify) cname_ssrc_mapping_free);
+      priv->cname_ssrc_mappings = NULL;
       /* block until we go to PLAYING */
       priv->blocked = TRUE;
       priv->timer_running = TRUE;
@@ -1737,6 +1880,10 @@ gst_rtp_jitter_buffer_change_state (GstElement * element,
       JBUF_UNLOCK (priv);
       g_thread_join (priv->timer_thread);
       priv->timer_thread = NULL;
+      gst_clear_caps (&priv->reference_timestamp_caps);
+      g_list_free_full (priv->cname_ssrc_mappings,
+          (GDestroyNotify) cname_ssrc_mapping_free);
+      priv->cname_ssrc_mappings = NULL;
       break;
     case GST_STATE_CHANGE_READY_TO_NULL:
       break;
@@ -2127,10 +2274,9 @@ update_timer_offsets (GstRtpJitterBuffer * jitterbuffer)
         test->timeout = GST_CLOCK_TIME_NONE;
         test->offset = 0;
       }
-      /* as we apply the offset on all timers, the order of timers won't
-       * change and we can skip updating the timer queue */
     }
 
+    rtp_timer_queue_reschedule (priv->timers, test);
     test = rtp_timer_get_next (test);
   }
 }
@@ -2270,7 +2416,7 @@ get_rtx_delay (GstRtpJitterBufferPrivate * priv)
  * had for this packet.
  */
 static void
-update_timers (GstRtpJitterBuffer * jitterbuffer, guint16 seqnum,
+update_rtx_timers (GstRtpJitterBuffer * jitterbuffer, guint16 seqnum,
     GstClockTime dts, GstClockTime pts, gboolean do_next_seqnum,
     gboolean is_rtx, RtpTimer * timer)
 {
@@ -2315,7 +2461,7 @@ update_timers (GstRtpJitterBuffer * jitterbuffer, guint16 seqnum,
   }
 
   do_next_seqnum = do_next_seqnum && priv->packet_spacing > 0
-      && priv->do_retransmission && priv->rtx_next_seqnum;
+      && priv->rtx_next_seqnum;
 
   if (timer && timer->type != RTP_TIMER_DEADLINE) {
     if (timer->num_rtx_retry > 0) {
@@ -2342,27 +2488,27 @@ update_timers (GstRtpJitterBuffer * jitterbuffer, guint16 seqnum,
   }
 
   if (do_next_seqnum && pts != GST_CLOCK_TIME_NONE) {
-    GstClockTime expected, delay;
+    GstClockTime next_expected_pts, delay;
 
     /* calculate expected arrival time of the next seqnum */
-    expected = pts + priv->packet_spacing;
+    next_expected_pts = pts + priv->packet_spacing;
 
     delay = get_rtx_delay (priv);
 
     /* and update/install timer for next seqnum */
-    GST_DEBUG_OBJECT (jitterbuffer, "Add RTX timer #%d, expected %"
-        GST_TIME_FORMAT ", delay %" GST_TIME_FORMAT ", packet-spacing %"
+    GST_DEBUG_OBJECT (jitterbuffer, "Add RTX timer #%d, next_expected_pts %"
+        GST_TIME_FORMAT ", delay %" GST_TIME_FORMAT ", est packet duration %"
         GST_TIME_FORMAT ", jitter %" GST_TIME_FORMAT, priv->next_in_seqnum,
-        GST_TIME_ARGS (expected), GST_TIME_ARGS (delay),
+        GST_TIME_ARGS (next_expected_pts), GST_TIME_ARGS (delay),
         GST_TIME_ARGS (priv->packet_spacing), GST_TIME_ARGS (priv->avg_jitter));
 
     if (timer && !is_stats_timer) {
       timer->type = RTP_TIMER_EXPECTED;
       rtp_timer_queue_update_timer (priv->timers, timer, priv->next_in_seqnum,
-          expected, delay, 0, TRUE);
+          next_expected_pts, delay, 0, TRUE);
     } else {
       rtp_timer_queue_set_expected (priv->timers, priv->next_in_seqnum,
-          expected, delay, priv->packet_spacing);
+          next_expected_pts, delay, priv->packet_spacing);
     }
   } else if (timer && timer->type != RTP_TIMER_DEADLINE && !is_stats_timer) {
     /* if we had a timer, remove it, we don't know when to expect the next
@@ -2459,130 +2605,186 @@ insert_lost_event (GstRtpJitterBuffer * jitterbuffer,
 }
 
 static void
-calculate_expected (GstRtpJitterBuffer * jitterbuffer, guint32 expected,
-    guint16 seqnum, GstClockTime pts, gint gap)
+gst_rtp_jitter_buffer_handle_missing_packets (GstRtpJitterBuffer * jitterbuffer,
+    guint32 missing_seqnum, guint16 current_seqnum, GstClockTime pts, gint gap,
+    GstClockTime now)
 {
   GstRtpJitterBufferPrivate *priv = jitterbuffer->priv;
-  GstClockTime duration, expected_pts;
+  GstClockTime est_pkt_duration, est_pts;
   gboolean equidistant = priv->equidistant > 0;
   GstClockTime last_in_pts = priv->last_in_pts;
+  GstClockTimeDiff offset = timeout_offset (jitterbuffer);
+  GstClockTime rtx_delay = get_rtx_delay (priv);
+  guint16 remaining_gap;
+  GstClockTimeDiff remaining_duration;
+  GstClockTimeDiff remainder_duration;
+  guint i;
 
   GST_DEBUG_OBJECT (jitterbuffer,
-      "pts %" GST_TIME_FORMAT ", last %" GST_TIME_FORMAT,
-      GST_TIME_ARGS (pts), GST_TIME_ARGS (last_in_pts));
-
-  if (pts == GST_CLOCK_TIME_NONE) {
-    GST_WARNING_OBJECT (jitterbuffer, "Have no PTS");
-    return;
-  }
+      "Missing packets: (#%u->#%u), gap %d, pts %" GST_TIME_FORMAT
+      ", last-pts %" GST_TIME_FORMAT,
+      missing_seqnum, current_seqnum - 1, gap, GST_TIME_ARGS (pts),
+      GST_TIME_ARGS (last_in_pts));
 
   if (equidistant) {
-    GstClockTime total_duration;
+    GstClockTimeDiff total_duration;
+    gboolean too_late;
+
     /* the total duration spanned by the missing packets */
-    if (pts >= last_in_pts)
-      total_duration = pts - last_in_pts;
-    else
-      total_duration = 0;
+    total_duration = MAX (0, GST_CLOCK_DIFF (last_in_pts, pts));
 
     /* interpolate between the current time and the last time based on
      * number of packets we are missing, this is the estimated duration
      * for the missing packet based on equidistant packet spacing. */
-    duration = total_duration / (gap + 1);
+    est_pkt_duration = total_duration / (gap + 1);
 
-    GST_DEBUG_OBJECT (jitterbuffer, "duration %" GST_TIME_FORMAT,
-        GST_TIME_ARGS (duration));
+    /* if we have valid packet-spacing, use that */
+    if (total_duration > 0 && priv->packet_spacing) {
+      est_pkt_duration = priv->packet_spacing;
+    }
+
+    est_pts = last_in_pts + est_pkt_duration;
+    GST_DEBUG_OBJECT (jitterbuffer, "estimated missing packet pts %"
+        GST_TIME_FORMAT " and duration %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (est_pts), GST_TIME_ARGS (est_pkt_duration));
+
+    /* a packet is considered too late if our estimated pts plus all
+       applicable offsets are in the past */
+    too_late = now > (est_pts + offset);
 
-    if (total_duration > priv->latency_ns) {
-      GstClockTime gap_time;
+    /* Here we optimistically try to save any packets that could potentially
+       be saved by making sure we create lost/rtx timers for them, and for
+       the rest that could not possibly be saved, we create a "multi-lost"
+       event immediately containing the missing duration and sequence numbers */
+    if (too_late) {
       guint lost_packets;
+      GstClockTime lost_duration;
+      GstClockTimeDiff gap_time;
+      guint max_saveable_packets = 0;
+      GstClockTime max_saveable_duration;
+      GstClockTime saveable_duration;
 
-      if (duration > 0) {
-        GstClockTime gap_dur = gap * duration;
-        if (gap_dur > priv->latency_ns)
-          gap_time = gap_dur - priv->latency_ns;
-        else
-          gap_time = 0;
-        lost_packets = gap_time / duration;
-      } else {
-        gap_time = total_duration - priv->latency_ns;
-        lost_packets = gap;
-      }
+      /* gap time represents the total duration of all missing packets */
+      gap_time = MAX (0, GST_CLOCK_DIFF (est_pts, pts));
 
-      /* too many lost packets, some of the missing packets are already
-       * too late and we can generate lost packet events for them. */
-      GST_INFO_OBJECT (jitterbuffer,
-          "lost packets (%d, #%d->#%d) duration too large %" GST_TIME_FORMAT
-          " > %" GST_TIME_FORMAT ", consider %u lost (%" GST_TIME_FORMAT ")",
-          gap, expected, seqnum - 1, GST_TIME_ARGS (total_duration),
-          GST_TIME_ARGS (priv->latency_ns), lost_packets,
-          GST_TIME_ARGS (gap_time));
+      /* based on the estimated packet duration, we
+         can figure out how many packets we could possibly save */
+      if (est_pkt_duration)
+        max_saveable_packets = offset / est_pkt_duration;
+
+      /* and say that the amount of lost packet is the sequence-number
+         gap minus these saveable packets, but at least 1 */
+      lost_packets = MAX (1, (gint) gap - (gint) max_saveable_packets);
+
+      /* now we know how many packets we can possibly save */
+      max_saveable_packets = gap - lost_packets;
+
+      /* we convert that to time */
+      max_saveable_duration = max_saveable_packets * est_pkt_duration;
+
+      /* determine the actual amount of time we can save */
+      saveable_duration = MIN (max_saveable_duration, gap_time);
+
+      /* and we now have the duration we need to fill */
+      lost_duration = GST_CLOCK_DIFF (saveable_duration, gap_time);
 
       /* this multi-lost-packet event will be inserted directly into the packet-queue
          for immediate processing */
       if (lost_packets > 0) {
         RtpTimer *timer;
-        GstClockTime timestamp =
-            apply_offset (jitterbuffer, last_in_pts + duration);
-        insert_lost_event (jitterbuffer, expected, lost_packets, timestamp,
-            gap_time, 0);
+        GstClockTime timestamp = apply_offset (jitterbuffer, est_pts);
 
-        timer = rtp_timer_queue_find (priv->timers, expected);
-        if (timer && timer->type == RTP_TIMER_EXPECTED) {
+        GST_INFO_OBJECT (jitterbuffer, "lost event for %d packet(s) (#%d->#%d) "
+            "for duration %" GST_TIME_FORMAT, lost_packets, missing_seqnum,
+            missing_seqnum + lost_packets - 1, GST_TIME_ARGS (lost_duration));
+
+        insert_lost_event (jitterbuffer, missing_seqnum, lost_packets,
+            timestamp, lost_duration, 0);
+
+        timer = rtp_timer_queue_find (priv->timers, missing_seqnum);
+        if (timer && timer->type != RTP_TIMER_DEADLINE) {
           if (timer->queued)
             rtp_timer_queue_unschedule (priv->timers, timer);
           GST_DEBUG_OBJECT (jitterbuffer, "removing timer for seqnum #%u",
-              expected);
+              missing_seqnum);
           rtp_timer_free (timer);
         }
 
-        expected += lost_packets;
-        last_in_pts += gap_time;
+        missing_seqnum += lost_packets;
+        est_pts += lost_duration;
       }
     }
 
-    expected_pts = last_in_pts + duration;
   } else {
     /* If we cannot assume equidistant packet spacing, the only thing we now
      * for sure is that the missing packets have expected pts not later than
      * the last received pts. */
-    duration = 0;
-    expected_pts = pts;
+    est_pkt_duration = 0;
+    est_pts = pts;
   }
 
-  if (priv->do_retransmission) {
-    RtpTimer *timer = rtp_timer_queue_find (priv->timers, expected);
-    GstClockTime rtx_delay = get_rtx_delay (priv);
-
-    /* if we had a timer for the first missing packet, update it. */
-    if (timer && timer->type == RTP_TIMER_EXPECTED) {
-      GstClockTime timeout = timer->timeout;
-      GstClockTime delay = MAX (rtx_delay, pts - expected_pts);
-
-      timer->duration = duration;
-      if (timeout > (expected_pts + delay) && timer->num_rtx_retry == 0) {
-        rtp_timer_queue_update_timer (priv->timers, timer, timer->seqnum,
-            expected_pts, delay, 0, TRUE);
+  /* Figure out how many more packets we are missing. */
+  remaining_gap = current_seqnum - missing_seqnum;
+  /* and how much time these packets represent */
+  remaining_duration = MAX (0, GST_CLOCK_DIFF (est_pts, pts));
+  /* Given the calculated packet-duration (packet spacing when equidistant),
+     the remainder is what we are left with after subtracting the ideal time
+     for the gap */
+  remainder_duration =
+      MAX (0, GST_CLOCK_DIFF (est_pkt_duration * remaining_gap,
+          remaining_duration));
+
+  GST_DEBUG_OBJECT (jitterbuffer, "remaining gap of %u, with "
+      "duration %" GST_TIME_FORMAT " gives remainder duration %"
+      GST_STIME_FORMAT, remaining_gap, GST_TIME_ARGS (remaining_duration),
+      GST_STIME_ARGS (remainder_duration));
+
+  for (i = 0; i < remaining_gap; i++) {
+    GstClockTime duration = est_pkt_duration;
+    /* we add the remainder on the first packet */
+    if (i == 0)
+      duration += remainder_duration;
+
+    /* clip duration to what is actually left */
+    remaining_duration = MAX (0, GST_CLOCK_DIFF (est_pts, pts));
+    duration = MIN (duration, remaining_duration);
+
+    if (priv->do_retransmission) {
+      RtpTimer *timer = rtp_timer_queue_find (priv->timers, missing_seqnum);
+
+      /* if we had a timer for the missing packet, update it. */
+      if (timer && timer->type == RTP_TIMER_EXPECTED) {
+        timer->duration = duration;
+        if (timer->timeout > (est_pts + rtx_delay) && timer->num_rtx_retry == 0) {
+          rtp_timer_queue_update_timer (priv->timers, timer, timer->seqnum,
+              est_pts, rtx_delay, 0, TRUE);
+          GST_DEBUG_OBJECT (jitterbuffer, "Update RTX timer(s) #%u, "
+              "pts %" GST_TIME_FORMAT ", delay %" GST_TIME_FORMAT
+              ", duration %" GST_TIME_FORMAT,
+              missing_seqnum, GST_TIME_ARGS (est_pts),
+              GST_TIME_ARGS (rtx_delay), GST_TIME_ARGS (duration));
+        }
+      } else {
+        GST_DEBUG_OBJECT (jitterbuffer, "Add RTX timer(s) #%u, "
+            "pts %" GST_TIME_FORMAT ", delay %" GST_TIME_FORMAT
+            ", duration %" GST_TIME_FORMAT,
+            missing_seqnum, GST_TIME_ARGS (est_pts),
+            GST_TIME_ARGS (rtx_delay), GST_TIME_ARGS (duration));
+        rtp_timer_queue_set_expected (priv->timers, missing_seqnum, est_pts,
+            rtx_delay, duration);
       }
-      expected++;
-      expected_pts += duration;
+    } else {
+      GST_INFO_OBJECT (jitterbuffer,
+          "Add Lost timer for #%u, pts %" GST_TIME_FORMAT
+          ", duration %" GST_TIME_FORMAT ", offset %" GST_STIME_FORMAT,
+          missing_seqnum, GST_TIME_ARGS (est_pts),
+          GST_TIME_ARGS (duration), GST_STIME_ARGS (offset));
+      rtp_timer_queue_set_lost (priv->timers, missing_seqnum, est_pts,
+          duration, offset);
     }
 
-    while (gst_rtp_buffer_compare_seqnum (expected, seqnum) > 0) {
-      /* minimum delay the expected-timer has "waited" is the elapsed time
-       * since expected arrival of the missing packet */
-      GstClockTime delay = MAX (rtx_delay, pts - expected_pts);
-      rtp_timer_queue_set_expected (priv->timers, expected, expected_pts,
-          delay, duration);
-      expected_pts += duration;
-      expected++;
-    }
-  } else {
-    while (gst_rtp_buffer_compare_seqnum (expected, seqnum) > 0) {
-      rtp_timer_queue_set_lost (priv->timers, expected, expected_pts,
-          duration, timeout_offset (jitterbuffer));
-      expected_pts += duration;
-      expected++;
-    }
+    missing_seqnum++;
+    est_pts += duration;
   }
 }
 
@@ -2863,6 +3065,34 @@ gst_rtp_jitter_buffer_fast_start (GstRtpJitterBuffer * jitterbuffer)
   return FALSE;
 }
 
+static GstClockTime
+_get_inband_ntp_time (GstRtpJitterBuffer * jitterbuffer, GstRTPBuffer * rtp)
+{
+  GstRtpJitterBufferPrivate *priv = jitterbuffer->priv;
+  guint8 *data;
+  guint size;
+  guint64 ntptime;
+  GstClockTime ntpnstime;
+
+  if (priv->ntp64_ext_id == 0)
+    return GST_CLOCK_TIME_NONE;
+
+  if (!gst_rtp_buffer_get_extension_onebyte_header (rtp, priv->ntp64_ext_id, 0,
+          (gpointer *) & data, &size)
+      && !gst_rtp_buffer_get_extension_twobytes_header (rtp, NULL,
+          priv->ntp64_ext_id, 0, (gpointer *) & data, &size))
+    return GST_CLOCK_TIME_NONE;
+
+  if (size != 8)
+    return GST_CLOCK_TIME_NONE;
+
+  ntptime = GST_READ_UINT64_BE (data);
+  ntpnstime =
+      gst_util_uint64_scale (ntptime, GST_SECOND, G_GUINT64_CONSTANT (1) << 32);
+
+  return ntpnstime;
+}
+
 static GstFlowReturn
 gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
     GstBuffer * buffer)
@@ -2872,12 +3102,16 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
   guint16 seqnum;
   guint32 expected, rtptime;
   GstFlowReturn ret = GST_FLOW_OK;
+  GstClockTime now;
   GstClockTime dts, pts;
+  GstClockTime ntp_time;
+  GstClockTime inband_ntp_time;
   guint64 latency_ts;
   gboolean head;
   gboolean duplicate;
   gint percent = -1;
   guint8 pt;
+  guint32 ssrc;
   GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
   gboolean do_next_seqnum = FALSE;
   GstMessage *msg = NULL;
@@ -2897,9 +3131,12 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
   pt = gst_rtp_buffer_get_payload_type (&rtp);
   seqnum = gst_rtp_buffer_get_seq (&rtp);
   rtptime = gst_rtp_buffer_get_timestamp (&rtp);
+  inband_ntp_time = _get_inband_ntp_time (jitterbuffer, &rtp);
+  ssrc = gst_rtp_buffer_get_ssrc (&rtp);
   gst_rtp_buffer_unmap (&rtp);
 
   is_rtx = GST_BUFFER_IS_RETRANSMISSION (buffer);
+  now = get_current_running_time (jitterbuffer);
 
   /* make sure we have PTS and DTS set */
   pts = GST_BUFFER_PTS (buffer);
@@ -2912,7 +3149,7 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
   if (dts == -1) {
     /* If we have no DTS here, i.e. no capture time, get one from the
      * clock now to have something to calculate with in the future. */
-    dts = get_current_running_time (jitterbuffer);
+    dts = now;
     pts = dts;
 
     /* Remember that we estimated the DTS if we are running already
@@ -2931,8 +3168,10 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
   }
 
   GST_DEBUG_OBJECT (jitterbuffer,
-      "Received packet #%d at time %" GST_TIME_FORMAT ", discont %d, rtx %d",
-      seqnum, GST_TIME_ARGS (dts), GST_BUFFER_IS_DISCONT (buffer), is_rtx);
+      "Received packet #%d at time %" GST_TIME_FORMAT
+      ", discont %d, rtx %d, inband NTP time %" GST_TIME_FORMAT, seqnum,
+      GST_TIME_ARGS (dts), GST_BUFFER_IS_DISCONT (buffer), is_rtx,
+      GST_TIME_ARGS (inband_ntp_time));
 
   JBUF_LOCK_CHECK (priv, out_flushing);
 
@@ -2946,6 +3185,9 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
     /* reset clock-rate so that we get a new one */
     priv->clock_rate = -1;
 
+    priv->last_known_ext_rtptime = -1;
+    priv->last_known_ntpnstime = -1;
+
     /* Try to get the clock-rate from the caps first if we can. If there are no
      * caps we must fire the signal to get the clock-rate. */
     if ((caps = gst_pad_get_current_caps (pad))) {
@@ -2964,6 +3206,16 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
       goto no_clock_rate;
 
     gst_rtp_packet_rate_ctx_reset (&priv->packet_rate_ctx, priv->clock_rate);
+    priv->last_known_ext_rtptime = -1;
+    priv->last_known_ntpnstime = -1;
+  }
+
+  if (G_UNLIKELY (priv->last_ssrc != ssrc)) {
+    GST_DEBUG_OBJECT (jitterbuffer, "SSRC changed from %u to %u",
+        priv->last_ssrc, ssrc);
+    priv->last_ssrc = ssrc;
+    priv->last_known_ext_rtptime = -1;
+    priv->last_known_ntpnstime = -1;
   }
 
   /* don't accept more data on EOS */
@@ -3031,7 +3283,7 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
     pts =
         rtp_jitter_buffer_calculate_pts (priv->jbuf, dts, estimated_dts,
         rtptime, gst_element_get_base_time (GST_ELEMENT_CAST (jitterbuffer)),
-        0, FALSE);
+        0, FALSE, &ntp_time);
 
     if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pts))) {
       /* A valid timestamp cannot be calculated, discard packet */
@@ -3094,7 +3346,7 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
     pts =
         rtp_jitter_buffer_calculate_pts (priv->jbuf, dts, estimated_dts,
         rtptime, gst_element_get_base_time (GST_ELEMENT_CAST (jitterbuffer)),
-        gap, is_rtx);
+        gap, is_rtx, &ntp_time);
 
     if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pts))) {
       /* A valid timestamp cannot be calculated, discard packet */
@@ -3111,11 +3363,22 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
       if (gap > 0) {
         GST_DEBUG_OBJECT (jitterbuffer, "%d missing packets", gap);
         /* fill in the gap with EXPECTED timers */
-        calculate_expected (jitterbuffer, expected, seqnum, pts, gap);
+        gst_rtp_jitter_buffer_handle_missing_packets (jitterbuffer, expected,
+            seqnum, pts, gap, now);
         do_next_seqnum = TRUE;
       } else {
         GST_DEBUG_OBJECT (jitterbuffer, "old packet received");
         do_next_seqnum = FALSE;
+
+        /* If an out of order packet arrives before its lost timer has expired
+         * remove it to avoid false positive statistics. If this is an RTX
+         * packet then the timer will be updated later as part of update_rtx_timers() */
+        if (!is_rtx && timer && timer->type == RTP_TIMER_LOST) {
+          rtp_timer_queue_unschedule (priv->timers, timer);
+          GST_DEBUG_OBJECT (jitterbuffer,
+              "removing lost timer for late seqnum #%u", seqnum);
+          rtp_timer_free (g_steal_pointer (&timer));
+        }
       }
 
       /* reset spacing estimation when gap */
@@ -3129,8 +3392,22 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
     priv->next_in_seqnum = (seqnum + 1) & 0xffff;
   }
 
-  if (is_rtx)
+  if (inband_ntp_time != GST_CLOCK_TIME_NONE) {
+    guint64 ext_rtptime;
+
+    ext_rtptime = priv->jbuf->ext_rtptime;
+    ext_rtptime = gst_rtp_buffer_ext_timestamp (&ext_rtptime, rtptime);
+
+    priv->last_known_ext_rtptime = ext_rtptime;
+    priv->last_known_ntpnstime = inband_ntp_time;
+  }
+
+  if (is_rtx) {
+    /* For RTX there must be a corresponding timer or it would be an
+     * unsolicited RTX packet that would be dropped */
+    g_assert (timer != NULL);
     timer->num_rtx_received++;
+  }
 
   /* At 2^15, we would detect a seqnum rollover too early, therefore
    * limit the queue size. But let's not limit it to a number that is
@@ -3138,12 +3415,12 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
    * sequence number, let's allow at least 10k packets in any case. */
   while (rtp_jitter_buffer_is_full (priv->jbuf) &&
       priv->srcresult == GST_FLOW_OK) {
-    RtpTimer *timer = rtp_timer_queue_peek_earliest (priv->timers);
-    while (timer) {
-      timer->timeout = -1;
-      if (timer->type == RTP_TIMER_DEADLINE)
+    RtpTimer *earliest_timer = rtp_timer_queue_peek_earliest (priv->timers);
+    while (earliest_timer) {
+      earliest_timer->timeout = -1;
+      if (earliest_timer->type == RTP_TIMER_DEADLINE)
         break;
-      timer = rtp_timer_get_next (timer);
+      earliest_timer = rtp_timer_get_next (earliest_timer);
     }
 
     update_current_timer (jitterbuffer);
@@ -3162,7 +3439,11 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
     /* priv->last_popped_seqnum >= seqnum, we're too late. */
     if (G_UNLIKELY (gap <= 0)) {
       if (priv->do_retransmission) {
-        if (is_rtx && timer) {
+        if (is_rtx) {
+          /* For RTX there must be a corresponding timer or it would be an
+           * unsolicited RTX packet that would be dropped */
+          g_assert (timer != NULL);
+
           update_rtx_stats (jitterbuffer, timer, dts, FALSE);
           /* Only count the retranmitted packet too late if it has been
            * considered lost. If the original packet arrived before the
@@ -3205,6 +3486,39 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
       JBUF_SIGNAL_EVENT (priv);
     }
   }
+  // If we can calculate a NTP time based solely on the Sender Report, or
+  // inband NTP header extension do that so that we can still add a reference
+  // timestamp meta to the buffer
+  if (!GST_CLOCK_TIME_IS_VALID (ntp_time) &&
+      GST_CLOCK_TIME_IS_VALID (priv->last_known_ntpnstime) &&
+      priv->last_known_ext_rtptime != -1) {
+    guint64 ext_time = priv->last_known_ext_rtptime;
+
+    ext_time = gst_rtp_buffer_ext_timestamp (&ext_time, rtptime);
+
+    if (ext_time >= priv->last_known_ext_rtptime) {
+      ntp_time =
+          priv->last_known_ntpnstime + gst_util_uint64_scale (ext_time -
+          priv->last_known_ext_rtptime, GST_SECOND, priv->clock_rate);
+    } else {
+      ntp_time =
+          priv->last_known_ntpnstime -
+          gst_util_uint64_scale (priv->last_known_ext_rtptime - ext_time,
+          GST_SECOND, priv->clock_rate);
+    }
+  }
+
+  if (priv->add_reference_timestamp_meta && GST_CLOCK_TIME_IS_VALID (ntp_time)
+      && priv->reference_timestamp_caps != NULL) {
+    buffer = gst_buffer_make_writable (buffer);
+
+    GST_TRACE_OBJECT (jitterbuffer,
+        "adding NTP time reference meta: %" GST_TIME_FORMAT,
+        GST_TIME_ARGS (ntp_time));
+
+    gst_buffer_add_reference_timestamp_meta (buffer,
+        priv->reference_timestamp_caps, ntp_time, GST_CLOCK_TIME_NONE);
+  }
 
   /* If we estimated the DTS, don't consider it in the clock skew calculations
    * later. The code above always sets dts to pts or the other way around if
@@ -3218,8 +3532,12 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
    * FALSE if a packet with the same seqnum was already in the queue, meaning we
    * have a duplicate. */
   if (G_UNLIKELY (duplicate)) {
-    if (is_rtx && timer)
+    if (is_rtx) {
+      /* For RTX there must be a corresponding timer or it would be an
+       * unsolicited RTX packet that would be dropped */
+      g_assert (timer != NULL);
       update_rtx_stats (jitterbuffer, timer, dts, FALSE);
+    }
     goto duplicate;
   }
 
@@ -3227,13 +3545,18 @@ gst_rtp_jitter_buffer_chain (GstPad * pad, GstObject * parent,
   if (gst_rtp_jitter_buffer_fast_start (jitterbuffer))
     head = TRUE;
 
-  /* update timers */
-  update_timers (jitterbuffer, seqnum, dts, pts, do_next_seqnum, is_rtx, timer);
+  /* update rtx timers */
+  if (priv->do_retransmission)
+    update_rtx_timers (jitterbuffer, seqnum, dts, pts, do_next_seqnum, is_rtx,
+        g_steal_pointer (&timer));
 
   /* we had an unhandled SR, handle it now */
   if (priv->last_sr)
     do_handle_sync (jitterbuffer);
 
+  if (inband_ntp_time != GST_CLOCK_TIME_NONE)
+    do_handle_sync_inband (jitterbuffer, inband_ntp_time);
+
   if (G_UNLIKELY (head)) {
     /* signal addition of new buffer when the _loop is waiting. */
     if (G_LIKELY (priv->active))
@@ -3535,7 +3858,7 @@ pop_and_push_next (GstRtpJitterBuffer * jitterbuffer, guint seqnum)
     while (rtp_timer_queue_length (priv->timers) > 0) {
       /* Stopping timers */
       unschedule_current_timer (jitterbuffer);
-      JBUF_WAIT_TIMER (priv);
+      JBUF_WAIT_TIMER_CHECK (priv, out_flushing_wait);
     }
   }
 
@@ -3602,6 +3925,12 @@ out_flushing:
   {
     return priv->srcresult;
   }
+
+out_flushing_wait:
+  {
+    rtp_jitter_buffer_free_item (item);
+    return priv->srcresult;
+  }
 }
 
 #define GST_FLOW_WAIT GST_FLOW_CUSTOM_SUCCESS
@@ -3828,14 +4157,16 @@ do_expected_timeout (GstRtpJitterBuffer * jitterbuffer, RtpTimer * timer,
   GstClockTime rtx_retry_timeout;
   GstClock *clock;
   GstClockTimeDiff offset = 0;
+  GstClockTime timeout;
 
-  GST_DEBUG_OBJECT (jitterbuffer, "expected %d didn't arrive, now %"
+  GST_DEBUG_OBJECT (jitterbuffer, "expected #%d didn't arrive, now %"
       GST_TIME_FORMAT, timer->seqnum, GST_TIME_ARGS (now));
 
   rtx_retry_timeout = get_rtx_retry_timeout (priv);
   rtx_retry_period = get_rtx_retry_period (priv, rtx_retry_timeout);
 
-  delay = timer->rtx_delay + timer->rtx_retry;
+  /* delay expresses how late this packet is currently */
+  delay = now - timer->rtx_base;
 
   delay_ms = GST_TIME_AS_MSECONDS (delay);
   rtx_retry_timeout_ms = GST_TIME_AS_MSECONDS (rtx_retry_timeout);
@@ -3870,28 +4201,34 @@ do_expected_timeout (GstRtpJitterBuffer * jitterbuffer, RtpTimer * timer,
   }
   GST_OBJECT_UNLOCK (jitterbuffer);
 
-  /* calculate the timeout for the next retransmission attempt */
-  timer->rtx_retry += rtx_retry_timeout;
-  GST_DEBUG_OBJECT (jitterbuffer, "timer #%i base %" GST_TIME_FORMAT ", delay %"
-      GST_TIME_FORMAT ", retry %" GST_TIME_FORMAT ", num_retry %u",
-      timer->seqnum, GST_TIME_ARGS (timer->rtx_base),
-      GST_TIME_ARGS (timer->rtx_delay), GST_TIME_ARGS (timer->rtx_retry),
-      timer->num_rtx_retry);
+  /*
+     Calculate the timeout for the next retransmission attempt:
+     We have just successfully sent one RTX request, and we need to
+     find out when to schedule the next one.
+
+     The rtx_retry_timeout tells us the logical timeout between RTX
+     requests based on things like round-trip time, jitter and packet spacing,
+     and is how long we are going to wait before attempting another RTX packet
+   */
+  timeout = timer->rtx_last + rtx_retry_timeout;
+  GST_DEBUG_OBJECT (jitterbuffer,
+      "timer #%i new timeout %" GST_TIME_FORMAT ", rtx retry timeout %"
+      GST_TIME_FORMAT ", num_retry %u", timer->seqnum, GST_TIME_ARGS (timeout),
+      GST_TIME_ARGS (rtx_retry_timeout), timer->num_rtx_retry);
   if ((priv->rtx_max_retries != -1
           && timer->num_rtx_retry >= priv->rtx_max_retries)
-      || (timer->rtx_retry + timer->rtx_delay > rtx_retry_period)
-      || (timer->rtx_base + rtx_retry_period < now)) {
-    GST_DEBUG_OBJECT (jitterbuffer, "reschedule #%i as LOST timer",
-        timer->seqnum);
+      || (timeout > timer->rtx_base + rtx_retry_period)) {
     /* too many retransmission request, we now convert the timer
      * to a lost timer, leave the num_rtx_retry as it is for stats */
     timer->type = RTP_TIMER_LOST;
-    timer->rtx_delay = 0;
-    timer->rtx_retry = 0;
+    timeout = timer->rtx_base;
     offset = timeout_offset (jitterbuffer);
+    GST_DEBUG_OBJECT (jitterbuffer, "reschedule #%i as LOST timer for %"
+        GST_TIME_FORMAT, timer->seqnum,
+        GST_TIME_ARGS (timer->rtx_base + offset));
   }
   rtp_timer_queue_update_timer (priv->timers, timer, timer->seqnum,
-      timer->rtx_base + timer->rtx_retry, timer->rtx_delay, offset, FALSE);
+      timeout, 0, offset, FALSE);
 
   return FALSE;
 }
@@ -4205,6 +4542,72 @@ pause:
   }
 }
 
+static void
+do_handle_sync_inband (GstRtpJitterBuffer * jitterbuffer, guint64 ntpnstime)
+{
+  GstRtpJitterBufferPrivate *priv;
+  GstStructure *s;
+  guint64 base_rtptime, base_time;
+  guint32 clock_rate;
+  guint64 last_rtptime;
+  const gchar *cname = NULL;
+  GList *l;
+
+  priv = jitterbuffer->priv;
+
+  /* get the last values from the jitterbuffer */
+  rtp_jitter_buffer_get_sync (priv->jbuf, &base_rtptime, &base_time,
+      &clock_rate, &last_rtptime);
+
+  for (l = priv->cname_ssrc_mappings; l; l = l->next) {
+    const CNameSSRCMapping *map = l->data;
+
+    if (map->ssrc == priv->last_ssrc) {
+      cname = map->cname;
+      break;
+    }
+  }
+
+  GST_DEBUG_OBJECT (jitterbuffer,
+      "inband NTP-64 %" GST_TIME_FORMAT " rtptime %" G_GUINT64_FORMAT ", base %"
+      G_GUINT64_FORMAT ", clock-rate %" G_GUINT32_FORMAT ", clock-base %"
+      G_GUINT64_FORMAT ", CNAME %s", GST_TIME_ARGS (ntpnstime), last_rtptime,
+      base_rtptime, clock_rate, priv->clock_base, GST_STR_NULL (cname));
+
+  /* no CNAME known yet for this ssrc */
+  if (cname == NULL) {
+    GST_DEBUG_OBJECT (jitterbuffer, "no CNAME for this packet known yet");
+    return;
+  }
+
+  if (priv->last_ntpnstime != GST_CLOCK_TIME_NONE
+      && ntpnstime - priv->last_ntpnstime < priv->sync_interval * GST_MSECOND) {
+    GST_DEBUG_OBJECT (jitterbuffer,
+        "discarding RTCP sender packet for sync; "
+        "previous sender info too recent " "(previous NTP %" G_GUINT64_FORMAT
+        ")", priv->last_ntpnstime);
+    return;
+  }
+  priv->last_ntpnstime = ntpnstime;
+
+  s = gst_structure_new ("application/x-rtp-sync",
+      "base-rtptime", G_TYPE_UINT64, base_rtptime,
+      "base-time", G_TYPE_UINT64, base_time,
+      "clock-rate", G_TYPE_UINT, clock_rate,
+      "clock-base", G_TYPE_UINT64, priv->clock_base,
+      "cname", G_TYPE_STRING, cname,
+      "ssrc", G_TYPE_UINT, priv->last_ssrc,
+      "inband-ext-rtptime", G_TYPE_UINT64, last_rtptime,
+      "inband-ntpnstime", G_TYPE_UINT64, ntpnstime, NULL);
+
+  GST_DEBUG_OBJECT (jitterbuffer, "signaling sync");
+  JBUF_UNLOCK (priv);
+  g_signal_emit (jitterbuffer,
+      gst_rtp_jitter_buffer_signals[SIGNAL_HANDLE_SYNC], 0, s);
+  JBUF_LOCK (priv);
+  gst_structure_free (s);
+}
+
 /* collect the info from the latest RTCP packet and the jitterbuffer sync, do
  * some sanity checks and then emit the handle-sync signal with the parameters.
  * This function must be called with the LOCK */
@@ -4226,12 +4629,14 @@ do_handle_sync (GstRtpJitterBuffer * jitterbuffer)
       &clock_rate, &last_rtptime);
 
   clock_base = priv->clock_base;
-  ext_rtptime = priv->ext_rtptime;
+  ext_rtptime = priv->last_sr_ext_rtptime;
 
-  GST_DEBUG_OBJECT (jitterbuffer, "ext SR %" G_GUINT64_FORMAT ", base %"
-      G_GUINT64_FORMAT ", clock-rate %" G_GUINT32_FORMAT
-      ", clock-base %" G_GUINT64_FORMAT ", last-rtptime %" G_GUINT64_FORMAT,
-      ext_rtptime, base_rtptime, clock_rate, clock_base, last_rtptime);
+  GST_DEBUG_OBJECT (jitterbuffer,
+      "ext SR %" G_GUINT64_FORMAT ", NTP %" G_GUINT64_FORMAT ", base %"
+      G_GUINT64_FORMAT ", clock-rate %" G_GUINT32_FORMAT ", clock-base %"
+      G_GUINT64_FORMAT ", last-rtptime %" G_GUINT64_FORMAT, ext_rtptime,
+      priv->last_sr_ntpnstime, base_rtptime, clock_rate, clock_base,
+      last_rtptime);
 
   if (base_rtptime == -1 || clock_rate == -1 || base_time == -1) {
     /* we keep this SR packet for later. When we get a valid RTP packet the
@@ -4271,15 +4676,27 @@ do_handle_sync (GstRtpJitterBuffer * jitterbuffer)
     GST_DEBUG_OBJECT (jitterbuffer, "keeping RTCP packet for later");
   } else if (valid) {
     GstStructure *s;
+    GList *l;
 
     s = gst_structure_new ("application/x-rtp-sync",
         "base-rtptime", G_TYPE_UINT64, base_rtptime,
         "base-time", G_TYPE_UINT64, base_time,
         "clock-rate", G_TYPE_UINT, clock_rate,
         "clock-base", G_TYPE_UINT64, clock_base,
+        "ssrc", G_TYPE_UINT, priv->last_sr_ssrc,
         "sr-ext-rtptime", G_TYPE_UINT64, ext_rtptime,
+        "sr-ntpnstime", G_TYPE_UINT64, priv->last_sr_ntpnstime,
         "sr-buffer", GST_TYPE_BUFFER, priv->last_sr, NULL);
 
+    for (l = priv->cname_ssrc_mappings; l; l = l->next) {
+      const CNameSSRCMapping *map = l->data;
+
+      if (map->ssrc == priv->last_ssrc) {
+        gst_structure_set (s, "cname", G_TYPE_STRING, map->cname, NULL);
+        break;
+      }
+    }
+
     GST_DEBUG_OBJECT (jitterbuffer, "signaling sync");
     gst_buffer_replace (&priv->last_sr, NULL);
     JBUF_UNLOCK (priv);
@@ -4293,6 +4710,18 @@ do_handle_sync (GstRtpJitterBuffer * jitterbuffer)
   }
 }
 
+#define GST_RTCP_BUFFER_FOR_PACKETS(b,buffer,packet) \
+  for ((b) = gst_rtcp_buffer_get_first_packet ((buffer), (packet)); (b); \
+          (b) = gst_rtcp_packet_move_to_next ((packet)))
+
+#define GST_RTCP_SDES_FOR_ITEMS(b,packet) \
+  for ((b) = gst_rtcp_packet_sdes_first_item ((packet)); (b); \
+          (b) = gst_rtcp_packet_sdes_next_item ((packet)))
+
+#define GST_RTCP_SDES_FOR_ENTRIES(b,packet) \
+  for ((b) = gst_rtcp_packet_sdes_first_entry ((packet)); (b); \
+          (b) = gst_rtcp_packet_sdes_next_entry ((packet)))
+
 static GstFlowReturn
 gst_rtp_jitter_buffer_chain_rtcp (GstPad * pad, GstObject * parent,
     GstBuffer * buffer)
@@ -4302,9 +4731,13 @@ gst_rtp_jitter_buffer_chain_rtcp (GstPad * pad, GstObject * parent,
   GstFlowReturn ret = GST_FLOW_OK;
   guint32 ssrc;
   GstRTCPPacket packet;
-  guint64 ext_rtptime;
+  guint64 ext_rtptime, ntptime;
+  GstClockTime ntpnstime = GST_CLOCK_TIME_NONE;
   guint32 rtptime;
   GstRTCPBuffer rtcp = { NULL, };
+  gchar *cname = NULL;
+  gboolean have_sr = FALSE;
+  gboolean more;
 
   jitterbuffer = GST_RTP_JITTER_BUFFER (parent);
 
@@ -4315,35 +4748,109 @@ gst_rtp_jitter_buffer_chain_rtcp (GstPad * pad, GstObject * parent,
 
   gst_rtcp_buffer_map (buffer, GST_MAP_READ, &rtcp);
 
-  if (!gst_rtcp_buffer_get_first_packet (&rtcp, &packet))
-    goto empty_buffer;
+  GST_RTCP_BUFFER_FOR_PACKETS (more, &rtcp, &packet) {
+    /* first packet must be SR or RR or else the validate would have failed */
+    switch (gst_rtcp_packet_get_type (&packet)) {
+      case GST_RTCP_TYPE_SR:
+        /* only parse first. There is only supposed to be one SR in the packet
+         * but we will deal with malformed packets gracefully by trying the
+         * next RTCP packet */
+        if (have_sr)
+          continue;
 
-  /* first packet must be SR or RR or else the validate would have failed */
-  switch (gst_rtcp_packet_get_type (&packet)) {
-    case GST_RTCP_TYPE_SR:
-      gst_rtcp_packet_sr_get_sender_info (&packet, &ssrc, NULL, &rtptime,
-          NULL, NULL);
-      break;
-    default:
-      goto ignore_buffer;
+        /* get NTP and RTP times */
+        gst_rtcp_packet_sr_get_sender_info (&packet, &ssrc, &ntptime, &rtptime,
+            NULL, NULL);
+
+        /* convert ntptime to nanoseconds */
+        ntpnstime =
+            gst_util_uint64_scale (ntptime, GST_SECOND,
+            G_GUINT64_CONSTANT (1) << 32);
+
+        have_sr = TRUE;
+
+        break;
+      case GST_RTCP_TYPE_SDES:
+      {
+        gboolean more_items;
+
+        /* Bail out if we have not seen an SR item yet. */
+        if (!have_sr)
+          goto ignore_buffer;
+
+        GST_RTCP_SDES_FOR_ITEMS (more_items, &packet) {
+          gboolean more_entries;
+
+          /* skip items that are not about the SSRC of the sender */
+          if (gst_rtcp_packet_sdes_get_ssrc (&packet) != ssrc)
+            continue;
+
+          /* find the CNAME entry */
+          GST_RTCP_SDES_FOR_ENTRIES (more_entries, &packet) {
+            GstRTCPSDESType type;
+            guint8 len;
+            const guint8 *data;
+
+            gst_rtcp_packet_sdes_get_entry (&packet, &type, &len,
+                (guint8 **) & data);
+
+            if (type == GST_RTCP_SDES_CNAME) {
+              cname = g_strndup ((const gchar *) data, len);
+              goto out;
+            }
+          }
+        }
+
+        /* only deal with first SDES, there is only supposed to be one SDES in
+         * the RTCP packet but we deal with bad packets gracefully. */
+        goto out;
+      }
+      default:
+        /* we can ignore these packets */
+        break;
+    }
   }
+out:
   gst_rtcp_buffer_unmap (&rtcp);
 
-  GST_DEBUG_OBJECT (jitterbuffer, "received RTCP of SSRC %08x", ssrc);
+  GST_DEBUG_OBJECT (jitterbuffer, "received RTCP of SSRC %08x from CNAME %s",
+      ssrc, GST_STR_NULL (cname));
+
+  if (!have_sr)
+    goto empty_buffer;
 
   JBUF_LOCK (priv);
+  if (cname)
+    insert_cname_ssrc_mapping (jitterbuffer, cname, ssrc);
+
   /* convert the RTP timestamp to our extended timestamp, using the same offset
    * we used in the jitterbuffer */
   ext_rtptime = priv->jbuf->ext_rtptime;
   ext_rtptime = gst_rtp_buffer_ext_timestamp (&ext_rtptime, rtptime);
 
-  priv->ext_rtptime = ext_rtptime;
-  gst_buffer_replace (&priv->last_sr, buffer);
+  priv->last_sr_ext_rtptime = ext_rtptime;
+  priv->last_sr_ssrc = ssrc;
+  priv->last_sr_ntpnstime = ntpnstime;
+
+  priv->last_known_ext_rtptime = ext_rtptime;
+  priv->last_known_ntpnstime = ntpnstime;
+
+  if (priv->last_ntpnstime != GST_CLOCK_TIME_NONE
+      && ntpnstime - priv->last_ntpnstime < priv->sync_interval * GST_MSECOND) {
+    gst_buffer_replace (&priv->last_sr, NULL);
+    GST_DEBUG_OBJECT (jitterbuffer, "discarding RTCP sender packet for sync; "
+        "previous sender info too recent "
+        "(previous NTP %" G_GUINT64_FORMAT ")", priv->last_ntpnstime);
+  } else {
+    gst_buffer_replace (&priv->last_sr, buffer);
+    do_handle_sync (jitterbuffer);
+    priv->last_ntpnstime = ntpnstime;
+  }
 
-  do_handle_sync (jitterbuffer);
   JBUF_UNLOCK (priv);
 
 done:
+  g_free (cname);
   gst_buffer_unref (buffer);
 
   return ret;
@@ -4688,6 +5195,16 @@ gst_rtp_jitter_buffer_set_property (GObject * object,
       priv->faststart_min_packets = g_value_get_uint (value);
       JBUF_UNLOCK (priv);
       break;
+    case PROP_ADD_REFERENCE_TIMESTAMP_META:
+      JBUF_LOCK (priv);
+      priv->add_reference_timestamp_meta = g_value_get_boolean (value);
+      JBUF_UNLOCK (priv);
+      break;
+    case PROP_SYNC_INTERVAL:
+      JBUF_LOCK (priv);
+      priv->sync_interval = g_value_get_uint (value);
+      JBUF_UNLOCK (priv);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -4844,6 +5361,16 @@ gst_rtp_jitter_buffer_get_property (GObject * object,
       g_value_set_uint (value, priv->faststart_min_packets);
       JBUF_UNLOCK (priv);
       break;
+    case PROP_ADD_REFERENCE_TIMESTAMP_META:
+      JBUF_LOCK (priv);
+      g_value_set_boolean (value, priv->add_reference_timestamp_meta);
+      JBUF_UNLOCK (priv);
+      break;
+    case PROP_SYNC_INTERVAL:
+      JBUF_LOCK (priv);
+      g_value_set_uint (value, priv->sync_interval);
+      JBUF_UNLOCK (priv);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
diff --git a/gst/rtpmanager/gstrtpjitterbuffer.h b/gst/rtpmanager/gstrtpjitterbuffer.h
index debb13b3a..9605e7ba2 100644
--- a/gst/rtpmanager/gstrtpjitterbuffer.h
+++ b/gst/rtpmanager/gstrtpjitterbuffer.h
@@ -82,6 +82,8 @@ struct _GstRtpJitterBufferClass
 
 GType gst_rtp_jitter_buffer_get_type (void);
 
+GST_ELEMENT_REGISTER_DECLARE (rtpjitterbuffer);
+
 G_END_DECLS
 
 #endif /* __GST_RTP_JITTER_BUFFER_H__ */
diff --git a/gst/rtpmanager/gstrtpmanager.c b/gst/rtpmanager/gstrtpmanager.c
index 4ba624fba..59a9eeb3a 100644
--- a/gst/rtpmanager/gstrtpmanager.c
+++ b/gst/rtpmanager/gstrtpmanager.c
@@ -32,53 +32,43 @@
 #include "gstrtpdtmfmux.h"
 #include "gstrtpmux.h"
 #include "gstrtpfunnel.h"
+#include "gstrtpst2022-1-fecdec.h"
+#include "gstrtpst2022-1-fecenc.h"
+#include "gstrtphdrext-twcc.h"
+#include "gstrtphdrext-clientaudiolevel.h"
+#include "gstrtphdrext-mid.h"
+#include "gstrtphdrext-ntp.h"
+#include "gstrtphdrext-repairedstreamid.h"
+#include "gstrtphdrext-streamid.h"
 
 static gboolean
 plugin_init (GstPlugin * plugin)
 {
-  if (!gst_element_register (plugin, "rtpbin", GST_RANK_NONE, GST_TYPE_RTP_BIN))
-    return FALSE;
+  gboolean ret = FALSE;
 
-  if (!gst_element_register (plugin, "rtpjitterbuffer", GST_RANK_NONE,
-          GST_TYPE_RTP_JITTER_BUFFER))
-    return FALSE;
+  ret |= GST_ELEMENT_REGISTER (rtpbin, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpjitterbuffer, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpptdemux, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpsession, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtprtxqueue, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtprtxreceive, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtprtxsend, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpssrcdemux, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpmux, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpdtmfmux, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpfunnel, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpst2022_1_fecdec, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtpst2022_1_fecenc, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtphdrexttwcc, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtphdrextclientaudiolevel, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtphdrextmid, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtphdrextntp64, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtphdrextstreamid, plugin);
+  ret |= GST_ELEMENT_REGISTER (rtphdrextrepairedstreamid, plugin);
 
-  if (!gst_element_register (plugin, "rtpptdemux", GST_RANK_NONE,
-          GST_TYPE_RTP_PT_DEMUX))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpsession", GST_RANK_NONE,
-          GST_TYPE_RTP_SESSION))
-    return FALSE;
-
-  if (!gst_rtp_rtx_queue_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_rtx_receive_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_rtx_send_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpssrcdemux", GST_RANK_NONE,
-          GST_TYPE_RTP_SSRC_DEMUX))
-    return FALSE;
-
-  if (!gst_rtp_mux_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_rtp_dtmf_mux_plugin_init (plugin))
-    return FALSE;
-
-  if (!gst_element_register (plugin, "rtpfunnel", GST_RANK_NONE,
-          GST_TYPE_RTP_FUNNEL))
-    return FALSE;
-
-  return TRUE;
+  return ret;
 }
 
-GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
-    GST_VERSION_MINOR,
-    rtpmanager,
-    "RTP session management plugin library",
-    plugin_init, VERSION, "LGPL", GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
+GST_PLUGIN_DEFINE (GST_VERSION_MAJOR, GST_VERSION_MINOR, rtpmanager,
+    "RTP session management plugin library", plugin_init, VERSION, "LGPL",
+    GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
diff --git a/gst/rtpmanager/gstrtpmux.c b/gst/rtpmanager/gstrtpmux.c
index 4d16d5d3c..6387c655c 100644
--- a/gst/rtpmanager/gstrtpmux.c
+++ b/gst/rtpmanager/gstrtpmux.c
@@ -112,8 +112,9 @@ static void gst_rtp_mux_dispose (GObject * object);
 static gboolean gst_rtp_mux_src_event_real (GstRTPMux * rtp_mux,
     GstEvent * event);
 
-G_DEFINE_TYPE (GstRTPMux, gst_rtp_mux, GST_TYPE_ELEMENT);
-
+G_DEFINE_TYPE_WITH_CODE (GstRTPMux, gst_rtp_mux, GST_TYPE_ELEMENT,
+    GST_DEBUG_CATEGORY_INIT (gst_rtp_mux_debug, "rtpmux", 0, "rtp muxer"));
+GST_ELEMENT_REGISTER_DEFINE (rtpmux, "rtpmux", GST_RANK_NONE, GST_TYPE_RTP_MUX);
 
 static void
 gst_rtp_mux_class_init (GstRTPMuxClass * klass)
@@ -1013,12 +1014,3 @@ gst_rtp_mux_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-gboolean
-gst_rtp_mux_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (gst_rtp_mux_debug, "rtpmux", 0, "rtp muxer");
-
-  return gst_element_register (plugin, "rtpmux", GST_RANK_NONE,
-      GST_TYPE_RTP_MUX);
-}
diff --git a/gst/rtpmanager/gstrtpmux.h b/gst/rtpmanager/gstrtpmux.h
index 65343da3a..82d00c7d3 100644
--- a/gst/rtpmanager/gstrtpmux.h
+++ b/gst/rtpmanager/gstrtpmux.h
@@ -88,9 +88,9 @@ struct _GstRTPMuxClass
   gboolean (*src_event) (GstRTPMux *rtp_mux, GstEvent *event);
 };
 
-
 GType gst_rtp_mux_get_type (void);
-gboolean gst_rtp_mux_plugin_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (rtpmux);
 
 G_END_DECLS
 #endif /* __GST_RTP_MUX_H__ */
diff --git a/gst/rtpmanager/gstrtpptdemux.c b/gst/rtpmanager/gstrtpptdemux.c
index 56ce75161..5cbbc7264 100644
--- a/gst/rtpmanager/gstrtpptdemux.c
+++ b/gst/rtpmanager/gstrtpptdemux.c
@@ -122,6 +122,8 @@ enum
 
 #define gst_rtp_pt_demux_parent_class parent_class
 G_DEFINE_TYPE (GstRtpPtDemux, gst_rtp_pt_demux, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE (rtpptdemux, "rtpptdemux", GST_RANK_NONE,
+    GST_TYPE_RTP_PT_DEMUX);
 
 static void gst_rtp_pt_demux_finalize (GObject * object);
 
@@ -475,8 +477,12 @@ gst_rtp_pt_demux_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
     if (!caps)
       goto no_caps;
 
-    if (gst_rtp_pt_demux_pt_is_ignored (rtpdemux, pt))
+    /* must be after the get_caps() call as get_caps() may cause external code
+     * (e.g. rtpbin) to update the ignored-pt list */
+    if (gst_rtp_pt_demux_pt_is_ignored (rtpdemux, pt)) {
+      gst_clear_caps (&caps);
       goto ignored;
+    }
 
     klass = GST_ELEMENT_GET_CLASS (rtpdemux);
     templ = gst_element_class_get_pad_template (klass, "src_%u");
@@ -561,7 +567,7 @@ invalid_buffer:
     GST_ELEMENT_WARNING (rtpdemux, STREAM, DEMUX, (NULL),
         ("Dropping invalid RTP payload"));
     gst_buffer_unref (buf);
-    return GST_FLOW_ERROR;
+    return GST_FLOW_OK;
   }
 no_caps:
   {
diff --git a/gst/rtpmanager/gstrtpptdemux.h b/gst/rtpmanager/gstrtpptdemux.h
index 4beae863b..9ba4f7767 100644
--- a/gst/rtpmanager/gstrtpptdemux.h
+++ b/gst/rtpmanager/gstrtpptdemux.h
@@ -60,4 +60,6 @@ struct _GstRtpPtDemuxClass
 
 GType gst_rtp_pt_demux_get_type (void);
 
+GST_ELEMENT_REGISTER_DECLARE (rtpptdemux);
+
 #endif /* __GST_RTP_PT_DEMUX_H__ */
diff --git a/gst/rtpmanager/gstrtprtxqueue.c b/gst/rtpmanager/gstrtprtxqueue.c
index 97678eb35..e098eb9c2 100644
--- a/gst/rtpmanager/gstrtprtxqueue.c
+++ b/gst/rtpmanager/gstrtprtxqueue.c
@@ -122,7 +122,11 @@ static void gst_rtp_rtx_queue_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
 static void gst_rtp_rtx_queue_finalize (GObject * object);
 
-G_DEFINE_TYPE (GstRTPRtxQueue, gst_rtp_rtx_queue, GST_TYPE_ELEMENT);
+G_DEFINE_TYPE_WITH_CODE (GstRTPRtxQueue, gst_rtp_rtx_queue, GST_TYPE_ELEMENT,
+    GST_DEBUG_CATEGORY_INIT (gst_rtp_rtx_queue_debug, "rtprtxqueue", 0,
+        "rtp retransmission queue"));
+GST_ELEMENT_REGISTER_DEFINE (rtprtxqueue, "rtprtxqueue", GST_RANK_NONE,
+    GST_TYPE_RTP_RTX_QUEUE);
 
 static void
 gst_rtp_rtx_queue_class_init (GstRTPRtxQueueClass * klass)
@@ -514,13 +518,3 @@ gst_rtp_rtx_queue_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-gboolean
-gst_rtp_rtx_queue_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (gst_rtp_rtx_queue_debug, "rtprtxqueue", 0,
-      "rtp retransmission queue");
-
-  return gst_element_register (plugin, "rtprtxqueue", GST_RANK_NONE,
-      GST_TYPE_RTP_RTX_QUEUE);
-}
diff --git a/gst/rtpmanager/gstrtprtxqueue.h b/gst/rtpmanager/gstrtprtxqueue.h
index bee8d44af..92269732e 100644
--- a/gst/rtpmanager/gstrtprtxqueue.h
+++ b/gst/rtpmanager/gstrtprtxqueue.h
@@ -72,9 +72,9 @@ struct _GstRTPRtxQueueClass
   GstElementClass parent_class;
 };
 
-
 GType gst_rtp_rtx_queue_get_type (void);
-gboolean gst_rtp_rtx_queue_plugin_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (rtprtxqueue);
 
 G_END_DECLS
 #endif /* __GST_RTP_RTX_QUEUE_H__ */
diff --git a/gst/rtpmanager/gstrtprtxreceive.c b/gst/rtpmanager/gstrtprtxreceive.c
index 77fe78493..274ceed22 100644
--- a/gst/rtpmanager/gstrtprtxreceive.c
+++ b/gst/rtpmanager/gstrtprtxreceive.c
@@ -145,7 +145,7 @@
 #endif
 
 #include <gst/gst.h>
-#include <gst/rtp/gstrtpbuffer.h>
+#include <gst/rtp/rtp.h>
 #include <string.h>
 #include <stdlib.h>
 
@@ -159,12 +159,26 @@ GST_DEBUG_CATEGORY_STATIC (gst_rtp_rtx_receive_debug);
 enum
 {
   PROP_0,
+  PROP_SSRC_MAP,
   PROP_PAYLOAD_TYPE_MAP,
   PROP_NUM_RTX_REQUESTS,
   PROP_NUM_RTX_PACKETS,
   PROP_NUM_RTX_ASSOC_PACKETS
 };
 
+enum
+{
+  SIGNAL_0,
+  SIGNAL_ADD_EXTENSION,
+  SIGNAL_CLEAR_EXTENSIONS,
+  LAST_SIGNAL
+};
+
+static guint gst_rtp_rtx_receive_signals[LAST_SIGNAL] = { 0, };
+
+#define RTPHDREXT_STREAM_ID GST_RTP_HDREXT_BASE "sdes:rtp-stream-id"
+#define RTPHDREXT_REPAIRED_STREAM_ID GST_RTP_HDREXT_BASE "sdes:repaired-rtp-stream-id"
+
 static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
@@ -191,7 +205,45 @@ static void gst_rtp_rtx_receive_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
 static void gst_rtp_rtx_receive_finalize (GObject * object);
 
-G_DEFINE_TYPE (GstRtpRtxReceive, gst_rtp_rtx_receive, GST_TYPE_ELEMENT);
+G_DEFINE_TYPE_WITH_CODE (GstRtpRtxReceive, gst_rtp_rtx_receive,
+    GST_TYPE_ELEMENT, GST_DEBUG_CATEGORY_INIT (gst_rtp_rtx_receive_debug,
+        "rtprtxreceive", 0, "rtp retransmission receiver"));
+GST_ELEMENT_REGISTER_DEFINE (rtprtxreceive, "rtprtxreceive", GST_RANK_NONE,
+    GST_TYPE_RTP_RTX_RECEIVE);
+
+static void
+gst_rtp_rtx_receive_add_extension (GstRtpRtxReceive * rtx,
+    GstRTPHeaderExtension * ext)
+{
+  g_return_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext));
+  g_return_if_fail (gst_rtp_header_extension_get_id (ext) > 0);
+
+  GST_OBJECT_LOCK (rtx);
+  if (g_strcmp0 (gst_rtp_header_extension_get_uri (ext),
+          RTPHDREXT_STREAM_ID) == 0) {
+    gst_clear_object (&rtx->rid_stream);
+    rtx->rid_stream = gst_object_ref (ext);
+  } else if (g_strcmp0 (gst_rtp_header_extension_get_uri (ext),
+          RTPHDREXT_REPAIRED_STREAM_ID) == 0) {
+    gst_clear_object (&rtx->rid_repaired);
+    rtx->rid_repaired = gst_object_ref (ext);
+  } else {
+    g_warning ("rtprtxsend (%s) doesn't know how to deal with the "
+        "RTP Header Extension with URI \'%s\'", GST_OBJECT_NAME (rtx),
+        gst_rtp_header_extension_get_uri (ext));
+  }
+  /* XXX: check for other duplicate ids? */
+  GST_OBJECT_UNLOCK (rtx);
+}
+
+static void
+gst_rtp_rtx_receive_clear_extensions (GstRtpRtxReceive * rtx)
+{
+  GST_OBJECT_LOCK (rtx);
+  gst_clear_object (&rtx->rid_stream);
+  gst_clear_object (&rtx->rid_repaired);
+  GST_OBJECT_UNLOCK (rtx);
+}
 
 static void
 gst_rtp_rtx_receive_class_init (GstRtpRtxReceiveClass * klass)
@@ -206,6 +258,22 @@ gst_rtp_rtx_receive_class_init (GstRtpRtxReceiveClass * klass)
   gobject_class->set_property = gst_rtp_rtx_receive_set_property;
   gobject_class->finalize = gst_rtp_rtx_receive_finalize;
 
+  /**
+   * GstRtpRtxReceive:ssrc-map:
+   *
+   * Map of SSRCs to their retransmission SSRCs for SSRC-multiplexed mode.
+   *
+   * If an application know this information already (WebRTC signals this
+   * in their SDP), it can allow the rtxreceive element to know a packet
+   * is a "valid" RTX packet even if it has not been requested.
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class, PROP_SSRC_MAP,
+      g_param_spec_boxed ("ssrc-map", "SSRC Map",
+          "Map of SSRCs to their retransmission SSRCs for SSRC-multiplexed mode",
+          GST_TYPE_STRUCTURE, G_PARAM_WRITABLE | G_PARAM_STATIC_STRINGS));
+
   g_object_class_install_property (gobject_class, PROP_PAYLOAD_TYPE_MAP,
       g_param_spec_boxed ("payload-type-map", "Payload Type Map",
           "Map of original payload types to their retransmission payload types",
@@ -227,6 +295,38 @@ gst_rtp_rtx_receive_class_init (GstRtpRtxReceiveClass * klass)
           "correctly associated with retransmission requests", 0, G_MAXUINT,
           0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * rtprtxreceive::add-extension:
+   *
+   * Add @ext as an extension for writing part of an RTP header extension onto
+   * outgoing RTP packets.  Currently only supports using the following
+   * extension URIs. All other RTP header extensions are copied as-is.
+   *   - "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id": will be removed
+   *   - "urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id": will be
+   *     written instead of the "rtp-stream-id" header extension.
+   *
+   * Since: 1.22
+   */
+  gst_rtp_rtx_receive_signals[SIGNAL_ADD_EXTENSION] =
+      g_signal_new_class_handler ("add-extension", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_rtx_receive_add_extension), NULL, NULL, NULL,
+      G_TYPE_NONE, 1, GST_TYPE_RTP_HEADER_EXTENSION);
+
+  /**
+   * rtprtxreceive::clear-extensions:
+   * @object: the #GstRTPBasePayload
+   *
+   * Clear all RTP header extensions used by rtprtxreceive.
+   *
+   * Since: 1.22
+   */
+  gst_rtp_rtx_receive_signals[SIGNAL_CLEAR_EXTENSIONS] =
+      g_signal_new_class_handler ("clear-extensions", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_rtx_receive_clear_extensions), NULL, NULL, NULL,
+      G_TYPE_NONE, 0);
+
   gst_element_class_add_static_pad_template (gstelement_class, &src_factory);
   gst_element_class_add_static_pad_template (gstelement_class, &sink_factory);
 
@@ -254,14 +354,21 @@ gst_rtp_rtx_receive_reset (GstRtpRtxReceive * rtx)
 static void
 gst_rtp_rtx_receive_finalize (GObject * object)
 {
-  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE (object);
+  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE_CAST (object);
 
   g_hash_table_unref (rtx->ssrc2_ssrc1_map);
+  if (rtx->external_ssrc_map)
+    gst_structure_free (rtx->external_ssrc_map);
   g_hash_table_unref (rtx->seqnum_ssrc1_map);
   g_hash_table_unref (rtx->rtx_pt_map);
   if (rtx->rtx_pt_map_structure)
     gst_structure_free (rtx->rtx_pt_map_structure);
 
+  gst_clear_object (&rtx->rid_stream);
+  gst_clear_object (&rtx->rid_repaired);
+
+  gst_clear_buffer (&rtx->dummy_writable);
+
   G_OBJECT_CLASS (gst_rtp_rtx_receive_parent_class)->finalize (object);
 }
 
@@ -316,13 +423,15 @@ gst_rtp_rtx_receive_init (GstRtpRtxReceive * rtx)
       NULL, (GDestroyNotify) ssrc_assoc_free);
 
   rtx->rtx_pt_map = g_hash_table_new (g_direct_hash, g_direct_equal);
+
+  rtx->dummy_writable = gst_buffer_new ();
 }
 
 static gboolean
 gst_rtp_rtx_receive_src_event (GstPad * pad, GstObject * parent,
     GstEvent * event)
 {
-  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE (parent);
+  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE_CAST (parent);
   gboolean res;
 
   switch (GST_EVENT_TYPE (event)) {
@@ -442,13 +551,169 @@ gst_rtp_rtx_receive_src_event (GstPad * pad, GstObject * parent,
   return res;
 }
 
+static GstMemory *
+rewrite_header_extensions (GstRtpRtxReceive * rtx, GstRTPBuffer * rtp)
+{
+  gsize out_size = rtp->size[1] + 32;
+  guint16 bit_pattern;
+  guint8 *pdata;
+  guint wordlen;
+  GstMemory *mem;
+  GstMapInfo map;
+
+  mem = gst_allocator_alloc (NULL, out_size, NULL);
+
+  gst_memory_map (mem, &map, GST_MAP_READWRITE);
+
+  if (gst_rtp_buffer_get_extension_data (rtp, &bit_pattern, (gpointer) & pdata,
+          &wordlen)) {
+    GstRTPHeaderExtensionFlags ext_flags = 0;
+    gsize bytelen = wordlen * 4;
+    guint hdr_unit_bytes;
+    gsize read_offset = 0, write_offset = 4;
+
+    if (bit_pattern == 0xBEDE) {
+      /* one byte extensions */
+      hdr_unit_bytes = 1;
+      ext_flags |= GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+    } else if (bit_pattern >> 4 == 0x100) {
+      /* two byte extensions */
+      hdr_unit_bytes = 2;
+      ext_flags |= GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+    } else {
+      GST_DEBUG_OBJECT (rtx, "unknown extension bit pattern 0x%02x%02x",
+          bit_pattern >> 8, bit_pattern & 0xff);
+      goto copy_as_is;
+    }
+
+    GST_WRITE_UINT16_BE (map.data, bit_pattern);
+
+    while (TRUE) {
+      guint8 read_id, read_len;
+
+      if (read_offset + hdr_unit_bytes >= bytelen)
+        /* not enough remaning data */
+        break;
+
+      if (ext_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+        read_id = GST_READ_UINT8 (pdata + read_offset) >> 4;
+        read_len = (GST_READ_UINT8 (pdata + read_offset) & 0x0F) + 1;
+        read_offset += 1;
+
+        if (read_id == 0)
+          /* padding */
+          continue;
+
+        if (read_id == 15)
+          /* special id for possible future expansion */
+          break;
+      } else {
+        read_id = GST_READ_UINT8 (pdata + read_offset);
+        read_offset += 1;
+
+        if (read_id == 0)
+          /* padding */
+          continue;
+
+        read_len = GST_READ_UINT8 (pdata + read_offset);
+        read_offset += 1;
+      }
+      GST_TRACE_OBJECT (rtx, "found rtp header extension with id %u and "
+          "length %u", read_id, read_len);
+
+      /* Ignore extension headers where the size does not fit */
+      if (read_offset + read_len > bytelen) {
+        GST_WARNING_OBJECT (rtx, "Extension length extends past the "
+            "size of the extension data");
+        break;
+      }
+
+      /* rewrite the rtp-stream-id into a repaired-stream-id */
+      if (rtx->rid_stream
+          && read_id == gst_rtp_header_extension_get_id (rtx->rid_repaired)) {
+        if (!gst_rtp_header_extension_read (rtx->rid_repaired, ext_flags,
+                &pdata[read_offset], read_len, rtx->dummy_writable)) {
+          GST_WARNING_OBJECT (rtx, "RTP header extension (%s) could "
+              "not read payloaded data", GST_OBJECT_NAME (rtx->rid_stream));
+          goto copy_as_is;
+        }
+        if (rtx->rid_repaired) {
+          guint8 write_id = gst_rtp_header_extension_get_id (rtx->rid_stream);
+          gsize written;
+          char *rid;
+
+          g_object_get (rtx->rid_repaired, "rid", &rid, NULL);
+          g_object_set (rtx->rid_stream, "rid", rid, NULL);
+          g_clear_pointer (&rid, g_free);
+
+          written =
+              gst_rtp_header_extension_write (rtx->rid_stream, rtp->buffer,
+              ext_flags, rtx->dummy_writable,
+              &map.data[write_offset + hdr_unit_bytes],
+              map.size - write_offset - hdr_unit_bytes);
+          GST_TRACE_OBJECT (rtx->rid_repaired, "wrote %" G_GSIZE_FORMAT,
+              written);
+          if (written <= 0) {
+            GST_WARNING_OBJECT (rtx, "Failed to rewrite RID for RTX");
+            goto copy_as_is;
+          } else {
+            if (ext_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+              map.data[write_offset] =
+                  ((write_id & 0x0F) << 4) | ((written - 1) & 0x0F);
+            } else if (ext_flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) {
+              map.data[write_offset] = write_id & 0xFF;
+              map.data[write_offset + 1] = written & 0xFF;
+            } else {
+              g_assert_not_reached ();
+              goto copy_as_is;
+            }
+            write_offset += written + hdr_unit_bytes;
+          }
+        }
+      } else {
+        /* TODO: may need to write mid at different times to the original
+         * buffer to account for the difference in timing of acknowledgement
+         * of the rtx ssrc from the original ssrc.  This may add extra data to
+         * the header extension space that needs to be accounted for.
+         */
+        memcpy (&map.data[write_offset],
+            &pdata[read_offset - hdr_unit_bytes], read_len + hdr_unit_bytes);
+        write_offset += read_len + hdr_unit_bytes;
+      }
+
+      read_offset += read_len;
+    }
+
+    /* subtract the ext header */
+    wordlen = write_offset / 4 + ((write_offset % 4) ? 1 : 0);
+
+    /* wordlen in the ext data doesn't include the 4-byte header */
+    GST_WRITE_UINT16_BE (map.data + 2, wordlen - 1);
+
+    if (wordlen * 4 > write_offset)
+      memset (&map.data[write_offset], 0, wordlen * 4 - write_offset);
+
+    GST_MEMDUMP_OBJECT (rtx, "generated ext data", map.data, wordlen * 4);
+  } else {
+  copy_as_is:
+    wordlen = rtp->size[1] / 4;
+    memcpy (map.data, rtp->data[1], rtp->size[1]);
+    GST_LOG_OBJECT (rtx, "copying data as-is");
+  }
+
+  gst_memory_unmap (mem, &map);
+  gst_memory_resize (mem, 0, wordlen * 4);
+
+  return mem;
+}
+
 /* Copy fixed header and extension. Replace current ssrc by ssrc1,
  * remove OSN and replace current seq num by OSN.
  * Copy memory to avoid to manually copy each rtp buffer field.
  */
 static GstBuffer *
-_gst_rtp_buffer_new_from_rtx (GstRTPBuffer * rtp, guint32 ssrc1,
-    guint16 orign_seqnum, guint8 origin_payload_type)
+_gst_rtp_buffer_new_from_rtx (GstRtpRtxReceive * rtx, GstRTPBuffer * rtp,
+    guint32 ssrc1, guint16 orign_seqnum, guint8 origin_payload_type)
 {
   GstMemory *mem = NULL;
   GstRTPBuffer new_rtp = GST_RTP_BUFFER_INIT;
@@ -463,18 +728,17 @@ _gst_rtp_buffer_new_from_rtx (GstRTPBuffer * rtp, guint32 ssrc1,
 
   /* copy extension if any */
   if (rtp->size[1]) {
-    mem = gst_memory_copy (rtp->map[1].memory,
-        (guint8 *) rtp->data[1] - rtp->map[1].data, rtp->size[1]);
+    mem = rewrite_header_extensions (rtx, rtp);
     gst_buffer_append_memory (new_buffer, mem);
   }
 
   /* copy payload and remove OSN */
+  g_assert_cmpint (rtp->size[2], >, 1);
   payload_len = rtp->size[2] - 2;
   mem = gst_allocator_alloc (NULL, payload_len, NULL);
 
   gst_memory_map (mem, &map, GST_MAP_WRITE);
-  if (rtp->size[2])
-    memcpy (map.data, (guint8 *) rtp->data[2] + 2, payload_len);
+  memcpy (map.data, (guint8 *) rtp->data[2] + 2, payload_len);
   gst_memory_unmap (mem, &map);
   gst_buffer_append_memory (new_buffer, mem);
 
@@ -511,7 +775,7 @@ _gst_rtp_buffer_new_from_rtx (GstRTPBuffer * rtp, guint32 ssrc1,
 static GstFlowReturn
 gst_rtp_rtx_receive_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 {
-  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE (parent);
+  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE_CAST (parent);
   GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
   GstFlowReturn ret = GST_FLOW_OK;
   GstBuffer *new_buffer = NULL;
@@ -526,10 +790,17 @@ gst_rtp_rtx_receive_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   gboolean is_rtx;
   gboolean drop = FALSE;
 
+  if (rtx->rtx_pt_map_structure == NULL)
+    goto no_map;
+
   /* map current rtp packet to parse its header */
   if (!gst_rtp_buffer_map (buffer, GST_MAP_READ, &rtp))
     goto invalid_buffer;
 
+  GST_MEMDUMP_OBJECT (rtx, "rtp header", rtp.map[0].data, rtp.map[0].size);
+  GST_MEMDUMP_OBJECT (rtx, "rtp ext", rtp.map[1].data, rtp.map[1].size);
+  GST_MEMDUMP_OBJECT (rtx, "rtp payload", rtp.map[2].data, rtp.map[2].size);
+
   ssrc = gst_rtp_buffer_get_ssrc (&rtp);
   seqnum = gst_rtp_buffer_get_seq (&rtp);
   payload_type = gst_rtp_buffer_get_payload_type (&rtp);
@@ -575,67 +846,76 @@ gst_rtp_rtx_receive_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
     /* increase our statistic */
     ++rtx->num_rtx_packets;
 
-    /* read OSN in the rtx payload */
-    orign_seqnum = GST_READ_UINT16_BE (gst_rtp_buffer_get_payload (&rtp));
-    origin_payload_type =
-        GPOINTER_TO_UINT (g_hash_table_lookup (rtx->rtx_pt_map,
-            GUINT_TO_POINTER (payload_type)));
-
-    GST_DEBUG_OBJECT (rtx, "Got rtx packet: rtx seqnum %u, rtx ssrc %X, "
-        "rtx pt %u, orig seqnum %u, orig pt %u", seqnum, ssrc, payload_type,
-        orign_seqnum, origin_payload_type);
-
-    /* first we check if we already have associated this retransmission stream
-     * to a master stream */
-    if (g_hash_table_lookup_extended (rtx->ssrc2_ssrc1_map,
-            GUINT_TO_POINTER (ssrc), NULL, &ssrc1)) {
-      GST_TRACE_OBJECT (rtx,
-          "packet is from retransmission stream %X already associated to "
-          "master stream %X", ssrc, GPOINTER_TO_UINT (ssrc1));
-      ssrc2 = ssrc;
-    } else {
-      SsrcAssoc *assoc;
-
-      /* the current retransmitted packet has its rtx stream not already
-       * associated to a master stream, so retrieve it from our request
-       * history */
-      if (g_hash_table_lookup_extended (rtx->seqnum_ssrc1_map,
-              GUINT_TO_POINTER (orign_seqnum), NULL, (gpointer *) & assoc)) {
-        GST_LOG_OBJECT (rtx,
-            "associating retransmitted stream %X to master stream %X thanks "
-            "to rtx packet %u (orig seqnum %u)", ssrc, assoc->ssrc, seqnum,
-            orign_seqnum);
-        ssrc1 = GUINT_TO_POINTER (assoc->ssrc);
+    /* check if there enough data to read OSN from the paylaod,
+       we need at least two bytes
+     */
+    if (gst_rtp_buffer_get_payload_len (&rtp) > 1) {
+      /* read OSN in the rtx payload */
+      orign_seqnum = GST_READ_UINT16_BE (gst_rtp_buffer_get_payload (&rtp));
+      origin_payload_type =
+          GPOINTER_TO_UINT (g_hash_table_lookup (rtx->rtx_pt_map,
+              GUINT_TO_POINTER (payload_type)));
+
+      GST_DEBUG_OBJECT (rtx, "Got rtx packet: rtx seqnum %u, rtx ssrc %X, "
+          "rtx pt %u, orig seqnum %u, orig pt %u", seqnum, ssrc, payload_type,
+          orign_seqnum, origin_payload_type);
+
+      /* first we check if we already have associated this retransmission stream
+       * to a master stream */
+      if (g_hash_table_lookup_extended (rtx->ssrc2_ssrc1_map,
+              GUINT_TO_POINTER (ssrc), NULL, &ssrc1)) {
+        GST_TRACE_OBJECT (rtx,
+            "packet is from retransmission stream %X already associated to "
+            "master stream %X", ssrc, GPOINTER_TO_UINT (ssrc1));
         ssrc2 = ssrc;
-
-        /* just put a guard */
-        if (GPOINTER_TO_UINT (ssrc1) == ssrc2)
-          GST_WARNING_OBJECT (rtx, "RTX receiver ssrc2_ssrc1_map bad state, "
-              "master and rtx SSRCs are the same (%X)\n", ssrc);
-
-        /* free the spot so that this seqnum can be used to do another
-         * association */
-        g_hash_table_remove (rtx->seqnum_ssrc1_map,
-            GUINT_TO_POINTER (orign_seqnum));
-
-        /* actually do the association between rtx stream and master stream */
-        g_hash_table_insert (rtx->ssrc2_ssrc1_map, GUINT_TO_POINTER (ssrc2),
-            ssrc1);
-
-        /* also do the association between master stream and rtx stream
-         * every ssrc are unique so we can use the same hash table
-         * for both retrieving the ssrc1 from ssrc2 and also ssrc2 from ssrc1
-         */
-        g_hash_table_insert (rtx->ssrc2_ssrc1_map, ssrc1,
-            GUINT_TO_POINTER (ssrc2));
-
       } else {
-        /* we are not able to associate this rtx packet with a master stream */
-        GST_INFO_OBJECT (rtx,
-            "dropping rtx packet %u because its orig seqnum (%u) is not in our"
-            " pending retransmission requests", seqnum, orign_seqnum);
-        drop = TRUE;
+        SsrcAssoc *assoc;
+
+        /* the current retransmitted packet has its rtx stream not already
+         * associated to a master stream, so retrieve it from our request
+         * history */
+        if (g_hash_table_lookup_extended (rtx->seqnum_ssrc1_map,
+                GUINT_TO_POINTER (orign_seqnum), NULL, (gpointer *) & assoc)) {
+          GST_LOG_OBJECT (rtx,
+              "associating retransmitted stream %X to master stream %X thanks "
+              "to rtx packet %u (orig seqnum %u)", ssrc, assoc->ssrc, seqnum,
+              orign_seqnum);
+          ssrc1 = GUINT_TO_POINTER (assoc->ssrc);
+          ssrc2 = ssrc;
+
+          /* just put a guard */
+          if (GPOINTER_TO_UINT (ssrc1) == ssrc2)
+            GST_WARNING_OBJECT (rtx, "RTX receiver ssrc2_ssrc1_map bad state, "
+                "master and rtx SSRCs are the same (%X)\n", ssrc);
+
+          /* free the spot so that this seqnum can be used to do another
+           * association */
+          g_hash_table_remove (rtx->seqnum_ssrc1_map,
+              GUINT_TO_POINTER (orign_seqnum));
+
+          /* actually do the association between rtx stream and master stream */
+          g_hash_table_insert (rtx->ssrc2_ssrc1_map, GUINT_TO_POINTER (ssrc2),
+              ssrc1);
+
+          /* also do the association between master stream and rtx stream
+           * every ssrc are unique so we can use the same hash table
+           * for both retrieving the ssrc1 from ssrc2 and also ssrc2 from ssrc1
+           */
+          g_hash_table_insert (rtx->ssrc2_ssrc1_map, ssrc1,
+              GUINT_TO_POINTER (ssrc2));
+
+        } else {
+          /* we are not able to associate this rtx packet with a master stream */
+          GST_INFO_OBJECT (rtx,
+              "dropping rtx packet %u because its orig seqnum (%u) is not in our"
+              " pending retransmission requests", seqnum, orign_seqnum);
+          drop = TRUE;
+        }
       }
+    } else {
+      /* the rtx packet is empty */
+      GST_DEBUG_OBJECT (rtx, "drop rtx packet because it is empty");
+      drop = TRUE;
     }
   }
 
@@ -655,7 +935,7 @@ gst_rtp_rtx_receive_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
   /* create the retransmission packet */
   if (is_rtx)
     new_buffer =
-        _gst_rtp_buffer_new_from_rtx (&rtp, GPOINTER_TO_UINT (ssrc1),
+        _gst_rtp_buffer_new_from_rtx (rtx, &rtp, GPOINTER_TO_UINT (ssrc1),
         orign_seqnum, origin_payload_type);
 
   gst_rtp_buffer_unmap (&rtp);
@@ -675,10 +955,14 @@ gst_rtp_rtx_receive_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 
   return ret;
 
+no_map:
+  {
+    GST_DEBUG_OBJECT (pad, "No map set, passthrough");
+    return gst_pad_push (rtx->srcpad, buffer);
+  }
 invalid_buffer:
   {
-    GST_ELEMENT_WARNING (rtx, STREAM, DECODE, (NULL),
-        ("Received invalid RTP payload, dropping"));
+    GST_INFO_OBJECT (pad, "Received invalid RTP payload, dropping");
     gst_buffer_unref (buffer);
     return GST_FLOW_OK;
   }
@@ -688,7 +972,7 @@ static void
 gst_rtp_rtx_receive_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec)
 {
-  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE (object);
+  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE_CAST (object);
 
   switch (prop_id) {
     case PROP_PAYLOAD_TYPE_MAP:
@@ -738,9 +1022,19 @@ static void
 gst_rtp_rtx_receive_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec)
 {
-  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE (object);
+  GstRtpRtxReceive *rtx = GST_RTP_RTX_RECEIVE_CAST (object);
 
   switch (prop_id) {
+    case PROP_SSRC_MAP:
+      GST_OBJECT_LOCK (rtx);
+      if (rtx->external_ssrc_map)
+        gst_structure_free (rtx->external_ssrc_map);
+      rtx->external_ssrc_map = g_value_dup_boxed (value);
+      g_hash_table_remove_all (rtx->ssrc2_ssrc1_map);
+      gst_structure_foreach (rtx->external_ssrc_map,
+          structure_to_hash_table_inv, rtx->ssrc2_ssrc1_map);
+      GST_OBJECT_UNLOCK (rtx);
+      break;
     case PROP_PAYLOAD_TYPE_MAP:
       GST_OBJECT_LOCK (rtx);
       if (rtx->rtx_pt_map_structure)
@@ -764,7 +1058,7 @@ gst_rtp_rtx_receive_change_state (GstElement * element,
   GstStateChangeReturn ret;
   GstRtpRtxReceive *rtx;
 
-  rtx = GST_RTP_RTX_RECEIVE (element);
+  rtx = GST_RTP_RTX_RECEIVE_CAST (element);
 
   switch (transition) {
     default:
@@ -785,13 +1079,3 @@ gst_rtp_rtx_receive_change_state (GstElement * element,
 
   return ret;
 }
-
-gboolean
-gst_rtp_rtx_receive_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (gst_rtp_rtx_receive_debug, "rtprtxreceive", 0,
-      "rtp retransmission receiver");
-
-  return gst_element_register (plugin, "rtprtxreceive", GST_RANK_NONE,
-      GST_TYPE_RTP_RTX_RECEIVE);
-}
diff --git a/gst/rtpmanager/gstrtprtxreceive.h b/gst/rtpmanager/gstrtprtxreceive.h
index cf6c4a9f5..833c0a2fb 100644
--- a/gst/rtpmanager/gstrtprtxreceive.h
+++ b/gst/rtpmanager/gstrtprtxreceive.h
@@ -25,17 +25,19 @@
 #define __GST_RTP_RTX_RECEIVE_H__
 
 #include <gst/gst.h>
-#include <gst/rtp/gstrtpbuffer.h>
+#include <gst/rtp/rtp.h>
 
 G_BEGIN_DECLS
+typedef struct _GstRtpRtxReceive GstRtpRtxReceive;
+typedef struct _GstRtpRtxReceiveClass GstRtpRtxReceiveClass;
+
 #define GST_TYPE_RTP_RTX_RECEIVE (gst_rtp_rtx_receive_get_type())
 #define GST_RTP_RTX_RECEIVE(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_RTX_RECEIVE, GstRtpRtxReceive))
 #define GST_RTP_RTX_RECEIVE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_RTX_RECEIVE, GstRtpRtxReceiveClass))
 #define GST_RTP_RTX_RECEIVE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_RTX_RECEIVE, GstRtpRtxReceiveClass))
 #define GST_IS_RTP_RTX_RECEIVE(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_RTX_RECEIVE))
 #define GST_IS_RTP_RTX_RECEIVE_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_RTX_RECEIVE))
-typedef struct _GstRtpRtxReceive GstRtpRtxReceive;
-typedef struct _GstRtpRtxReceiveClass GstRtpRtxReceiveClass;
+#define GST_RTP_RTX_RECEIVE_CAST(obj) ((GstRtpRtxReceive *)(obj))
 
 struct _GstRtpRtxReceive
 {
@@ -50,6 +52,8 @@ struct _GstRtpRtxReceive
    * as we make sure all ssrc are unique */
   GHashTable *ssrc2_ssrc1_map;
 
+  GstStructure *external_ssrc_map;
+
   /* contains seqnum of request packets of whom their ssrc have
    * not been associated to a rtx stream yet */
   GHashTable *seqnum_ssrc1_map;
@@ -65,6 +69,11 @@ struct _GstRtpRtxReceive
   guint num_rtx_assoc_packets;
 
   GstClockTime last_time;
+
+  GstRTPHeaderExtension *rid_stream;
+  GstRTPHeaderExtension *rid_repaired;
+
+  GstBuffer *dummy_writable;
 };
 
 struct _GstRtpRtxReceiveClass
@@ -74,7 +83,8 @@ struct _GstRtpRtxReceiveClass
 
 
 GType gst_rtp_rtx_receive_get_type (void);
-gboolean gst_rtp_rtx_receive_plugin_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (rtprtxreceive);
 
 G_END_DECLS
 #endif /* __GST_RTP_RTX_RECEIVE_H__ */
diff --git a/gst/rtpmanager/gstrtprtxsend.c b/gst/rtpmanager/gstrtprtxsend.c
index bfa5db809..349bb169b 100644
--- a/gst/rtpmanager/gstrtprtxsend.c
+++ b/gst/rtpmanager/gstrtprtxsend.c
@@ -41,7 +41,6 @@
 #endif
 
 #include <gst/gst.h>
-#include <gst/rtp/gstrtpbuffer.h>
 #include <string.h>
 #include <stdlib.h>
 
@@ -66,6 +65,20 @@ enum
   PROP_CLOCK_RATE_MAP,
 };
 
+enum
+{
+  SIGNAL_0,
+  SIGNAL_ADD_EXTENSION,
+  SIGNAL_CLEAR_EXTENSIONS,
+  LAST_SIGNAL
+};
+
+static guint gst_rtp_rtx_send_signals[LAST_SIGNAL] = { 0, };
+
+#define RTPHDREXT_BUNDLE_MID GST_RTP_HDREXT_BASE "sdes:mid"
+#define RTPHDREXT_STREAM_ID GST_RTP_HDREXT_BASE "sdes:rtp-stream-id"
+#define RTPHDREXT_REPAIRED_STREAM_ID GST_RTP_HDREXT_BASE "sdes:repaired-rtp-stream-id"
+
 static GstStaticPadTemplate src_factory = GST_STATIC_PAD_TEMPLATE ("src",
     GST_PAD_SRC,
     GST_PAD_ALWAYS,
@@ -103,7 +116,47 @@ static void gst_rtp_rtx_send_get_property (GObject * object, guint prop_id,
     GValue * value, GParamSpec * pspec);
 static void gst_rtp_rtx_send_finalize (GObject * object);
 
-G_DEFINE_TYPE (GstRtpRtxSend, gst_rtp_rtx_send, GST_TYPE_ELEMENT);
+static void
+gst_rtp_rtx_send_add_extension (GstRtpRtxSend * rtx,
+    GstRTPHeaderExtension * ext)
+{
+  g_return_if_fail (GST_IS_RTP_HEADER_EXTENSION (ext));
+  g_return_if_fail (gst_rtp_header_extension_get_id (ext) > 0);
+
+  GST_OBJECT_LOCK (rtx);
+  if (g_strcmp0 (gst_rtp_header_extension_get_uri (ext),
+          RTPHDREXT_STREAM_ID) == 0) {
+    gst_clear_object (&rtx->rid_stream);
+    rtx->rid_stream = gst_object_ref (ext);
+  } else if (g_strcmp0 (gst_rtp_header_extension_get_uri (ext),
+          RTPHDREXT_REPAIRED_STREAM_ID) == 0) {
+    gst_clear_object (&rtx->rid_repaired);
+    rtx->rid_repaired = gst_object_ref (ext);
+  } else {
+    g_warning ("rtprtxsend (%s) doesn't know how to deal with the "
+        "RTP Header Extension with URI \'%s\'", GST_OBJECT_NAME (rtx),
+        gst_rtp_header_extension_get_uri (ext));
+  }
+  /* XXX: check for other duplicate ids? */
+  GST_OBJECT_UNLOCK (rtx);
+}
+
+static void
+gst_rtp_rtx_send_clear_extensions (GstRtpRtxSend * rtx)
+{
+  GST_OBJECT_LOCK (rtx);
+  gst_clear_object (&rtx->rid_stream);
+  gst_clear_object (&rtx->rid_repaired);
+  GST_OBJECT_UNLOCK (rtx);
+}
+
+G_DEFINE_TYPE_WITH_CODE (GstRtpRtxSend, gst_rtp_rtx_send, GST_TYPE_ELEMENT,
+    GST_DEBUG_CATEGORY_INIT (gst_rtp_rtx_send_debug, "rtprtxsend", 0,
+        "rtp retransmission sender"));
+GST_ELEMENT_REGISTER_DEFINE (rtprtxsend, "rtprtxsend", GST_RANK_NONE,
+    GST_TYPE_RTP_RTX_SEND);
+
+#define IS_RTX_ENABLED(rtx) (g_hash_table_size ((rtx)->rtx_pt_map) > 0)
 
 typedef struct
 {
@@ -148,6 +201,60 @@ ssrc_rtx_data_free (SSRCRtxData * data)
   g_slice_free (SSRCRtxData, data);
 }
 
+typedef enum
+{
+  RTX_TASK_START,
+  RTX_TASK_PAUSE,
+  RTX_TASK_STOP,
+} RtxTaskState;
+
+static void
+gst_rtp_rtx_send_set_flushing (GstRtpRtxSend * rtx, gboolean flush)
+{
+  GST_OBJECT_LOCK (rtx);
+  gst_data_queue_set_flushing (rtx->queue, flush);
+  gst_data_queue_flush (rtx->queue);
+  GST_OBJECT_UNLOCK (rtx);
+}
+
+static gboolean
+gst_rtp_rtx_send_set_task_state (GstRtpRtxSend * rtx, RtxTaskState task_state)
+{
+  GstTask *task = GST_PAD_TASK (rtx->srcpad);
+  GstPadMode mode = GST_PAD_MODE (rtx->srcpad);
+  gboolean ret = TRUE;
+
+  switch (task_state) {
+    case RTX_TASK_START:
+    {
+      gboolean active = task && GST_TASK_STATE (task) == GST_TASK_STARTED;
+      if (IS_RTX_ENABLED (rtx) && mode != GST_PAD_MODE_NONE && !active) {
+        GST_DEBUG_OBJECT (rtx, "Starting RTX task");
+        gst_rtp_rtx_send_set_flushing (rtx, FALSE);
+        ret = gst_pad_start_task (rtx->srcpad,
+            (GstTaskFunction) gst_rtp_rtx_send_src_loop, rtx, NULL);
+      }
+      break;
+    }
+    case RTX_TASK_PAUSE:
+      if (task) {
+        GST_DEBUG_OBJECT (rtx, "Pausing RTX task");
+        gst_rtp_rtx_send_set_flushing (rtx, TRUE);
+        ret = gst_pad_pause_task (rtx->srcpad);
+      }
+      break;
+    case RTX_TASK_STOP:
+      if (task) {
+        GST_DEBUG_OBJECT (rtx, "Stopping RTX task");
+        gst_rtp_rtx_send_set_flushing (rtx, TRUE);
+        ret = gst_pad_stop_task (rtx->srcpad);
+      }
+      break;
+  }
+
+  return ret;
+}
+
 static void
 gst_rtp_rtx_send_class_init (GstRtpRtxSendClass * klass)
 {
@@ -198,6 +305,38 @@ gst_rtp_rtx_send_class_init (GstRtpRtxSendClass * klass)
           "Map of payload types to their clock rates",
           GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * rtprtxsend::add-extension:
+   *
+   * Add @ext as an extension for writing part of an RTP header extension onto
+   * outgoing RTP packets.  Currently only supports using the following
+   * extension URIs. All other RTP header extensions are copied as-is.
+   *   - "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id": will be removed
+   *   - "urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id": will be
+   *     written instead of the "rtp-stream-id" header extension.
+   *
+   * Since: 1.22
+   */
+  gst_rtp_rtx_send_signals[SIGNAL_ADD_EXTENSION] =
+      g_signal_new_class_handler ("add-extension", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_rtx_send_add_extension), NULL, NULL, NULL,
+      G_TYPE_NONE, 1, GST_TYPE_RTP_HEADER_EXTENSION);
+
+  /**
+   * rtprtxsend::clear-extensions:
+   * @object: the #GstRTPBasePayload
+   *
+   * Clear all RTP header extensions used by this rtprtxsend.
+   *
+   * Since: 1.22
+   */
+  gst_rtp_rtx_send_signals[SIGNAL_CLEAR_EXTENSIONS] =
+      g_signal_new_class_handler ("clear-extensions", G_TYPE_FROM_CLASS (klass),
+      G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
+      G_CALLBACK (gst_rtp_rtx_send_clear_extensions), NULL, NULL, NULL,
+      G_TYPE_NONE, 0);
+
   gst_element_class_add_static_pad_template (gstelement_class, &src_factory);
   gst_element_class_add_static_pad_template (gstelement_class, &sink_factory);
 
@@ -225,7 +364,7 @@ gst_rtp_rtx_send_reset (GstRtpRtxSend * rtx)
 static void
 gst_rtp_rtx_send_finalize (GObject * object)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (object);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (object);
 
   g_hash_table_unref (rtx->ssrc_data);
   g_hash_table_unref (rtx->rtx_ssrcs);
@@ -239,6 +378,11 @@ gst_rtp_rtx_send_finalize (GObject * object)
     gst_structure_free (rtx->clock_rate_map_structure);
   g_object_unref (rtx->queue);
 
+  gst_clear_object (&rtx->rid_stream);
+  gst_clear_object (&rtx->rid_repaired);
+
+  gst_clear_buffer (&rtx->dummy_writable);
+
   G_OBJECT_CLASS (gst_rtp_rtx_send_parent_class)->finalize (object);
 }
 
@@ -281,15 +425,8 @@ gst_rtp_rtx_send_init (GstRtpRtxSend * rtx)
 
   rtx->max_size_time = DEFAULT_MAX_SIZE_TIME;
   rtx->max_size_packets = DEFAULT_MAX_SIZE_PACKETS;
-}
 
-static void
-gst_rtp_rtx_send_set_flushing (GstRtpRtxSend * rtx, gboolean flush)
-{
-  GST_OBJECT_LOCK (rtx);
-  gst_data_queue_set_flushing (rtx->queue, flush);
-  gst_data_queue_flush (rtx->queue);
-  GST_OBJECT_UNLOCK (rtx);
+  rtx->dummy_writable = gst_buffer_new ();
 }
 
 static gboolean
@@ -371,6 +508,162 @@ gst_rtp_rtx_send_get_ssrc_data (GstRtpRtxSend * rtx, guint32 ssrc)
   return data;
 }
 
+static GstMemory *
+rewrite_header_extensions (GstRtpRtxSend * rtx, GstRTPBuffer * rtp)
+{
+  gsize out_size = rtp->size[1] + 32;
+  guint16 bit_pattern;
+  guint8 *pdata;
+  guint wordlen;
+  GstMemory *mem;
+  GstMapInfo map;
+
+  mem = gst_allocator_alloc (NULL, out_size, NULL);
+
+  gst_memory_map (mem, &map, GST_MAP_READWRITE);
+
+  if (gst_rtp_buffer_get_extension_data (rtp, &bit_pattern, (gpointer) & pdata,
+          &wordlen)) {
+    GstRTPHeaderExtensionFlags ext_flags = 0;
+    gsize bytelen = wordlen * 4;
+    guint hdr_unit_bytes;
+    gsize read_offset = 0, write_offset = 4;
+
+    if (bit_pattern == 0xBEDE) {
+      /* one byte extensions */
+      hdr_unit_bytes = 1;
+      ext_flags |= GST_RTP_HEADER_EXTENSION_ONE_BYTE;
+    } else if (bit_pattern >> 4 == 0x100) {
+      /* two byte extensions */
+      hdr_unit_bytes = 2;
+      ext_flags |= GST_RTP_HEADER_EXTENSION_TWO_BYTE;
+    } else {
+      GST_DEBUG_OBJECT (rtx, "unknown extension bit pattern 0x%02x%02x",
+          bit_pattern >> 8, bit_pattern & 0xff);
+      goto copy_as_is;
+    }
+
+    GST_WRITE_UINT16_BE (map.data, bit_pattern);
+
+    while (TRUE) {
+      guint8 read_id, read_len;
+
+      if (read_offset + hdr_unit_bytes >= bytelen)
+        /* not enough remaning data */
+        break;
+
+      if (ext_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+        read_id = GST_READ_UINT8 (pdata + read_offset) >> 4;
+        read_len = (GST_READ_UINT8 (pdata + read_offset) & 0x0F) + 1;
+        read_offset += 1;
+
+        if (read_id == 0)
+          /* padding */
+          continue;
+
+        if (read_id == 15)
+          /* special id for possible future expansion */
+          break;
+      } else {
+        read_id = GST_READ_UINT8 (pdata + read_offset);
+        read_offset += 1;
+
+        if (read_id == 0)
+          /* padding */
+          continue;
+
+        read_len = GST_READ_UINT8 (pdata + read_offset);
+        read_offset += 1;
+      }
+      GST_TRACE_OBJECT (rtx, "found rtp header extension with id %u and "
+          "length %u", read_id, read_len);
+
+      /* Ignore extension headers where the size does not fit */
+      if (read_offset + read_len > bytelen) {
+        GST_WARNING_OBJECT (rtx, "Extension length extends past the "
+            "size of the extension data");
+        break;
+      }
+
+      /* rewrite the rtp-stream-id into a repaired-stream-id */
+      if (rtx->rid_stream
+          && read_id == gst_rtp_header_extension_get_id (rtx->rid_stream)) {
+        if (!gst_rtp_header_extension_read (rtx->rid_stream, ext_flags,
+                &pdata[read_offset], read_len, rtx->dummy_writable)) {
+          GST_WARNING_OBJECT (rtx, "RTP header extension (%s) could "
+              "not read payloaded data", GST_OBJECT_NAME (rtx->rid_stream));
+          goto copy_as_is;
+        }
+        if (rtx->rid_repaired) {
+          guint8 write_id = gst_rtp_header_extension_get_id (rtx->rid_repaired);
+          gsize written;
+          char *rid;
+
+          g_object_get (rtx->rid_stream, "rid", &rid, NULL);
+          g_object_set (rtx->rid_repaired, "rid", rid, NULL);
+          g_clear_pointer (&rid, g_free);
+
+          written =
+              gst_rtp_header_extension_write (rtx->rid_repaired, rtp->buffer,
+              ext_flags, rtx->dummy_writable,
+              &map.data[write_offset + hdr_unit_bytes],
+              map.size - write_offset - hdr_unit_bytes);
+          GST_TRACE_OBJECT (rtx->rid_repaired, "wrote %" G_GSIZE_FORMAT,
+              written);
+          if (written <= 0) {
+            GST_WARNING_OBJECT (rtx, "Failed to rewrite RID for RTX");
+            goto copy_as_is;
+          } else {
+            if (ext_flags & GST_RTP_HEADER_EXTENSION_ONE_BYTE) {
+              map.data[write_offset] =
+                  ((write_id & 0x0F) << 4) | ((written - 1) & 0x0F);
+            } else if (ext_flags & GST_RTP_HEADER_EXTENSION_TWO_BYTE) {
+              map.data[write_offset] = write_id & 0xFF;
+              map.data[write_offset + 1] = written & 0xFF;
+            } else {
+              g_assert_not_reached ();
+              goto copy_as_is;
+            }
+            write_offset += written + hdr_unit_bytes;
+          }
+        }
+      } else {
+        /* TODO: may need to write mid at different times to the original
+         * buffer to account for the difference in timing of acknowledgement
+         * of the rtx ssrc from the original ssrc. This may add extra data to
+         * the header extension space that needs to be accounted for.
+         */
+        memcpy (&map.data[write_offset], &pdata[read_offset - hdr_unit_bytes],
+            read_len + hdr_unit_bytes);
+        write_offset += read_len + hdr_unit_bytes;
+      }
+
+      read_offset += read_len;
+    }
+
+    /* subtract the ext header */
+    wordlen = write_offset / 4 + ((write_offset % 4) ? 1 : 0);
+
+    /* wordlen in the ext data doesn't include the 4-byte header */
+    GST_WRITE_UINT16_BE (map.data + 2, wordlen - 1);
+
+    if (wordlen * 4 > write_offset)
+      memset (&map.data[write_offset], 0, wordlen * 4 - write_offset);
+
+    GST_MEMDUMP_OBJECT (rtx, "generated ext data", map.data, wordlen * 4);
+  } else {
+  copy_as_is:
+    wordlen = rtp->size[1] / 4;
+    memcpy (map.data, rtp->data[1], rtp->size[1]);
+    GST_LOG_OBJECT (rtx, "copying data as-is");
+  }
+
+  gst_memory_unmap (mem, &map);
+  gst_memory_resize (mem, 0, wordlen * 4);
+
+  return mem;
+}
+
 /* Copy fixed header and extension. Add OSN before to copy payload
  * Copy memory to avoid to manually copy each rtp buffer field.
  */
@@ -411,10 +704,7 @@ gst_rtp_rtx_buffer_new (GstRtpRtxSend * rtx, GstBuffer * buffer)
 
   /* copy extension if any */
   if (rtp.size[1]) {
-    mem = gst_allocator_alloc (NULL, rtp.size[1], NULL);
-    gst_memory_map (mem, &map, GST_MAP_WRITE);
-    memcpy (map.data, rtp.data[1], rtp.size[1]);
-    gst_memory_unmap (mem, &map);
+    mem = rewrite_header_extensions (rtx, &rtp);
     gst_buffer_append_memory (new_buffer, mem);
   }
 
@@ -444,6 +734,9 @@ gst_rtp_rtx_buffer_new (GstRtpRtxSend * rtx, GstBuffer * buffer)
   /* Copy over timestamps */
   gst_buffer_copy_into (new_buffer, buffer, GST_BUFFER_COPY_TIMESTAMPS, 0, -1);
 
+  /* mark this is a RETRANSMISSION buffer */
+  GST_BUFFER_FLAG_SET (new_buffer, GST_RTP_BUFFER_FLAG_RETRANSMISSION);
+
   return new_buffer;
 }
 
@@ -460,7 +753,7 @@ buffer_queue_items_cmp (BufferQueueItem * a, BufferQueueItem * b,
 static gboolean
 gst_rtp_rtx_send_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (parent);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (parent);
   gboolean res;
 
   switch (GST_EVENT_TYPE (event)) {
@@ -600,19 +893,16 @@ gst_rtp_rtx_send_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
 static gboolean
 gst_rtp_rtx_send_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (parent);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (parent);
 
   switch (GST_EVENT_TYPE (event)) {
     case GST_EVENT_FLUSH_START:
       gst_pad_push_event (rtx->srcpad, event);
-      gst_rtp_rtx_send_set_flushing (rtx, TRUE);
-      gst_pad_pause_task (rtx->srcpad);
+      gst_rtp_rtx_send_set_task_state (rtx, RTX_TASK_PAUSE);
       return TRUE;
     case GST_EVENT_FLUSH_STOP:
       gst_pad_push_event (rtx->srcpad, event);
-      gst_rtp_rtx_send_set_flushing (rtx, FALSE);
-      gst_pad_start_task (rtx->srcpad,
-          (GstTaskFunction) gst_rtp_rtx_send_src_loop, rtx, NULL);
+      gst_rtp_rtx_send_set_task_state (rtx, RTX_TASK_START);
       return TRUE;
     case GST_EVENT_EOS:
       GST_INFO_OBJECT (rtx, "Got EOS - enqueueing it");
@@ -647,7 +937,8 @@ gst_rtp_rtx_send_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
               GUINT_TO_POINTER (payload), NULL, &rtx_payload))
         rtx_payload = GINT_TO_POINTER (-1);
 
-      if (GPOINTER_TO_INT (rtx_payload) == -1 && payload != -1)
+      if (rtx->rtx_pt_map_structure && GPOINTER_TO_INT (rtx_payload) == -1
+          && payload != -1)
         GST_WARNING_OBJECT (rtx, "Payload %d not in rtx-pt-map", payload);
 
       GST_DEBUG_OBJECT (rtx,
@@ -656,14 +947,16 @@ gst_rtp_rtx_send_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 
       gst_structure_get_int (s, "clock-rate", &data->clock_rate);
 
-      /* The session might need to know the RTX ssrc */
       caps = gst_caps_copy (caps);
-      gst_caps_set_simple (caps, "rtx-ssrc", G_TYPE_UINT, data->rtx_ssrc,
-          "rtx-seqnum-offset", G_TYPE_UINT, data->seqnum_base, NULL);
 
-      if (GPOINTER_TO_INT (rtx_payload) != -1)
+      /* The session might need to know the RTX ssrc */
+      if (GPOINTER_TO_INT (rtx_payload) != -1) {
+        gst_caps_set_simple (caps, "rtx-ssrc", G_TYPE_UINT, data->rtx_ssrc,
+            "rtx-seqnum-offset", G_TYPE_UINT, data->seqnum_base, NULL);
+
         gst_caps_set_simple (caps, "rtx-payload", G_TYPE_INT,
             GPOINTER_TO_INT (rtx_payload), NULL);
+      }
 
       GST_DEBUG_OBJECT (rtx, "got clock-rate from caps: %d for ssrc: %u",
           data->clock_rate, ssrc);
@@ -696,18 +989,24 @@ gst_rtp_rtx_send_get_ts_diff (SSRCRtxData * data)
   if (!high_buf || !low_buf || high_buf == low_buf)
     return 0;
 
-  high_ts = high_buf->timestamp;
-  low_ts = low_buf->timestamp;
+  if (data->clock_rate) {
+    high_ts = high_buf->timestamp;
+    low_ts = low_buf->timestamp;
 
-  /* it needs to work if ts wraps */
-  if (high_ts >= low_ts) {
-    result = (guint32) (high_ts - low_ts);
+    /* it needs to work if ts wraps */
+    if (high_ts >= low_ts) {
+      result = (guint32) (high_ts - low_ts);
+    } else {
+      result = (guint32) (high_ts + G_MAXUINT32 + 1 - low_ts);
+    }
+    result = gst_util_uint64_scale_int (result, 1000, data->clock_rate);
   } else {
-    result = (guint32) (high_ts + G_MAXUINT32 + 1 - low_ts);
+    high_ts = GST_BUFFER_PTS (high_buf->buffer);
+    low_ts = GST_BUFFER_PTS (low_buf->buffer);
+    result = gst_util_uint64_scale_int_round (high_ts - low_ts, 1, GST_MSECOND);
   }
 
-  /* return value in ms instead of clock ticks */
-  return (guint32) gst_util_uint64_scale_int (result, 1000, data->clock_rate);
+  return result;
 }
 
 /* Must be called with lock */
@@ -764,11 +1063,12 @@ process_buffer (GstRtpRtxSend * rtx, GstBuffer * buffer)
 static GstFlowReturn
 gst_rtp_rtx_send_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (parent);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (parent);
   GstFlowReturn ret;
 
   GST_OBJECT_LOCK (rtx);
-  process_buffer (rtx, buffer);
+  if (rtx->rtx_pt_map_structure)
+    process_buffer (rtx, buffer);
   GST_OBJECT_UNLOCK (rtx);
   ret = gst_pad_push (rtx->srcpad, buffer);
 
@@ -786,7 +1086,7 @@ static GstFlowReturn
 gst_rtp_rtx_send_chain_list (GstPad * pad, GstObject * parent,
     GstBufferList * list)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (parent);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (parent);
   GstFlowReturn ret;
 
   GST_OBJECT_LOCK (rtx);
@@ -829,7 +1129,7 @@ gst_rtp_rtx_send_src_loop (GstRtpRtxSend * rtx)
     data->destroy (data);
   } else {
     GST_LOG_OBJECT (rtx, "flushing");
-    gst_pad_pause_task (rtx->srcpad);
+    gst_rtp_rtx_send_set_task_state (rtx, RTX_TASK_PAUSE);
   }
 }
 
@@ -837,18 +1137,15 @@ static gboolean
 gst_rtp_rtx_send_activate_mode (GstPad * pad, GstObject * parent,
     GstPadMode mode, gboolean active)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (parent);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (parent);
   gboolean ret = FALSE;
 
   switch (mode) {
     case GST_PAD_MODE_PUSH:
       if (active) {
-        gst_rtp_rtx_send_set_flushing (rtx, FALSE);
-        ret = gst_pad_start_task (rtx->srcpad,
-            (GstTaskFunction) gst_rtp_rtx_send_src_loop, rtx, NULL);
+        ret = gst_rtp_rtx_send_set_task_state (rtx, RTX_TASK_START);
       } else {
-        gst_rtp_rtx_send_set_flushing (rtx, TRUE);
-        ret = gst_pad_stop_task (rtx->srcpad);
+        ret = gst_rtp_rtx_send_set_task_state (rtx, RTX_TASK_STOP);
       }
       GST_INFO_OBJECT (rtx, "activate_mode: active %d, ret %d", active, ret);
       break;
@@ -862,7 +1159,7 @@ static void
 gst_rtp_rtx_send_get_property (GObject * object,
     guint prop_id, GValue * value, GParamSpec * pspec)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (object);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (object);
 
   switch (prop_id) {
     case PROP_PAYLOAD_TYPE_MAP:
@@ -921,7 +1218,7 @@ static void
 gst_rtp_rtx_send_set_property (GObject * object,
     guint prop_id, const GValue * value, GParamSpec * pspec)
 {
-  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND (object);
+  GstRtpRtxSend *rtx = GST_RTP_RTX_SEND_CAST (object);
 
   switch (prop_id) {
     case PROP_SSRC_MAP:
@@ -940,6 +1237,12 @@ gst_rtp_rtx_send_set_property (GObject * object,
       gst_structure_foreach (rtx->rtx_pt_map_structure, structure_to_hash_table,
           rtx->rtx_pt_map);
       GST_OBJECT_UNLOCK (rtx);
+
+      if (IS_RTX_ENABLED (rtx))
+        gst_rtp_rtx_send_set_task_state (rtx, RTX_TASK_START);
+      else
+        gst_rtp_rtx_send_set_task_state (rtx, RTX_TASK_STOP);
+
       break;
     case PROP_MAX_SIZE_TIME:
       GST_OBJECT_LOCK (rtx);
@@ -973,7 +1276,7 @@ gst_rtp_rtx_send_change_state (GstElement * element, GstStateChange transition)
   GstStateChangeReturn ret;
   GstRtpRtxSend *rtx;
 
-  rtx = GST_RTP_RTX_SEND (element);
+  rtx = GST_RTP_RTX_SEND_CAST (element);
 
   switch (transition) {
     default:
@@ -994,13 +1297,3 @@ gst_rtp_rtx_send_change_state (GstElement * element, GstStateChange transition)
 
   return ret;
 }
-
-gboolean
-gst_rtp_rtx_send_plugin_init (GstPlugin * plugin)
-{
-  GST_DEBUG_CATEGORY_INIT (gst_rtp_rtx_send_debug, "rtprtxsend", 0,
-      "rtp retransmission sender");
-
-  return gst_element_register (plugin, "rtprtxsend", GST_RANK_NONE,
-      GST_TYPE_RTP_RTX_SEND);
-}
diff --git a/gst/rtpmanager/gstrtprtxsend.h b/gst/rtpmanager/gstrtprtxsend.h
index b25a511b3..60a4ec5bb 100644
--- a/gst/rtpmanager/gstrtprtxsend.h
+++ b/gst/rtpmanager/gstrtprtxsend.h
@@ -25,18 +25,21 @@
 #define __GST_RTP_RTX_SEND_H__
 
 #include <gst/gst.h>
-#include <gst/rtp/gstrtpbuffer.h>
+#include <gst/rtp/rtp.h>
 #include <gst/base/gstdataqueue.h>
 
 G_BEGIN_DECLS
+
+typedef struct _GstRtpRtxSend GstRtpRtxSend;
+typedef struct _GstRtpRtxSendClass GstRtpRtxSendClass;
+
 #define GST_TYPE_RTP_RTX_SEND (gst_rtp_rtx_send_get_type())
 #define GST_RTP_RTX_SEND(obj) (G_TYPE_CHECK_INSTANCE_CAST((obj),GST_TYPE_RTP_RTX_SEND, GstRtpRtxSend))
 #define GST_RTP_RTX_SEND_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST((klass),GST_TYPE_RTP_RTX_SEND, GstRtpRtxSendClass))
 #define GST_RTP_RTX_SEND_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), GST_TYPE_RTP_RTX_SEND, GstRtpRtxSendClass))
 #define GST_IS_RTP_RTX_SEND(obj) (G_TYPE_CHECK_INSTANCE_TYPE((obj),GST_TYPE_RTP_RTX_SEND))
 #define GST_IS_RTP_RTX_SEND_CLASS(obj) (G_TYPE_CHECK_CLASS_TYPE((klass),GST_TYPE_RTP_RTX_SEND))
-typedef struct _GstRtpRtxSend GstRtpRtxSend;
-typedef struct _GstRtpRtxSendClass GstRtpRtxSendClass;
+#define GST_RTP_RTX_SEND_CAST(obj) ((GstRtpRtxSend *)(obj))
 
 struct _GstRtpRtxSend
 {
@@ -74,6 +77,12 @@ struct _GstRtpRtxSend
   /* statistics */
   guint num_rtx_requests;
   guint num_rtx_packets;
+
+  /* list of relevant RTP Header Extensions */
+  GstRTPHeaderExtension *rid_stream;
+  GstRTPHeaderExtension *rid_repaired;
+
+  GstBuffer *dummy_writable;
 };
 
 struct _GstRtpRtxSendClass
@@ -81,9 +90,9 @@ struct _GstRtpRtxSendClass
   GstElementClass parent_class;
 };
 
-
 GType gst_rtp_rtx_send_get_type (void);
-gboolean gst_rtp_rtx_send_plugin_init (GstPlugin * plugin);
+
+GST_ELEMENT_REGISTER_DECLARE (rtprtxsend);
 
 G_END_DECLS
 #endif /* __GST_RTP_RTX_SEND_H__ */
diff --git a/gst/rtpmanager/gstrtpsession.c b/gst/rtpmanager/gstrtpsession.c
index 0b9fc3d5d..b131e7761 100644
--- a/gst/rtpmanager/gstrtpsession.c
+++ b/gst/rtpmanager/gstrtpsession.c
@@ -111,6 +111,7 @@
 
 #include "gstrtpsession.h"
 #include "rtpsession.h"
+#include "gstrtputils.h"
 
 GST_DEBUG_CATEGORY_STATIC (gst_rtp_session_debug);
 #define GST_CAT_DEFAULT gst_rtp_session_debug
@@ -222,6 +223,7 @@ enum
 #define DEFAULT_RTP_PROFILE          GST_RTP_PROFILE_AVP
 #define DEFAULT_NTP_TIME_SOURCE      GST_RTP_NTP_TIME_SOURCE_NTP
 #define DEFAULT_RTCP_SYNC_SEND_TIME  TRUE
+#define DEFAULT_UPDATE_NTP64_HEADER_EXT  TRUE
 
 enum
 {
@@ -243,7 +245,8 @@ enum
   PROP_TWCC_STATS,
   PROP_RTP_PROFILE,
   PROP_NTP_TIME_SOURCE,
-  PROP_RTCP_SYNC_SEND_TIME
+  PROP_RTCP_SYNC_SEND_TIME,
+  PROP_UPDATE_NTP64_HEADER_EXT
 };
 
 #define GST_RTP_SESSION_LOCK(sess)   g_mutex_lock (&(sess)->priv->lock)
@@ -297,7 +300,7 @@ static GstFlowReturn gst_rtp_session_send_rtcp (RTPSession * sess,
     RTPSource * src, GstBuffer * buffer, gboolean eos, gpointer user_data);
 static GstFlowReturn gst_rtp_session_sync_rtcp (RTPSession * sess,
     GstBuffer * buffer, gpointer user_data);
-static gint gst_rtp_session_clock_rate (RTPSession * sess, guint8 payload,
+static GstCaps *gst_rtp_session_caps (RTPSession * sess, guint8 payload,
     gpointer user_data);
 static void gst_rtp_session_reconsider (RTPSession * sess, gpointer user_data);
 static void gst_rtp_session_request_key_unit (RTPSession * sess, guint32 ssrc,
@@ -327,7 +330,7 @@ static RTPSessionCallbacks callbacks = {
   gst_rtp_session_send_rtp,
   gst_rtp_session_sync_rtcp,
   gst_rtp_session_send_rtcp,
-  gst_rtp_session_clock_rate,
+  gst_rtp_session_caps,
   gst_rtp_session_reconsider,
   gst_rtp_session_request_key_unit,
   gst_rtp_session_request_time,
@@ -351,7 +354,7 @@ static GstPad *gst_rtp_session_request_new_pad (GstElement * element,
     GstPadTemplate * templ, const gchar * name, const GstCaps * caps);
 static void gst_rtp_session_release_pad (GstElement * element, GstPad * pad);
 
-static gboolean gst_rtp_session_sink_setcaps (GstPad * pad,
+static gboolean gst_rtp_session_setcaps_recv_rtp (GstPad * pad,
     GstRtpSession * rtpsession, GstCaps * caps);
 static gboolean gst_rtp_session_setcaps_send_rtp (GstPad * pad,
     GstRtpSession * rtpsession, GstCaps * caps);
@@ -491,6 +494,8 @@ on_notify_stats (RTPSession * session, GParamSpec * spec,
 
 #define gst_rtp_session_parent_class parent_class
 G_DEFINE_TYPE_WITH_PRIVATE (GstRtpSession, gst_rtp_session, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE (rtpsession, "rtpsession", GST_RANK_NONE,
+    GST_TYPE_RTP_SESSION);
 
 static void
 gst_rtp_session_class_init (GstRtpSessionClass * klass)
@@ -772,7 +777,11 @@ gst_rtp_session_class_init (GstRtpSessionClass * klass)
    *  "packets-sent"     G_TYPE_UINT    Number of packets sent
    *  "packets-recv"     G_TYPE_UINT    Number of packets reported recevied
    *  "packet-loss-pct"  G_TYPE_DOUBLE  Packetloss percentage, based on
-   *      packets reported as lost from the recevier.
+   *      packets reported as lost from the receiver. Note: depending on the
+   *      implementation of the receiver and due to the nature of the TWCC
+   *      RRs being sent with high frequency, out of order packets may not
+   *      be fully accounted for and this number could be higher than other
+   *      measurement sources of packet loss.
    *  "avg-delta-of-delta", G_TYPE_INT64 In nanoseconds, a moving window
    *      average of the difference in inter-packet spacing between
    *      sender and receiver. A sudden increase in this number can indicate
@@ -803,6 +812,22 @@ gst_rtp_session_class_init (GstRtpSessionClass * klass)
           DEFAULT_RTCP_SYNC_SEND_TIME,
           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 
+  /**
+   * GstRtpSession:update-ntp64-header-ext:
+   *
+   * Whether RTP NTP header extension should be updated with actual
+   * NTP time. If not, use the NTP time from buffer timestamp metadata
+   *
+   * Since: 1.22
+   */
+  g_object_class_install_property (gobject_class,
+      PROP_UPDATE_NTP64_HEADER_EXT,
+      g_param_spec_boolean ("update-ntp64-header-ext",
+          "Update NTP-64 RTP Header Extension",
+          "Whether RTP NTP header extension should be updated with actual NTP time",
+          DEFAULT_UPDATE_NTP64_HEADER_EXT,
+          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+
   gstelement_class->change_state =
       GST_DEBUG_FUNCPTR (gst_rtp_session_change_state);
   gstelement_class->request_new_pad =
@@ -975,6 +1000,10 @@ gst_rtp_session_set_property (GObject * object, guint prop_id,
     case PROP_RTCP_SYNC_SEND_TIME:
       priv->rtcp_sync_send_time = g_value_get_boolean (value);
       break;
+    case PROP_UPDATE_NTP64_HEADER_EXT:
+      g_object_set_property (G_OBJECT (priv->session),
+          "update-ntp64-header-ext", value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1054,6 +1083,10 @@ gst_rtp_session_get_property (GObject * object, guint prop_id,
     case PROP_RTCP_SYNC_SEND_TIME:
       g_value_set_boolean (value, priv->rtcp_sync_send_time);
       break;
+    case PROP_UPDATE_NTP64_HEADER_EXT:
+      g_object_get_property (G_OBJECT (priv->session),
+          "update-ntp64-header-ext", value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1095,7 +1128,7 @@ get_current_times (GstRtpSession * rtpsession, GstClockTime * running_time,
     if (rtpsession->priv->use_pipeline_clock) {
       ntpns = rt;
       /* add constant to convert from 1970 based time to 1900 based time */
-      ntpns += (2208988800LL * GST_SECOND);
+      ntpns += (GST_RTP_NTP_UNIX_OFFSET * GST_SECOND);
     } else {
       switch (rtpsession->priv->ntp_time_source) {
         case GST_RTP_NTP_TIME_SOURCE_NTP:
@@ -1105,7 +1138,7 @@ get_current_times (GstRtpSession * rtpsession, GstClockTime * running_time,
 
           /* add constant to convert from 1970 based time to 1900 based time */
           if (rtpsession->priv->ntp_time_source == GST_RTP_NTP_TIME_SOURCE_NTP)
-            ntpns += (2208988800LL * GST_SECOND);
+            ntpns += (GST_RTP_NTP_UNIX_OFFSET * GST_SECOND);
           break;
         }
         case GST_RTP_NTP_TIME_SOURCE_RUNNING_TIME:
@@ -1303,6 +1336,7 @@ gst_rtp_session_change_state (GstElement * element, GstStateChange transition)
     case GST_STATE_CHANGE_READY_TO_PAUSED:
       GST_RTP_SESSION_LOCK (rtpsession);
       rtpsession->priv->wait_send = TRUE;
+      rtpsession->priv->send_latency = GST_CLOCK_TIME_NONE;
       GST_RTP_SESSION_UNLOCK (rtpsession);
       break;
     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
@@ -1670,41 +1704,12 @@ no_caps:
 }
 
 /* called when the session manager needs the clock rate */
-static gint
-gst_rtp_session_clock_rate (RTPSession * sess, guint8 payload,
-    gpointer user_data)
+static GstCaps *
+gst_rtp_session_caps (RTPSession * sess, guint8 payload, gpointer user_data)
 {
-  gint result = -1;
-  GstRtpSession *rtpsession;
-  GstCaps *caps;
-  const GstStructure *s;
-
-  rtpsession = GST_RTP_SESSION_CAST (user_data);
-
-  caps = gst_rtp_session_get_caps_for_pt (rtpsession, payload);
+  GstRtpSession *rtpsession = GST_RTP_SESSION_CAST (user_data);
 
-  if (!caps)
-    goto done;
-
-  s = gst_caps_get_structure (caps, 0);
-  if (!gst_structure_get_int (s, "clock-rate", &result))
-    goto no_clock_rate;
-
-  gst_caps_unref (caps);
-
-  GST_DEBUG_OBJECT (rtpsession, "parsed clock-rate %d", result);
-
-done:
-
-  return result;
-
-  /* ERRORS */
-no_clock_rate:
-  {
-    gst_caps_unref (caps);
-    GST_DEBUG_OBJECT (rtpsession, "No clock-rate in caps!");
-    goto done;
-  }
+  return gst_rtp_session_get_caps_for_pt (rtpsession, payload);
 }
 
 /* called when the session manager asks us to reconsider the timeout */
@@ -1741,7 +1746,7 @@ gst_rtp_session_event_recv_rtp_sink (GstPad * pad, GstObject * parent,
 
       /* process */
       gst_event_parse_caps (event, &caps);
-      gst_rtp_session_sink_setcaps (pad, rtpsession, caps);
+      gst_rtp_session_setcaps_recv_rtp (pad, rtpsession, caps);
       ret = gst_pad_push_event (rtpsession->recv_rtp_src, event);
       break;
     }
@@ -1959,7 +1964,7 @@ gst_rtp_session_iterate_internal_links (GstPad * pad, GstObject * parent)
 }
 
 static gboolean
-gst_rtp_session_sink_setcaps (GstPad * pad, GstRtpSession * rtpsession,
+gst_rtp_session_setcaps_recv_rtp (GstPad * pad, GstRtpSession * rtpsession,
     GstCaps * caps)
 {
   GST_RTP_SESSION_LOCK (rtpsession);
@@ -2396,6 +2401,8 @@ gst_rtp_session_chain_send_rtp_common (GstRtpSession * rtpsession,
   GstFlowReturn ret;
   GstClockTime timestamp, running_time;
   GstClockTime current_time;
+  guint64 ntpnstime;
+  GstClock *clock;
 
   priv = rtpsession->priv;
 
@@ -2421,16 +2428,98 @@ gst_rtp_session_chain_send_rtp_common (GstRtpSession * rtpsession,
     running_time =
         gst_segment_to_running_time (&rtpsession->send_rtp_seg, GST_FORMAT_TIME,
         timestamp);
-    if (priv->rtcp_sync_send_time)
-      running_time += priv->send_latency;
+    if (priv->rtcp_sync_send_time) {
+      if (priv->send_latency != GST_CLOCK_TIME_NONE) {
+        running_time += priv->send_latency;
+      } else {
+        GST_WARNING_OBJECT (rtpsession,
+            "Can't determine running time for this packet without knowing configured latency");
+        running_time = -1;
+      }
+    }
   } else {
     /* no timestamp. */
     running_time = -1;
   }
 
   current_time = gst_clock_get_time (priv->sysclock);
+
+  /* Calculate the NTP time of this packet based on the session configuration
+   * and the running time from above */
+  GST_OBJECT_LOCK (rtpsession);
+  if (running_time != -1 && (clock = GST_ELEMENT_CLOCK (rtpsession))) {
+    GstClockTime base_time;
+    base_time = GST_ELEMENT_CAST (rtpsession)->base_time;
+    gst_object_ref (clock);
+    GST_OBJECT_UNLOCK (rtpsession);
+
+    if (rtpsession->priv->use_pipeline_clock) {
+      ntpnstime = running_time;
+      /* add constant to convert from 1970 based time to 1900 based time */
+      ntpnstime += (GST_RTP_NTP_UNIX_OFFSET * GST_SECOND);
+    } else {
+      switch (rtpsession->priv->ntp_time_source) {
+        case GST_RTP_NTP_TIME_SOURCE_NTP:
+        case GST_RTP_NTP_TIME_SOURCE_UNIX:{
+          GstClockTime wallclock_now, pipeline_now;
+
+          /* pipeline clock time for this packet */
+          ntpnstime = running_time + base_time;
+
+          /* get current wallclock and pipeline clock time */
+          wallclock_now = g_get_real_time () * GST_USECOND;
+          pipeline_now = gst_clock_get_time (clock);
+
+          /* adjust pipeline clock time by the current diff.
+           * Note that this will include some jitter for each packet */
+          if (wallclock_now > pipeline_now) {
+            GstClockTime diff = wallclock_now - pipeline_now;
+
+            ntpnstime += diff;
+          } else {
+            GstClockTime diff = pipeline_now - wallclock_now;
+
+            if (diff > ntpnstime) {
+              /* This can't really happen unless the clock configuration is
+               * broken */
+              ntpnstime = GST_CLOCK_TIME_NONE;
+            } else {
+              ntpnstime -= diff;
+            }
+          }
+
+          /* add constant to convert from 1970 based time to 1900 based time */
+          if (ntpnstime != GST_CLOCK_TIME_NONE
+              && rtpsession->priv->ntp_time_source ==
+              GST_RTP_NTP_TIME_SOURCE_NTP)
+            ntpnstime += (GST_RTP_NTP_UNIX_OFFSET * GST_SECOND);
+          break;
+        }
+        case GST_RTP_NTP_TIME_SOURCE_RUNNING_TIME:
+          ntpnstime = running_time;
+          break;
+        case GST_RTP_NTP_TIME_SOURCE_CLOCK_TIME:
+          ntpnstime = running_time + base_time;
+          break;
+        default:
+          ntpnstime = -1;
+          g_assert_not_reached ();
+          break;
+      }
+    }
+
+    gst_object_unref (clock);
+  } else {
+    if (!GST_ELEMENT_CLOCK (rtpsession)) {
+      GST_WARNING_OBJECT (rtpsession,
+          "Don't have a clock yet and can't determine NTP time for this packet");
+    }
+    GST_OBJECT_UNLOCK (rtpsession);
+    ntpnstime = GST_CLOCK_TIME_NONE;
+  }
+
   ret = rtp_session_send_rtp (priv->session, data, is_list, current_time,
-      running_time);
+      running_time, ntpnstime);
   if (ret != GST_FLOW_OK)
     goto push_error;
 
diff --git a/gst/rtpmanager/gstrtpsession.h b/gst/rtpmanager/gstrtpsession.h
index 599ec9a39..5a3ecfc1c 100644
--- a/gst/rtpmanager/gstrtpsession.h
+++ b/gst/rtpmanager/gstrtpsession.h
@@ -80,6 +80,8 @@ struct _GstRtpSessionClass {
 
 GType gst_rtp_session_get_type (void);
 
+GST_ELEMENT_REGISTER_DECLARE (rtpsession);
+
 typedef enum {
   GST_RTP_NTP_TIME_SOURCE_NTP,
   GST_RTP_NTP_TIME_SOURCE_UNIX,
diff --git a/gst/rtpmanager/gstrtpssrcdemux.c b/gst/rtpmanager/gstrtpssrcdemux.c
index 96d53490d..9713131e1 100644
--- a/gst/rtpmanager/gstrtpssrcdemux.c
+++ b/gst/rtpmanager/gstrtpssrcdemux.c
@@ -83,6 +83,10 @@ GST_STATIC_PAD_TEMPLATE ("rtcp_src_%u",
 #define INTERNAL_STREAM_LOCK(obj)   (g_rec_mutex_lock (&(obj)->padlock))
 #define INTERNAL_STREAM_UNLOCK(obj) (g_rec_mutex_unlock (&(obj)->padlock))
 
+#define GST_PAD_FLAG_STICKIES_SENT (GST_PAD_FLAG_LAST << 0)
+#define GST_PAD_STICKIES_SENT(pad)  (GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_STICKIES_SENT))
+#define GST_PAD_SET_STICKIES_SENT(pad) (GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_STICKIES_SENT))
+
 typedef enum
 {
   RTP_PAD,
@@ -107,6 +111,8 @@ enum
 
 #define gst_rtp_ssrc_demux_parent_class parent_class
 G_DEFINE_TYPE (GstRtpSsrcDemux, gst_rtp_ssrc_demux, GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE (rtpssrcdemux, "rtpssrcdemux", GST_RANK_NONE,
+    GST_TYPE_RTP_SSRC_DEMUX);
 
 /* GObject vmethods */
 static void gst_rtp_ssrc_demux_dispose (GObject * object);
@@ -143,24 +149,24 @@ static guint gst_rtp_ssrc_demux_signals[LAST_SIGNAL] = { 0 };
 /*
  * Item for storing GstPad <-> SSRC pairs.
  */
-struct _GstRtpSsrcDemuxPad
+typedef struct
 {
   guint32 ssrc;
   GstPad *rtp_pad;
   GstCaps *caps;
   GstPad *rtcp_pad;
-};
+} GstRtpSsrcDemuxPads;
 
 /* find a src pad for a given SSRC, returns NULL if the SSRC was not found
  * MUST be called with object lock
  */
-static GstRtpSsrcDemuxPad *
-find_demux_pad_for_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc)
+static GstRtpSsrcDemuxPads *
+find_demux_pads_for_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc)
 {
   GSList *walk;
 
   for (walk = demux->srcpads; walk; walk = g_slist_next (walk)) {
-    GstRtpSsrcDemuxPad *pad = (GstRtpSsrcDemuxPad *) walk->data;
+    GstRtpSsrcDemuxPads *pad = (GstRtpSsrcDemuxPads *) walk->data;
 
     if (pad->ssrc == ssrc)
       return pad;
@@ -172,23 +178,23 @@ find_demux_pad_for_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc)
 static GstPad *
 get_demux_pad_for_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc, PadType padtype)
 {
-  GstRtpSsrcDemuxPad *demuxpad;
+  GstRtpSsrcDemuxPads *dpads;
   GstPad *retpad;
 
   GST_OBJECT_LOCK (demux);
 
-  demuxpad = find_demux_pad_for_ssrc (demux, ssrc);
-  if (!demuxpad) {
+  dpads = find_demux_pads_for_ssrc (demux, ssrc);
+  if (!dpads) {
     GST_OBJECT_UNLOCK (demux);
     return NULL;
   }
 
   switch (padtype) {
     case RTP_PAD:
-      retpad = gst_object_ref (demuxpad->rtp_pad);
+      retpad = gst_object_ref (dpads->rtp_pad);
       break;
     case RTCP_PAD:
-      retpad = gst_object_ref (demuxpad->rtcp_pad);
+      retpad = gst_object_ref (dpads->rtcp_pad);
       break;
     default:
       retpad = NULL;
@@ -242,13 +248,11 @@ forward_sticky_events (GstPad * pad, GstEvent ** event, gpointer user_data)
   GstEvent *newevent;
 
   newevent = add_ssrc_and_ref (*event, data->ssrc);
-
   gst_pad_push_event (data->pad, newevent);
 
   return TRUE;
 }
 
-/* With internal stream lock held */
 static void
 forward_initial_events (GstRtpSsrcDemux * demux, guint32 ssrc, GstPad * pad,
     PadType padtype)
@@ -278,7 +282,7 @@ find_or_create_demux_pad_for_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc,
   GstElementClass *klass;
   GstPadTemplate *templ;
   gchar *padname;
-  GstRtpSsrcDemuxPad *demuxpad;
+  GstRtpSsrcDemuxPads *dpads;
   GstPad *retpad;
   guint num_streams;
 
@@ -311,16 +315,13 @@ find_or_create_demux_pad_for_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc,
   g_free (padname);
 
   /* wrap in structure and add to list */
-  demuxpad = g_new0 (GstRtpSsrcDemuxPad, 1);
-  demuxpad->ssrc = ssrc;
-  demuxpad->rtp_pad = rtp_pad;
-  demuxpad->rtcp_pad = rtcp_pad;
-
-  gst_pad_set_element_private (rtp_pad, demuxpad);
-  gst_pad_set_element_private (rtcp_pad, demuxpad);
+  dpads = g_new0 (GstRtpSsrcDemuxPads, 1);
+  dpads->ssrc = ssrc;
+  dpads->rtp_pad = rtp_pad;
+  dpads->rtcp_pad = rtcp_pad;
 
   GST_OBJECT_LOCK (demux);
-  demux->srcpads = g_slist_prepend (demux->srcpads, demuxpad);
+  demux->srcpads = g_slist_prepend (demux->srcpads, dpads);
   GST_OBJECT_UNLOCK (demux);
 
   gst_pad_set_query_function (rtp_pad, gst_rtp_ssrc_demux_src_query);
@@ -336,18 +337,15 @@ find_or_create_demux_pad_for_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc,
   gst_pad_use_fixed_caps (rtcp_pad);
   gst_pad_set_active (rtcp_pad, TRUE);
 
-  forward_initial_events (demux, ssrc, rtp_pad, RTP_PAD);
-  forward_initial_events (demux, ssrc, rtcp_pad, RTCP_PAD);
-
   gst_element_add_pad (GST_ELEMENT_CAST (demux), rtp_pad);
   gst_element_add_pad (GST_ELEMENT_CAST (demux), rtcp_pad);
 
   switch (padtype) {
     case RTP_PAD:
-      retpad = gst_object_ref (demuxpad->rtp_pad);
+      retpad = gst_object_ref (dpads->rtp_pad);
       break;
     case RTCP_PAD:
-      retpad = gst_object_ref (demuxpad->rtcp_pad);
+      retpad = gst_object_ref (dpads->rtcp_pad);
       break;
     default:
       retpad = NULL;
@@ -514,21 +512,22 @@ gst_rtp_ssrc_demux_init (GstRtpSsrcDemux * demux)
 }
 
 static void
-gst_rtp_ssrc_demux_reset (GstRtpSsrcDemux * demux)
+gst_rtp_ssrc_demux_pads_free (GstRtpSsrcDemuxPads * dpads)
 {
-  GSList *walk;
+  gst_pad_set_active (dpads->rtp_pad, FALSE);
+  gst_pad_set_active (dpads->rtcp_pad, FALSE);
 
-  for (walk = demux->srcpads; walk; walk = g_slist_next (walk)) {
-    GstRtpSsrcDemuxPad *dpad = (GstRtpSsrcDemuxPad *) walk->data;
+  gst_element_remove_pad (GST_PAD_PARENT (dpads->rtp_pad), dpads->rtp_pad);
+  gst_element_remove_pad (GST_PAD_PARENT (dpads->rtcp_pad), dpads->rtcp_pad);
 
-    gst_pad_set_active (dpad->rtp_pad, FALSE);
-    gst_pad_set_active (dpad->rtcp_pad, FALSE);
+  g_free (dpads);
+}
 
-    gst_element_remove_pad (GST_ELEMENT_CAST (demux), dpad->rtp_pad);
-    gst_element_remove_pad (GST_ELEMENT_CAST (demux), dpad->rtcp_pad);
-    g_free (dpad);
-  }
-  g_slist_free (demux->srcpads);
+static void
+gst_rtp_ssrc_demux_reset (GstRtpSsrcDemux * demux)
+{
+  g_slist_free_full (demux->srcpads,
+      (GDestroyNotify) gst_rtp_ssrc_demux_pads_free);
   demux->srcpads = NULL;
 }
 
@@ -558,31 +557,25 @@ gst_rtp_ssrc_demux_finalize (GObject * object)
 static void
 gst_rtp_ssrc_demux_clear_ssrc (GstRtpSsrcDemux * demux, guint32 ssrc)
 {
-  GstRtpSsrcDemuxPad *dpad;
+  GstRtpSsrcDemuxPads *dpads;
 
   GST_OBJECT_LOCK (demux);
-  dpad = find_demux_pad_for_ssrc (demux, ssrc);
-  if (dpad == NULL) {
+  dpads = find_demux_pads_for_ssrc (demux, ssrc);
+  if (dpads == NULL) {
     GST_OBJECT_UNLOCK (demux);
     goto unknown_pad;
   }
 
   GST_DEBUG_OBJECT (demux, "clearing pad for SSRC %08x", ssrc);
 
-  demux->srcpads = g_slist_remove (demux->srcpads, dpad);
+  demux->srcpads = g_slist_remove (demux->srcpads, dpads);
   GST_OBJECT_UNLOCK (demux);
 
-  gst_pad_set_active (dpad->rtp_pad, FALSE);
-  gst_pad_set_active (dpad->rtcp_pad, FALSE);
-
   g_signal_emit (G_OBJECT (demux),
       gst_rtp_ssrc_demux_signals[SIGNAL_REMOVED_SSRC_PAD], 0, ssrc,
-      dpad->rtp_pad);
+      dpads->rtp_pad);
 
-  gst_element_remove_pad (GST_ELEMENT_CAST (demux), dpad->rtp_pad);
-  gst_element_remove_pad (GST_ELEMENT_CAST (demux), dpad->rtcp_pad);
-
-  g_free (dpad);
+  gst_rtp_ssrc_demux_pads_free (dpads);
 
   return;
 
@@ -609,12 +602,19 @@ forward_event (GstPad * pad, gpointer user_data)
   GSList *walk = NULL;
   GstEvent *newevent = NULL;
 
+  /* special case for EOS */
+  if (GST_EVENT_TYPE (fdata->event) == GST_EVENT_EOS)
+    GST_PAD_SET_STICKIES_SENT (pad);
+
+  if (GST_EVENT_IS_STICKY (fdata->event) && !GST_PAD_STICKIES_SENT (pad))
+    return FALSE;
+
   GST_OBJECT_LOCK (fdata->demux);
   for (walk = fdata->demux->srcpads; walk; walk = walk->next) {
-    GstRtpSsrcDemuxPad *dpad = (GstRtpSsrcDemuxPad *) walk->data;
+    GstRtpSsrcDemuxPads *dpads = (GstRtpSsrcDemuxPads *) walk->data;
 
-    if (pad == dpad->rtp_pad || pad == dpad->rtcp_pad) {
-      newevent = add_ssrc_and_ref (fdata->event, dpad->ssrc);
+    if (pad == dpads->rtp_pad || pad == dpads->rtcp_pad) {
+      newevent = add_ssrc_and_ref (fdata->event, dpads->ssrc);
       break;
     }
   }
@@ -671,6 +671,11 @@ gst_rtp_ssrc_demux_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
   if (srcpad == NULL)
     goto create_failed;
 
+  if (!GST_PAD_STICKIES_SENT (srcpad)) {
+    forward_initial_events (demux, ssrc, srcpad, RTP_PAD);
+    GST_PAD_SET_STICKIES_SENT (srcpad);
+  }
+
   /* push to srcpad */
   ret = gst_pad_push (srcpad, buf);
 
@@ -761,6 +766,11 @@ gst_rtp_ssrc_demux_rtcp_chain (GstPad * pad, GstObject * parent,
   if (srcpad == NULL)
     goto create_failed;
 
+  if (!GST_PAD_STICKIES_SENT (srcpad)) {
+    forward_initial_events (demux, ssrc, srcpad, RTCP_PAD);
+    GST_PAD_SET_STICKIES_SENT (srcpad);
+  }
+
   /* push to srcpad */
   ret = gst_pad_push (srcpad, buf);
 
@@ -804,15 +814,15 @@ create_failed:
   }
 }
 
-static GstRtpSsrcDemuxPad *
+static GstRtpSsrcDemuxPads *
 find_demux_pad_for_pad (GstRtpSsrcDemux * demux, GstPad * pad)
 {
   GSList *walk;
 
   for (walk = demux->srcpads; walk; walk = g_slist_next (walk)) {
-    GstRtpSsrcDemuxPad *dpad = (GstRtpSsrcDemuxPad *) walk->data;
-    if (dpad->rtp_pad == pad || dpad->rtcp_pad == pad) {
-      return dpad;
+    GstRtpSsrcDemuxPads *dpads = (GstRtpSsrcDemuxPads *) walk->data;
+    if (dpads->rtp_pad == pad || dpads->rtcp_pad == pad) {
+      return dpads;
     }
   }
 
@@ -835,14 +845,14 @@ gst_rtp_ssrc_demux_src_event (GstPad * pad, GstObject * parent,
     case GST_EVENT_CUSTOM_BOTH_OOB:
       s = gst_event_get_structure (event);
       if (s && !gst_structure_has_field (s, "ssrc")) {
-        GstRtpSsrcDemuxPad *dpad = find_demux_pad_for_pad (demux, pad);
+        GstRtpSsrcDemuxPads *dpads = find_demux_pad_for_pad (demux, pad);
 
-        if (dpad) {
+        if (dpads) {
           GstStructure *ws;
 
           event = gst_event_make_writable (event);
           ws = gst_event_writable_structure (event);
-          gst_structure_set (ws, "ssrc", G_TYPE_UINT, dpad->ssrc, NULL);
+          gst_structure_set (ws, "ssrc", G_TYPE_UINT, dpads->ssrc, NULL);
         }
       }
       break;
@@ -865,12 +875,12 @@ gst_rtp_ssrc_demux_iterate_internal_links_src (GstPad * pad, GstObject * parent)
 
   GST_OBJECT_LOCK (demux);
   for (current = demux->srcpads; current; current = g_slist_next (current)) {
-    GstRtpSsrcDemuxPad *dpad = (GstRtpSsrcDemuxPad *) current->data;
+    GstRtpSsrcDemuxPads *dpads = (GstRtpSsrcDemuxPads *) current->data;
 
-    if (pad == dpad->rtp_pad) {
+    if (pad == dpads->rtp_pad) {
       otherpad = demux->rtp_sink;
       break;
-    } else if (pad == dpad->rtcp_pad) {
+    } else if (pad == dpads->rtcp_pad) {
       otherpad = demux->rtcp_sink;
       break;
     }
@@ -947,17 +957,12 @@ gst_rtp_ssrc_demux_src_query (GstPad * pad, GstObject * parent,
       if ((res = gst_pad_peer_query (demux->rtp_sink, query))) {
         gboolean live;
         GstClockTime min_latency, max_latency;
-        GstRtpSsrcDemuxPad *demuxpad;
-
-        demuxpad = gst_pad_get_element_private (pad);
 
         gst_query_parse_latency (query, &live, &min_latency, &max_latency);
 
-        GST_DEBUG_OBJECT (demux, "peer min latency %" GST_TIME_FORMAT,
+        GST_DEBUG_OBJECT (pad, "peer min latency %" GST_TIME_FORMAT,
             GST_TIME_ARGS (min_latency));
 
-        GST_DEBUG_OBJECT (demux, "latency for SSRC %08x", demuxpad->ssrc);
-
         gst_query_set_latency (query, live, min_latency, max_latency);
       }
       break;
diff --git a/gst/rtpmanager/gstrtpssrcdemux.h b/gst/rtpmanager/gstrtpssrcdemux.h
index 3bb210c8e..e7e347d25 100644
--- a/gst/rtpmanager/gstrtpssrcdemux.h
+++ b/gst/rtpmanager/gstrtpssrcdemux.h
@@ -30,7 +30,6 @@
 
 typedef struct _GstRtpSsrcDemux GstRtpSsrcDemux;
 typedef struct _GstRtpSsrcDemuxClass GstRtpSsrcDemuxClass;
-typedef struct _GstRtpSsrcDemuxPad GstRtpSsrcDemuxPad;
 
 struct _GstRtpSsrcDemux
 {
@@ -58,4 +57,6 @@ struct _GstRtpSsrcDemuxClass
 
 GType gst_rtp_ssrc_demux_get_type (void);
 
+GST_ELEMENT_REGISTER_DECLARE (rtpssrcdemux);
+
 #endif /* __GST_RTP_SSRC_DEMUX_H__ */
diff --git a/gst/rtpmanager/gstrtpst2022-1-fecdec.c b/gst/rtpmanager/gstrtpst2022-1-fecdec.c
new file mode 100644
index 000000000..77b275fb1
--- /dev/null
+++ b/gst/rtpmanager/gstrtpst2022-1-fecdec.c
@@ -0,0 +1,1013 @@
+/* GStreamer
+ * Copyright (C) <2020> Mathieu Duponchelle <mathieu@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-rtpst2022-1-fecdec
+ * @see_also: #element-rtpst2022-1-fecenc
+ *
+ * This element takes as input a media stream and up to two FEC
+ * streams as described in SMPTE 2022-1: Forward Error Correction
+ * for Real-Time Video/Audio Transport Over IP Networks, and makes
+ * use of the FEC packets to recover media packets that may have
+ * gotten lost.
+ *
+ * ## Design
+ *
+ * The approach picked for this element is to proactively reconstruct missing
+ * packets as soon as possible. When a FEC packet arrives, the element
+ * immediately checks whether a media packet in the row / column it protects
+ * can be reconstructed.
+ *
+ * Similarly, when a media packet comes in, the element checks whether it has
+ * already received a corresponding packet in both the column and row the packet
+ * belongs to, and if so goes through the first step listed above.
+ *
+ * This process is repeated recursively, allowing for recoveries over one
+ * dimension to unblock recoveries over the other.
+ *
+ * In perfect networking conditions, this incurs next to no overhead as FEC
+ * packets will arrive after the media packets, causing no reconstruction to
+ * take place, just a few checks upon chaining.
+ *
+ * ## sender / receiver example
+ *
+ * ``` shell
+ * gst-launch-1.0 \
+ *   rtpbin name=rtp fec-encoders='fec,0="rtpst2022-1-fecenc\ rows\=5\ columns\=5";' \
+ *   uridecodebin uri=file:///path/to/video/file ! x264enc key-int-max=60 tune=zerolatency ! \
+ *     queue ! mpegtsmux ! rtpmp2tpay ssrc=0 ! rtp.send_rtp_sink_0 \
+ *   rtp.send_rtp_src_0 ! udpsink host=127.0.0.1 port=5000 \
+ *   rtp.send_fec_src_0_0 ! udpsink host=127.0.0.1 port=5002 async=false \
+ *   rtp.send_fec_src_0_1 ! udpsink host=127.0.0.1 port=5004 async=false
+ * ```
+ *
+ * ``` shell
+ * gst-launch-1.0 \
+ *   rtpbin latency=500 fec-decoders='fec,0="rtpst2022-1-fecdec\ size-time\=1000000000";' name=rtp \
+ *   udpsrc address=127.0.0.1 port=5002 caps="application/x-rtp, payload=96" ! queue ! rtp.recv_fec_sink_0_0 \
+ *   udpsrc address=127.0.0.1 port=5004 caps="application/x-rtp, payload=96" ! queue ! rtp.recv_fec_sink_0_1 \
+ *   udpsrc address=127.0.0.1 port=5000 caps="application/x-rtp, media=video, clock-rate=90000, encoding-name=mp2t, payload=33" ! \
+ *     queue ! netsim drop-probability=0.05 ! rtp.recv_rtp_sink_0 \
+ *   rtp. ! decodebin ! videoconvert ! queue ! autovideosink
+ * ```
+ *
+ * With the above command line, as the media packet size is constant,
+ * the fec overhead can be approximated to the number of fec packets
+ * per 2-d matrix of media packet, here 10 fec packets for each 25
+ * media packets.
+ *
+ * Increasing the number of rows and columns will decrease the overhead,
+ * but obviously increase the likelihood of recovery failure for lost
+ * packets on the receiver side.
+ *
+ * Since: 1.20
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/base/base.h>
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtpst2022-1-fecdec.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_rtpst_2022_1_fecdec_debug);
+#define GST_CAT_DEFAULT gst_rtpst_2022_1_fecdec_debug
+
+#define DEFAULT_SIZE_TIME (GST_SECOND)
+
+typedef struct
+{
+  guint16 seq;
+  GstBuffer *buffer;
+} Item;
+
+static GstFlowReturn store_media_item (GstRTPST_2022_1_FecDec * dec,
+    GstRTPBuffer * rtp, Item * item);
+
+static void
+free_item (Item * item)
+{
+  gst_buffer_unref (item->buffer);
+  item->buffer = NULL;
+  g_free (item);
+}
+
+static gint
+cmp_items (Item * a, Item * b, gpointer unused)
+{
+  return gst_rtp_buffer_compare_seqnum (b->seq, a->seq);
+}
+
+enum
+{
+  PROP_0,
+  PROP_SIZE_TIME,
+};
+
+struct _GstRTPST_2022_1_FecDecClass
+{
+  GstElementClass class;
+};
+
+struct _GstRTPST_2022_1_FecDec
+{
+  GstElement element;
+
+  GstPad *srcpad;
+  GstPad *sinkpad;
+  GList *fec_sinkpads;
+
+  /* All the following field are protected by the OBJECT_LOCK */
+  GSequence *packets;
+  GHashTable *column_fec_packets;
+  GSequence *fec_packets[2];
+  /* N columns */
+  guint l;
+  /* N rows */
+  guint d;
+
+  GstClockTime size_time;
+  GstClockTime max_arrival_time;
+  GstClockTime max_fec_arrival_time[2];
+};
+
+#define RTP_CAPS "application/x-rtp"
+
+typedef struct
+{
+  guint16 seq;
+  guint16 len;
+  guint8 E;
+  guint8 pt;
+  guint32 mask;
+  guint32 timestamp;
+  guint8 N;
+  guint8 D;
+  guint8 type;
+  guint8 index;
+  guint8 offset;
+  guint8 NA;
+  guint8 seq_ext;
+  guint8 *payload;
+  guint payload_len;
+  gboolean marker;
+  gboolean padding;
+  gboolean extension;
+} Rtp2DFecHeader;
+
+static GstStaticPadTemplate fec_sink_template =
+GST_STATIC_PAD_TEMPLATE ("fec_%u",
+    GST_PAD_SINK,
+    GST_PAD_REQUEST,
+    GST_STATIC_CAPS (RTP_CAPS));
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (RTP_CAPS));
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (RTP_CAPS));
+
+#define gst_rtpst_2022_1_fecdec_parent_class parent_class
+G_DEFINE_TYPE (GstRTPST_2022_1_FecDec, gst_rtpst_2022_1_fecdec,
+    GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE (rtpst2022_1_fecdec, "rtpst2022-1-fecdec",
+    GST_RANK_NONE, GST_TYPE_RTPST_2022_1_FECDEC);
+
+static void
+trim_items (GstRTPST_2022_1_FecDec * dec)
+{
+  GSequenceIter *tmp_iter, *iter = NULL;
+
+  for (tmp_iter = g_sequence_get_begin_iter (dec->packets);
+      tmp_iter; tmp_iter = g_sequence_iter_next (tmp_iter)) {
+    Item *item;
+
+    if (g_sequence_iter_is_end (tmp_iter))
+      break;
+
+    item = g_sequence_get (tmp_iter);
+
+    if (dec->max_arrival_time - GST_BUFFER_DTS_OR_PTS (item->buffer) <
+        dec->size_time)
+      break;
+
+    iter = tmp_iter;
+  }
+
+  if (iter) {
+    Item *item = g_sequence_get (iter);
+    GST_TRACE_OBJECT (dec,
+        "Trimming packets up to %" GST_TIME_FORMAT " (seq: %u)",
+        GST_TIME_ARGS (GST_BUFFER_DTS_OR_PTS (item->buffer)), item->seq);
+    g_sequence_remove_range (g_sequence_get_begin_iter (dec->packets),
+        g_sequence_iter_next (iter));
+  }
+}
+
+static void
+trim_fec_items (GstRTPST_2022_1_FecDec * dec, guint D)
+{
+  GSequenceIter *tmp_iter, *iter = NULL;
+
+  for (tmp_iter = g_sequence_get_begin_iter (dec->fec_packets[D]);
+      tmp_iter; tmp_iter = g_sequence_iter_next (tmp_iter)) {
+    Item *item;
+
+    if (g_sequence_iter_is_end (tmp_iter))
+      break;
+
+    item = g_sequence_get (tmp_iter);
+
+    if (dec->max_fec_arrival_time[D] - GST_BUFFER_DTS_OR_PTS (item->buffer) <
+        dec->size_time)
+      break;
+
+    if (!D) {
+      guint i;
+      guint16 seq;
+
+      for (i = 0; i < dec->d; i++) {
+        seq = item->seq + i * dec->l;
+        g_hash_table_remove (dec->column_fec_packets, GUINT_TO_POINTER (seq));
+      }
+    }
+
+    iter = tmp_iter;
+  }
+
+  if (iter) {
+    Item *item = g_sequence_get (iter);
+    GST_TRACE_OBJECT (dec,
+        "Trimming %s FEC packets up to %" GST_TIME_FORMAT " (seq: %u)",
+        D ? "row" : "column",
+        GST_TIME_ARGS (GST_BUFFER_DTS_OR_PTS (item->buffer)), item->seq);
+    g_sequence_remove_range (g_sequence_get_begin_iter (dec->fec_packets[D]),
+        g_sequence_iter_next (iter));
+  }
+}
+
+static Item *
+lookup_media_packet (GstRTPST_2022_1_FecDec * dec, guint16 seqnum)
+{
+  GSequenceIter *iter;
+  Item *ret = NULL;
+  Item dummy = { seqnum, NULL };
+
+  iter =
+      g_sequence_lookup (dec->packets, &dummy, (GCompareDataFunc) cmp_items,
+      NULL);
+
+  if (iter)
+    ret = g_sequence_get (iter);
+
+  return ret;
+}
+
+static gboolean
+parse_header (GstRTPBuffer * rtp, Rtp2DFecHeader * fec)
+{
+  gboolean ret = FALSE;
+  GstBitReader bits;
+  guint8 *data = gst_rtp_buffer_get_payload (rtp);
+  guint len = gst_rtp_buffer_get_payload_len (rtp);
+
+  if (len < 16)
+    goto done;
+
+  gst_bit_reader_init (&bits, data, len);
+
+  fec->marker = gst_rtp_buffer_get_marker (rtp);
+  fec->padding = gst_rtp_buffer_get_padding (rtp);
+  fec->extension = gst_rtp_buffer_get_extension (rtp);
+  fec->seq = gst_bit_reader_get_bits_uint16_unchecked (&bits, 16);
+  fec->len = gst_bit_reader_get_bits_uint16_unchecked (&bits, 16);
+  fec->E = gst_bit_reader_get_bits_uint8_unchecked (&bits, 1);
+  fec->pt = gst_bit_reader_get_bits_uint8_unchecked (&bits, 7);
+  fec->mask = gst_bit_reader_get_bits_uint32_unchecked (&bits, 24);
+  fec->timestamp = gst_bit_reader_get_bits_uint32_unchecked (&bits, 32);
+  fec->N = gst_bit_reader_get_bits_uint8_unchecked (&bits, 1);
+  fec->D = gst_bit_reader_get_bits_uint8_unchecked (&bits, 1);
+  fec->type = gst_bit_reader_get_bits_uint8_unchecked (&bits, 3);
+  fec->index = gst_bit_reader_get_bits_uint8_unchecked (&bits, 3);
+  fec->offset = gst_bit_reader_get_bits_uint8_unchecked (&bits, 8);
+  fec->NA = gst_bit_reader_get_bits_uint8_unchecked (&bits, 8);
+  fec->seq_ext = gst_bit_reader_get_bits_uint8_unchecked (&bits, 8);
+  fec->payload = data + 16;
+  fec->payload_len = len - 16;
+
+  ret = TRUE;
+
+done:
+  return ret;
+}
+
+static Item *
+get_row_fec (GstRTPST_2022_1_FecDec * dec, guint16 seqnum)
+{
+  GSequenceIter *iter;
+  Item *ret = NULL;
+  Item dummy = { 0, };
+
+  if (dec->l == G_MAXUINT)
+    goto done;
+
+  /* Potential underflow is intended */
+  dummy.seq = seqnum - dec->l;
+
+  iter =
+      g_sequence_search (dec->fec_packets[1], &dummy,
+      (GCompareDataFunc) cmp_items, NULL);
+
+  if (!g_sequence_iter_is_end (iter)) {
+    gint seqdiff;
+    ret = g_sequence_get (iter);
+
+    seqdiff = gst_rtp_buffer_compare_seqnum (ret->seq, seqnum);
+
+    /* Now check whether the fec packet does apply */
+    if (seqdiff < 0 || seqdiff >= dec->l)
+      ret = NULL;
+  }
+
+done:
+  return ret;
+}
+
+static Item *
+get_column_fec (GstRTPST_2022_1_FecDec * dec, guint16 seqnum)
+{
+  Item *ret = NULL;
+
+  if (dec->l == G_MAXUINT || dec->d == G_MAXUINT)
+    goto done;
+
+  ret =
+      g_hash_table_lookup (dec->column_fec_packets, GUINT_TO_POINTER (seqnum));
+
+done:
+  return ret;
+}
+
+static void
+_xor_mem (guint8 * restrict dst, const guint8 * restrict src, gsize length)
+{
+  guint i;
+
+  for (i = 0; i < (length / sizeof (guint64)); ++i) {
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+    GST_WRITE_UINT64_LE (dst,
+        GST_READ_UINT64_LE (dst) ^ GST_READ_UINT64_LE (src));
+#else
+    GST_WRITE_UINT64_BE (dst,
+        GST_READ_UINT64_BE (dst) ^ GST_READ_UINT64_BE (src));
+#endif
+    dst += sizeof (guint64);
+    src += sizeof (guint64);
+  }
+  for (i = 0; i < (length % sizeof (guint64)); ++i)
+    dst[i] ^= src[i];
+}
+
+static GstFlowReturn
+xor_items (GstRTPST_2022_1_FecDec * dec, Rtp2DFecHeader * fec, GList * packets,
+    guint16 seqnum)
+{
+  guint8 *xored;
+  guint32 xored_timestamp;
+  guint8 xored_pt;
+  guint16 xored_payload_len;
+  Item *item;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  GList *tmp;
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstBuffer *buffer;
+  gboolean xored_marker;
+  gboolean xored_padding;
+  gboolean xored_extension;
+
+  /* Figure out the recovered packet length first */
+  xored_payload_len = fec->len;
+  for (tmp = packets; tmp; tmp = tmp->next) {
+    GstRTPBuffer media_rtp = GST_RTP_BUFFER_INIT;
+    Item *item = (Item *) tmp->data;
+
+    gst_rtp_buffer_map (item->buffer, GST_MAP_READ, &media_rtp);
+    xored_payload_len ^= gst_rtp_buffer_get_payload_len (&media_rtp);
+    gst_rtp_buffer_unmap (&media_rtp);
+  }
+
+  if (xored_payload_len > fec->payload_len) {
+    GST_WARNING_OBJECT (dec, "FEC payload len %u < length recovery %u",
+        fec->payload_len, xored_payload_len);
+    goto done;
+  }
+
+  item = g_malloc0 (sizeof (Item));
+  item->seq = seqnum;
+  item->buffer = gst_rtp_buffer_new_allocate (xored_payload_len, 0, 0);
+  gst_rtp_buffer_map (item->buffer, GST_MAP_WRITE, &rtp);
+
+  xored = gst_rtp_buffer_get_payload (&rtp);
+  memcpy (xored, fec->payload, xored_payload_len);
+  xored_timestamp = fec->timestamp;
+  xored_pt = fec->pt;
+  xored_marker = fec->marker;
+  xored_padding = fec->padding;
+  xored_extension = fec->extension;
+
+  for (tmp = packets; tmp; tmp = tmp->next) {
+    GstRTPBuffer media_rtp = GST_RTP_BUFFER_INIT;
+    Item *item = (Item *) tmp->data;
+
+    gst_rtp_buffer_map (item->buffer, GST_MAP_READ, &media_rtp);
+    _xor_mem (xored, gst_rtp_buffer_get_payload (&media_rtp),
+        MIN (gst_rtp_buffer_get_payload_len (&media_rtp), xored_payload_len));
+    xored_timestamp ^= gst_rtp_buffer_get_timestamp (&media_rtp);
+    xored_pt ^= gst_rtp_buffer_get_payload_type (&media_rtp);
+    xored_marker ^= gst_rtp_buffer_get_marker (&media_rtp);
+    xored_padding ^= gst_rtp_buffer_get_padding (&media_rtp);
+    xored_extension ^= gst_rtp_buffer_get_extension (&media_rtp);
+
+    gst_rtp_buffer_unmap (&media_rtp);
+  }
+
+  GST_DEBUG_OBJECT (dec,
+      "Recovered buffer through %s FEC with seqnum %u, payload len %u and timestamp %u",
+      fec->D ? "row" : "column", seqnum, xored_payload_len, xored_timestamp);
+
+  GST_BUFFER_DTS (item->buffer) = dec->max_arrival_time;
+
+  gst_rtp_buffer_set_timestamp (&rtp, xored_timestamp);
+  gst_rtp_buffer_set_seq (&rtp, seqnum);
+  gst_rtp_buffer_set_payload_type (&rtp, xored_pt);
+  gst_rtp_buffer_set_marker (&rtp, xored_marker);
+  gst_rtp_buffer_set_padding (&rtp, xored_padding);
+  gst_rtp_buffer_set_extension (&rtp, xored_extension);
+
+  gst_rtp_buffer_unmap (&rtp);
+
+  /* Store a ref on item->buffer as store_media_item may
+   * recurse and call this method again, potentially releasing
+   * the object lock and leaving our item unprotected in
+   * dec->packets
+   */
+  buffer = gst_buffer_ref (item->buffer);
+
+  /* It is right that we should celebrate,
+   * for your brother was dead, and is alive again */
+  gst_rtp_buffer_map (item->buffer, GST_MAP_READ, &rtp);
+  ret = store_media_item (dec, &rtp, item);
+  gst_rtp_buffer_unmap (&rtp);
+
+  if (ret == GST_FLOW_OK) {
+    /* Unlocking here is safe */
+    GST_OBJECT_UNLOCK (dec);
+    ret = gst_pad_push (dec->srcpad, buffer);
+    GST_OBJECT_LOCK (dec);
+  } else {
+    gst_buffer_unref (buffer);
+  }
+
+done:
+  return ret;
+}
+
+/* Returns a flow value if we should discard the packet, GST_FLOW_CUSTOM_SUCCESS otherwise */
+static GstFlowReturn
+check_fec (GstRTPST_2022_1_FecDec * dec, Rtp2DFecHeader * fec)
+{
+  GList *packets = NULL;
+  gint missing_seq = -1;
+  guint n_packets = 0;
+  guint required_n_packets;
+  GstFlowReturn ret = GST_FLOW_OK;
+
+  if (fec->D) {
+    guint i = 0;
+
+    required_n_packets = dec->l;
+
+    for (i = 0; i < dec->l; i++) {
+      Item *item = lookup_media_packet (dec, fec->seq + i);
+
+      if (item) {
+        packets = g_list_prepend (packets, item);
+        n_packets += 1;
+      } else {
+        missing_seq = fec->seq + i;
+      }
+    }
+  } else {
+    guint i = 0;
+
+    required_n_packets = dec->d;
+
+    for (i = 0; i < dec->d; i++) {
+      Item *item = lookup_media_packet (dec, fec->seq + i * dec->l);
+
+      if (item) {
+        packets = g_list_prepend (packets, item);
+        n_packets += 1;
+      } else {
+        missing_seq = fec->seq + i * dec->l;
+      }
+    }
+  }
+
+  if (n_packets == required_n_packets) {
+    g_assert (missing_seq == -1);
+    GST_LOG_OBJECT (dec,
+        "All media packets present, we can discard that FEC packet");
+  } else if (n_packets + 1 == required_n_packets) {
+    g_assert (missing_seq != -1);
+    ret = xor_items (dec, fec, packets, missing_seq);
+    GST_LOG_OBJECT (dec, "We have enough info to reconstruct %u", missing_seq);
+  } else {
+    ret = GST_FLOW_CUSTOM_SUCCESS;
+    GST_LOG_OBJECT (dec, "Too many media packets missing, storing FEC packet");
+  }
+  g_list_free (packets);
+
+  return ret;
+}
+
+static GstFlowReturn
+check_fec_item (GstRTPST_2022_1_FecDec * dec, Item * item)
+{
+  Rtp2DFecHeader fec;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  GstFlowReturn ret;
+
+  gst_rtp_buffer_map (item->buffer, GST_MAP_READ, &rtp);
+
+  parse_header (&rtp, &fec);
+
+  ret = check_fec (dec, &fec);
+
+  gst_rtp_buffer_unmap (&rtp);
+
+  return ret;
+}
+
+static GstFlowReturn
+store_media_item (GstRTPST_2022_1_FecDec * dec, GstRTPBuffer * rtp, Item * item)
+{
+  GstFlowReturn ret = GST_FLOW_OK;
+  Item *fec_item;
+  guint16 seq;
+
+  seq = gst_rtp_buffer_get_seq (rtp);
+
+  g_sequence_insert_sorted (dec->packets, item, (GCompareDataFunc) cmp_items,
+      NULL);
+
+  if ((fec_item = get_row_fec (dec, seq))) {
+    ret = check_fec_item (dec, fec_item);
+    if (ret == GST_FLOW_CUSTOM_SUCCESS)
+      ret = GST_FLOW_OK;
+  }
+
+  if (ret == GST_FLOW_OK && (fec_item = get_column_fec (dec, seq))) {
+    ret = check_fec_item (dec, fec_item);
+    if (ret == GST_FLOW_CUSTOM_SUCCESS)
+      ret = GST_FLOW_OK;
+  }
+
+  return ret;
+}
+
+static GstFlowReturn
+store_media (GstRTPST_2022_1_FecDec * dec, GstRTPBuffer * rtp,
+    GstBuffer * buffer)
+{
+  Item *item;
+  guint16 seq;
+
+  seq = gst_rtp_buffer_get_seq (rtp);
+  item = g_malloc0 (sizeof (Item));
+  item->buffer = gst_buffer_ref (buffer);
+  item->seq = seq;
+
+  return store_media_item (dec, rtp, item);
+}
+
+static GstFlowReturn
+gst_rtpst_2022_1_fecdec_sink_chain_fec (GstPad * pad, GstObject * parent,
+    GstBuffer * buffer)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (parent);
+  Rtp2DFecHeader fec = { 0, };
+  guint payload_len;
+  guint8 *payload;
+  GstFlowReturn ret = GST_FLOW_OK;
+  Item *item;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+
+  GST_OBJECT_LOCK (dec);
+
+  if (!gst_rtp_buffer_map (buffer, GST_MAP_READ, &rtp)) {
+    GST_WARNING_OBJECT (pad, "Chained FEC buffer isn't valid RTP");
+    goto discard;
+  }
+
+  payload_len = gst_rtp_buffer_get_payload_len (&rtp);
+  payload = gst_rtp_buffer_get_payload (&rtp);
+
+  if (!parse_header (&rtp, &fec)) {
+    GST_WARNING_OBJECT (pad, "Failed to parse FEC header (payload len: %d)",
+        payload_len);
+    GST_MEMDUMP_OBJECT (pad, "Invalid payload", payload, payload_len);
+    goto discard;
+  }
+
+  GST_TRACE_OBJECT
+      (pad,
+      "Handling FEC buffer with SNBase / N / D / NA / offset %u / %u / %u / %u / %u",
+      fec.seq, fec.N, fec.D, fec.NA, fec.offset);
+
+  if (fec.D) {
+    if (dec->l == G_MAXUINT) {
+      dec->l = fec.NA;
+    } else if (fec.NA != dec->l) {
+      GST_WARNING_OBJECT (dec, "2D FEC dimensionality cannot change");
+      goto discard;
+    }
+
+    if (fec.offset != 1) {
+      GST_WARNING_OBJECT (pad, "offset must be 1 for row FEC packets");
+      goto discard;
+    }
+  } else {
+    if (dec->d == G_MAXUINT) {
+      dec->d = fec.NA;
+    } else if (fec.NA != dec->d) {
+      GST_WARNING_OBJECT (dec, "2D FEC dimensionality cannot change");
+      goto discard;
+    }
+
+    if (dec->l == G_MAXUINT) {
+      dec->l = fec.offset;
+    } else if (fec.offset != dec->l) {
+      GST_WARNING_OBJECT (dec, "2D FEC dimensionality cannot change");
+      goto discard;
+    }
+  }
+
+  dec->max_fec_arrival_time[fec.D] = GST_BUFFER_DTS_OR_PTS (buffer);
+  trim_fec_items (dec, fec.D);
+
+  ret = check_fec (dec, &fec);
+
+  if (ret == GST_FLOW_CUSTOM_SUCCESS) {
+    item = g_malloc0 (sizeof (Item));
+    item->buffer = buffer;
+    item->seq = fec.seq;
+
+    if (!fec.D) {
+      guint i;
+      guint16 seq;
+
+      for (i = 0; i < dec->d; i++) {
+        seq = fec.seq + i * dec->l;
+        g_hash_table_insert (dec->column_fec_packets, GUINT_TO_POINTER (seq),
+            item);
+      }
+    }
+    g_sequence_insert_sorted (dec->fec_packets[fec.D], item,
+        (GCompareDataFunc) cmp_items, NULL);
+    ret = GST_FLOW_OK;
+  } else {
+    goto discard;
+  }
+
+  gst_rtp_buffer_unmap (&rtp);
+
+done:
+  GST_OBJECT_UNLOCK (dec);
+  return ret;
+
+discard:
+  if (rtp.buffer != NULL)
+    gst_rtp_buffer_unmap (&rtp);
+
+  gst_buffer_unref (buffer);
+
+  goto done;
+}
+
+static GstFlowReturn
+gst_rtpst_2022_1_fecdec_sink_chain (GstPad * pad, GstObject * parent,
+    GstBuffer * buffer)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (parent);
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+
+  if (!gst_rtp_buffer_map (buffer, GST_MAP_READ, &rtp)) {
+    GST_WARNING_OBJECT (pad, "Chained buffer isn't valid RTP");
+    goto error;
+  }
+
+  GST_OBJECT_LOCK (dec);
+  dec->max_arrival_time =
+      MAX (dec->max_arrival_time, GST_BUFFER_DTS_OR_PTS (buffer));
+  trim_items (dec);
+  ret = store_media (dec, &rtp, buffer);
+  GST_OBJECT_UNLOCK (dec);
+
+  gst_rtp_buffer_unmap (&rtp);
+
+  if (ret == GST_FLOW_OK)
+    ret = gst_pad_push (dec->srcpad, buffer);
+
+done:
+  return ret;
+
+error:
+  gst_buffer_unref (buffer);
+  goto done;
+}
+
+static gboolean
+gst_rtpst_2022_1_fecdec_src_event (GstPad * pad, GstObject * parent,
+    GstEvent * event)
+{
+  gboolean handled = FALSE;
+  gboolean ret = TRUE;
+
+  if (!handled) {
+    gst_pad_event_default (pad, parent, event);
+  }
+
+  return ret;
+}
+
+/* Takes the object lock */
+static void
+gst_rtpst_2022_1_fecdec_reset (GstRTPST_2022_1_FecDec * dec, gboolean allocate)
+{
+  guint i;
+
+  GST_OBJECT_LOCK (dec);
+
+  if (dec->packets) {
+    g_sequence_free (dec->packets);
+    dec->packets = NULL;
+  }
+
+  if (dec->column_fec_packets) {
+    g_hash_table_unref (dec->column_fec_packets);
+    dec->column_fec_packets = NULL;
+  }
+
+  if (allocate) {
+    dec->packets = g_sequence_new ((GDestroyNotify) free_item);
+    dec->column_fec_packets = g_hash_table_new (g_direct_hash, g_direct_equal);
+  }
+
+  for (i = 0; i < 2; i++) {
+    if (dec->fec_packets[i]) {
+      g_sequence_free (dec->fec_packets[i]);
+      dec->fec_packets[i] = NULL;
+    }
+
+    if (allocate)
+      dec->fec_packets[i] = g_sequence_new ((GDestroyNotify) free_item);
+  }
+
+  dec->d = G_MAXUINT;
+  dec->l = G_MAXUINT;
+
+  GST_OBJECT_UNLOCK (dec);
+}
+
+static GstStateChangeReturn
+gst_rtpst_2022_1_fecdec_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret;
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_rtpst_2022_1_fecdec_reset (dec, TRUE);
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_rtpst_2022_1_fecdec_reset (dec, FALSE);
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  return ret;
+}
+
+static void
+gst_rtpst_2022_1_fecdec_finalize (GObject * object)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (object);
+
+  gst_rtpst_2022_1_fecdec_reset (dec, FALSE);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_rtpst_2022_1_fecdec_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (object);
+
+  switch (prop_id) {
+    case PROP_SIZE_TIME:
+      dec->size_time = g_value_get_uint64 (value);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtpst_2022_1_fecdec_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (object);
+
+  switch (prop_id) {
+    case PROP_SIZE_TIME:
+      g_value_set_uint64 (value, dec->size_time);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+gst_2d_fec_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (parent);
+  gboolean ret;
+
+  if (GST_EVENT_TYPE (event) == GST_EVENT_FLUSH_STOP)
+    gst_rtpst_2022_1_fecdec_reset (dec, TRUE);
+
+  ret = gst_pad_event_default (pad, parent, event);
+
+  return ret;
+}
+
+static GstIterator *
+gst_rtpst_2022_1_fecdec_iterate_linked_pads (GstPad * pad, GstObject * parent)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (parent);
+  GstPad *otherpad = NULL;
+  GstIterator *it = NULL;
+  GValue val = { 0, };
+
+  if (pad == dec->srcpad)
+    otherpad = dec->sinkpad;
+  else if (pad == dec->sinkpad)
+    otherpad = dec->srcpad;
+
+  if (otherpad) {
+    g_value_init (&val, GST_TYPE_PAD);
+    g_value_set_object (&val, otherpad);
+    it = gst_iterator_new_single (GST_TYPE_PAD, &val);
+    g_value_unset (&val);
+  }
+
+  return it;
+}
+
+static GstPad *
+gst_rtpst_2022_1_fecdec_request_new_pad (GstElement * element,
+    GstPadTemplate * templ, const gchar * name, const GstCaps * caps)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (element);
+  GstPad *sinkpad = NULL;
+
+  GST_DEBUG_OBJECT (element, "requesting pad");
+
+  if (g_list_length (dec->fec_sinkpads) > 1) {
+    GST_ERROR_OBJECT (dec, "not accepting more than two fec streams");
+    goto done;
+  }
+
+  sinkpad = gst_pad_new_from_template (templ, name);
+  gst_pad_set_chain_function (sinkpad, gst_rtpst_2022_1_fecdec_sink_chain_fec);
+  gst_element_add_pad (GST_ELEMENT (dec), sinkpad);
+  gst_pad_set_iterate_internal_links_function (sinkpad,
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_iterate_linked_pads));
+
+  gst_pad_set_active (sinkpad, TRUE);
+
+  GST_DEBUG_OBJECT (element, "requested pad %s:%s",
+      GST_DEBUG_PAD_NAME (sinkpad));
+
+done:
+  return sinkpad;
+}
+
+static void
+gst_rtpst_2022_1_fecdec_release_pad (GstElement * element, GstPad * pad)
+{
+  GstRTPST_2022_1_FecDec *dec = GST_RTPST_2022_1_FECDEC_CAST (element);
+
+  GST_DEBUG_OBJECT (element, "releasing pad %s:%s", GST_DEBUG_PAD_NAME (pad));
+
+  dec->fec_sinkpads = g_list_remove (dec->fec_sinkpads, pad);
+
+  gst_pad_set_active (pad, FALSE);
+  gst_element_remove_pad (GST_ELEMENT_CAST (dec), pad);
+}
+
+static void
+gst_rtpst_2022_1_fecdec_class_init (GstRTPST_2022_1_FecDecClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->set_property =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_set_property);
+  gobject_class->get_property =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_get_property);
+  gobject_class->finalize =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_finalize);
+
+  g_object_class_install_property (gobject_class, PROP_SIZE_TIME,
+      g_param_spec_uint64 ("size-time", "Storage size (in ns)",
+          "The amount of data to store (in ns, 0-disable)", 0,
+          G_MAXUINT64, DEFAULT_SIZE_TIME,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS));
+
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_change_state);
+  gstelement_class->request_new_pad =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_request_new_pad);
+  gstelement_class->release_pad =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_release_pad);
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "SMPTE 2022-1 FEC decoder", "SMPTE 2022-1 FEC decoding",
+      "performs FEC as described by SMPTE 2022-1",
+      "Mathieu Duponchelle <mathieu@centricular.com>");
+
+  gst_element_class_add_static_pad_template (gstelement_class, &sink_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &fec_sink_template);
+  gst_element_class_add_static_pad_template (gstelement_class, &src_template);
+
+  GST_DEBUG_CATEGORY_INIT (gst_rtpst_2022_1_fecdec_debug,
+      "rtpst2022-1-fecdec", 0, "SMPTE 2022-1 FEC decoder element");
+}
+
+static void
+gst_rtpst_2022_1_fecdec_init (GstRTPST_2022_1_FecDec * dec)
+{
+  dec->srcpad = gst_pad_new_from_static_template (&src_template, "src");
+  GST_PAD_SET_PROXY_CAPS (dec->srcpad);
+  gst_pad_use_fixed_caps (dec->srcpad);
+  gst_pad_set_event_function (dec->srcpad,
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_src_event));
+  gst_pad_set_iterate_internal_links_function (dec->srcpad,
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_iterate_linked_pads));
+  gst_element_add_pad (GST_ELEMENT (dec), dec->srcpad);
+
+  dec->sinkpad = gst_pad_new_from_static_template (&sink_template, "sink");
+  GST_PAD_SET_PROXY_CAPS (dec->sinkpad);
+  gst_pad_set_chain_function (dec->sinkpad, gst_rtpst_2022_1_fecdec_sink_chain);
+  gst_pad_set_event_function (dec->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_2d_fec_sink_event));
+  gst_pad_set_iterate_internal_links_function (dec->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecdec_iterate_linked_pads));
+  gst_element_add_pad (GST_ELEMENT (dec), dec->sinkpad);
+
+  dec->d = G_MAXUINT;
+  dec->l = G_MAXUINT;
+}
diff --git a/gst/rtpmanager/gstrtpst2022-1-fecdec.h b/gst/rtpmanager/gstrtpst2022-1-fecdec.h
new file mode 100644
index 000000000..7fc463143
--- /dev/null
+++ b/gst/rtpmanager/gstrtpst2022-1-fecdec.h
@@ -0,0 +1,39 @@
+/* GStreamer
+ * Copyright (C) <2020> Mathieu Duponchelle <mathieu@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_RTPST_2022_1_FECDEC_H__
+#define __GST_RTPST_2022_1_FECDEC_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstRTPST_2022_1_FecDecClass GstRTPST_2022_1_FecDecClass;
+typedef struct _GstRTPST_2022_1_FecDec GstRTPST_2022_1_FecDec;
+
+#define GST_TYPE_RTPST_2022_1_FECDEC (gst_rtpst_2022_1_fecdec_get_type())
+#define GST_RTPST_2022_1_FECDEC_CAST(obj) ((GstRTPST_2022_1_FecDec *)(obj))
+
+GType gst_rtpst_2022_1_fecdec_get_type (void);
+
+GST_ELEMENT_REGISTER_DECLARE (rtpst2022_1_fecdec);
+
+G_END_DECLS
+
+#endif /* __GST_RTPST_2022_1_FECDEC_H__ */
diff --git a/gst/rtpmanager/gstrtpst2022-1-fecenc.c b/gst/rtpmanager/gstrtpst2022-1-fecenc.c
new file mode 100644
index 000000000..de2782ab2
--- /dev/null
+++ b/gst/rtpmanager/gstrtpst2022-1-fecenc.c
@@ -0,0 +1,803 @@
+/* GStreamer
+ * Copyright (C) <2020> Mathieu Duponchelle <mathieu@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+/**
+ * SECTION:element-rtpst2022-1-fecenc
+ * @see_also: #element-rtpst2022-1-fecdec
+ *
+ * This element takes as input a media stream and up to two FEC
+ * streams as described in SMPTE 2022-1: Forward Error Correction
+ * for Real-Time Video/Audio Transport Over IP Networks, and makes
+ * use of the FEC packets to recover media packets that may have
+ * gotten lost.
+ *
+ * ## sender / receiver example
+ *
+ * ``` shell
+ * gst-launch-1.0 \
+ *   rtpbin name=rtp fec-encoders='fec,0="rtpst2022-1-fecenc\ rows\=5\ columns\=5";' \
+ *   uridecodebin uri=file:///path/to/video/file ! x264enc key-int-max=60 tune=zerolatency ! \
+ *     queue ! mpegtsmux ! rtpmp2tpay ssrc=0 ! rtp.send_rtp_sink_0 \
+ *   rtp.send_rtp_src_0 ! udpsink host=127.0.0.1 port=5000 \
+ *   rtp.send_fec_src_0_0 ! udpsink host=127.0.0.1 port=5002 async=false \
+ *   rtp.send_fec_src_0_1 ! udpsink host=127.0.0.1 port=5004 async=false
+ * ```
+ *
+ * ``` shell
+ * gst-launch-1.0 \
+ *   rtpbin latency=500 fec-decoders='fec,0="rtpst2022-1-fecdec\ size-time\=1000000000";' name=rtp \
+ *   udpsrc address=127.0.0.1 port=5002 caps="application/x-rtp, payload=96" ! queue ! rtp.recv_fec_sink_0_0 \
+ *   udpsrc address=127.0.0.1 port=5004 caps="application/x-rtp, payload=96" ! queue ! rtp.recv_fec_sink_0_1 \
+ *   udpsrc address=127.0.0.1 port=5000 caps="application/x-rtp, media=video, clock-rate=90000, encoding-name=mp2t, payload=33" ! \
+ *     queue ! netsim drop-probability=0.05 ! rtp.recv_rtp_sink_0 \
+ *   rtp. ! decodebin ! videoconvert ! queue ! autovideosink
+ * ```
+ *
+ * With the above command line, as the media packet size is constant,
+ * the fec overhead can be approximated to the number of fec packets
+ * per 2-d matrix of media packet, here 10 fec packets for each 25
+ * media packets.
+ *
+ * Increasing the number of rows and columns will decrease the overhead,
+ * but obviously increase the likelihood of recovery failure for lost
+ * packets on the receiver side.
+ *
+ * Since: 1.20
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <gst/base/base.h>
+#include <gst/rtp/gstrtpbuffer.h>
+
+#include "gstrtpst2022-1-fecenc.h"
+
+GST_DEBUG_CATEGORY_STATIC (gst_rtpst_2022_1_fecenc_debug);
+#define GST_CAT_DEFAULT gst_rtpst_2022_1_fecenc_debug
+
+enum
+{
+  PROP_0,
+  PROP_COLUMNS,
+  PROP_ROWS,
+  PROP_PT,
+  PROP_ENABLE_COLUMN,
+  PROP_ENABLE_ROW,
+};
+
+#define DEFAULT_ROWS 0
+#define DEFAULT_COLUMNS 0
+#define DEFAULT_PT 96
+#define DEFAULT_ENABLE_COLUMN TRUE
+#define DEFAULT_ENABLE_ROW TRUE
+
+typedef struct
+{
+  guint16 target_media_seq;     /* The media seqnum we want to send that packet alongside */
+  guint16 seq_base;             /* Only used for logging purposes */
+  GstBuffer *buffer;
+} Item;
+
+typedef struct
+{
+  guint8 *xored_payload;
+  guint32 xored_timestamp;
+  guint8 xored_pt;
+  guint16 xored_payload_len;
+  gboolean xored_marker;
+  gboolean xored_padding;
+  gboolean xored_extension;
+
+  guint16 seq_base;
+
+  guint16 payload_len;
+  guint n_packets;
+} FecPacket;
+
+struct _GstRTPST_2022_1_FecEncClass
+{
+  GstElementClass class;
+};
+
+struct _GstRTPST_2022_1_FecEnc
+{
+  GstElement element;
+
+  GstPad *srcpad;
+  GstPad *sinkpad;
+
+  /* These pads do not participate in the flow return of the element,
+   * which should continue working even if the sending of FEC packets
+   * fails
+   */
+  GstPad *row_fec_srcpad;
+  GstPad *column_fec_srcpad;
+
+  /* The following fields are only accessed on state change or from the
+   * streaming thread, and only settable in state < PAUSED */
+
+  /* N columns */
+  guint l;
+  /* N rows */
+  guint d;
+
+  /* Whether we have pushed initial events on the column FEC source pad */
+  gboolean column_events_pushed;
+
+  /* The current row FEC packet */
+  FecPacket *row;
+  /* Tracks the row seqnum */
+  guint16 row_seq;
+  /* Whether we have pushed initial events on the row FEC source pad */
+  gboolean row_events_pushed;
+
+  /* These two fields are used to enforce input seqnum consecutiveness,
+   * and to determine when column FEC packets should be pushed */
+  gboolean last_media_seqnum_set;
+  guint16 last_media_seqnum;
+
+  /* This field is used to timestamp our FEC packets, we just piggy back */
+  guint32 last_media_timestamp;
+
+  /* The payload type of the FEC packets */
+  gint pt;
+
+  /* The following fields can be changed while PLAYING, and are
+   * protected with the OBJECT_LOCK
+   */
+  /* Tracks the property, can be changed while PLAYING */
+  gboolean enable_row;
+  /* Tracks the property, can be changed while PLAYING */
+  gboolean enable_column;
+
+  /* Array of FecPackets, with size enc->l */
+  GPtrArray *columns;
+  /* Index of the current column in the array above */
+  guint current_column;
+  /* Tracks the column seqnum */
+  guint16 column_seq;
+  /* Column FEC packets must be delayed to make them more resilient
+   * to loss bursts, we store them here */
+  GQueue queued_column_packets;
+};
+
+#define RTP_CAPS "application/x-rtp"
+
+static GstStaticPadTemplate fec_src_template =
+GST_STATIC_PAD_TEMPLATE ("fec_%u",
+    GST_PAD_SRC,
+    GST_PAD_SOMETIMES,
+    GST_STATIC_CAPS (RTP_CAPS));
+
+static GstStaticPadTemplate sink_template = GST_STATIC_PAD_TEMPLATE ("sink",
+    GST_PAD_SINK,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (RTP_CAPS));
+
+static GstStaticPadTemplate src_template = GST_STATIC_PAD_TEMPLATE ("src",
+    GST_PAD_SRC,
+    GST_PAD_ALWAYS,
+    GST_STATIC_CAPS (RTP_CAPS));
+
+#define gst_rtpst_2022_1_fecenc_parent_class parent_class
+G_DEFINE_TYPE (GstRTPST_2022_1_FecEnc, gst_rtpst_2022_1_fecenc,
+    GST_TYPE_ELEMENT);
+GST_ELEMENT_REGISTER_DEFINE (rtpst2022_1_fecenc, "rtpst2022-1-fecenc",
+    GST_RANK_NONE, GST_TYPE_RTPST_2022_1_FECENC);
+
+static void
+free_item (Item * item)
+{
+  if (item->buffer)
+    gst_buffer_unref (item->buffer);
+
+  g_free (item);
+}
+
+static void
+free_fec_packet (FecPacket * packet)
+{
+  if (packet->xored_payload)
+    g_free (packet->xored_payload);
+  g_free (packet);
+}
+
+static void
+_xor_mem (guint8 * restrict dst, const guint8 * restrict src, gsize length)
+{
+  guint i;
+
+  for (i = 0; i < (length / sizeof (guint64)); ++i) {
+#if G_BYTE_ORDER == G_LITTLE_ENDIAN
+    GST_WRITE_UINT64_LE (dst,
+        GST_READ_UINT64_LE (dst) ^ GST_READ_UINT64_LE (src));
+#else
+    GST_WRITE_UINT64_BE (dst,
+        GST_READ_UINT64_BE (dst) ^ GST_READ_UINT64_BE (src));
+#endif
+    dst += sizeof (guint64);
+    src += sizeof (guint64);
+  }
+  for (i = 0; i < (length % sizeof (guint64)); ++i)
+    dst[i] ^= src[i];
+}
+
+static void
+fec_packet_update (FecPacket * fec, GstRTPBuffer * rtp)
+{
+  if (fec->n_packets == 0) {
+    fec->seq_base = gst_rtp_buffer_get_seq (rtp);
+    fec->payload_len = gst_rtp_buffer_get_payload_len (rtp);
+    fec->xored_payload_len = gst_rtp_buffer_get_payload_len (rtp);
+    fec->xored_pt = gst_rtp_buffer_get_payload_type (rtp);
+    fec->xored_timestamp = gst_rtp_buffer_get_timestamp (rtp);
+    fec->xored_marker = gst_rtp_buffer_get_marker (rtp);
+    fec->xored_padding = gst_rtp_buffer_get_padding (rtp);
+    fec->xored_extension = gst_rtp_buffer_get_extension (rtp);
+    fec->xored_payload = g_malloc (sizeof (guint8) * fec->payload_len);
+    memcpy (fec->xored_payload, gst_rtp_buffer_get_payload (rtp),
+        fec->payload_len);
+  } else {
+    guint plen = gst_rtp_buffer_get_payload_len (rtp);
+
+    if (fec->payload_len < plen) {
+      fec->xored_payload =
+          g_realloc (fec->xored_payload, sizeof (guint8) * plen);
+      memset (fec->xored_payload + fec->payload_len, 0,
+          plen - fec->payload_len);
+      fec->payload_len = plen;
+    }
+
+    fec->xored_payload_len ^= plen;
+    fec->xored_pt ^= gst_rtp_buffer_get_payload_type (rtp);
+    fec->xored_timestamp ^= gst_rtp_buffer_get_timestamp (rtp);
+    fec->xored_marker ^= gst_rtp_buffer_get_marker (rtp);
+    fec->xored_padding ^= gst_rtp_buffer_get_padding (rtp);
+    fec->xored_extension ^= gst_rtp_buffer_get_extension (rtp);
+    _xor_mem (fec->xored_payload, gst_rtp_buffer_get_payload (rtp), plen);
+  }
+
+  fec->n_packets += 1;
+}
+
+static void
+push_initial_events (GstRTPST_2022_1_FecEnc * enc, GstPad * pad,
+    const gchar * id)
+{
+  gchar *stream_id;
+  GstCaps *caps;
+  GstSegment segment;
+
+  stream_id = gst_pad_create_stream_id (pad, GST_ELEMENT (enc), id);
+  gst_pad_push_event (pad, gst_event_new_stream_start (stream_id));
+  g_free (stream_id);
+
+  caps = gst_caps_new_simple ("application/x-rtp",
+      "payload", G_TYPE_UINT, enc->pt, "ssrc", G_TYPE_UINT, 0, NULL);
+  gst_pad_push_event (pad, gst_event_new_caps (caps));
+  gst_caps_unref (caps);
+
+  gst_segment_init (&segment, GST_FORMAT_TIME);
+  gst_pad_push_event (pad, gst_event_new_segment (&segment));
+}
+
+static void
+queue_fec_packet (GstRTPST_2022_1_FecEnc * enc, FecPacket * fec, gboolean row)
+{
+  GstBuffer *buffer = gst_rtp_buffer_new_allocate (fec->payload_len + 16, 0, 0);
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  GstBitWriter bits;
+  guint8 *data;
+
+  gst_rtp_buffer_map (buffer, GST_MAP_WRITE, &rtp);
+  data = gst_rtp_buffer_get_payload (&rtp);
+  memset (data, 0x00, 16);
+
+  gst_bit_writer_init_with_data (&bits, data, 17, FALSE);
+
+  gst_bit_writer_put_bits_uint16 (&bits, fec->seq_base, 16);    /* SNBase low bits */
+  gst_bit_writer_put_bits_uint16 (&bits, fec->xored_payload_len, 16);   /* Length Recovery */
+  gst_bit_writer_put_bits_uint8 (&bits, 1, 1);  /* E */
+  gst_bit_writer_put_bits_uint8 (&bits, fec->xored_pt, 7);      /* PT recovery */
+  gst_bit_writer_put_bits_uint32 (&bits, 0, 24);        /* Mask */
+  gst_bit_writer_put_bits_uint32 (&bits, fec->xored_timestamp, 32);     /* TS recovery */
+  gst_bit_writer_put_bits_uint8 (&bits, 0, 1);  /* N */
+  gst_bit_writer_put_bits_uint8 (&bits, row ? 1 : 0, 1);        /* D */
+  gst_bit_writer_put_bits_uint8 (&bits, 0, 3);  /* type */
+  gst_bit_writer_put_bits_uint8 (&bits, 0, 3);  /* index */
+  gst_bit_writer_put_bits_uint8 (&bits, row ? 1 : enc->l, 8);   /* Offset */
+  gst_bit_writer_put_bits_uint8 (&bits, fec->n_packets, 8);     /* NA */
+  gst_bit_writer_put_bits_uint8 (&bits, 0, 8);  /* SNBase ext bits */
+
+  memcpy (data + 16, fec->xored_payload, fec->payload_len);
+
+  gst_bit_writer_reset (&bits);
+
+  gst_rtp_buffer_set_payload_type (&rtp, enc->pt);
+  gst_rtp_buffer_set_seq (&rtp, row ? enc->row_seq++ : enc->column_seq++);
+  gst_rtp_buffer_set_marker (&rtp, fec->xored_marker);
+  gst_rtp_buffer_set_padding (&rtp, fec->xored_padding);
+  gst_rtp_buffer_set_extension (&rtp, fec->xored_extension);
+
+  /* We're sending it out immediately */
+  if (row)
+    gst_rtp_buffer_set_timestamp (&rtp, enc->last_media_timestamp);
+
+  gst_rtp_buffer_unmap (&rtp);
+
+  /* We can send row FEC packets immediately, column packets need
+   * delaying by L <= delay < L * D
+   */
+  if (row) {
+    GstFlowReturn ret;
+
+    GST_LOG_OBJECT (enc,
+        "Pushing row FEC packet, seq base: %u, media seqnum: %u",
+        fec->seq_base, enc->last_media_seqnum);
+
+    /* Safe to unlock here */
+    GST_OBJECT_UNLOCK (enc);
+    ret = gst_pad_push (enc->row_fec_srcpad, buffer);
+    GST_OBJECT_LOCK (enc);
+
+    if (ret != GST_FLOW_OK && ret != GST_FLOW_FLUSHING)
+      GST_WARNING_OBJECT (enc->row_fec_srcpad,
+          "Failed to push row FEC packet: %s", gst_flow_get_name (ret));
+  } else {
+    Item *item = g_malloc0 (sizeof (Item));
+
+    item->buffer = buffer;
+    item->seq_base = fec->seq_base;
+    /* Let's get cute and linearize */
+    item->target_media_seq =
+        enc->last_media_seqnum + enc->l - enc->current_column +
+        enc->d * enc->current_column;
+
+    g_queue_push_tail (&enc->queued_column_packets, item);
+  }
+}
+
+static void
+gst_2d_fec_push_item_unlocked (GstRTPST_2022_1_FecEnc * enc)
+{
+  GstFlowReturn ret;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  Item *item = g_queue_pop_head (&enc->queued_column_packets);
+
+  GST_LOG_OBJECT (enc,
+      "Pushing column FEC packet, target media seq: %u, seq base: %u, "
+      "media seqnum: %u", item->target_media_seq, item->seq_base,
+      enc->last_media_seqnum);
+  gst_rtp_buffer_map (item->buffer, GST_MAP_WRITE, &rtp);
+  gst_rtp_buffer_set_timestamp (&rtp, enc->last_media_timestamp);
+  gst_rtp_buffer_unmap (&rtp);
+  GST_OBJECT_UNLOCK (enc);
+  ret = gst_pad_push (enc->column_fec_srcpad, gst_buffer_ref (item->buffer));
+  GST_OBJECT_LOCK (enc);
+
+  if (ret != GST_FLOW_OK && ret != GST_FLOW_FLUSHING)
+    GST_WARNING_OBJECT (enc->column_fec_srcpad,
+        "Failed to push column FEC packet: %s", gst_flow_get_name (ret));
+
+  free_item (item);
+}
+
+static GstFlowReturn
+gst_rtpst_2022_1_fecenc_sink_chain (GstPad * pad, GstObject * parent,
+    GstBuffer * buffer)
+{
+  GstRTPST_2022_1_FecEnc *enc = GST_RTPST_2022_1_FECENC_CAST (parent);
+  GstFlowReturn ret = GST_FLOW_OK;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+
+  if (!gst_rtp_buffer_map (buffer, GST_MAP_READ, &rtp)) {
+    GST_ERROR_OBJECT (enc, "Chained buffer isn't valid RTP");
+    goto error;
+  }
+
+  if (gst_rtp_buffer_get_ssrc (&rtp) != 0) {
+    GST_ERROR_OBJECT (enc, "Chained buffer must have SSRC == 0");
+    goto error;
+  }
+
+  if (enc->last_media_seqnum_set
+      && (guint16) (enc->last_media_seqnum + 1) !=
+      gst_rtp_buffer_get_seq (&rtp)) {
+    GST_ERROR_OBJECT (enc, "consecutive sequence numbers are required");
+    goto error;
+  }
+
+  if (!enc->row_events_pushed) {
+    push_initial_events (enc, enc->row_fec_srcpad, "row-fec");
+    enc->row_events_pushed = TRUE;
+  }
+
+  if (!enc->column_events_pushed) {
+    push_initial_events (enc, enc->column_fec_srcpad, "column-fec");
+    enc->column_events_pushed = TRUE;
+  }
+
+  enc->last_media_timestamp = gst_rtp_buffer_get_timestamp (&rtp);
+  enc->last_media_seqnum = gst_rtp_buffer_get_seq (&rtp);
+  enc->last_media_seqnum_set = TRUE;
+
+  GST_OBJECT_LOCK (enc);
+  if (enc->enable_row && enc->l) {
+    g_assert (enc->row->n_packets < enc->l);
+    fec_packet_update (enc->row, &rtp);
+    if (enc->row->n_packets == enc->l) {
+      queue_fec_packet (enc, enc->row, TRUE);
+      g_free (enc->row->xored_payload);
+      memset (enc->row, 0x00, sizeof (FecPacket));
+    }
+  }
+
+  if (enc->enable_column && enc->l && enc->d) {
+    FecPacket *column = g_ptr_array_index (enc->columns, enc->current_column);
+
+    fec_packet_update (column, &rtp);
+    if (column->n_packets == enc->d) {
+      queue_fec_packet (enc, column, FALSE);
+      g_free (column->xored_payload);
+      memset (column, 0x00, sizeof (FecPacket));
+    }
+
+    enc->current_column++;
+    enc->current_column %= enc->l;
+  }
+
+  gst_rtp_buffer_unmap (&rtp);
+
+  {
+    Item *item = g_queue_peek_head (&enc->queued_column_packets);
+    if (item && item->target_media_seq == enc->last_media_seqnum)
+      gst_2d_fec_push_item_unlocked (enc);
+  }
+
+  GST_OBJECT_UNLOCK (enc);
+
+  ret = gst_pad_push (enc->srcpad, buffer);
+
+done:
+  return ret;
+
+error:
+  if (rtp.buffer)
+    gst_rtp_buffer_unmap (&rtp);
+  gst_buffer_unref (buffer);
+  ret = GST_FLOW_ERROR;
+  goto done;
+}
+
+static GstIterator *
+gst_rtpst_2022_1_fecenc_iterate_linked_pads (GstPad * pad, GstObject * parent)
+{
+  GstRTPST_2022_1_FecEnc *enc = GST_RTPST_2022_1_FECENC_CAST (parent);
+  GstPad *otherpad = NULL;
+  GstIterator *it = NULL;
+  GValue val = { 0, };
+
+  if (pad == enc->srcpad)
+    otherpad = enc->sinkpad;
+  else if (pad == enc->sinkpad)
+    otherpad = enc->srcpad;
+
+  if (otherpad) {
+    g_value_init (&val, GST_TYPE_PAD);
+    g_value_set_object (&val, otherpad);
+    it = gst_iterator_new_single (GST_TYPE_PAD, &val);
+    g_value_unset (&val);
+  }
+
+  return it;
+}
+
+static void
+gst_rtpst_2022_1_fecenc_reset (GstRTPST_2022_1_FecEnc * enc, gboolean allocate)
+{
+  if (enc->row) {
+    free_fec_packet (enc->row);
+    enc->row = NULL;
+  }
+
+  if (enc->columns) {
+    g_ptr_array_unref (enc->columns);
+    enc->columns = NULL;
+  }
+
+  if (enc->row_fec_srcpad) {
+    gst_element_remove_pad (GST_ELEMENT (enc), enc->row_fec_srcpad);
+    enc->row_fec_srcpad = NULL;
+  }
+
+  if (enc->column_fec_srcpad) {
+    gst_element_remove_pad (GST_ELEMENT (enc), enc->column_fec_srcpad);
+    enc->column_fec_srcpad = NULL;
+  }
+
+  g_queue_clear_full (&enc->queued_column_packets, (GDestroyNotify) free_item);
+
+  if (allocate) {
+    guint i;
+
+    enc->row = g_malloc0 (sizeof (FecPacket));
+    enc->columns =
+        g_ptr_array_new_full (enc->l, (GDestroyNotify) free_fec_packet);
+
+    for (i = 0; i < enc->l; i++) {
+      g_ptr_array_add (enc->columns, g_malloc0 (sizeof (FecPacket)));
+    }
+
+    g_queue_init (&enc->queued_column_packets);
+
+    enc->column_fec_srcpad =
+        gst_pad_new_from_static_template (&fec_src_template, "fec_0");
+    gst_pad_set_active (enc->column_fec_srcpad, TRUE);
+    gst_pad_set_iterate_internal_links_function (enc->column_fec_srcpad,
+        GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_iterate_linked_pads));
+    gst_element_add_pad (GST_ELEMENT (enc), enc->column_fec_srcpad);
+
+    enc->row_fec_srcpad =
+        gst_pad_new_from_static_template (&fec_src_template, "fec_1");
+    gst_pad_set_active (enc->row_fec_srcpad, TRUE);
+    gst_pad_set_iterate_internal_links_function (enc->row_fec_srcpad,
+        GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_iterate_linked_pads));
+    gst_element_add_pad (GST_ELEMENT (enc), enc->row_fec_srcpad);
+
+    gst_element_no_more_pads (GST_ELEMENT (enc));
+  }
+
+  enc->current_column = 0;
+  enc->last_media_seqnum_set = FALSE;
+}
+
+static GstStateChangeReturn
+gst_rtpst_2022_1_fecenc_change_state (GstElement * element,
+    GstStateChange transition)
+{
+  GstStateChangeReturn ret;
+  GstRTPST_2022_1_FecEnc *enc = GST_RTPST_2022_1_FECENC_CAST (element);
+
+  switch (transition) {
+    case GST_STATE_CHANGE_READY_TO_PAUSED:
+      gst_rtpst_2022_1_fecenc_reset (enc, TRUE);
+      break;
+    case GST_STATE_CHANGE_PAUSED_TO_READY:
+      gst_rtpst_2022_1_fecenc_reset (enc, FALSE);
+      break;
+    default:
+      break;
+  }
+
+  ret = GST_ELEMENT_CLASS (parent_class)->change_state (element, transition);
+
+  return ret;
+}
+
+static void
+gst_rtpst_2022_1_fecenc_finalize (GObject * object)
+{
+  GstRTPST_2022_1_FecEnc *enc = GST_RTPST_2022_1_FECENC_CAST (object);
+
+  gst_rtpst_2022_1_fecenc_reset (enc, FALSE);
+
+  G_OBJECT_CLASS (parent_class)->finalize (object);
+}
+
+static void
+gst_rtpst_2022_1_fecenc_set_property (GObject * object, guint prop_id,
+    const GValue * value, GParamSpec * pspec)
+{
+  GstRTPST_2022_1_FecEnc *enc = GST_RTPST_2022_1_FECENC_CAST (object);
+
+  if (GST_STATE (enc) > GST_STATE_READY) {
+    GST_ERROR_OBJECT (enc,
+        "rtpst2022-1-fecenc properties can't be changed in PLAYING or PAUSED state");
+    return;
+  }
+
+  switch (prop_id) {
+    case PROP_COLUMNS:
+      enc->l = g_value_get_uint (value);
+      break;
+    case PROP_ROWS:
+      enc->d = g_value_get_uint (value);
+      break;
+    case PROP_PT:
+      enc->pt = g_value_get_int (value);
+      break;
+    case PROP_ENABLE_COLUMN:
+      GST_OBJECT_LOCK (enc);
+      enc->enable_column = g_value_get_boolean (value);
+      if (!enc->enable_column) {
+        guint i;
+
+        if (enc->columns) {
+          for (i = 0; i < enc->l; i++) {
+            FecPacket *column = g_ptr_array_index (enc->columns, i);
+            g_free (column->xored_payload);
+            memset (column, 0x00, sizeof (FecPacket));
+          }
+        }
+        enc->current_column = 0;
+        enc->column_seq = 0;
+        g_queue_clear_full (&enc->queued_column_packets,
+            (GDestroyNotify) free_item);
+      }
+      GST_OBJECT_UNLOCK (enc);
+      break;
+    case PROP_ENABLE_ROW:
+      GST_OBJECT_LOCK (enc);
+      enc->enable_row = g_value_get_boolean (value);
+      GST_OBJECT_UNLOCK (enc);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static void
+gst_rtpst_2022_1_fecenc_get_property (GObject * object, guint prop_id,
+    GValue * value, GParamSpec * pspec)
+{
+  GstRTPST_2022_1_FecEnc *enc = GST_RTPST_2022_1_FECENC_CAST (object);
+
+  switch (prop_id) {
+    case PROP_COLUMNS:
+      g_value_set_uint (value, enc->l);
+      break;
+    case PROP_ROWS:
+      g_value_set_uint (value, enc->d);
+      break;
+    case PROP_PT:
+      g_value_set_int (value, enc->pt);
+      break;
+    case PROP_ENABLE_COLUMN:
+      GST_OBJECT_LOCK (enc);
+      g_value_set_boolean (value, enc->enable_column);
+      GST_OBJECT_UNLOCK (enc);
+      break;
+    case PROP_ENABLE_ROW:
+      GST_OBJECT_LOCK (enc);
+      g_value_set_boolean (value, enc->enable_row);
+      GST_OBJECT_UNLOCK (enc);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+      break;
+  }
+}
+
+static gboolean
+gst_2d_fec_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
+{
+  GstRTPST_2022_1_FecEnc *enc = GST_RTPST_2022_1_FECENC_CAST (parent);
+  gboolean ret;
+
+  switch (GST_EVENT_TYPE (event)) {
+    case GST_EVENT_FLUSH_STOP:
+      gst_rtpst_2022_1_fecenc_reset (enc, TRUE);
+      break;
+    case GST_EVENT_EOS:
+      gst_pad_push_event (enc->row_fec_srcpad, gst_event_ref (event));
+      GST_OBJECT_LOCK (enc);
+      while (g_queue_peek_head (&enc->queued_column_packets))
+        gst_2d_fec_push_item_unlocked (enc);
+      GST_OBJECT_UNLOCK (enc);
+      gst_pad_push_event (enc->column_fec_srcpad, gst_event_ref (event));
+      break;
+    default:
+      break;
+  }
+
+  ret = gst_pad_event_default (pad, parent, event);
+
+  return ret;
+}
+
+static void
+gst_rtpst_2022_1_fecenc_class_init (GstRTPST_2022_1_FecEncClass * klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+  GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
+
+  gobject_class->set_property =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_set_property);
+  gobject_class->get_property =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_get_property);
+  gobject_class->finalize =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_finalize);
+
+  g_object_class_install_property (gobject_class, PROP_COLUMNS,
+      g_param_spec_uint ("columns", "Columns",
+          "Number of columns to apply row FEC on, 0=disabled", 0,
+          255, DEFAULT_COLUMNS,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
+
+  g_object_class_install_property (gobject_class, PROP_ROWS,
+      g_param_spec_uint ("rows", "Rows",
+          "Number of rows to apply column FEC on, 0=disabled", 0,
+          255, DEFAULT_ROWS,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
+
+  g_object_class_install_property (gobject_class, PROP_PT,
+      g_param_spec_int ("pt", "Payload Type",
+          "The payload type of FEC packets", 96,
+          255, DEFAULT_PT,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_READY));
+
+  g_object_class_install_property (gobject_class, PROP_ENABLE_COLUMN,
+      g_param_spec_boolean ("enable-column-fec", "Enable Column FEC",
+          "Whether the encoder should compute and send column FEC",
+          DEFAULT_ENABLE_COLUMN,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_PLAYING));
+
+  g_object_class_install_property (gobject_class, PROP_ENABLE_ROW,
+      g_param_spec_boolean ("enable-row-fec", "Enable Row FEC",
+          "Whether the encoder should compute and send row FEC",
+          DEFAULT_ENABLE_ROW,
+          G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS |
+          GST_PARAM_MUTABLE_PLAYING));
+
+  gstelement_class->change_state =
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_change_state);
+
+  gst_element_class_set_static_metadata (gstelement_class,
+      "SMPTE 2022-1 FEC encoder", "SMPTE 2022-1 FEC encoding",
+      "performs FEC as described by SMPTE 2022-1",
+      "Mathieu Duponchelle <mathieu@centricular.com>");
+
+  gst_element_class_add_static_pad_template (gstelement_class, &sink_template);
+  gst_element_class_add_static_pad_template (gstelement_class,
+      &fec_src_template);
+  gst_element_class_add_static_pad_template (gstelement_class, &src_template);
+
+  GST_DEBUG_CATEGORY_INIT (gst_rtpst_2022_1_fecenc_debug,
+      "rtpst2022-1-fecenc", 0, "SMPTE 2022-1 FEC encoder element");
+}
+
+static void
+gst_rtpst_2022_1_fecenc_init (GstRTPST_2022_1_FecEnc * enc)
+{
+  enc->srcpad = gst_pad_new_from_static_template (&src_template, "src");
+  gst_pad_use_fixed_caps (enc->srcpad);
+  GST_PAD_SET_PROXY_CAPS (enc->srcpad);
+  gst_pad_set_iterate_internal_links_function (enc->srcpad,
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_iterate_linked_pads));
+  gst_element_add_pad (GST_ELEMENT (enc), enc->srcpad);
+
+  enc->sinkpad = gst_pad_new_from_static_template (&sink_template, "sink");
+  GST_PAD_SET_PROXY_CAPS (enc->sinkpad);
+  gst_pad_set_chain_function (enc->sinkpad, gst_rtpst_2022_1_fecenc_sink_chain);
+  gst_pad_set_event_function (enc->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_2d_fec_sink_event));
+  gst_pad_set_iterate_internal_links_function (enc->sinkpad,
+      GST_DEBUG_FUNCPTR (gst_rtpst_2022_1_fecenc_iterate_linked_pads));
+  gst_element_add_pad (GST_ELEMENT (enc), enc->sinkpad);
+
+  enc->d = 0;
+  enc->l = 0;
+}
diff --git a/gst/rtpmanager/gstrtpst2022-1-fecenc.h b/gst/rtpmanager/gstrtpst2022-1-fecenc.h
new file mode 100644
index 000000000..33e5de43a
--- /dev/null
+++ b/gst/rtpmanager/gstrtpst2022-1-fecenc.h
@@ -0,0 +1,39 @@
+/* GStreamer
+ * Copyright (C) <2020> Mathieu Duponchelle <mathieu@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_RTPST_2022_1_FECENC_H__
+#define __GST_RTPST_2022_1_FECENC_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+typedef struct _GstRTPST_2022_1_FecEncClass GstRTPST_2022_1_FecEncClass;
+typedef struct _GstRTPST_2022_1_FecEnc GstRTPST_2022_1_FecEnc;
+
+#define GST_TYPE_RTPST_2022_1_FECENC (gst_rtpst_2022_1_fecenc_get_type())
+#define GST_RTPST_2022_1_FECENC_CAST(obj) ((GstRTPST_2022_1_FecEnc *)(obj))
+
+GType gst_rtpst_2022_1_fecenc_get_type (void);
+
+GST_ELEMENT_REGISTER_DECLARE (rtpst2022_1_fecenc);
+
+G_END_DECLS
+
+#endif /* __GST_RTPST_2022_1_FECENC_H__ */
diff --git a/gst/rtpmanager/gstrtputils.c b/gst/rtpmanager/gstrtputils.c
new file mode 100644
index 000000000..eb8113368
--- /dev/null
+++ b/gst/rtpmanager/gstrtputils.c
@@ -0,0 +1,44 @@
+/* GStreamer
+ * Copyright (C) 2022 Sebastian Drge <sebastian@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#include "gstrtputils.h"
+
+guint8
+gst_rtp_get_extmap_id_for_attribute (const GstStructure * s,
+    const gchar * ext_name)
+{
+  guint i;
+  guint8 extmap_id = 0;
+  guint n_fields = gst_structure_n_fields (s);
+
+  for (i = 0; i < n_fields; i++) {
+    const gchar *field_name = gst_structure_nth_field_name (s, i);
+    if (g_str_has_prefix (field_name, "extmap-")) {
+      const gchar *str = gst_structure_get_string (s, field_name);
+      if (str && g_strcmp0 (str, ext_name) == 0) {
+        gint64 id = g_ascii_strtoll (field_name + 7, NULL, 10);
+        if (id > 0 && id < 15) {
+          extmap_id = id;
+          break;
+        }
+      }
+    }
+  }
+  return extmap_id;
+}
diff --git a/gst/rtpmanager/gstrtputils.h b/gst/rtpmanager/gstrtputils.h
new file mode 100644
index 000000000..668933360
--- /dev/null
+++ b/gst/rtpmanager/gstrtputils.h
@@ -0,0 +1,34 @@
+/* GStreamer
+ * Copyright (C) 2022 Sebastian Drge <sebastian@centricular.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
+ * Boston, MA 02110-1301, USA.
+ */
+
+#ifndef __GST_RTP_UTILS_H__
+#define __GST_RTP_UTILS_H__
+
+#include <gst/gst.h>
+
+G_BEGIN_DECLS
+
+#define GST_RTP_NTP_UNIX_OFFSET (2208988800LL)
+
+G_GNUC_INTERNAL guint8
+gst_rtp_get_extmap_id_for_attribute (const GstStructure * s, const gchar * ext_name);
+
+G_END_DECLS
+
+#endif /* __GST_RTP_UTILS_H__ */
diff --git a/gst/rtpmanager/meson.build b/gst/rtpmanager/meson.build
index 118a1e1ea..11435d902 100644
--- a/gst/rtpmanager/meson.build
+++ b/gst/rtpmanager/meson.build
@@ -3,6 +3,12 @@ rtpmanager_sources = [
   'gstrtpbin.c',
   'gstrtpdtmfmux.c',
   'gstrtpjitterbuffer.c',
+  'gstrtphdrext-twcc.c',
+  'gstrtphdrext-clientaudiolevel.c',
+  'gstrtphdrext-mid.c',
+  'gstrtphdrext-ntp.c',
+  'gstrtphdrext-repairedstreamid.c',
+  'gstrtphdrext-streamid.c',
   'gstrtpmux.c',
   'gstrtpptdemux.c',
   'gstrtprtxqueue.c',
@@ -17,15 +23,17 @@ rtpmanager_sources = [
   'rtptwcc.c',
   'gstrtpsession.c',
   'gstrtpfunnel.c',
+  'gstrtpst2022-1-fecdec.c',
+  'gstrtpst2022-1-fecenc.c',
+  'gstrtputils.c'
 ]
 
 gstrtpmanager = library('gstrtpmanager',
   rtpmanager_sources,
   c_args : gst_plugins_good_args,
   include_directories : [configinc, libsinc],
-  dependencies : [gstbase_dep, gstnet_dep, gstrtp_dep, gio_dep],
+  dependencies : [gstbase_dep, gstnet_dep, gstrtp_dep, gstaudio_dep, gio_dep],
   install : true,
   install_dir : plugins_install_dir,
 )
-pkgconfig.generate(gstrtpmanager, install_dir : plugins_pkgconfig_install_dir)
 plugins += [gstrtpmanager]
diff --git a/gst/rtpmanager/rtpjitterbuffer.c b/gst/rtpmanager/rtpjitterbuffer.c
index aef5cbc35..1ab0aaf60 100644
--- a/gst/rtpmanager/rtpjitterbuffer.c
+++ b/gst/rtpmanager/rtpjitterbuffer.c
@@ -703,7 +703,7 @@ queue_do_insert (RTPJitterBuffer * jbuf, GList * list, GList * item)
 GstClockTime
 rtp_jitter_buffer_calculate_pts (RTPJitterBuffer * jbuf, GstClockTime dts,
     gboolean estimated_dts, guint32 rtptime, GstClockTime base_time,
-    gint gap, gboolean is_rtx)
+    gint gap, gboolean is_rtx, GstClockTime * p_ntp_time)
 {
   guint64 ext_rtptime;
   GstClockTime gstrtptime, pts;
@@ -711,6 +711,8 @@ rtp_jitter_buffer_calculate_pts (RTPJitterBuffer * jbuf, GstClockTime dts,
   guint64 media_clock_offset;
   gboolean rfc7273_mode;
 
+  *p_ntp_time = GST_CLOCK_TIME_NONE;
+
   /* rtp time jumps are checked for during skew calculation, but bypassed
    * in other mode, so mind those here and reset jb if needed.
    * Only reset if valid input time, which is likely for UDP input
@@ -870,48 +872,125 @@ rtp_jitter_buffer_calculate_pts (RTPJitterBuffer * jbuf, GstClockTime dts,
   } else if (rfc7273_mode && (jbuf->mode == RTP_JITTER_BUFFER_MODE_SLAVE
           || jbuf->mode == RTP_JITTER_BUFFER_MODE_SYNCED)
       && media_clock_offset != -1 && jbuf->rfc7273_sync) {
-    GstClockTime ntptime, rtptime_tmp;
+    GstClockTime ntptime;
     GstClockTime ntprtptime, rtpsystime;
     GstClockTime internal, external;
     GstClockTime rate_num, rate_denom;
+    GstClockTime ntprtptime_period_start;
+    gboolean negative_ntprtptime_period_start;
 
     /* Don't do any of the dts related adjustments further down */
     dts = -1;
 
     /* Calculate the actual clock time on the sender side based on the
-     * RFC7273 clock and convert it to our pipeline clock
-     */
+     * RFC7273 clock and convert it to our pipeline clock. */
 
     gst_clock_get_calibration (media_clock, &internal, &external, &rate_num,
         &rate_denom);
 
+    /* Current NTP clock estimation */
     ntptime = gst_clock_get_internal_time (media_clock);
 
-    ntprtptime = gst_util_uint64_scale (ntptime, jbuf->clock_rate, GST_SECOND);
+    /* Current RTP time based on the estimated NTP clock and the corresponding
+     * RTP time period start */
+    ntprtptime = ntprtptime_period_start =
+        gst_util_uint64_scale (ntptime, jbuf->clock_rate, GST_SECOND);
     ntprtptime += media_clock_offset;
     ntprtptime &= 0xffffffff;
 
-    rtptime_tmp = rtptime;
+    /* If we're in the first period then the start of the period might be
+     * before the clock epoch */
+    if (ntprtptime_period_start >= ntprtptime) {
+      ntprtptime_period_start = ntprtptime_period_start - ntprtptime;
+      negative_ntprtptime_period_start = FALSE;
+    } else {
+      ntprtptime_period_start = ntprtptime - ntprtptime_period_start;
+      negative_ntprtptime_period_start = TRUE;
+    }
+
+    GST_TRACE ("Current NTP time %" GST_TIME_FORMAT " (RTP: %" G_GUINT64_FORMAT
+        ")", GST_TIME_ARGS (ntptime), ntprtptime);
+    GST_TRACE ("Current NTP RTP time period start %c%" GST_TIME_FORMAT
+        " (RTP: %c%" G_GUINT64_FORMAT ")",
+        negative_ntprtptime_period_start ? '-' : '+',
+        GST_TIME_ARGS (gst_util_uint64_scale (ntprtptime_period_start,
+                GST_SECOND, jbuf->clock_rate)),
+        negative_ntprtptime_period_start ? '-' : '+', ntprtptime_period_start);
+    GST_TRACE ("Current NTP RTP time related to period start %" GST_TIME_FORMAT
+        " (RTP: %" G_GUINT64_FORMAT ")",
+        GST_TIME_ARGS (gst_util_uint64_scale (ntprtptime, GST_SECOND,
+                jbuf->clock_rate)), ntprtptime);
+
     /* Check for wraparounds, we assume that the diff between current RTP
-     * timestamp and current media clock time can't be bigger than
-     * 2**31 clock units */
-    if (ntprtptime > rtptime_tmp && ntprtptime - rtptime_tmp >= 0x80000000)
-      rtptime_tmp += G_GUINT64_CONSTANT (0x100000000);
-    else if (rtptime_tmp > ntprtptime && rtptime_tmp - ntprtptime >= 0x80000000)
-      ntprtptime += G_GUINT64_CONSTANT (0x100000000);
-
-    if (ntprtptime > rtptime_tmp)
-      ntptime -=
-          gst_util_uint64_scale (ntprtptime - rtptime_tmp, GST_SECOND,
-          jbuf->clock_rate);
-    else
-      ntptime +=
-          gst_util_uint64_scale (rtptime_tmp - ntprtptime, GST_SECOND,
-          jbuf->clock_rate);
+     * timestamp and current media clock time can't be bigger than 2**31 clock
+     * rate units. If it is bigger then get closer to it by moving one RTP
+     * timestamp period into the future or into the past.
+     *
+     * E.g.
+     *    current NTP: 0x_______5 fffffffe
+     *    packet  RTP: 0x         00000001
+     * => packet  NTP: 0x_______6 00000001
+     *
+     *    current NTP: 0x_______5 00000001
+     *    packet  RTP: 0x         fffffffe
+     * => packet  NTP: 0x_______4 fffffffe
+     *
+     */
+    if (ntprtptime > rtptime && ntprtptime - rtptime >= 0x80000000) {
+      if (negative_ntprtptime_period_start) {
+        negative_ntprtptime_period_start = FALSE;
+        g_assert (ntprtptime_period_start <= 0x100000000);
+        ntprtptime_period_start = 0x100000000 - ntprtptime_period_start;
+      } else {
+        ntprtptime_period_start += 0x100000000;
+      }
+    } else if (rtptime > ntprtptime && rtptime - ntprtptime >= 0x80000000) {
+      if (negative_ntprtptime_period_start) {
+        ntprtptime_period_start += 0x100000000;
+      } else if (ntprtptime_period_start < 0x100000000) {
+        negative_ntprtptime_period_start = TRUE;
+        ntprtptime_period_start = 0x100000000 - ntprtptime_period_start;
+      } else {
+        ntprtptime_period_start -= 0x100000000;
+      }
+    }
 
+    GST_TRACE ("Wraparound adjusted NTP RTP time period start %c%"
+        GST_TIME_FORMAT " (RTP: %c%" G_GUINT64_FORMAT ")",
+        negative_ntprtptime_period_start ? '-' : '+',
+        GST_TIME_ARGS (gst_util_uint64_scale (ntprtptime_period_start,
+                GST_SECOND, jbuf->clock_rate)),
+        negative_ntprtptime_period_start ? '-' : '+', ntprtptime_period_start);
+
+    /* Packet timestamp according to the NTP clock in RTP time units.
+     * Note that this does not include any inaccuracy caused by the estimation
+     * of the NTP clock unless it is more than 2**31 RTP time units off. */
+    if (negative_ntprtptime_period_start) {
+      if (rtptime >= ntprtptime_period_start) {
+        ntprtptime = rtptime - ntprtptime_period_start;
+      } else {
+        /* Packet is timestamped before the NTP clock epoch! */
+        ntprtptime = 0;
+      }
+    } else {
+      ntprtptime = ntprtptime_period_start + rtptime;
+    }
+
+    /* Packet timestamp in nanoseconds according to the NTP clock. */
+    ntptime = gst_util_uint64_scale (ntprtptime, GST_SECOND, jbuf->clock_rate);
+
+    GST_DEBUG ("RFC7273 packet NTP time %" GST_TIME_FORMAT " (RTP: %"
+        G_GUINT64_FORMAT ")", GST_TIME_ARGS (ntptime), ntprtptime);
+
+    *p_ntp_time = ntptime;
+
+    /* Packet timestamp converted to the pipeline clock.
+     * Note that this includes again inaccuracy caused by the estimation of
+     * the NTP vs. pipeline clock. */
     rtpsystime =
         gst_clock_adjust_with_calibration (media_clock, ntptime, internal,
         external, rate_num, rate_denom);
+
     /* All this assumes that the pipeline has enough additional
      * latency to cover for the network delay */
     if (rtpsystime > base_time)
@@ -919,14 +998,8 @@ rtp_jitter_buffer_calculate_pts (RTPJitterBuffer * jbuf, GstClockTime dts,
     else
       pts = 0;
 
-    GST_DEBUG ("RFC7273 clock time %" GST_TIME_FORMAT ", ntptime %"
-        GST_TIME_FORMAT ", ntprtptime %" G_GUINT64_FORMAT ", rtptime %"
-        G_GUINT32_FORMAT ", base_time %" GST_TIME_FORMAT ", internal %"
-        GST_TIME_FORMAT ", external %" GST_TIME_FORMAT ", out %"
-        GST_TIME_FORMAT, GST_TIME_ARGS (rtpsystime), GST_TIME_ARGS (ntptime),
-        ntprtptime, rtptime, GST_TIME_ARGS (base_time),
-        GST_TIME_ARGS (internal), GST_TIME_ARGS (external),
-        GST_TIME_ARGS (pts));
+    GST_DEBUG ("Packet pipeline clock time %" GST_TIME_FORMAT ", PTS %"
+        GST_TIME_FORMAT, GST_TIME_ARGS (rtpsystime), GST_TIME_ARGS (pts));
   } else {
     /* If we used the RFC7273 clock before and not anymore,
      * we need to resync it later again */
@@ -1265,7 +1338,8 @@ rtp_jitter_buffer_pop (RTPJitterBuffer * jbuf, gint * percent)
 
   /* let's clear the pointers so we can ensure we don't free items that are
    * still in the jitterbuffer */
-  item->next = item->prev = NULL;
+  if (item)
+    item->next = item->prev = NULL;
 
   return (RTPJitterBufferItem *) item;
 }
diff --git a/gst/rtpmanager/rtpjitterbuffer.h b/gst/rtpmanager/rtpjitterbuffer.h
index 8accee4b4..d0e60c275 100644
--- a/gst/rtpmanager/rtpjitterbuffer.h
+++ b/gst/rtpmanager/rtpjitterbuffer.h
@@ -210,7 +210,7 @@ void                  rtp_jitter_buffer_get_sync         (RTPJitterBuffer *jbuf,
 
 GstClockTime          rtp_jitter_buffer_calculate_pts    (RTPJitterBuffer * jbuf, GstClockTime dts, gboolean estimated_dts,
                                                           guint32 rtptime, GstClockTime base_time, gint gap,
-                                                          gboolean is_rtx);
+                                                          gboolean is_rtx, GstClockTime * p_ntp_time);
 
 gboolean              rtp_jitter_buffer_can_fast_start   (RTPJitterBuffer * jbuf, gint num_packet);
 
diff --git a/gst/rtpmanager/rtpsession.c b/gst/rtpmanager/rtpsession.c
index dcfb1d796..294bcf0c1 100644
--- a/gst/rtpmanager/rtpsession.c
+++ b/gst/rtpmanager/rtpsession.c
@@ -30,6 +30,7 @@
 #include <gst/glib-compat-private.h>
 
 #include "rtpsession.h"
+#include "gstrtputils.h"
 
 GST_DEBUG_CATEGORY (rtp_session_debug);
 #define GST_CAT_DEFAULT rtp_session_debug
@@ -78,6 +79,9 @@ enum
 #define DEFAULT_RTP_PROFILE          GST_RTP_PROFILE_AVP
 #define DEFAULT_RTCP_REDUCED_SIZE    FALSE
 #define DEFAULT_RTCP_DISABLE_SR_TIMESTAMP FALSE
+#define DEFAULT_FAVOR_NEW            FALSE
+#define DEFAULT_TWCC_FEEDBACK_INTERVAL GST_CLOCK_TIME_NONE
+#define DEFAULT_UPDATE_NTP64_HEADER_EXT TRUE
 
 enum
 {
@@ -103,9 +107,14 @@ enum
   PROP_STATS,
   PROP_RTP_PROFILE,
   PROP_RTCP_REDUCED_SIZE,
-  PROP_RTCP_DISABLE_SR_TIMESTAMP
+  PROP_RTCP_DISABLE_SR_TIMESTAMP,
+  PROP_TWCC_FEEDBACK_INTERVAL,
+  PROP_UPDATE_NTP64_HEADER_EXT,
+  PROP_LAST,
 };
 
+static GParamSpec *properties[PROP_LAST];
+
 /* update average packet size */
 #define INIT_AVG(avg, val) \
    (avg) = (val);
@@ -115,9 +124,6 @@ enum
   else                                  \
    (avg) = ((val) + (15 * (avg))) >> 4;
 
-
-#define TWCC_EXTMAP_STR "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
-
 /* GObject vmethods */
 static void rtp_session_finalize (GObject * object);
 static void rtp_session_set_property (GObject * object, guint prop_id,
@@ -449,64 +455,62 @@ rtp_session_class_init (RTPSessionClass * klass)
       G_TYPE_UINT, 4, G_TYPE_UINT, G_TYPE_UINT, G_TYPE_ARRAY,
       GST_TYPE_BUFFER | G_SIGNAL_TYPE_STATIC_SCOPE);
 
-  g_object_class_install_property (gobject_class, PROP_INTERNAL_SSRC,
+  properties[PROP_INTERNAL_SSRC] =
       g_param_spec_uint ("internal-ssrc", "Internal SSRC",
-          "The internal SSRC used for the session (deprecated)",
-          0, G_MAXUINT, 0,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS |
-          GST_PARAM_DOC_SHOW_DEFAULT));
+      "The internal SSRC used for the session (deprecated)",
+      0, G_MAXUINT, 0,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | GST_PARAM_DOC_SHOW_DEFAULT);
 
-  g_object_class_install_property (gobject_class, PROP_INTERNAL_SOURCE,
+  properties[PROP_INTERNAL_SOURCE] =
       g_param_spec_object ("internal-source", "Internal Source",
-          "The internal source element of the session (deprecated)",
-          RTP_TYPE_SOURCE, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+      "The internal source element of the session (deprecated)",
+      RTP_TYPE_SOURCE, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_BANDWIDTH,
+  properties[PROP_BANDWIDTH] =
       g_param_spec_double ("bandwidth", "Bandwidth",
-          "The bandwidth of the session in bits per second (0 for auto-discover)",
-          0.0, G_MAXDOUBLE, DEFAULT_BANDWIDTH,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "The bandwidth of the session in bits per second (0 for auto-discover)",
+      0.0, G_MAXDOUBLE, DEFAULT_BANDWIDTH,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_RTCP_FRACTION,
+  properties[PROP_RTCP_FRACTION] =
       g_param_spec_double ("rtcp-fraction", "RTCP Fraction",
-          "The fraction of the bandwidth used for RTCP in bits per second (or as a real fraction of the RTP bandwidth if < 1)",
-          0.0, G_MAXDOUBLE, DEFAULT_RTCP_FRACTION,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "The fraction of the bandwidth used for RTCP in bits per second (or as a real fraction of the RTP bandwidth if < 1)",
+      0.0, G_MAXDOUBLE, DEFAULT_RTCP_FRACTION,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_RTCP_RR_BANDWIDTH,
+  properties[PROP_RTCP_RR_BANDWIDTH] =
       g_param_spec_int ("rtcp-rr-bandwidth", "RTCP RR bandwidth",
-          "The RTCP bandwidth used for receivers in bits per second (-1 = default)",
-          -1, G_MAXINT, DEFAULT_RTCP_RR_BANDWIDTH,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "The RTCP bandwidth used for receivers in bits per second (-1 = default)",
+      -1, G_MAXINT, DEFAULT_RTCP_RR_BANDWIDTH,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_RTCP_RS_BANDWIDTH,
+  properties[PROP_RTCP_RS_BANDWIDTH] =
       g_param_spec_int ("rtcp-rs-bandwidth", "RTCP RS bandwidth",
-          "The RTCP bandwidth used for senders in bits per second (-1 = default)",
-          -1, G_MAXINT, DEFAULT_RTCP_RS_BANDWIDTH,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "The RTCP bandwidth used for senders in bits per second (-1 = default)",
+      -1, G_MAXINT, DEFAULT_RTCP_RS_BANDWIDTH,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_RTCP_MTU,
+  properties[PROP_RTCP_MTU] =
       g_param_spec_uint ("rtcp-mtu", "RTCP MTU",
-          "The maximum size of the RTCP packets",
-          16, G_MAXINT16, DEFAULT_RTCP_MTU,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "The maximum size of the RTCP packets",
+      16, G_MAXINT16, DEFAULT_RTCP_MTU,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_SDES,
+  properties[PROP_SDES] =
       g_param_spec_boxed ("sdes", "SDES",
-          "The SDES items of this session",
-          GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS
-          | GST_PARAM_DOC_SHOW_DEFAULT));
+      "The SDES items of this session",
+      GST_TYPE_STRUCTURE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS
+      | GST_PARAM_DOC_SHOW_DEFAULT);
 
-  g_object_class_install_property (gobject_class, PROP_NUM_SOURCES,
+  properties[PROP_NUM_SOURCES] =
       g_param_spec_uint ("num-sources", "Num Sources",
-          "The number of sources in the session", 0, G_MAXUINT,
-          DEFAULT_NUM_SOURCES, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+      "The number of sources in the session", 0, G_MAXUINT,
+      DEFAULT_NUM_SOURCES, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_NUM_ACTIVE_SOURCES,
+  properties[PROP_NUM_ACTIVE_SOURCES] =
       g_param_spec_uint ("num-active-sources", "Num Active Sources",
-          "The number of active sources in the session", 0, G_MAXUINT,
-          DEFAULT_NUM_ACTIVE_SOURCES,
-          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+      "The number of active sources in the session", 0, G_MAXUINT,
+      DEFAULT_NUM_ACTIVE_SOURCES, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
   /**
    * RTPSource:sources
    *
@@ -532,56 +536,54 @@ rtp_session_class_init (RTPSessionClass * klass)
    * }
    * ```
    */
-  g_object_class_install_property (gobject_class, PROP_SOURCES,
+  properties[PROP_SOURCES] =
       g_param_spec_boxed ("sources", "Sources",
-          "An array of all known sources in the session",
-          G_TYPE_VALUE_ARRAY, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+      "An array of all known sources in the session",
+      G_TYPE_VALUE_ARRAY, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_FAVOR_NEW,
+  properties[PROP_FAVOR_NEW] =
       g_param_spec_boolean ("favor-new", "Favor new sources",
-          "Resolve SSRC conflict in favor of new sources", FALSE,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "Resolve SSRC conflict in favor of new sources", DEFAULT_FAVOR_NEW,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_RTCP_MIN_INTERVAL,
+  properties[PROP_RTCP_MIN_INTERVAL] =
       g_param_spec_uint64 ("rtcp-min-interval", "Minimum RTCP interval",
-          "Minimum interval between Regular RTCP packet (in ns)",
-          0, G_MAXUINT64, DEFAULT_RTCP_MIN_INTERVAL,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "Minimum interval between Regular RTCP packet (in ns)",
+      0, G_MAXUINT64, DEFAULT_RTCP_MIN_INTERVAL,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class,
-      PROP_RTCP_FEEDBACK_RETENTION_WINDOW,
+  properties[PROP_RTCP_FEEDBACK_RETENTION_WINDOW] =
       g_param_spec_uint64 ("rtcp-feedback-retention-window",
-          "RTCP Feedback retention window",
-          "Duration during which RTCP Feedback packets are retained (in ns)",
-          0, G_MAXUINT64, DEFAULT_RTCP_FEEDBACK_RETENTION_WINDOW,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "RTCP Feedback retention window",
+      "Duration during which RTCP Feedback packets are retained (in ns)",
+      0, G_MAXUINT64, DEFAULT_RTCP_FEEDBACK_RETENTION_WINDOW,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class,
-      PROP_RTCP_IMMEDIATE_FEEDBACK_THRESHOLD,
+  properties[PROP_RTCP_IMMEDIATE_FEEDBACK_THRESHOLD] =
       g_param_spec_uint ("rtcp-immediate-feedback-threshold",
-          "RTCP Immediate Feedback threshold",
-          "The maximum number of members of a RTP session for which immediate"
-          " feedback is used (DEPRECATED: has no effect and is not needed)",
-          0, G_MAXUINT, DEFAULT_RTCP_IMMEDIATE_FEEDBACK_THRESHOLD,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_DEPRECATED));
+      "RTCP Immediate Feedback threshold",
+      "The maximum number of members of a RTP session for which immediate"
+      " feedback is used (DEPRECATED: has no effect and is not needed)",
+      0, G_MAXUINT, DEFAULT_RTCP_IMMEDIATE_FEEDBACK_THRESHOLD,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS | G_PARAM_DEPRECATED);
 
-  g_object_class_install_property (gobject_class, PROP_PROBATION,
+  properties[PROP_PROBATION] =
       g_param_spec_uint ("probation", "Number of probations",
-          "Consecutive packet sequence numbers to accept the source",
-          0, G_MAXUINT, DEFAULT_PROBATION,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "Consecutive packet sequence numbers to accept the source",
+      0, G_MAXUINT, DEFAULT_PROBATION,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_MAX_DROPOUT_TIME,
+  properties[PROP_MAX_DROPOUT_TIME] =
       g_param_spec_uint ("max-dropout-time", "Max dropout time",
-          "The maximum time (milliseconds) of missing packets tolerated.",
-          0, G_MAXUINT, DEFAULT_MAX_DROPOUT_TIME,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "The maximum time (milliseconds) of missing packets tolerated.",
+      0, G_MAXUINT, DEFAULT_MAX_DROPOUT_TIME,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_MAX_MISORDER_TIME,
+  properties[PROP_MAX_MISORDER_TIME] =
       g_param_spec_uint ("max-misorder-time", "Max misorder time",
-          "The maximum time (milliseconds) of misordered packets tolerated.",
-          0, G_MAXUINT, DEFAULT_MAX_MISORDER_TIME,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "The maximum time (milliseconds) of misordered packets tolerated.",
+      0, G_MAXUINT, DEFAULT_MAX_MISORDER_TIME,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
   /**
    * RTPSession:stats:
@@ -598,21 +600,20 @@ rtp_session_class_init (RTPSessionClass * klass)
    *
    * Since: 1.4
    */
-  g_object_class_install_property (gobject_class, PROP_STATS,
+  properties[PROP_STATS] =
       g_param_spec_boxed ("stats", "Statistics",
-          "Various statistics", GST_TYPE_STRUCTURE,
-          G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
+      "Various statistics", GST_TYPE_STRUCTURE,
+      G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_RTP_PROFILE,
+  properties[PROP_RTP_PROFILE] =
       g_param_spec_enum ("rtp-profile", "RTP Profile",
-          "RTP profile to use for this session", GST_TYPE_RTP_PROFILE,
-          DEFAULT_RTP_PROFILE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "RTP profile to use for this session", GST_TYPE_RTP_PROFILE,
+      DEFAULT_RTP_PROFILE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
-  g_object_class_install_property (gobject_class, PROP_RTCP_REDUCED_SIZE,
+  properties[PROP_RTCP_REDUCED_SIZE] =
       g_param_spec_boolean ("rtcp-reduced-size", "RTCP Reduced Size",
-          "Use Reduced Size RTCP for feedback packets",
-          DEFAULT_RTCP_REDUCED_SIZE,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "Use Reduced Size RTCP for feedback packets",
+      DEFAULT_RTCP_REDUCED_SIZE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
 
   /**
    * RTPSession:disable-sr-timestamp:
@@ -621,13 +622,45 @@ rtp_session_class_init (RTPSessionClass * klass)
    *
    * Since: 1.16
    */
-  g_object_class_install_property (gobject_class,
-      PROP_RTCP_DISABLE_SR_TIMESTAMP,
+  properties[PROP_RTCP_DISABLE_SR_TIMESTAMP] =
       g_param_spec_boolean ("disable-sr-timestamp",
-          "Disable Sender Report Timestamp",
-          "Whether sender reports should be timestamped",
-          DEFAULT_RTCP_DISABLE_SR_TIMESTAMP,
-          G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
+      "Disable Sender Report Timestamp",
+      "Whether sender reports should be timestamped",
+      DEFAULT_RTCP_DISABLE_SR_TIMESTAMP,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  /**
+   * RTPSession:twcc-feedback-interval:
+   *
+   * The interval to send TWCC reports on.
+   * This overrides the default behavior of sending reports
+   * based on marker-bits.
+   *
+   * Since: 1.20
+   */
+  properties[PROP_TWCC_FEEDBACK_INTERVAL] =
+      g_param_spec_uint64 ("twcc-feedback-interval",
+      "TWCC Feedback Interval",
+      "The interval to send TWCC reports on",
+      0, G_MAXUINT64, DEFAULT_TWCC_FEEDBACK_INTERVAL,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  /**
+   * RTPSession:update-ntp64-header-ext:
+   *
+   * Whether RTP NTP header extension should be updated with actual
+   * NTP time. If not, use the NTP time from buffer timestamp metadata
+   *
+   * Since: 1.22
+   */
+  properties[PROP_UPDATE_NTP64_HEADER_EXT] =
+      g_param_spec_boolean ("update-ntp64-header-ext",
+      "Update NTP-64 RTP Header Extension",
+      "Whether RTP NTP header extension should be updated with actual NTP time",
+      DEFAULT_UPDATE_NTP64_HEADER_EXT,
+      G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS);
+
+  g_object_class_install_properties (gobject_class, PROP_LAST, properties);
 
   klass->get_source_by_ssrc =
       GST_DEBUG_FUNCPTR (rtp_session_get_source_by_ssrc);
@@ -672,9 +705,12 @@ rtp_session_init (RTPSession * sess)
   sess->header_len = UDP_IP_HEADER_OVERHEAD;
   sess->mtu = DEFAULT_RTCP_MTU;
 
+  sess->update_ntp64_header_ext = DEFAULT_UPDATE_NTP64_HEADER_EXT;
+
   sess->probation = DEFAULT_PROBATION;
   sess->max_dropout_time = DEFAULT_MAX_DROPOUT_TIME;
   sess->max_misorder_time = DEFAULT_MAX_MISORDER_TIME;
+  sess->favor_new = DEFAULT_FAVOR_NEW;
 
   /* some default SDES entries */
   sess->sdes = gst_structure_new_empty ("application/x-rtp-source-sdes");
@@ -907,6 +943,13 @@ rtp_session_set_property (GObject * object, guint prop_id,
     case PROP_RTCP_DISABLE_SR_TIMESTAMP:
       sess->timestamp_sender_reports = !g_value_get_boolean (value);
       break;
+    case PROP_TWCC_FEEDBACK_INTERVAL:
+      rtp_twcc_manager_set_feedback_interval (sess->twcc,
+          g_value_get_uint64 (value));
+      break;
+    case PROP_UPDATE_NTP64_HEADER_EXT:
+      sess->update_ntp64_header_ext = g_value_get_boolean (value);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -989,6 +1032,13 @@ rtp_session_get_property (GObject * object, guint prop_id,
     case PROP_RTCP_DISABLE_SR_TIMESTAMP:
       g_value_set_boolean (value, !sess->timestamp_sender_reports);
       break;
+    case PROP_TWCC_FEEDBACK_INTERVAL:
+      g_value_set_uint64 (value,
+          rtp_twcc_manager_get_feedback_interval (sess->twcc));
+      break;
+    case PROP_UPDATE_NTP64_HEADER_EXT:
+      g_value_set_boolean (value, sess->update_ntp64_header_ext);
+      break;
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
       break;
@@ -1199,9 +1249,9 @@ rtp_session_set_callbacks (RTPSession * sess, RTPSessionCallbacks * callbacks,
     sess->callbacks.sync_rtcp = callbacks->sync_rtcp;
     sess->sync_rtcp_user_data = user_data;
   }
-  if (callbacks->clock_rate) {
-    sess->callbacks.clock_rate = callbacks->clock_rate;
-    sess->clock_rate_user_data = user_data;
+  if (callbacks->caps) {
+    sess->callbacks.caps = callbacks->caps;
+    sess->caps_user_data = user_data;
   }
   if (callbacks->reconsider) {
     sess->callbacks.reconsider = callbacks->reconsider;
@@ -1306,7 +1356,7 @@ rtp_session_set_sync_rtcp_callback (RTPSession * sess,
 }
 
 /**
- * rtp_session_set_clock_rate_callback:
+ * rtp_session_set_caps_callback:
  * @sess: an #RTPSession
  * @callback: callback to set
  * @user_data: user data passed in the callback
@@ -1314,13 +1364,13 @@ rtp_session_set_sync_rtcp_callback (RTPSession * sess,
  * Configure only the clock_rate callback to be notified of the clock_rate action.
  */
 void
-rtp_session_set_clock_rate_callback (RTPSession * sess,
-    RTPSessionClockRate callback, gpointer user_data)
+rtp_session_set_caps_callback (RTPSession * sess,
+    RTPSessionCaps callback, gpointer user_data)
 {
   g_return_if_fail (RTP_IS_SESSION (sess));
 
-  sess->callbacks.clock_rate = callback;
-  sess->clock_rate_user_data = user_data;
+  sess->callbacks.caps = callback;
+  sess->caps_user_data = user_data;
 }
 
 /**
@@ -1524,30 +1574,26 @@ source_push_rtp (RTPSource * source, gpointer data, RTPSession * session)
   return result;
 }
 
-static gint
-source_clock_rate (RTPSource * source, guint8 pt, RTPSession * session)
+static GstCaps *
+source_caps (RTPSource * source, guint8 pt, RTPSession * session)
 {
-  gint result;
+  GstCaps *result = NULL;
 
   RTP_SESSION_UNLOCK (session);
 
-  if (session->callbacks.clock_rate)
-    result =
-        session->callbacks.clock_rate (session, pt,
-        session->clock_rate_user_data);
-  else
-    result = -1;
+  if (session->callbacks.caps)
+    result = session->callbacks.caps (session, pt, session->caps_user_data);
 
   RTP_SESSION_LOCK (session);
 
-  GST_DEBUG ("got clock-rate %d for pt %d", result, pt);
+  GST_DEBUG ("got caps %" GST_PTR_FORMAT " for pt %d", result, pt);
 
   return result;
 }
 
 static RTPSourceCallbacks callbacks = {
   (RTPSourcePushRTP) source_push_rtp,
-  (RTPSourceClockRate) source_clock_rate,
+  (RTPSourceCaps) source_caps,
 };
 
 
@@ -1899,7 +1945,8 @@ obtain_internal_source (RTPSession * sess, guint32 ssrc, gboolean * created,
 
     source->validated = TRUE;
     source->internal = TRUE;
-    source->probation = FALSE;
+    source->probation = 0;
+    source->curr_probation = 0;
     rtp_source_set_sdes_struct (source, gst_structure_copy (sess->sdes));
     rtp_source_set_callbacks (source, &callbacks, sess);
 
@@ -2094,6 +2141,25 @@ update_packet (GstBuffer ** buffer, guint idx, RTPPacketInfo * pinfo)
       pinfo->header_ext = gst_rtp_buffer_get_extension_bytes (&rtp,
           &pinfo->header_ext_bit_pattern);
     }
+
+    if (pinfo->ntp64_ext_id != 0 && pinfo->send && !pinfo->have_ntp64_ext) {
+      guint8 *data;
+      guint size;
+
+      /* Remember here that there is a 64-bit NTP header extension on this buffer
+       * or any of the other buffers in the buffer list.
+       * Later we update this after making the buffer(list) writable.
+       */
+      if ((gst_rtp_buffer_get_extension_onebyte_header (&rtp,
+                  pinfo->ntp64_ext_id, 0, (gpointer *) & data, &size)
+              && size == 8)
+          || (gst_rtp_buffer_get_extension_twobytes_header (&rtp, NULL,
+                  pinfo->ntp64_ext_id, 0, (gpointer *) & data, &size)
+              && size == 8)) {
+        pinfo->have_ntp64_ext = TRUE;
+      }
+    }
+
     gst_rtp_buffer_unmap (&rtp);
   }
 
@@ -2142,15 +2208,19 @@ update_packet_info (RTPSession * sess, RTPPacketInfo * pinfo,
   pinfo->payload_len = 0;
   pinfo->packets = 0;
   pinfo->marker = FALSE;
+  pinfo->ntp64_ext_id = send ? sess->send_ntp64_ext_id : 0;
+  pinfo->have_ntp64_ext = FALSE;
 
   if (is_list) {
     GstBufferList *list = GST_BUFFER_LIST_CAST (data);
     res =
         gst_buffer_list_foreach (list, (GstBufferListFunc) update_packet,
         pinfo);
+    pinfo->arrival_time = GST_CLOCK_TIME_NONE;
   } else {
     GstBuffer *buffer = GST_BUFFER_CAST (data);
     res = update_packet (&buffer, 0, pinfo);
+    pinfo->arrival_time = GST_BUFFER_DTS (buffer);
   }
 
   return res;
@@ -2169,22 +2239,6 @@ clean_packet_info (RTPPacketInfo * pinfo)
     g_bytes_unref (pinfo->header_ext);
 }
 
-static gint32
-packet_info_get_twcc_seqnum (RTPPacketInfo * pinfo, guint8 ext_id)
-{
-  gint32 val = -1;
-  gpointer data;
-  guint size;
-
-  if (pinfo->header_ext &&
-      gst_rtp_buffer_get_extension_onebyte_header_from_bytes (pinfo->header_ext,
-          pinfo->header_ext_bit_pattern, ext_id, 0, &data, &size)) {
-    if (size == 2)
-      val = GST_READ_UINT16_BE (data);
-  }
-  return val;
-}
-
 static gboolean
 source_update_active (RTPSession * sess, RTPSource * source,
     gboolean prevactive)
@@ -2210,16 +2264,7 @@ source_update_active (RTPSession * sess, RTPSource * source,
 static void
 process_twcc_packet (RTPSession * sess, RTPPacketInfo * pinfo)
 {
-  gint32 twcc_seqnum;
-
-  if (sess->twcc_recv_ext_id == 0)
-    return;
-
-  twcc_seqnum = packet_info_get_twcc_seqnum (pinfo, sess->twcc_recv_ext_id);
-  if (twcc_seqnum == -1)
-    return;
-
-  if (rtp_twcc_manager_recv_packet (sess->twcc, twcc_seqnum, pinfo)) {
+  if (rtp_twcc_manager_recv_packet (sess->twcc, pinfo)) {
     RTP_SESSION_UNLOCK (sess);
 
     /* TODO: find a better rational for this number, and possibly tune it based
@@ -2393,7 +2438,7 @@ rtp_session_process_rb (RTPSession * sess, RTPSource * source,
        * the sender of the RTCP message. We could also compare our stats against
        * the other sender to see if we are better or worse. */
       /* FIXME, need to keep track who the RB block is from */
-      rtp_source_process_rb (source, pinfo->ntpnstime, fractionlost,
+      rtp_source_process_rb (source, ssrc, pinfo->ntpnstime, fractionlost,
           packetslost, exthighestseq, jitter, lsr, dlsr);
     }
   }
@@ -2722,11 +2767,16 @@ rtp_session_process_app (RTPSession * sess, GstRTCPPacket * packet,
 
 static gboolean
 rtp_session_request_local_key_unit (RTPSession * sess, RTPSource * src,
-    guint32 media_ssrc, gboolean fir, GstClockTime current_time)
+    const guint32 * ssrcs, guint num_ssrcs, gboolean fir,
+    GstClockTime current_time)
 {
   guint32 round_trip = 0;
+  gint i;
+
+  g_return_val_if_fail (ssrcs != NULL && num_ssrcs > 0, FALSE);
 
-  rtp_source_get_last_rb (src, NULL, NULL, NULL, NULL, NULL, NULL, &round_trip);
+  rtp_source_get_last_rb (src, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+      &round_trip);
 
   if (src->last_keyframe_request != GST_CLOCK_TIME_NONE && round_trip) {
     GstClockTime round_trip_in_ns = gst_util_uint64_scale (round_trip,
@@ -2749,14 +2799,17 @@ rtp_session_request_local_key_unit (RTPSession * sess, RTPSource * src,
 
   src->last_keyframe_request = current_time;
 
-  GST_LOG ("received %s request from %X about %X %p(%p)", fir ? "FIR" : "PLI",
-      rtp_source_get_ssrc (src), media_ssrc, sess->callbacks.process_rtp,
-      sess->callbacks.request_key_unit);
+  for (i = 0; i < num_ssrcs; ++i) {
+    GST_LOG ("received %s request from %X about %X %p(%p)",
+        fir ? "FIR" : "PLI",
+        rtp_source_get_ssrc (src), ssrcs[i], sess->callbacks.process_rtp,
+        sess->callbacks.request_key_unit);
 
-  RTP_SESSION_UNLOCK (sess);
-  sess->callbacks.request_key_unit (sess, media_ssrc, fir,
-      sess->request_key_unit_user_data);
-  RTP_SESSION_LOCK (sess);
+    RTP_SESSION_UNLOCK (sess);
+    sess->callbacks.request_key_unit (sess, ssrcs[i], fir,
+        sess->request_key_unit_user_data);
+    RTP_SESSION_LOCK (sess);
+  }
 
   return TRUE;
 }
@@ -2778,19 +2831,19 @@ rtp_session_process_pli (RTPSession * sess, guint32 sender_ssrc,
       return;
   }
 
-  rtp_session_request_local_key_unit (sess, src, media_ssrc, FALSE,
+  rtp_session_request_local_key_unit (sess, src, &media_ssrc, 1, FALSE,
       current_time);
 }
 
 static void
 rtp_session_process_fir (RTPSession * sess, guint32 sender_ssrc,
-    guint32 media_ssrc, guint8 * fci_data, guint fci_length,
-    GstClockTime current_time)
+    guint8 * fci_data, guint fci_length, GstClockTime current_time)
 {
   RTPSource *src;
   guint32 ssrc;
   guint position = 0;
-  gboolean our_request = FALSE;
+  guint32 ssrcs[32];
+  guint num_ssrcs = 0;
 
   if (!sess->callbacks.request_key_unit)
     return;
@@ -2828,15 +2881,14 @@ rtp_session_process_fir (RTPSession * sess, guint32 sender_ssrc,
     if (own == NULL)
       continue;
 
-    if (own->internal) {
-      our_request = TRUE;
-      break;
+    if (own->internal && num_ssrcs < 32) {
+      ssrcs[num_ssrcs++] = ssrc;
     }
   }
-  if (!our_request)
+  if (num_ssrcs == 0)
     return;
 
-  rtp_session_request_local_key_unit (sess, src, media_ssrc, TRUE,
+  rtp_session_request_local_key_unit (sess, src, ssrcs, num_ssrcs, TRUE,
       current_time);
 }
 
@@ -2868,6 +2920,34 @@ rtp_session_process_nack (RTPSession * sess, guint32 sender_ssrc,
   }
 }
 
+static void
+rtp_session_process_sr_req (RTPSession * sess, guint32 sender_ssrc,
+    guint32 media_ssrc)
+{
+  RTPSource *src;
+
+  /* Request a new SR in feedback profiles ASAP */
+  if (sess->rtp_profile != GST_RTP_PROFILE_AVPF
+      && sess->rtp_profile != GST_RTP_PROFILE_SAVPF)
+    return;
+
+  src = find_source (sess, sender_ssrc);
+  /* Our own RTCP packet */
+  if (src && src->internal)
+    return;
+
+  src = find_source (sess, media_ssrc);
+  /* Not an SSRC we're producing */
+  if (!src || !src->internal)
+    return;
+
+  GST_DEBUG_OBJECT (sess, "Handling RTCP-SR-REQ");
+  /* FIXME: 5s max_delay hard-coded here as we have to give some
+   * high enough value */
+  sess->sr_req_pending = TRUE;
+  rtp_session_send_rtcp (sess, 5 * GST_SECOND);
+}
+
 static void
 rtp_session_process_twcc (RTPSession * sess, guint32 sender_ssrc,
     guint32 media_ssrc, guint8 * fci_data, guint fci_length)
@@ -2973,8 +3053,8 @@ rtp_session_process_feedback (RTPSession * sess, GstRTCPPacket * packet,
           case GST_RTCP_PSFB_TYPE_FIR:
             if (src)
               src->stats.recv_fir_count++;
-            rtp_session_process_fir (sess, sender_ssrc, media_ssrc, fci_data,
-                fci_length, current_time);
+            rtp_session_process_fir (sess, sender_ssrc, fci_data, fci_length,
+                current_time);
             break;
           default:
             break;
@@ -2988,6 +3068,9 @@ rtp_session_process_feedback (RTPSession * sess, GstRTCPPacket * packet,
             rtp_session_process_nack (sess, sender_ssrc, media_ssrc,
                 fci_data, fci_length, current_time);
             break;
+          case GST_RTCP_RTPFB_TYPE_RTCP_SR_REQ:
+            rtp_session_process_sr_req (sess, sender_ssrc, media_ssrc);
+            break;
           case GST_RTCP_RTPFB_TYPE_TWCC:
             rtp_session_process_twcc (sess, sender_ssrc, media_ssrc,
                 fci_data, fci_length);
@@ -3021,7 +3104,7 @@ rtp_session_process_rtcp (RTPSession * sess, GstBuffer * buffer,
     GstClockTime current_time, GstClockTime running_time, guint64 ntpnstime)
 {
   GstRTCPPacket packet;
-  gboolean more, is_bye = FALSE, do_sync = FALSE;
+  gboolean more, is_bye = FALSE, do_sync = FALSE, has_report = FALSE;
   RTPPacketInfo pinfo = { 0, };
   GstFlowReturn result = GST_FLOW_OK;
   GstRTCPBuffer rtcp = { NULL, };
@@ -3052,9 +3135,11 @@ rtp_session_process_rtcp (RTPSession * sess, GstBuffer * buffer,
 
     switch (type) {
       case GST_RTCP_TYPE_SR:
+        has_report = TRUE;
         rtp_session_process_sr (sess, &packet, &pinfo, &do_sync);
         break;
       case GST_RTCP_TYPE_RR:
+        has_report = TRUE;
         rtp_session_process_rr (sess, &packet, &pinfo);
         break;
       case GST_RTCP_TYPE_SDES:
@@ -3102,6 +3187,10 @@ rtp_session_process_rtcp (RTPSession * sess, GstBuffer * buffer,
       sess->stats.avg_rtcp_packet_size, pinfo.bytes);
   RTP_SESSION_UNLOCK (sess);
 
+  if (has_report) {
+    g_object_notify_by_pspec (G_OBJECT (sess), properties[PROP_STATS]);
+  }
+
   pinfo.data = NULL;
   clean_packet_info (&pinfo);
 
@@ -3123,29 +3212,6 @@ invalid_packet:
   }
 }
 
-static guint8
-_get_extmap_id_for_attribute (const GstStructure * s, const gchar * ext_name)
-{
-  guint i;
-  guint8 extmap_id = 0;
-  guint n_fields = gst_structure_n_fields (s);
-
-  for (i = 0; i < n_fields; i++) {
-    const gchar *field_name = gst_structure_nth_field_name (s, i);
-    if (g_str_has_prefix (field_name, "extmap-")) {
-      const gchar *str = gst_structure_get_string (s, field_name);
-      if (str && g_strcmp0 (str, ext_name) == 0) {
-        gint64 id = g_ascii_strtoll (field_name + 7, NULL, 10);
-        if (id > 0 && id < 15) {
-          extmap_id = id;
-          break;
-        }
-      }
-    }
-  }
-  return extmap_id;
-}
-
 /**
  * rtp_session_update_send_caps:
  * @sess: an #RTPSession
@@ -3176,7 +3242,7 @@ rtp_session_update_send_caps (RTPSession * sess, GstCaps * caps)
     sess->internal_ssrc_set = TRUE;
     sess->internal_ssrc_from_caps_or_property = TRUE;
     if (source) {
-      rtp_source_update_caps (source, caps);
+      rtp_source_update_send_caps (source, caps);
 
       if (created)
         on_new_sender_ssrc (sess, source);
@@ -3188,7 +3254,7 @@ rtp_session_update_send_caps (RTPSession * sess, GstCaps * caps)
       source =
           obtain_internal_source (sess, ssrc, &created, GST_CLOCK_TIME_NONE);
       if (source) {
-        rtp_source_update_caps (source, caps);
+        rtp_source_update_send_caps (source, caps);
 
         if (created)
           on_new_sender_ssrc (sess, source);
@@ -3201,28 +3267,150 @@ rtp_session_update_send_caps (RTPSession * sess, GstCaps * caps)
     sess->internal_ssrc_from_caps_or_property = FALSE;
   }
 
-  sess->twcc_send_ext_id = _get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
-  if (sess->twcc_send_ext_id > 0) {
-    GST_INFO ("TWCC enabled for send using extension id: %u",
-        sess->twcc_send_ext_id);
-  }
+  sess->send_ntp64_ext_id =
+      gst_rtp_get_extmap_id_for_attribute (s,
+      GST_RTP_HDREXT_BASE GST_RTP_HDREXT_NTP_64);
+
+  rtp_twcc_manager_parse_send_ext_id (sess->twcc, s);
 }
 
 static void
-send_twcc_packet (RTPSession * sess, RTPPacketInfo * pinfo)
+update_ntp64_header_ext_data (RTPPacketInfo * pinfo, GstBuffer * buffer)
 {
-  gint32 twcc_seqnum;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
 
-  if (sess->twcc_send_ext_id == 0)
-    return;
+  if (gst_rtp_buffer_map (buffer, GST_MAP_READWRITE, &rtp)) {
+    guint16 bits;
+    guint8 *data;
+    guint wordlen;
 
-  twcc_seqnum = packet_info_get_twcc_seqnum (pinfo, sess->twcc_send_ext_id);
-  if (twcc_seqnum == -1)
-    return;
+    if (gst_rtp_buffer_get_extension_data (&rtp, &bits, (gpointer *) & data,
+            &wordlen)) {
+      gsize len = wordlen * 4;
+
+      /* One-byte header */
+      if (bits == 0xBEDE) {
+        /* One-byte header extension */
+        while (TRUE) {
+          guint8 ext_id, ext_len;
+
+          if (len < 1)
+            break;
+
+          ext_id = GST_READ_UINT8 (data) >> 4;
+          ext_len = (GST_READ_UINT8 (data) & 0xF) + 1;
+          data += 1;
+          len -= 1;
+          if (ext_id == 0) {
+            /* Skip padding */
+            continue;
+          } else if (ext_id == 15) {
+            /* Stop parsing */
+            break;
+          }
+
+          /* extension doesn't fit into the header */
+          if (ext_len > len)
+            break;
+
+          if (ext_id == pinfo->ntp64_ext_id && ext_len == 8) {
+            if (pinfo->ntpnstime != GST_CLOCK_TIME_NONE) {
+              guint64 ntptime = gst_util_uint64_scale (pinfo->ntpnstime,
+                  G_GUINT64_CONSTANT (1) << 32,
+                  GST_SECOND);
+
+              GST_WRITE_UINT64_BE (data, ntptime);
+            } else {
+              /* Replace extension with padding */
+              memset (data - 1, 0, 1 + ext_len);
+            }
+          }
+
+          /* skip to the next extension */
+          data += ext_len;
+          len -= ext_len;
+        }
+      } else if ((bits >> 4) == 0x100) {
+        /* Two-byte header extension */
+
+        while (TRUE) {
+          guint8 ext_id, ext_len;
+
+          if (len < 1)
+            break;
+
+          ext_id = GST_READ_UINT8 (data);
+          data += 1;
+          len -= 1;
+          if (ext_id == 0) {
+            /* Skip padding */
+            continue;
+          }
+
+          ext_len = GST_READ_UINT8 (data);
+          data += 1;
+          len -= 1;
+
+          /* extension doesn't fit into the header */
+          if (ext_len > len)
+            break;
+
+          if (ext_id == pinfo->ntp64_ext_id && ext_len == 8) {
+            if (pinfo->ntpnstime != GST_CLOCK_TIME_NONE) {
+              guint64 ntptime = gst_util_uint64_scale (pinfo->ntpnstime,
+                  G_GUINT64_CONSTANT (1) << 32,
+                  GST_SECOND);
+
+              GST_WRITE_UINT64_BE (data, ntptime);
+            } else {
+              /* Replace extension with padding */
+              memset (data - 2, 0, 2 + ext_len);
+            }
+          }
 
-  rtp_twcc_manager_send_packet (sess->twcc, twcc_seqnum, pinfo);
+          /* skip to the next extension */
+          data += ext_len;
+          len -= ext_len;
+        }
+      }
+    }
+    gst_rtp_buffer_unmap (&rtp);
+  }
 }
 
+static void
+update_ntp64_header_ext (RTPPacketInfo * pinfo)
+{
+  /* Early return if we don't know the header extension id or the packets
+   * don't contain the header extension */
+  if (pinfo->ntp64_ext_id == 0 || !pinfo->have_ntp64_ext)
+    return;
+
+  /* If no NTP time is known then the header extension will be replaced with
+   * padding, otherwise it will be updated */
+  GST_TRACE
+      ("Updating NTP-64 header extension for SSRC %08x packet with RTP time %u and running time %"
+      GST_TIME_FORMAT " to %" GST_TIME_FORMAT, pinfo->ssrc, pinfo->rtptime,
+      GST_TIME_ARGS (pinfo->running_time), GST_TIME_ARGS (pinfo->ntpnstime));
+
+  if (GST_IS_BUFFER_LIST (pinfo->data)) {
+    GstBufferList *list;
+    guint i = 0;
+
+    pinfo->data = gst_buffer_list_make_writable (pinfo->data);
+
+    list = GST_BUFFER_LIST (pinfo->data);
+
+    for (i = 0; i < gst_buffer_list_length (list); i++) {
+      GstBuffer *buffer = gst_buffer_list_get_writable (list, i);
+
+      update_ntp64_header_ext_data (pinfo, buffer);
+    }
+  } else {
+    pinfo->data = gst_buffer_make_writable (pinfo->data);
+    update_ntp64_header_ext_data (pinfo, pinfo->data);
+  }
+}
 
 /**
  * rtp_session_send_rtp:
@@ -3239,7 +3427,7 @@ send_twcc_packet (RTPSession * sess, RTPPacketInfo * pinfo)
  */
 GstFlowReturn
 rtp_session_send_rtp (RTPSession * sess, gpointer data, gboolean is_list,
-    GstClockTime current_time, GstClockTime running_time)
+    GstClockTime current_time, GstClockTime running_time, guint64 ntpnstime)
 {
   GstFlowReturn result;
   RTPSource *source;
@@ -3255,10 +3443,14 @@ rtp_session_send_rtp (RTPSession * sess, gpointer data, gboolean is_list,
 
   RTP_SESSION_LOCK (sess);
   if (!update_packet_info (sess, &pinfo, TRUE, TRUE, is_list, data,
-          current_time, running_time, -1))
+          current_time, running_time, ntpnstime))
     goto invalid_packet;
 
-  send_twcc_packet (sess, &pinfo);
+  /* Update any 64-bit NTP header extensions with the actual NTP time here */
+  if (sess->update_ntp64_header_ext)
+    update_ntp64_header_ext (&pinfo);
+
+  rtp_twcc_manager_send_packet (sess->twcc, &pinfo);
 
   source = obtain_internal_source (sess, pinfo.ssrc, &created, current_time);
   if (created)
@@ -3281,13 +3473,15 @@ rtp_session_send_rtp (RTPSession * sess, gpointer data, gboolean is_list,
         GST_DEBUG ("Collision for SSRC %x, change our sender ssrc", pinfo.ssrc);
 
         rtp_session_have_conflict (sess, source, from, current_time);
-
-        goto collision;
       }
     } else {
       GST_LOG ("Ignoring collision on sent SSRC %x because remote source"
           " doesn't have an address", pinfo.ssrc);
     }
+
+    /* the the sending source is not internal, we have to drop the packet,
+       or else we will end up receving it ourselves! */
+    goto collision;
   }
 
   prevsender = RTP_SOURCE_IS_SENDER (source);
@@ -3611,14 +3805,14 @@ session_start_rtcp (RTPSession * sess, ReportData * data)
 
   gst_rtcp_buffer_map (data->rtcp, GST_MAP_READWRITE, rtcp);
 
-  if (data->is_early && sess->reduced_size_rtcp)
-    return;
-
-  if (RTP_SOURCE_IS_SENDER (own)) {
+  if (RTP_SOURCE_IS_SENDER (own) && (!data->is_early || !sess->reduced_size_rtcp
+          || sess->sr_req_pending)) {
     guint64 ntptime;
     guint32 rtptime;
     guint32 packet_count, octet_count;
 
+    sess->sr_req_pending = FALSE;
+
     /* we are a sender, create SR */
     GST_DEBUG ("create SR for SSRC %08x", own->ssrc);
     gst_rtcp_buffer_add_packet (rtcp, GST_RTCP_TYPE_SR, packet);
@@ -3635,7 +3829,7 @@ session_start_rtcp (RTPSession * sess, ReportData * data)
         sess->timestamp_sender_reports ? ntptime : 0,
         sess->timestamp_sender_reports ? rtptime : 0,
         packet_count, octet_count);
-  } else {
+  } else if (!data->is_early || !sess->reduced_size_rtcp) {
     /* we are only receiver, create RR */
     GST_DEBUG ("create RR for SSRC %08x", own->ssrc);
     gst_rtcp_buffer_add_packet (rtcp, GST_RTCP_TYPE_RR, packet);
@@ -3694,6 +3888,7 @@ session_report_blocks (const gchar * key, RTPSource * source, ReportData * data)
 
   /* store last generated RR packet */
   source->last_rr.is_valid = TRUE;
+  source->last_rr.ssrc = data->source->ssrc;
   source->last_rr.fractionlost = fractionlost;
   source->last_rr.packetslost = packetslost;
   source->last_rr.exthighestseq = exthighestseq;
@@ -4002,7 +4197,8 @@ session_cleanup (const gchar * key, RTPSource * source, ReportData * data)
         /* this is an internal source that is not using our suggested ssrc.
          * since there must be another source using this ssrc, we can remove
          * this one instead of making it a receiver forever */
-        if (source->ssrc != sess->suggested_ssrc) {
+        if (source->ssrc != sess->suggested_ssrc
+            && source->media_ssrc != sess->suggested_ssrc) {
           rtp_source_mark_bye (source, "timed out");
           /* do not schedule bye here, since we are inside the RTCP timeout
            * processing and scheduling bye will interfere with SR/RR sending */
@@ -4283,6 +4479,8 @@ generate_twcc (const gchar * key, RTPSource * source, ReportData * data)
     return;
   }
 
+  GST_DEBUG ("generating TWCC feedback for source %08x", source->ssrc);
+
   while ((buf = rtp_twcc_manager_get_feedback (sess->twcc, source->ssrc))) {
     ReportOutput *output = g_slice_new (ReportOutput);
     output->source = g_object_ref (source);
@@ -4300,6 +4498,7 @@ generate_rtcp (const gchar * key, RTPSource * source, ReportData * data)
   RTPSession *sess = data->sess;
   gboolean is_bye = FALSE;
   ReportOutput *output;
+  gboolean sr_req_pending = sess->sr_req_pending;
 
   /* only generate RTCP for active internal sources */
   if (!source->internal || source->sent_bye)
@@ -4330,7 +4529,8 @@ generate_rtcp (const gchar * key, RTPSource * source, ReportData * data)
     g_hash_table_foreach (sess->ssrcs[sess->mask_idx],
         (GHFunc) session_report_blocks, data);
   }
-  if (!data->has_sdes && (!data->is_early || !sess->reduced_size_rtcp))
+  if (!data->has_sdes && (!data->is_early || !sess->reduced_size_rtcp
+          || sr_req_pending))
     session_sdes (sess, data);
 
   if (data->have_fir)
@@ -4549,7 +4749,7 @@ done:
   RTP_SESSION_UNLOCK (sess);
 
   /* notify about updated statistics */
-  g_object_notify (G_OBJECT (sess), "stats");
+  g_object_notify_by_pspec (G_OBJECT (sess), properties[PROP_STATS]);
 
   /* push out the RTCP packets */
   while ((output = g_queue_pop_head (&data.output))) {
@@ -4916,10 +5116,5 @@ void
 rtp_session_update_recv_caps_structure (RTPSession * sess,
     const GstStructure * s)
 {
-  guint8 ext_id = _get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
-  if (ext_id > 0) {
-    sess->twcc_recv_ext_id = ext_id;
-    GST_INFO ("TWCC enabled for recv using extension id: %u",
-        sess->twcc_recv_ext_id);
-  }
+  rtp_twcc_manager_parse_recv_ext_id (sess->twcc, s);
 }
diff --git a/gst/rtpmanager/rtpsession.h b/gst/rtpmanager/rtpsession.h
index 949fcc49b..84b2948dc 100644
--- a/gst/rtpmanager/rtpsession.h
+++ b/gst/rtpmanager/rtpsession.h
@@ -97,16 +97,16 @@ typedef GstFlowReturn (*RTPSessionSendRTCP) (RTPSession *sess, RTPSource *src, G
 typedef GstFlowReturn (*RTPSessionSyncRTCP) (RTPSession *sess, GstBuffer *buffer, gpointer user_data);
 
 /**
- * RTPSessionClockRate:
+ * RTPSessionCaps:
  * @sess: an #RTPSession
  * @payload: the payload
  * @user_data: user data specified when registering
  *
- * This callback will be called when @sess needs the clock-rate of @payload.
+ * This callback will be called when @sess needs the caps of @payload.
  *
- * Returns: the clock-rate of @pt.
+ * Returns: the caps of @pt.
  */
-typedef gint (*RTPSessionClockRate) (RTPSession *sess, guint8 payload, gpointer user_data);
+typedef GstCaps * (*RTPSessionCaps) (RTPSession *sess, guint8 payload, gpointer user_data);
 
 /**
  * RTPSessionReconsider:
@@ -209,7 +209,7 @@ typedef struct {
   RTPSessionSendRTP     send_rtp;
   RTPSessionSyncRTCP    sync_rtcp;
   RTPSessionSendRTCP    send_rtcp;
-  RTPSessionClockRate   clock_rate;
+  RTPSessionCaps        caps;
   RTPSessionReconsider  reconsider;
   RTPSessionRequestKeyUnit request_key_unit;
   RTPSessionRequestTime request_time;
@@ -280,6 +280,7 @@ struct _RTPSession {
 
   GstClockTime  next_early_rtcp_time;
 
+  gboolean      sr_req_pending;
   gboolean      scheduled_bye;
 
   RTPSessionCallbacks   callbacks;
@@ -287,7 +288,7 @@ struct _RTPSession {
   gpointer              send_rtp_user_data;
   gpointer              send_rtcp_user_data;
   gpointer              sync_rtcp_user_data;
-  gpointer              clock_rate_user_data;
+  gpointer              caps_user_data;
   gpointer              reconsider_user_data;
   gpointer              request_key_unit_user_data;
   gpointer              request_time_user_data;
@@ -309,11 +310,14 @@ struct _RTPSession {
 
   gboolean timestamp_sender_reports;
 
+  /* RFC6051 64-bit NTP header extension */
+  guint8 send_ntp64_ext_id;
+
+  gboolean update_ntp64_header_ext;
+
   /* Transport-wide cc-extension */
   RTPTWCCManager *twcc;
   RTPTWCCStats *twcc_stats;
-  guint8 twcc_recv_ext_id;
-  guint8 twcc_send_ext_id;
 };
 
 /**
@@ -373,8 +377,8 @@ void            rtp_session_set_send_rtcp_callback   (RTPSession * sess,
 void            rtp_session_set_sync_rtcp_callback   (RTPSession * sess,
                                                     RTPSessionSyncRTCP callback,
                                                     gpointer user_data);
-void            rtp_session_set_clock_rate_callback   (RTPSession * sess,
-                                                    RTPSessionClockRate callback,
+void            rtp_session_set_caps_callback        (RTPSession * sess,
+                                                    RTPSessionCaps callback,
                                                     gpointer user_data);
 void            rtp_session_set_reconsider_callback (RTPSession * sess,
                                                     RTPSessionReconsider callback,
@@ -412,7 +416,8 @@ GstFlowReturn   rtp_session_process_rtcp           (RTPSession *sess, GstBuffer
 /* processing packets for sending */
 void            rtp_session_update_send_caps       (RTPSession *sess, GstCaps *caps);
 GstFlowReturn   rtp_session_send_rtp               (RTPSession *sess, gpointer data, gboolean is_list,
-                                                    GstClockTime current_time, GstClockTime running_time);
+                                                    GstClockTime current_time, GstClockTime running_time,
+                                                    guint64 ntpnstime);
 
 /* scheduling bye */
 void            rtp_session_mark_all_bye           (RTPSession *sess, const gchar *reason);
diff --git a/gst/rtpmanager/rtpsource.c b/gst/rtpmanager/rtpsource.c
index 12aa12549..c221c1f22 100644
--- a/gst/rtpmanager/rtpsource.c
+++ b/gst/rtpmanager/rtpsource.c
@@ -373,6 +373,7 @@ rtp_source_create_stats (RTPSource * src)
   gboolean internal = src->internal;
   gchar *address_str;
   gboolean have_rb;
+  guint32 ssrc = 0;
   guint8 fractionlost = 0;
   gint32 packetslost = 0;
   guint32 exthighestseq = 0;
@@ -453,11 +454,12 @@ rtp_source_create_stats (RTPSource * src)
         (guint) src->last_rr.dlsr, NULL);
 
     /* get the last RB */
-    have_rb = rtp_source_get_last_rb (src, &fractionlost, &packetslost,
-        &exthighestseq, &jitter, &lsr, &dlsr, &round_trip);
+    have_rb = rtp_source_get_last_rb (src, &ssrc, &fractionlost,
+        &packetslost, &exthighestseq, &jitter, &lsr, &dlsr, &round_trip);
 
     gst_structure_set (s,
         "have-rb", G_TYPE_BOOLEAN, have_rb,
+        "rb-ssrc", G_TYPE_UINT, ssrc,
         "rb-fractionlost", G_TYPE_UINT, (guint) fractionlost,
         "rb-packetslost", G_TYPE_INT, (gint) packetslost,
         "rb-exthighestseq", G_TYPE_UINT, (guint) exthighestseq,
@@ -647,7 +649,7 @@ rtp_source_set_callbacks (RTPSource * src, RTPSourceCallbacks * cb,
   g_return_if_fail (RTP_IS_SOURCE (src));
 
   src->callbacks.push_rtp = cb->push_rtp;
-  src->callbacks.clock_rate = cb->clock_rate;
+  src->callbacks.caps = cb->caps;
   src->user_data = user_data;
 }
 
@@ -818,11 +820,12 @@ rtp_source_get_bye_reason (RTPSource * src)
  * Parse @caps and store all relevant information in @source.
  */
 void
-rtp_source_update_caps (RTPSource * src, GstCaps * caps)
+rtp_source_update_send_caps (RTPSource * src, GstCaps * caps)
 {
   GstStructure *s;
   guint val;
   gint ival;
+  guint ssrc, rtx_ssrc = -1;
   gboolean rtx;
 
   /* nothing changed, return */
@@ -831,7 +834,17 @@ rtp_source_update_caps (RTPSource * src, GstCaps * caps)
 
   s = gst_caps_get_structure (caps, 0);
 
-  rtx = (gst_structure_get_uint (s, "rtx-ssrc", &val) && val == src->ssrc);
+  if (!gst_structure_get_uint (s, "ssrc", &ssrc))
+    return;
+  gst_structure_get_uint (s, "rtx-ssrc", &rtx_ssrc);
+
+  if (src->ssrc != ssrc && src->ssrc != rtx_ssrc) {
+    GST_WARNING ("got ssrc %u/%u that doesn't match with this source's ssrc %u",
+        ssrc, rtx_ssrc, src->ssrc);
+    return;
+  }
+
+  rtx = (rtx_ssrc == src->ssrc);
 
   if (gst_structure_get_int (s, rtx ? "rtx-payload" : "payload", &ival))
     src->payload = ival;
@@ -857,6 +870,12 @@ rtp_source_update_caps (RTPSource * src, GstCaps * caps)
       src->seqnum_offset);
 
   gst_caps_replace (&src->caps, caps);
+
+  if (rtx) {
+    src->media_ssrc = ssrc;
+  } else {
+    src->media_ssrc = -1;
+  }
 }
 
 /**
@@ -921,7 +940,7 @@ push_packet (RTPSource * src, GstBuffer * buffer)
 }
 
 static void
-fetch_clock_rate_from_payload (RTPSource * src, guint8 payload)
+fetch_caps_for_payload (RTPSource * src, guint8 payload)
 {
   if (src->payload == -1) {
     /* first payload received, nothing was in the caps, lock on to this payload */
@@ -935,16 +954,40 @@ fetch_clock_rate_from_payload (RTPSource * src, guint8 payload)
     src->stats.transit = -1;
   }
 
-  if (src->clock_rate == -1) {
-    gint clock_rate = -1;
+  if (src->clock_rate == -1 || !src->caps) {
+    GstCaps *caps = NULL;
+
+    if (src->callbacks.caps) {
+      caps = src->callbacks.caps (src, payload, src->user_data);
+    }
 
-    if (src->callbacks.clock_rate)
-      clock_rate = src->callbacks.clock_rate (src, payload, src->user_data);
+    GST_DEBUG ("got caps %" GST_PTR_FORMAT, caps);
 
-    GST_DEBUG ("got clock-rate %d", clock_rate);
+    if (caps) {
+      const GstStructure *s;
+      gint clock_rate = -1;
+      const gchar *encoding_name;
 
-    src->clock_rate = clock_rate;
-    gst_rtp_packet_rate_ctx_reset (&src->packet_rate_ctx, clock_rate);
+      s = gst_caps_get_structure (caps, 0);
+
+      if (gst_structure_get_int (s, "clock-rate", &clock_rate)) {
+        src->clock_rate = clock_rate;
+        gst_rtp_packet_rate_ctx_reset (&src->packet_rate_ctx, clock_rate);
+      } else {
+        GST_DEBUG ("No clock-rate in caps!");
+      }
+
+      encoding_name = gst_structure_get_string (s, "encoding-name");
+      /* Disable probation for RTX sources as packets will arrive very
+       * irregularly and waiting for a second packet usually exceeds the
+       * deadline of the retransmission */
+      if (g_strcmp0 (encoding_name, "rtx") == 0) {
+        src->probation = src->curr_probation = 0;
+      }
+    }
+
+    gst_caps_replace (&src->caps, caps);
+    gst_clear_caps (&caps);
   }
 }
 
@@ -1208,6 +1251,28 @@ update_receiver_stats (RTPSource * src, RTPPacketInfo * pinfo,
       GST_INFO ("duplicate or reordered packet (seqnr %u, expected %u)",
           seqnr, expected);
     }
+  } else {
+    /* Sender stats - update the outbound sequence number */
+    expected = src->stats.max_seq + 1;
+    delta = gst_rtp_buffer_compare_seqnum (expected, seqnr);
+    /* No probation for local senders, just check for lost / dropouts */
+    if (delta >= 0 && delta < max_dropout) {
+      stats->bad_seq = RTP_SEQ_MOD + 1; /* so seq == bad_seq is false */
+      /* in order, with permissible gap */
+      if (seqnr < stats->max_seq) {
+        /* sequence number wrapped - count another 64K cycle. */
+        stats->cycles += RTP_SEQ_MOD;
+      }
+      stats->max_seq = seqnr;
+    } else if (delta < -max_misorder || delta >= max_dropout) {
+      /* the sequence number made a very large jump */
+      if (seqnr != stats->bad_seq) {
+        /* unacceptable jump */
+        stats->bad_seq = (seqnr + 1) & (RTP_SEQ_MOD - 1);
+      }
+    } else {                    /* delta < 0 && delta >= -max_misorder */
+      stats->bad_seq = RTP_SEQ_MOD + 1; /* so seq == bad_seq is false */
+    }
   }
 
   src->stats.octets_received += pinfo->payload_len;
@@ -1261,7 +1326,7 @@ rtp_source_process_rtp (RTPSource * src, RTPPacketInfo * pinfo)
   g_return_val_if_fail (RTP_IS_SOURCE (src), GST_FLOW_ERROR);
   g_return_val_if_fail (pinfo != NULL, GST_FLOW_ERROR);
 
-  fetch_clock_rate_from_payload (src, pinfo->pt);
+  fetch_caps_for_payload (src, pinfo->pt);
 
   if (!update_receiver_stats (src, pinfo, TRUE))
     return GST_FLOW_OK;
@@ -1445,6 +1510,7 @@ rtp_source_process_sr (RTPSource * src, GstClockTime time, guint64 ntptime,
 /**
  * rtp_source_process_rb:
  * @src: an #RTPSource
+ * @ssrc: SSRC of the local source for this this RB was sent
  * @ntpnstime: the current time in nanoseconds since 1970
  * @fractionlost: fraction lost since last SR/RR
  * @packetslost: the cumulative number of packets lost
@@ -1458,7 +1524,7 @@ rtp_source_process_sr (RTPSource * src, GstClockTime time, guint64 ntptime,
  * Update the report block in @src.
  */
 void
-rtp_source_process_rb (RTPSource * src, guint64 ntpnstime,
+rtp_source_process_rb (RTPSource * src, guint32 ssrc, guint64 ntpnstime,
     guint8 fractionlost, gint32 packetslost, guint32 exthighestseq,
     guint32 jitter, guint32 lsr, guint32 dlsr)
 {
@@ -1479,6 +1545,7 @@ rtp_source_process_rb (RTPSource * src, guint64 ntpnstime,
 
   /* update current */
   curr->is_valid = TRUE;
+  curr->ssrc = ssrc;
   curr->fractionlost = fractionlost;
   curr->packetslost = packetslost;
   curr->exthighestseq = exthighestseq;
@@ -1551,7 +1618,7 @@ rtp_source_get_new_sr (RTPSource * src, guint64 ntpnstime,
   if (src->clock_rate == -1 && src->pt_set) {
     GST_INFO ("no clock-rate, getting for pt %u and SSRC %u", src->pt,
         src->ssrc);
-    fetch_clock_rate_from_payload (src, src->pt);
+    fetch_caps_for_payload (src, src->pt);
   }
 
   if (src->clock_rate != -1) {
@@ -1732,6 +1799,7 @@ rtp_source_get_last_sr (RTPSource * src, GstClockTime * time, guint64 * ntptime,
 /**
  * rtp_source_get_last_rb:
  * @src: an #RTPSource
+ * @ssrc: SSRC of the local source for this this RB was sent
  * @fractionlost: fraction lost since last SR/RR
  * @packetslost: the cumulative number of packets lost
  * @exthighestseq: the extended last sequence number received
@@ -1748,9 +1816,9 @@ rtp_source_get_last_sr (RTPSource * src, GstClockTime * time, guint64 * ntptime,
  * Returns: %TRUE if there was a valid SB report.
  */
 gboolean
-rtp_source_get_last_rb (RTPSource * src, guint8 * fractionlost,
-    gint32 * packetslost, guint32 * exthighestseq, guint32 * jitter,
-    guint32 * lsr, guint32 * dlsr, guint32 * round_trip)
+rtp_source_get_last_rb (RTPSource * src, guint32 * ssrc,
+    guint8 * fractionlost, gint32 * packetslost, guint32 * exthighestseq,
+    guint32 * jitter, guint32 * lsr, guint32 * dlsr, guint32 * round_trip)
 {
   RTPReceiverReport *curr;
 
@@ -1760,6 +1828,8 @@ rtp_source_get_last_rb (RTPSource * src, guint8 * fractionlost,
   if (!curr->is_valid)
     return FALSE;
 
+  if (ssrc)
+    *ssrc = curr->ssrc;
   if (fractionlost)
     *fractionlost = curr->fractionlost;
   if (packetslost)
@@ -1824,7 +1894,7 @@ timeout_conflicting_addresses (GList * conflicting_addresses,
     RTPConflictingAddress *known_conflict = item->data;
     GList *next_item = g_list_next (item);
 
-    if (known_conflict->time < current_time - collision_timeout) {
+    if (known_conflict->time + collision_timeout < current_time) {
       gchar *buf;
 
       conflicting_addresses = g_list_delete_link (conflicting_addresses, item);
@@ -2026,7 +2096,7 @@ rtp_source_get_nacks (RTPSource * src, guint * n_nacks)
 }
 
 /**
- * rtp_source_get_nacks:
+ * rtp_source_get_nack_deadlines:
  * @src: The #RTPSource
  * @n_nacks: result number of nacks
  *
diff --git a/gst/rtpmanager/rtpsource.h b/gst/rtpmanager/rtpsource.h
index dff7b313f..f099e4b79 100644
--- a/gst/rtpmanager/rtpsource.h
+++ b/gst/rtpmanager/rtpsource.h
@@ -86,29 +86,29 @@ typedef GstFlowReturn (*RTPSourcePushRTP) (RTPSource *src, gpointer data,
 	gpointer user_data);
 
 /**
- * RTPSourceClockRate:
+ * RTPSourceCaps:
  * @src: an #RTPSource
  * @payload: a payload type
  * @user_data: user data specified when registering
  *
- * This callback will be called when @src needs the clock-rate of the
+ * This callback will be called when @src needs the caps of the
  * @payload.
  *
- * Returns: a clock-rate for @payload.
+ * Returns: a caps for @payload.
  */
-typedef gint (*RTPSourceClockRate) (RTPSource *src, guint8 payload, gpointer user_data);
+typedef GstCaps * (*RTPSourceCaps) (RTPSource *src, guint8 payload, gpointer user_data);
 
 /**
  * RTPSourceCallbacks:
  * @push_rtp: a packet becomes available for handling
- * @clock_rate: a clock-rate is requested
+ * @caps: a caps is requested
  * @get_time: the current clock time is requested
  *
  * Callbacks performed by #RTPSource when actions need to be performed.
  */
 typedef struct {
   RTPSourcePushRTP     push_rtp;
-  RTPSourceClockRate   clock_rate;
+  RTPSourceCaps        caps;
 } RTPSourceCallbacks;
 
 /**
@@ -137,6 +137,9 @@ struct _RTPSource {
   /*< private >*/
   guint32       ssrc;
 
+  /* If not -1 then this is the SSRC of the corresponding media RTPSource */
+  guint32       media_ssrc;
+
   guint16       generation;
   GHashTable    *reported_in_sr_of;     /* set of SSRCs */
 
@@ -230,7 +233,7 @@ void            rtp_source_mark_bye            (RTPSource *src, const gchar *rea
 gboolean        rtp_source_is_marked_bye       (RTPSource *src);
 gchar *         rtp_source_get_bye_reason      (RTPSource *src);
 
-void            rtp_source_update_caps         (RTPSource *src, GstCaps *caps);
+void            rtp_source_update_send_caps    (RTPSource *src, GstCaps *caps);
 
 /* SDES info */
 const GstStructure *
@@ -249,7 +252,7 @@ GstFlowReturn   rtp_source_send_rtp            (RTPSource *src, RTPPacketInfo *p
 /* RTCP messages */
 void            rtp_source_process_sr          (RTPSource *src, GstClockTime time, guint64 ntptime,
                                                 guint32 rtptime, guint32 packet_count, guint32 octet_count);
-void            rtp_source_process_rb          (RTPSource *src, guint64 ntpnstime, guint8 fractionlost,
+void            rtp_source_process_rb          (RTPSource *src, guint32 ssrc, guint64 ntpnstime, guint8 fractionlost,
                                                 gint32 packetslost, guint32 exthighestseq, guint32 jitter,
                                                 guint32 lsr, guint32 dlsr);
 
@@ -263,7 +266,7 @@ gboolean        rtp_source_get_new_rb          (RTPSource *src, GstClockTime tim
 gboolean        rtp_source_get_last_sr         (RTPSource *src, GstClockTime *time, guint64 *ntptime,
                                                 guint32 *rtptime, guint32 *packet_count,
 						guint32 *octet_count);
-gboolean        rtp_source_get_last_rb         (RTPSource *src, guint8 *fractionlost, gint32 *packetslost,
+gboolean        rtp_source_get_last_rb         (RTPSource *src, guint32 * ssrc, guint8 *fractionlost, gint32 *packetslost,
                                                 guint32 *exthighestseq, guint32 *jitter,
                                                 guint32 *lsr, guint32 *dlsr, guint32 *round_trip);
 
diff --git a/gst/rtpmanager/rtpstats.c b/gst/rtpmanager/rtpstats.c
index 45fff3705..0f35046f1 100644
--- a/gst/rtpmanager/rtpstats.c
+++ b/gst/rtpmanager/rtpstats.c
@@ -484,6 +484,7 @@ rtp_twcc_stats_get_packets_structure (GArray * twcc_packets)
         "seqnum", G_TYPE_UINT, pkt->seqnum,
         "local-ts", G_TYPE_UINT64, pkt->local_ts,
         "remote-ts", G_TYPE_UINT64, pkt->remote_ts,
+        "payload-type", G_TYPE_UCHAR, pkt->pt,
         "size", G_TYPE_UINT, pkt->size,
         "lost", G_TYPE_BOOLEAN, pkt->status == RTP_TWCC_PACKET_STATUS_NOT_RECV,
         NULL);
diff --git a/gst/rtpmanager/rtpstats.h b/gst/rtpmanager/rtpstats.h
index 776651f44..45ad377ee 100644
--- a/gst/rtpmanager/rtpstats.h
+++ b/gst/rtpmanager/rtpstats.h
@@ -51,7 +51,7 @@ typedef struct {
  */
 typedef struct {
   gboolean is_valid;
-  guint32 ssrc; /* who the report is from */
+  guint32 ssrc; /* which source is the report about */
   guint8  fractionlost;
   guint32 packetslost;
   guint32 exthighestseq;
@@ -70,6 +70,7 @@ typedef struct {
  * @address: address of the sender of the packet
  * @current_time: current time according to the system clock
  * @running_time: time of a packet as buffer running_time
+ * @arrival_time: time of arrival of a packet
  * @ntpnstime: time of a packet NTP time in nanoseconds
  * @header_len: number of overhead bytes per packet
  * @bytes: bytes of the packet including lowlevel overhead
@@ -78,9 +79,13 @@ typedef struct {
  * @pt: the payload type of the packet
  * @rtptime: the RTP time of the packet
  * @marker: the marker bit
- *
- * @tw_seqnum_ext_id: the extension-header ID for transport-wide seqnums
- * @tw_seqnum: the transport-wide seqnum of the packet
+ * @csrc_count: Number of CSRCs in @csrcs
+ * @csrcs: CSRCs
+ * @header_ext: Header extension data
+ * @header_ext_bit_pattern: Header extension bit pattern
+ * @ntp64_ext_id: Extension header ID for RFC6051 64-bit NTP timestamp.
+ * @have_ntp64_ext: If there is at least one 64-bit NTP timestamp header
+ *     extension.
  *
  * Structure holding information about the packet.
  */
@@ -92,6 +97,7 @@ typedef struct {
   GSocketAddress *address;
   GstClockTime  current_time;
   GstClockTime  running_time;
+  GstClockTime  arrival_time;
   guint64       ntpnstime;
   guint         header_len;
   guint         bytes;
@@ -106,6 +112,8 @@ typedef struct {
   guint32       csrcs[16];
   GBytes        *header_ext;
   guint16       header_ext_bit_pattern;
+  guint8        ntp64_ext_id;
+  gboolean      have_ntp64_ext;
 } RTPPacketInfo;
 
 /**
diff --git a/gst/rtpmanager/rtptimerqueue.c b/gst/rtpmanager/rtptimerqueue.c
index 446a70ea5..6cee0266e 100644
--- a/gst/rtpmanager/rtptimerqueue.c
+++ b/gst/rtpmanager/rtptimerqueue.c
@@ -304,6 +304,8 @@ rtp_timer_queue_finalize (GObject * object)
     rtp_timer_free (timer);
   g_hash_table_unref (queue->hashtable);
   g_assert (queue->timers.length == 0);
+
+  G_OBJECT_CLASS (rtp_timer_queue_parent_class)->finalize (object);
 }
 
 static void
@@ -582,8 +584,6 @@ rtp_timer_queue_set_timer (RtpTimerQueue * queue, RtpTimerType type,
   if (!timer->queued || timer->seqnum != seqnum) {
     if (type == RTP_TIMER_EXPECTED) {
       timer->rtx_base = timeout;
-      timer->rtx_delay = delay;
-      timer->rtx_retry = 0;
     }
 
     timer->rtx_last = GST_CLOCK_TIME_NONE;
@@ -702,11 +702,9 @@ rtp_timer_queue_update_timer (RtpTimerQueue * queue, RtpTimer * timer,
   g_return_if_fail (timer != NULL);
 
   if (reset) {
-    GST_DEBUG ("reset rtx delay %" GST_TIME_FORMAT "->%" GST_TIME_FORMAT,
-        GST_TIME_ARGS (timer->rtx_delay), GST_TIME_ARGS (delay));
+    GST_DEBUG ("reset rtx base %" GST_TIME_FORMAT "->%" GST_TIME_FORMAT,
+        GST_TIME_ARGS (timer->rtx_base), GST_TIME_ARGS (timeout));
     timer->rtx_base = timeout;
-    timer->rtx_delay = delay;
-    timer->rtx_retry = 0;
   }
 
   if (timer->seqnum != seqnum) {
diff --git a/gst/rtpmanager/rtptimerqueue.h b/gst/rtpmanager/rtptimerqueue.h
index 969cbd37f..283f22879 100644
--- a/gst/rtpmanager/rtptimerqueue.h
+++ b/gst/rtpmanager/rtptimerqueue.h
@@ -65,8 +65,6 @@ typedef struct
   GstClockTimeDiff offset;
   GstClockTime duration;
   GstClockTime rtx_base;
-  GstClockTime rtx_delay;
-  GstClockTime rtx_retry;
   GstClockTime rtx_last;
   guint num_rtx_retry;
   guint num_rtx_received;
diff --git a/gst/rtpmanager/rtptwcc.c b/gst/rtpmanager/rtptwcc.c
index f5b5351bf..ba8b5a854 100644
--- a/gst/rtpmanager/rtptwcc.c
+++ b/gst/rtpmanager/rtptwcc.c
@@ -22,13 +22,20 @@
 #include <gst/base/gstbitreader.h>
 #include <gst/base/gstbitwriter.h>
 
+#include "gstrtputils.h"
+
 GST_DEBUG_CATEGORY_EXTERN (rtp_session_debug);
 #define GST_CAT_DEFAULT rtp_session_debug
 
+#define TWCC_EXTMAP_STR "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"
+
 #define REF_TIME_UNIT (64 * GST_MSECOND)
 #define DELTA_UNIT (250 * GST_USECOND)
 #define MAX_TS_DELTA (0xff * DELTA_UNIT)
 
+#define STATUS_VECTOR_MAX_CAPACITY 14
+#define STATUS_VECTOR_TWO_BIT_MAX_CAPACITY 7
+
 typedef enum
 {
   RTP_TWCC_CHUNK_TYPE_RUN_LENGTH = 0,
@@ -60,6 +67,7 @@ typedef struct
   GstClockTime socket_ts;
   GstClockTime remote_ts;
   guint16 seqnum;
+  guint8 pt;
   guint size;
   gboolean lost;
 } SentPacket;
@@ -68,11 +76,15 @@ struct _RTPTWCCManager
 {
   GObject object;
 
+  guint8 send_ext_id;
+  guint8 recv_ext_id;
+  guint16 send_seqnum;
+
   guint mtu;
   guint max_packets_per_rtcp;
   GArray *recv_packets;
 
-  guint8 fb_pkt_count;
+  guint64 fb_pkt_count;
   gint32 last_seqnum;
 
   GArray *sent_packets;
@@ -83,10 +95,14 @@ struct _RTPTWCCManager
   guint64 recv_media_ssrc;
 
   guint16 expected_recv_seqnum;
+  guint16 packet_count_no_marker;
 
   gboolean first_fci_parse;
   guint16 expected_parsed_seqnum;
   guint8 expected_parsed_fb_pkt_count;
+
+  GstClockTime next_feedback_send_time;
+  GstClockTime feedback_interval;
 };
 
 G_DEFINE_TYPE (RTPTWCCManager, rtp_twcc_manager, G_TYPE_OBJECT);
@@ -105,6 +121,9 @@ rtp_twcc_manager_init (RTPTWCCManager * twcc)
   twcc->recv_sender_ssrc = -1;
 
   twcc->first_fci_parse = TRUE;
+
+  twcc->feedback_interval = GST_CLOCK_TIME_NONE;
+  twcc->next_feedback_send_time = GST_CLOCK_TIME_NONE;
 }
 
 static void
@@ -142,7 +161,35 @@ recv_packet_init (RecvPacket * packet, guint16 seqnum, RTPPacketInfo * pinfo)
 {
   memset (packet, 0, sizeof (RecvPacket));
   packet->seqnum = seqnum;
-  packet->ts = pinfo->running_time;
+
+  if (GST_CLOCK_TIME_IS_VALID (pinfo->arrival_time))
+    packet->ts = pinfo->arrival_time;
+  else
+    packet->ts = pinfo->current_time;
+}
+
+void
+rtp_twcc_manager_parse_recv_ext_id (RTPTWCCManager * twcc,
+    const GstStructure * s)
+{
+  guint8 recv_ext_id = gst_rtp_get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
+  if (recv_ext_id > 0) {
+    twcc->recv_ext_id = recv_ext_id;
+    GST_INFO ("TWCC enabled for recv using extension id: %u",
+        twcc->recv_ext_id);
+  }
+}
+
+void
+rtp_twcc_manager_parse_send_ext_id (RTPTWCCManager * twcc,
+    const GstStructure * s)
+{
+  guint8 send_ext_id = gst_rtp_get_extmap_id_for_attribute (s, TWCC_EXTMAP_STR);
+  if (send_ext_id > 0) {
+    twcc->send_ext_id = send_ext_id;
+    GST_INFO ("TWCC enabled for send using extension id: %u",
+        twcc->send_ext_id);
+  }
 }
 
 void
@@ -157,6 +204,114 @@ rtp_twcc_manager_set_mtu (RTPTWCCManager * twcc, guint mtu)
   twcc->max_packets_per_rtcp = ((twcc->mtu - 32) * 7) / (2 + 14);
 }
 
+void
+rtp_twcc_manager_set_feedback_interval (RTPTWCCManager * twcc,
+    GstClockTime feedback_interval)
+{
+  twcc->feedback_interval = feedback_interval;
+}
+
+GstClockTime
+rtp_twcc_manager_get_feedback_interval (RTPTWCCManager * twcc)
+{
+  return twcc->feedback_interval;
+}
+
+static gboolean
+_get_twcc_seqnum_data (RTPPacketInfo * pinfo, guint8 ext_id, gpointer * data)
+{
+  gboolean ret = FALSE;
+  guint size;
+
+  if (pinfo->header_ext &&
+      gst_rtp_buffer_get_extension_onebyte_header_from_bytes (pinfo->header_ext,
+          pinfo->header_ext_bit_pattern, ext_id, 0, data, &size)) {
+    if (size == 2)
+      ret = TRUE;
+  }
+  return ret;
+}
+
+static void
+sent_packet_init (SentPacket * packet, guint16 seqnum, RTPPacketInfo * pinfo,
+    GstRTPBuffer * rtp)
+{
+  packet->seqnum = seqnum;
+  packet->ts = pinfo->current_time;
+  packet->size = gst_rtp_buffer_get_payload_len (rtp);
+  packet->pt = gst_rtp_buffer_get_payload_type (rtp);
+  packet->remote_ts = GST_CLOCK_TIME_NONE;
+  packet->socket_ts = GST_CLOCK_TIME_NONE;
+  packet->lost = FALSE;
+}
+
+static void
+_set_twcc_seqnum_data (RTPTWCCManager * twcc, RTPPacketInfo * pinfo,
+    GstBuffer * buf, guint8 ext_id)
+{
+  SentPacket packet;
+  GstRTPBuffer rtp = GST_RTP_BUFFER_INIT;
+  gpointer data;
+
+  if (gst_rtp_buffer_map (buf, GST_MAP_READWRITE, &rtp)) {
+    if (gst_rtp_buffer_get_extension_onebyte_header (&rtp,
+            ext_id, 0, &data, NULL)) {
+      guint16 seqnum = twcc->send_seqnum++;
+
+      GST_WRITE_UINT16_BE (data, seqnum);
+      sent_packet_init (&packet, seqnum, pinfo, &rtp);
+      g_array_append_val (twcc->sent_packets, packet);
+
+      GST_LOG ("Send: twcc-seqnum: %u, pt: %u, marker: %d, len: %u, ts: %"
+          GST_TIME_FORMAT, seqnum, packet.pt, pinfo->marker, packet.size,
+          GST_TIME_ARGS (pinfo->current_time));
+    }
+    gst_rtp_buffer_unmap (&rtp);
+  }
+}
+
+static void
+rtp_twcc_manager_set_send_twcc_seqnum (RTPTWCCManager * twcc,
+    RTPPacketInfo * pinfo)
+{
+  if (GST_IS_BUFFER_LIST (pinfo->data)) {
+    GstBufferList *list;
+    guint i = 0;
+
+    pinfo->data = gst_buffer_list_make_writable (pinfo->data);
+
+    list = GST_BUFFER_LIST (pinfo->data);
+
+    for (i = 0; i < gst_buffer_list_length (list); i++) {
+      GstBuffer *buffer = gst_buffer_list_get_writable (list, i);
+
+      _set_twcc_seqnum_data (twcc, pinfo, buffer, twcc->send_ext_id);
+    }
+  } else {
+    pinfo->data = gst_buffer_make_writable (pinfo->data);
+    _set_twcc_seqnum_data (twcc, pinfo, pinfo->data, twcc->send_ext_id);
+  }
+}
+
+static gint32
+rtp_twcc_manager_get_recv_twcc_seqnum (RTPTWCCManager * twcc,
+    RTPPacketInfo * pinfo)
+{
+  gint32 val = -1;
+  gpointer data;
+
+  if (twcc->recv_ext_id == 0) {
+    GST_DEBUG ("Received TWCC packet, but no extension registered; ignoring");
+    return val;
+  }
+
+  if (_get_twcc_seqnum_data (pinfo, twcc->recv_ext_id, &data)) {
+    val = GST_READ_UINT16_BE (data);
+  }
+
+  return val;
+}
+
 static gint
 _twcc_seqnum_sort (gconstpointer a, gconstpointer b)
 {
@@ -197,7 +352,7 @@ rtp_twcc_write_run_length_chunk (GArray * packet_chunks,
     guint16 data = 0;
     guint len = MIN (run_length - written, 8191);
 
-    GST_LOG ("Writing a run-lenght of %u with status %u", len, status);
+    GST_LOG ("Writing a run-length of %u with status %u", len, status);
 
     gst_bit_writer_init_with_data (&writer, (guint8 *) & data, 2, FALSE);
     gst_bit_writer_put_bits_uint8 (&writer, RTP_TWCC_CHUNK_TYPE_RUN_LENGTH, 1);
@@ -257,7 +412,7 @@ chunk_bit_writer_get_available_slots (ChunkBitWriter * writer)
 static guint
 chunk_bit_writer_get_total_slots (ChunkBitWriter * writer)
 {
-  return 14 / writer->symbol_size;
+  return STATUS_VECTOR_MAX_CAPACITY / writer->symbol_size;
 }
 
 static void
@@ -340,13 +495,43 @@ run_lenght_helper_update (RunLengthHelper * rlh, RecvPacket * pkt)
   }
 }
 
+static guint
+_get_max_packets_capacity (guint symbol_size)
+{
+  if (symbol_size == 2)
+    return STATUS_VECTOR_TWO_BIT_MAX_CAPACITY;
+
+  return STATUS_VECTOR_MAX_CAPACITY;
+}
+
+static gboolean
+_pkt_fits_run_length_chunk (RecvPacket * pkt, guint packets_per_chunks,
+    guint remaining_packets)
+{
+  if (pkt->missing_run == 0) {
+    /* we have more or the same equal packets than the ones we can write in to a status chunk */
+    if (pkt->equal_run >= packets_per_chunks)
+      return TRUE;
+
+    /* we have more than one equal and not enough space for the remainings */
+    if (pkt->equal_run > 1 && remaining_packets > STATUS_VECTOR_MAX_CAPACITY)
+      return TRUE;
+
+    /* we have all equal packets for the remaining to write */
+    if (pkt->equal_run == remaining_packets)
+      return TRUE;
+  }
+
+  return FALSE;
+}
+
 static void
 rtp_twcc_write_chunks (GArray * packet_chunks,
     GArray * twcc_packets, guint symbol_size)
 {
   ChunkBitWriter writer;
   guint i;
-  guint bits_per_chunks = 7 * symbol_size;
+  guint packets_per_chunks = _get_max_packets_capacity (symbol_size);
 
   chunk_bit_writer_init (&writer, packet_chunks, symbol_size);
 
@@ -354,21 +539,26 @@ rtp_twcc_write_chunks (GArray * packet_chunks,
     RecvPacket *pkt = &g_array_index (twcc_packets, RecvPacket, i);
     guint remaining_packets = twcc_packets->len - i;
 
+    GST_LOG
+        ("About to write pkt: #%u missing_run: %u equal_run: %u status: %u, remaining_packets: %u",
+        pkt->seqnum, pkt->missing_run, pkt->equal_run, pkt->status,
+        remaining_packets);
+
     /* we can only start a run-length chunk if the status-chunk is
        completed */
     if (chunk_bit_writer_is_empty (&writer)) {
       /* first write in any preceeding gaps, we use run-length
          if it would take up more than one chunk (14/7) */
-      if (pkt->missing_run > bits_per_chunks) {
+      if (pkt->missing_run > packets_per_chunks) {
         rtp_twcc_write_run_length_chunk (packet_chunks,
             RTP_TWCC_PACKET_STATUS_NOT_RECV, pkt->missing_run);
       }
 
       /* we have a run of the same status, write a run-length chunk and skip
          to the next point */
-      if (pkt->missing_run == 0 &&
-          (pkt->equal_run > bits_per_chunks ||
-              pkt->equal_run == remaining_packets)) {
+      if (_pkt_fits_run_length_chunk (pkt, packets_per_chunks,
+              remaining_packets)) {
+
         rtp_twcc_write_run_length_chunk (packet_chunks,
             pkt->status, pkt->equal_run);
         i += pkt->equal_run - 1;
@@ -404,6 +594,7 @@ rtp_twcc_manager_add_fci (RTPTWCCManager * twcc, GstRTCPPacket * packet)
   guint symbol_size = 1;
   GstClockTimeDiff delta_ts;
   gint64 delta_ts_rounded;
+  guint8 fb_pkt_count;
 
   g_array_sort (twcc->recv_packets, _twcc_seqnum_sort);
 
@@ -415,19 +606,19 @@ rtp_twcc_manager_add_fci (RTPTWCCManager * twcc, GstRTCPPacket * packet)
 
   packet_count = last->seqnum - first->seqnum + 1;
   base_time = first->ts / REF_TIME_UNIT;
+  fb_pkt_count = (guint8) (twcc->fb_pkt_count % G_MAXUINT8);
 
   GST_WRITE_UINT16_BE (header.base_seqnum, first->seqnum);
   GST_WRITE_UINT16_BE (header.packet_count, packet_count);
   GST_WRITE_UINT24_BE (header.base_time, base_time);
-  GST_WRITE_UINT8 (header.fb_pkt_count, twcc->fb_pkt_count);
+  GST_WRITE_UINT8 (header.fb_pkt_count, fb_pkt_count);
 
   base_time *= REF_TIME_UNIT;
   ts_rounded = base_time;
 
   GST_DEBUG ("Created TWCC feedback: base_seqnum: #%u, packet_count: %u, "
       "base_time %" GST_TIME_FORMAT " fb_pkt_count: %u",
-      first->seqnum, packet_count, GST_TIME_ARGS (base_time),
-      twcc->fb_pkt_count);
+      first->seqnum, packet_count, GST_TIME_ARGS (base_time), fb_pkt_count);
 
   twcc->fb_pkt_count++;
   twcc->expected_recv_seqnum = first->seqnum + packet_count;
@@ -527,24 +718,7 @@ rtp_twcc_manager_create_feedback (RTPTWCCManager * twcc)
 static gboolean
 _exceeds_max_packets (RTPTWCCManager * twcc, guint16 seqnum)
 {
-  RecvPacket *first, *last;
-  guint16 packet_count;
-
-  if (twcc->recv_packets->len == 0)
-    return FALSE;
-
-  /* find the delta betwen first stored packet and this seqnum */
-  first = &g_array_index (twcc->recv_packets, RecvPacket, 0);
-  packet_count = seqnum - first->seqnum + 1;
-  if (packet_count > twcc->max_packets_per_rtcp)
-    return TRUE;
-
-  /* then find the delta between last stored packet and this seqnum */
-  last =
-      &g_array_index (twcc->recv_packets, RecvPacket,
-      twcc->recv_packets->len - 1);
-  packet_count = seqnum - (last->seqnum + 1);
-  if (packet_count > twcc->max_packets_per_rtcp)
+  if (twcc->recv_packets->len + 1 > twcc->max_packets_per_rtcp)
     return TRUE;
 
   return FALSE;
@@ -559,25 +733,36 @@ _many_packets_some_lost (RTPTWCCManager * twcc, guint16 seqnum)
   RecvPacket *first;
   guint16 packet_count;
   guint received_packets = twcc->recv_packets->len;
+  guint lost_packets;
   if (received_packets == 0)
     return FALSE;
 
   first = &g_array_index (twcc->recv_packets, RecvPacket, 0);
   packet_count = seqnum - first->seqnum + 1;
-  /* packet-count larger than recevied-packets means we have lost packets */
-  if (packet_count >= 30 && packet_count > received_packets)
+
+  /* check if we lost half of the threshold */
+  lost_packets = packet_count - received_packets;
+  if (received_packets >= 30 && lost_packets >= 60)
+    return TRUE;
+
+  /* we have lost the marker bit for some and lost some */
+  if (twcc->packet_count_no_marker >= 10 && lost_packets >= 60)
     return TRUE;
 
   return FALSE;
 }
 
 gboolean
-rtp_twcc_manager_recv_packet (RTPTWCCManager * twcc,
-    guint16 seqnum, RTPPacketInfo * pinfo)
+rtp_twcc_manager_recv_packet (RTPTWCCManager * twcc, RTPPacketInfo * pinfo)
 {
   gboolean send_feedback = FALSE;
   RecvPacket packet;
-  gint32 diff;
+  gint32 seqnum;
+  gint diff;
+
+  seqnum = rtp_twcc_manager_get_recv_twcc_seqnum (twcc, pinfo);
+  if (seqnum == -1)
+    return FALSE;
 
   /* if this packet would exceed the capacity of our MTU, we create a feedback
      with the current packets, and start over with this one */
@@ -595,23 +780,54 @@ rtp_twcc_manager_recv_packet (RTPTWCCManager * twcc,
   /* check if we are reordered, and treat it as lost if we already sent
      a feedback msg with a higher seqnum. If the diff is huge, treat
      it as a restart of a stream */
-  diff = (gint32) seqnum - (gint32) twcc->expected_recv_seqnum;
-  if (twcc->fb_pkt_count > 0 && diff < 0 && diff > -1000) {
+  diff = gst_rtp_buffer_compare_seqnum (twcc->expected_recv_seqnum, seqnum);
+  if (twcc->fb_pkt_count > 0 && diff < 0) {
     GST_INFO ("Received out of order packet (%u after %u), treating as lost",
         seqnum, twcc->expected_recv_seqnum);
     return FALSE;
   }
 
+  if (twcc->recv_packets->len > 0) {
+    RecvPacket *last = &g_array_index (twcc->recv_packets, RecvPacket,
+        twcc->recv_packets->len - 1);
+
+    diff = gst_rtp_buffer_compare_seqnum (last->seqnum, seqnum);
+    if (diff == 0) {
+      GST_INFO ("Received duplicate packet (%u), dropping", seqnum);
+      return FALSE;
+    }
+  }
+
   /* store the packet for Transport-wide RTCP feedback message */
   recv_packet_init (&packet, seqnum, pinfo);
   g_array_append_val (twcc->recv_packets, packet);
   twcc->last_seqnum = seqnum;
-  GST_LOG ("Receive: twcc-seqnum: %u, marker: %d, ts: %" GST_TIME_FORMAT,
-      seqnum, pinfo->marker, GST_TIME_ARGS (pinfo->running_time));
 
-  if (pinfo->marker || _many_packets_some_lost (twcc, seqnum)) {
+  GST_LOG ("Receive: twcc-seqnum: %u, pt: %u, marker: %d, ts: %"
+      GST_TIME_FORMAT, seqnum, pinfo->pt, pinfo->marker,
+      GST_TIME_ARGS (pinfo->arrival_time));
+
+  if (!pinfo->marker)
+    twcc->packet_count_no_marker++;
+
+  /* are we sending on an interval, or based on marker bit */
+  if (GST_CLOCK_TIME_IS_VALID (twcc->feedback_interval)) {
+    if (!GST_CLOCK_TIME_IS_VALID (twcc->next_feedback_send_time))
+      twcc->next_feedback_send_time =
+          pinfo->running_time + twcc->feedback_interval;
+
+    if (pinfo->running_time >= twcc->next_feedback_send_time) {
+      rtp_twcc_manager_create_feedback (twcc);
+      send_feedback = TRUE;
+
+      while (pinfo->running_time >= twcc->next_feedback_send_time)
+        twcc->next_feedback_send_time += twcc->feedback_interval;
+    }
+  } else if (pinfo->marker || _many_packets_some_lost (twcc, seqnum)) {
     rtp_twcc_manager_create_feedback (twcc);
     send_feedback = TRUE;
+
+    twcc->packet_count_no_marker = 0;
   }
 
   return send_feedback;
@@ -642,39 +858,13 @@ rtp_twcc_manager_get_feedback (RTPTWCCManager * twcc, guint sender_ssrc)
   return buf;
 }
 
-static void
-sent_packet_init (SentPacket * packet, guint16 seqnum, RTPPacketInfo * pinfo)
-{
-  packet->seqnum = seqnum;
-  packet->ts = pinfo->running_time;
-  packet->size = pinfo->payload_len;
-  packet->remote_ts = GST_CLOCK_TIME_NONE;
-  packet->socket_ts = GST_CLOCK_TIME_NONE;
-  packet->lost = FALSE;
-}
-
 void
-rtp_twcc_manager_send_packet (RTPTWCCManager * twcc,
-    guint16 seqnum, RTPPacketInfo * pinfo)
+rtp_twcc_manager_send_packet (RTPTWCCManager * twcc, RTPPacketInfo * pinfo)
 {
-  SentPacket packet;
-  sent_packet_init (&packet, seqnum, pinfo);
-  g_array_append_val (twcc->sent_packets, packet);
-
-  GST_LOG ("Send: twcc-seqnum: %u, marker: %d, ts: %" GST_TIME_FORMAT,
-      seqnum, pinfo->marker, GST_TIME_ARGS (pinfo->running_time));
-}
+  if (twcc->send_ext_id == 0)
+    return;
 
-void
-rtp_twcc_manager_set_send_packet_ts (RTPTWCCManager * twcc,
-    guint packet_id, GstClockTime ts)
-{
-  SentPacket *pkt = NULL;
-  pkt = &g_array_index (twcc->sent_packets, SentPacket, packet_id);
-  if (pkt) {
-    pkt->socket_ts = ts;
-    GST_DEBUG ("assigning: pkt-id: %u to packet: %u", packet_id, pkt->seqnum);
-  }
+  rtp_twcc_manager_set_send_twcc_seqnum (twcc, pinfo);
 }
 
 static void
@@ -696,14 +886,14 @@ static guint
 _parse_run_length_chunk (GstBitReader * reader, GArray * twcc_packets,
     guint16 seqnum_offset, guint remaining_packets)
 {
-  guint run_length;
+  guint16 run_length;
   guint8 status_code;
   guint i;
 
   gst_bit_reader_get_bits_uint8 (reader, &status_code, 2);
+  gst_bit_reader_get_bits_uint16 (reader, &run_length, 13);
 
-  run_length = *(guint16 *) reader->data & ~0xE0;       /* mask out the 3 last bits */
-  run_length = MIN (remaining_packets, GST_READ_UINT16_BE (&run_length));
+  run_length = MIN (remaining_packets, run_length);
 
   for (i = 0; i < run_length; i++) {
     _add_twcc_packet (twcc_packets, seqnum_offset + i, status_code);
@@ -759,6 +949,7 @@ _check_for_lost_packets (RTPTWCCManager * twcc, GArray * twcc_packets,
     guint16 base_seqnum, guint16 packet_count, guint8 fb_pkt_count)
 {
   guint packets_lost;
+  gint8 fb_pkt_count_diff;
   guint i;
 
   /* first packet */
@@ -767,22 +958,31 @@ _check_for_lost_packets (RTPTWCCManager * twcc, GArray * twcc_packets,
     goto done;
   }
 
+  fb_pkt_count_diff =
+      (gint8) (fb_pkt_count - twcc->expected_parsed_fb_pkt_count);
+
   /* we have gone backwards, don't reset the expectations,
      but process the packet nonetheless */
-  if (fb_pkt_count < twcc->expected_parsed_fb_pkt_count) {
-    GST_WARNING ("feedback packet count going backwards (%u < %u)",
+  if (fb_pkt_count_diff < 0) {
+    GST_DEBUG ("feedback packet count going backwards (%u < %u)",
         fb_pkt_count, twcc->expected_parsed_fb_pkt_count);
     return;
   }
 
   /* we have jumped forwards, reset expectations, but don't trigger
      lost packets in case the missing fb-packet(s) arrive later */
-  if (fb_pkt_count > twcc->expected_parsed_fb_pkt_count) {
-    GST_WARNING ("feedback packet count jumped ahead (%u > %u)",
+  if (fb_pkt_count_diff > 0) {
+    GST_DEBUG ("feedback packet count jumped ahead (%u > %u)",
         fb_pkt_count, twcc->expected_parsed_fb_pkt_count);
     goto done;
   }
 
+  if (base_seqnum < twcc->expected_parsed_seqnum) {
+    GST_DEBUG ("twcc seqnum is older than expected  (%u < %u)", base_seqnum,
+        twcc->expected_parsed_seqnum);
+    return;
+  }
+
   packets_lost = base_seqnum - twcc->expected_parsed_seqnum;
   for (i = 0; i < packets_lost; i++) {
     _add_twcc_packet (twcc_packets, twcc->expected_parsed_seqnum + i,
@@ -896,6 +1096,7 @@ rtp_twcc_manager_parse_fci (RTPTWCCManager * twcc,
           pkt->local_ts = found->ts;
         }
         pkt->size = found->size;
+        pkt->pt = found->pt;
 
         GST_LOG ("matching pkt: #%u with local_ts: %" GST_TIME_FORMAT
             " size: %u", pkt->seqnum, GST_TIME_ARGS (pkt->local_ts), pkt->size);
diff --git a/gst/rtpmanager/rtptwcc.h b/gst/rtpmanager/rtptwcc.h
index 50da70477..a826e9a4c 100644
--- a/gst/rtpmanager/rtptwcc.h
+++ b/gst/rtpmanager/rtptwcc.h
@@ -49,19 +49,25 @@ struct _RTPTWCCPacket
   RTPTWCCPacketStatus status;
   guint16 seqnum;
   guint size;
+  guint8 pt;
 };
 
 RTPTWCCManager * rtp_twcc_manager_new (guint mtu);
 
+void rtp_twcc_manager_parse_recv_ext_id (RTPTWCCManager * twcc,
+    const GstStructure * s);
+void rtp_twcc_manager_parse_send_ext_id (RTPTWCCManager * twcc,
+    const GstStructure * s);
+
 void rtp_twcc_manager_set_mtu (RTPTWCCManager * twcc, guint mtu);
+void rtp_twcc_manager_set_feedback_interval (RTPTWCCManager * twcc,
+    GstClockTime feedback_interval);
+GstClockTime rtp_twcc_manager_get_feedback_interval (RTPTWCCManager * twcc);
 
 gboolean rtp_twcc_manager_recv_packet (RTPTWCCManager * twcc,
-    guint16 seqnum, RTPPacketInfo * pinfo);
-
+    RTPPacketInfo * pinfo);
 void rtp_twcc_manager_send_packet (RTPTWCCManager * twcc,
-    guint16 seqnum, RTPPacketInfo * pinfo);
-void rtp_twcc_manager_set_send_packet_ts (RTPTWCCManager * twcc,
-    guint packet_id, GstClockTime ts);
+    RTPPacketInfo * pinfo);
 
 GstBuffer * rtp_twcc_manager_get_feedback (RTPTWCCManager * twcc,
     guint32 sender_ssrc);
-- 
2.38.1

